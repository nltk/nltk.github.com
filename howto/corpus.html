<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Corpus Readers</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="corpus-readers">
<h1 class="title">Corpus Readers</h1>

<!-- Copyright (C) 2001-2015 NLTK Project -->
<!-- For license information, see LICENSE.TXT -->
<p>The <cite>nltk.corpus</cite> package defines a collection of <em>corpus reader</em>
classes, which can be used to access the contents of a diverse set of
corpora.  The list of available corpora is given at:</p>
<p><a class="reference external" href="http://www.nltk.org/nltk_data/">http://www.nltk.org/nltk_data/</a></p>
<p>Each corpus reader class is specialized to handle a specific
corpus format.  In addition, the <cite>nltk.corpus</cite> package automatically
creates a set of corpus reader instances that can be used to access
the corpora in the NLTK data package.
Section <a class="reference internal" href="#corpus-reader-objects">Corpus Reader Objects</a> (&quot;Corpus Reader Objects&quot;) describes
the corpus reader instances that can be used to read the corpora in
the NLTK data package.  Section <a class="reference internal" href="#corpus-reader-classes">Corpus Reader Classes</a> (&quot;Corpus
Reader Classes&quot;) describes the corpus reader classes themselves, and
discusses the issues involved in creating new corpus reader objects
and new corpus reader classes.  Section <a class="reference internal" href="#regression-tests">Regression Tests</a>
(&quot;Regression Tests&quot;) contains regression tests for the corpus readers
and associated functions and classes.</p>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><strong>Table of Contents</strong></p>
<ul class="simple">
<li><a class="reference internal" href="#corpus-reader-objects" id="id2">Corpus Reader Objects</a><ul>
<li><a class="reference internal" href="#overview" id="id3">Overview</a></li>
<li><a class="reference internal" href="#plaintext-corpora" id="id4">Plaintext Corpora</a></li>
<li><a class="reference internal" href="#tagged-corpora" id="id5">Tagged Corpora</a></li>
<li><a class="reference internal" href="#chunked-corpora" id="id6">Chunked Corpora</a></li>
<li><a class="reference internal" href="#parsed-corpora" id="id7">Parsed Corpora</a></li>
<li><a class="reference internal" href="#word-lists-and-lexicons" id="id8">Word Lists and Lexicons</a></li>
<li><a class="reference internal" href="#wordnet" id="id9">WordNet</a></li>
<li><a class="reference internal" href="#framenet" id="id10">FrameNet</a></li>
<li><a class="reference internal" href="#propbank" id="id11">PropBank</a></li>
<li><a class="reference internal" href="#sentiwordnet" id="id12">SentiWordNet</a></li>
<li><a class="reference internal" href="#categorized-corpora" id="id13">Categorized Corpora</a></li>
<li><a class="reference internal" href="#other-corpora" id="id14">Other Corpora</a></li>
</ul>
</li>
<li><a class="reference internal" href="#corpus-reader-classes" id="id15">Corpus Reader Classes</a><ul>
<li><a class="reference internal" href="#automatically-created-corpus-reader-instances" id="id16">Automatically Created Corpus Reader Instances</a></li>
<li><a class="reference internal" href="#creating-new-corpus-reader-instances" id="id17">Creating New Corpus Reader Instances</a></li>
<li><a class="reference internal" href="#corpus-types" id="id18">Corpus Types</a></li>
<li><a class="reference internal" href="#common-corpus-reader-methods" id="id19">Common Corpus Reader Methods</a></li>
<li><a class="reference internal" href="#data-access-methods" id="id20">Data Access Methods</a></li>
<li><a class="reference internal" href="#stream-backed-corpus-views" id="id21">Stream Backed Corpus Views</a></li>
<li><a class="reference internal" href="#writing-new-corpus-readers" id="id22">Writing New Corpus Readers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regression-tests" id="id23">Regression Tests</a><ul>
<li><a class="reference internal" href="#plaintext-corpus-reader" id="id24">Plaintext Corpus Reader</a></li>
<li><a class="reference internal" href="#tagged-corpus-reader" id="id25">Tagged Corpus Reader</a></li>
<li><a class="reference internal" href="#verbnet-corpus-reader" id="id26">Verbnet Corpus Reader</a></li>
<li><a class="reference internal" href="#corpus-view-regression-tests" id="id27">Corpus View Regression Tests</a></li>
<li><a class="reference internal" href="#seekableunicodestreamreader" id="id28">SeekableUnicodeStreamReader</a></li>
<li><a class="reference internal" href="#squashed-bugs" id="id29">Squashed Bugs</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="corpus-reader-objects">
<h1>Corpus Reader Objects</h1>
<div class="section" id="overview">
<h2>Overview</h2>
<p>NLTK includes a diverse set of corpora which can be
read using the <tt class="docutils literal">nltk.corpus</tt> package.  Each corpus is accessed by
means of a &quot;corpus reader&quot; object from <tt class="docutils literal">nltk.corpus</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import nltk.corpus
&gt;&gt;&gt; # The Brown corpus:
&gt;&gt;&gt; print(str(nltk.corpus.brown).replace('\\\\','/'))
&lt;CategorizedTaggedCorpusReader in '.../corpora/brown'...&gt;
&gt;&gt;&gt; # The Penn Treebank Corpus:
&gt;&gt;&gt; print(str(nltk.corpus.treebank).replace('\\\\','/'))
&lt;BracketParseCorpusReader in '.../corpora/treebank/combined'...&gt;
&gt;&gt;&gt; # The Name Genders Corpus:
&gt;&gt;&gt; print(str(nltk.corpus.names).replace('\\\\','/'))
&lt;WordListCorpusReader in '.../corpora/names'...&gt;
&gt;&gt;&gt; # The Inaugural Address Corpus:
&gt;&gt;&gt; print(str(nltk.corpus.inaugural).replace('\\\\','/'))
&lt;PlaintextCorpusReader in '.../corpora/inaugural'...&gt;
</pre>
</blockquote>
<p>Most corpora consist of a set of files, each containing a document (or
other pieces of text).  A list of identifiers for these files is
accessed via the <tt class="docutils literal">fileids()</tt> method of the corpus reader:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.treebank.fileids() # doctest: +ELLIPSIS
['wsj_0001.mrg', 'wsj_0002.mrg', 'wsj_0003.mrg', 'wsj_0004.mrg', ...]
&gt;&gt;&gt; nltk.corpus.inaugural.fileids() # doctest: +ELLIPSIS
['1789-Washington.txt', '1793-Washington.txt', '1797-Adams.txt', ...]
</pre>
</blockquote>
<p>Each corpus reader provides a variety of methods to read data from the
corpus, depending on the format of the corpus.  For example, plaintext
corpora support methods to read the corpus as raw text, a list of
words, a list of sentences, or a list of paragraphs.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import inaugural
&gt;&gt;&gt; inaugural.raw('1789-Washington.txt') # doctest: +ELLIPSIS
'Fellow-Citizens of the Senate ...'
&gt;&gt;&gt; inaugural.words('1789-Washington.txt')
['Fellow', '-', 'Citizens', 'of', 'the', ...]
&gt;&gt;&gt; inaugural.sents('1789-Washington.txt') # doctest: +ELLIPSIS
[['Fellow', '-', 'Citizens'...], ['Among', 'the', 'vicissitudes'...]...]
&gt;&gt;&gt; inaugural.paras('1789-Washington.txt') # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[[['Fellow', '-', 'Citizens'...]],
 [['Among', 'the', 'vicissitudes'...],
  ['On', 'the', 'one', 'hand', ',', 'I'...]...]...]
</pre>
</blockquote>
<p>Each of these reader methods may be given a single document's item
name or a list of document item names.  When given a list of document
item names, the reader methods will concatenate together the contents
of the individual documents.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; l1 = len(inaugural.words('1789-Washington.txt'))
&gt;&gt;&gt; l2 = len(inaugural.words('1793-Washington.txt'))
&gt;&gt;&gt; l3 = len(inaugural.words(['1789-Washington.txt', '1793-Washington.txt']))
&gt;&gt;&gt; print('%s+%s == %s' % (l1, l2, l3))
1538+147 == 1685
</pre>
</blockquote>
<p>If the reader methods are called without any arguments, they will
typically load all documents in the corpus.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; len(inaugural.words())
145735
</pre>
</blockquote>
<p>If a corpus contains a README file, it can be accessed with a <tt class="docutils literal">readme()</tt> method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; inaugural.readme()[:32]
'C-Span Inaugural Address Corpus\n'
</pre>
</blockquote>
</div>
<div class="section" id="plaintext-corpora">
<h2>Plaintext Corpora</h2>
<p>Here are the first few words from each of NLTK's plaintext corpora:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.abc.words()
['PM', 'denies', 'knowledge', 'of', 'AWB', ...]
&gt;&gt;&gt; nltk.corpus.genesis.words()
[u'In', u'the', u'beginning', u'God', u'created', ...]
&gt;&gt;&gt; nltk.corpus.gutenberg.words(fileids='austen-emma.txt')
['[', 'Emma', 'by', 'Jane', 'Austen', '1816', ...]
&gt;&gt;&gt; nltk.corpus.inaugural.words()
['Fellow', '-', 'Citizens', 'of', 'the', ...]
&gt;&gt;&gt; nltk.corpus.state_union.words()
['PRESIDENT', 'HARRY', 'S', '.', 'TRUMAN', &quot;'&quot;, ...]
&gt;&gt;&gt; nltk.corpus.webtext.words()
['Cookie', 'Manager', ':', '&quot;', 'Don', &quot;'&quot;, 't', ...]
</pre>
</blockquote>
</div>
<div class="section" id="tagged-corpora">
<h2>Tagged Corpora</h2>
<p>In addition to the plaintext corpora, NLTK's data package also
contains a wide variety of annotated corpora.  For example, the Brown
Corpus is annotated with part-of-speech tags, and defines additional
methods <tt class="docutils literal"><span class="pre">tagged_*()</span></tt> which words as <cite>(word,tag)</cite> tuples, rather
than just bare word strings.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import brown
&gt;&gt;&gt; print(brown.words())
['The', 'Fulton', 'County', 'Grand', 'Jury', ...]
&gt;&gt;&gt; print(brown.tagged_words())
[('The', 'AT'), ('Fulton', 'NP-TL'), ...]
&gt;&gt;&gt; print(brown.sents()) # doctest: +ELLIPSIS
[['The', 'Fulton', 'County'...], ['The', 'jury', 'further'...], ...]
&gt;&gt;&gt; print(brown.tagged_sents()) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[[('The', 'AT'), ('Fulton', 'NP-TL')...],
 [('The', 'AT'), ('jury', 'NN'), ('further', 'RBR')...]...]
&gt;&gt;&gt; print(brown.paras(categories='reviews')) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[[['It', 'is', 'not', 'news', 'that', 'Nathan', 'Milstein'...],
  ['Certainly', 'not', 'in', 'Orchestra', 'Hall', 'where'...]],
 [['There', 'was', 'about', 'that', 'song', 'something', ...],
  ['Not', 'the', 'noblest', 'performance', 'we', 'have', ...], ...], ...]
&gt;&gt;&gt; print(brown.tagged_paras(categories='reviews')) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[[[('It', 'PPS'), ('is', 'BEZ'), ('not', '*'), ...],
  [('Certainly', 'RB'), ('not', '*'), ('in', 'IN'), ...]],
 [[('There', 'EX'), ('was', 'BEDZ'), ('about', 'IN'), ...],
  [('Not', '*'), ('the', 'AT'), ('noblest', 'JJT'), ...], ...], ...]
</pre>
</blockquote>
<p>Similarly, the Indian Language POS-Tagged Corpus includes samples of
Indian text annotated with part-of-speech tags:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import indian
&gt;&gt;&gt; print(indian.words()) # doctest: +SKIP
['\xe0\xa6\xae\xe0\xa6\xb9\xe0\xa6\xbf\...',
 '\xe0\xa6\xb8\xe0\xa6\xa8\xe0\xa7\x8d\xe0...', ...]
&gt;&gt;&gt; print(indian.tagged_words()) # doctest: +SKIP
[('\xe0\xa6\xae\xe0\xa6\xb9\xe0\xa6\xbf...', 'NN'),
 ('\xe0\xa6\xb8\xe0\xa6\xa8\xe0\xa7\x8d\xe0...', 'NN'), ...]
</pre>
</blockquote>
<p>Several tagged corpora support access to a simplified, universal tagset, e.g. where all nouns
tags are collapsed to a single category <tt class="docutils literal">NOUN</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(brown.tagged_sents(tagset='universal')) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[[('The', 'DET'), ('Fulton', 'NOUN'), ('County', 'NOUN'), ('Grand', 'ADJ'), ('Jury', 'NOUN'), ...],
 [('The', 'DET'), ('jury', 'NOUN'), ('further', 'ADV'), ('said', 'VERB'), ('in', 'ADP'), ...]...]
&gt;&gt;&gt; from nltk.corpus import conll2000, switchboard
&gt;&gt;&gt; print(conll2000.tagged_words(tagset='universal')) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[('Confidence', 'NOUN'), ('in', 'ADP'), ...]
</pre>
</blockquote>
<p>Use <tt class="docutils literal">nltk.app.pos_concordance()</tt> to access a GUI for searching tagged corpora.</p>
</div>
<div class="section" id="chunked-corpora">
<h2>Chunked Corpora</h2>
<p>The CoNLL corpora also provide chunk structures, which are encoded as
flat trees.  The CoNLL 2000 Corpus includes phrasal chunks; and the
CoNLL 2002 Corpus includes named entity chunks.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import conll2000, conll2002
&gt;&gt;&gt; print(conll2000.sents()) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[['Confidence', 'in', 'the', 'pound', 'is', 'widely', ...],
 ['Chancellor', 'of', 'the', 'Exchequer', ...], ...]
&gt;&gt;&gt; for tree in conll2000.chunked_sents()[:2]:
...     print(tree) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
(S
  (NP Confidence/NN)
  (PP in/IN)
  (NP the/DT pound/NN)
  (VP is/VBZ widely/RB expected/VBN to/TO take/VB)
  (NP another/DT sharp/JJ dive/NN)
  if/IN
  ...)
(S
  Chancellor/NNP
  (PP of/IN)
  (NP the/DT Exchequer/NNP)
  ...)
&gt;&gt;&gt; print(conll2002.sents()) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[[u'Sao', u'Paulo', u'(', u'Brasil', u')', u',', ...], [u'-'], ...]
&gt;&gt;&gt; for tree in conll2002.chunked_sents()[:2]:
...     print(tree) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
(S
  (LOC Sao/NC Paulo/VMI)
  (/Fpa
  (LOC Brasil/NC)
  )/Fpt
  ...)
(S -/Fg)
</pre>
</blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Since the CONLL corpora do not contain paragraph break
information, these readers do not support the <tt class="docutils literal">para()</tt> method.)</p>
</div>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">if you call the conll corpora reader methods without any
arguments, they will return the contents of the entire corpus,
<em>including</em> the 'test' portions of the corpus.)</p>
</div>
<p>SemCor is a subset of the Brown corpus tagged with WordNet senses and
named entities. Both kinds of lexical items include multiword units,
which are encoded as chunks (senses and part-of-speech tags pertain
to the entire chunk).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import semcor
&gt;&gt;&gt; semcor.words()
['The', 'Fulton', 'County', 'Grand', 'Jury', ...]
&gt;&gt;&gt; semcor.chunks()
[['The'], ['Fulton', 'County', 'Grand', 'Jury'], ...]
&gt;&gt;&gt; semcor.sents() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[['The', 'Fulton', 'County', 'Grand', 'Jury', 'said', ...],
['The', 'jury', 'further', 'said', ...], ...]
&gt;&gt;&gt; semcor.chunk_sents() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[[['The'], ['Fulton', 'County', 'Grand', 'Jury'], ['said'], ...
['.']], [['The'], ['jury'], ['further'], ['said'], ... ['.']], ...]
&gt;&gt;&gt; list(map(str, semcor.tagged_chunks(tag='both')[:3]))
['(DT The)', &quot;(Lemma('group.n.01.group') (NE (NNP Fulton County Grand Jury)))&quot;, &quot;(Lemma('state.v.01.say') (VB said))&quot;]
&gt;&gt;&gt; [[str(c) for c in s] for s in semcor.tagged_sents(tag='both')[:2]]
[['(DT The)', &quot;(Lemma('group.n.01.group') (NE (NNP Fulton County Grand Jury)))&quot;, ...
 '(None .)'], ['(DT The)', ... '(None .)']]
</pre>
</blockquote>
<p>The IEER corpus is another chunked corpus.  This corpus is unusual in
that each corpus item contains multiple documents.  (This reflects the
fact that each corpus file contains multiple documents.)  The IEER
corpus defines the <cite>parsed_docs</cite> method, which returns the documents
in a given item as <cite>IEERDocument</cite> objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import ieer
&gt;&gt;&gt; ieer.fileids() # doctest: +NORMALIZE_WHITESPACE
['APW_19980314', 'APW_19980424', 'APW_19980429',
 'NYT_19980315', 'NYT_19980403', 'NYT_19980407']
&gt;&gt;&gt; docs = ieer.parsed_docs('APW_19980314')
&gt;&gt;&gt; print(docs[0])
&lt;IEERDocument APW19980314.0391: 'Kenyans protest tax hikes'&gt;
&gt;&gt;&gt; print(docs[0].docno)
APW19980314.0391
&gt;&gt;&gt; print(docs[0].doctype)
NEWS STORY
&gt;&gt;&gt; print(docs[0].date_time)
03/14/1998 10:36:00
&gt;&gt;&gt; print(docs[0].headline)
(DOCUMENT Kenyans protest tax hikes)
&gt;&gt;&gt; print(docs[0].text) # doctest: +ELLIPSIS
(DOCUMENT
  (LOCATION NAIROBI)
  ,
  (LOCATION Kenya)
  (
  (ORGANIZATION AP)
  )
  _
  (CARDINAL Thousands)
  of
  laborers,
  ...
  on
  (DATE Saturday)
  ...)
</pre>
</blockquote>
</div>
<div class="section" id="parsed-corpora">
<h2>Parsed Corpora</h2>
<p>The Treebank corpora provide a syntactic parse for each sentence.  The
NLTK data package includes a 10% sample of the Penn Treebank (in
<tt class="docutils literal">treebank</tt>), as well as the Sinica Treebank (in <tt class="docutils literal">sinica_treebank</tt>).</p>
<p>Reading the Penn Treebank (Wall Street Journal sample):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import treebank
&gt;&gt;&gt; print(treebank.fileids()) # doctest: +ELLIPSIS
['wsj_0001.mrg', 'wsj_0002.mrg', 'wsj_0003.mrg', 'wsj_0004.mrg', ...]
&gt;&gt;&gt; print(treebank.words('wsj_0003.mrg'))
['A', 'form', 'of', 'asbestos', 'once', 'used', ...]
&gt;&gt;&gt; print(treebank.tagged_words('wsj_0003.mrg'))
[('A', 'DT'), ('form', 'NN'), ('of', 'IN'), ...]
&gt;&gt;&gt; print(treebank.parsed_sents('wsj_0003.mrg')[0]) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
(S
  (S-TPC-1
    (NP-SBJ
      (NP (NP (DT A) (NN form)) (PP (IN of) (NP (NN asbestos))))
      (RRC ...)...)...)
  ...
  (VP (VBD reported) (SBAR (-NONE- 0) (S (-NONE- *T*-1))))
  (. .))
</pre>
</blockquote>
<p>If you have access to a full installation of the Penn Treebank, NLTK
can be configured to load it as well. Download the <tt class="docutils literal">ptb</tt> package,
and in the directory <tt class="docutils literal">nltk_data/corpora/ptb</tt> place the <tt class="docutils literal">BROWN</tt>
and <tt class="docutils literal">WSJ</tt> directories of the Treebank installation (symlinks work
as well). Then use the <tt class="docutils literal">ptb</tt> module instead of <tt class="docutils literal">treebank</tt>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import ptb
&gt;&gt;&gt; print(ptb.fileids()) # doctest: +SKIP
['BROWN/CF/CF01.MRG', 'BROWN/CF/CF02.MRG', 'BROWN/CF/CF03.MRG', 'BROWN/CF/CF04.MRG', ...]
&gt;&gt;&gt; print(ptb.words('WSJ/00/WSJ_0003.MRG')) # doctest: +SKIP
['A', 'form', 'of', 'asbestos', 'once', 'used', '*', ...]
&gt;&gt;&gt; print(ptb.tagged_words('WSJ/00/WSJ_0003.MRG')) # doctest: +SKIP
[('A', 'DT'), ('form', 'NN'), ('of', 'IN'), ...]
</pre>
</blockquote>
<p>...and so forth, like <tt class="docutils literal">treebank</tt> but with extended fileids. Categories
specified in <tt class="docutils literal">allcats.txt</tt> can be used to filter by genre; they consist
of <tt class="docutils literal">news</tt> (for WSJ articles) and names of the Brown subcategories
(<tt class="docutils literal">fiction</tt>, <tt class="docutils literal">humor</tt>, <tt class="docutils literal">romance</tt>, etc.):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; ptb.categories() # doctest: +SKIP
['adventure', 'belles_lettres', 'fiction', 'humor', 'lore', 'mystery', 'news', 'romance', 'science_fiction']
&gt;&gt;&gt; print(ptb.fileids('news')) # doctest: +SKIP
['WSJ/00/WSJ_0001.MRG', 'WSJ/00/WSJ_0002.MRG', 'WSJ/00/WSJ_0003.MRG', ...]
&gt;&gt;&gt; print(ptb.words(categories=['humor','fiction'])) # doctest: +SKIP
['Thirty-three', 'Scotty', 'did', 'not', 'go', 'back', ...]
</pre>
</blockquote>
<p>As PropBank and NomBank depend on the (WSJ portion of the) Penn Treebank,
the modules <tt class="docutils literal">propbank_ptb</tt> and <tt class="docutils literal">nombank_ptb</tt> are provided for access
to a full PTB installation.</p>
<p>Reading the Sinica Treebank:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import sinica_treebank
&gt;&gt;&gt; print(sinica_treebank.sents()) # doctest: +SKIP
[['\xe4\xb8\x80'], ['\xe5\x8f\x8b\xe6\x83\x85'], ...]
&gt;&gt;&gt; sinica_treebank.parsed_sents()[25] # doctest: +SKIP
Tree('S',
    [Tree('NP',
        [Tree('Nba', ['\xe5\x98\x89\xe7\x8f\x8d'])]),
     Tree('V\xe2\x80\xa7\xe5\x9c\xb0',
        [Tree('VA11', ['\xe4\xb8\x8d\xe5\x81\x9c']),
         Tree('DE', ['\xe7\x9a\x84'])]),
     Tree('VA4', ['\xe5\x93\xad\xe6\xb3\xa3'])])
</pre>
</blockquote>
<p>Reading the CoNLL 2007 Dependency Treebanks:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import conll2007
&gt;&gt;&gt; conll2007.sents('esp.train')[0] # doctest: +SKIP
['El', 'aumento', 'del', 'índice', 'de', 'desempleo', ...]
&gt;&gt;&gt; conll2007.parsed_sents('esp.train')[0] # doctest: +SKIP
&lt;DependencyGraph with 38 nodes&gt;
&gt;&gt;&gt; print(conll2007.parsed_sents('esp.train')[0].tree()) # doctest: +SKIP
(fortaleció
  (aumento El (del (índice (de (desempleo estadounidense)))))
  hoy
  considerablemente
  (al
    (euro
      (cotizaba
        ,
        que
        (a (15.35 las GMT))
        se
        (en (mercado el (de divisas) (de Fráncfort)))
        (a 0,9452_dólares)
        (frente_a , (0,9349_dólares los (de (mañana esta)))))))
  .)
</pre>
</blockquote>
<p>NLTK also provides a corpus reader for the York-Toronto-Helsinki
Parsed Corpus of Old English Prose (YCOE); but the corpus itself is
not included in the NLTK data package.  If you install it yourself,
you can use NLTK to access it:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import ycoe
&gt;&gt;&gt; for tree in ycoe.parsed_sents('cocuraC')[:4]:
...     print(tree) # doctest: +SKIP
(CP-THT
  (C +D+atte)
  (IP-SUB ...)
  ...
  (. .))
(IP-MAT
  (IP-MAT-0
    (PP (P On) (NP (ADJ o+dre) (N wisan)))...)
  ...
  (. .))
(IP-MAT
  (NP-NOM-x-2 *exp*)
  (NP-DAT-1 (D^D +D+am) (ADJ^D unge+dyldegum))
  ...
  (. .))
(IP-MAT
  (ADVP (ADV Sw+a))
  (NP-NOM-x (PRO^N hit))
  (ADVP-TMP (ADV^T oft))
  ...
  (. .))
</pre>
</blockquote>
<p>If the YCOE corpus is not available, you will get an error message
when you try to access it:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import ycoe
&gt;&gt;&gt; print(ycoe) # doctest: +SKIP
Traceback (most recent call last):
LookupError:
**********************************************************************
  Resource 'corpora/ycoe' not found.  For installation
  instructions, please see &lt;http://nltk.org/index.php/Installation&gt;.
  Searched in:
    - ...
**********************************************************************
</pre>
</blockquote>
</div>
<div class="section" id="word-lists-and-lexicons">
<h2>Word Lists and Lexicons</h2>
<p>The NLTK data package also includes a number of lexicons and word
lists.  These are accessed just like text corpora.  The following
examples illustrate the use of the wordlist corpora:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import names, stopwords, words
&gt;&gt;&gt; words.fileids()
['en', 'en-basic']
&gt;&gt;&gt; words.words('en') # doctest: +ELLIPSIS
['A', 'a', 'aa', 'aal', 'aalii', 'aam', 'Aani', 'aardvark', 'aardwolf', ...]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; stopwords.fileids() # doctest: +ELLIPSIS
['danish', 'dutch', 'english', 'finnish', 'french', 'german', 'hungarian', ...]
&gt;&gt;&gt; stopwords.words('portuguese') # doctest: +ELLIPSIS
['de', 'a', 'o', 'que', 'e', 'do', 'da', 'em', 'um', 'para', ...]
&gt;&gt;&gt; names.fileids()
['female.txt', 'male.txt']
&gt;&gt;&gt; names.words('male.txt') # doctest: +ELLIPSIS
['Aamir', 'Aaron', 'Abbey', 'Abbie', 'Abbot', 'Abbott', ...]
&gt;&gt;&gt; names.words('female.txt') # doctest: +ELLIPSIS
['Abagael', 'Abagail', 'Abbe', 'Abbey', 'Abbi', 'Abbie', ...]
</pre>
</blockquote>
<p>The CMU Pronunciation Dictionary corpus contains pronounciation
transcriptions for over 100,000 words.  It can be accessed as a list
of entries (where each entry consists of a word, an identifier, and a
transcription) or as a dictionary from words to lists of
transcriptions.  Transcriptions are encoded as tuples of phoneme
strings.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import cmudict
&gt;&gt;&gt; print(cmudict.entries()[653:659]) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[('acetate', ['AE1', 'S', 'AH0', 'T', 'EY2', 'T']),
('acetic', ['AH0', 'S', 'EH1', 'T', 'IH0', 'K']),
('acetic', ['AH0', 'S', 'IY1', 'T', 'IH0', 'K']),
('aceto', ['AA0', 'S', 'EH1', 'T', 'OW0']),
('acetochlor', ['AA0', 'S', 'EH1', 'T', 'OW0', 'K', 'L', 'AO2', 'R']),
('acetone', ['AE1', 'S', 'AH0', 'T', 'OW2', 'N'])]
&gt;&gt;&gt; # Load the entire cmudict corpus into a Python dictionary:
&gt;&gt;&gt; transcr = cmudict.dict()
&gt;&gt;&gt; print([transcr[w][0] for w in 'Natural Language Tool Kit'.lower().split()]) # doctest: +NORMALIZE_WHITESPACE
[['N', 'AE1', 'CH', 'ER0', 'AH0', 'L'],
 ['L', 'AE1', 'NG', 'G', 'W', 'AH0', 'JH'],
 ['T', 'UW1', 'L'],
 ['K', 'IH1', 'T']]
</pre>
</blockquote>
</div>
<div class="section" id="wordnet">
<h2>WordNet</h2>
<p>Please see the separate WordNet howto.</p>
</div>
<div class="section" id="framenet">
<h2>FrameNet</h2>
<p>Please see the separate FrameNet howto.</p>
</div>
<div class="section" id="propbank">
<h2>PropBank</h2>
<p>Please see the separate PropBank howto.</p>
</div>
<div class="section" id="sentiwordnet">
<h2>SentiWordNet</h2>
<p>Please see the separate SentiWordNet howto.</p>
</div>
<div class="section" id="categorized-corpora">
<h2>Categorized Corpora</h2>
<p>Several corpora included with NLTK contain documents that have been categorized for
topic, genre, polarity, etc.  In addition to the standard corpus interface, these
corpora provide access to the list of categories and the mapping between the documents
and their categories (in both directions).  Access the categories using the <tt class="docutils literal">categories()</tt>
method, e.g.:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import brown, movie_reviews, reuters
&gt;&gt;&gt; brown.categories() # doctest: +NORMALIZE_WHITESPACE
['adventure', 'belles_lettres', 'editorial', 'fiction', 'government', 'hobbies', 'humor',
'learned', 'lore', 'mystery', 'news', 'religion', 'reviews', 'romance', 'science_fiction']
&gt;&gt;&gt; movie_reviews.categories()
['neg', 'pos']
&gt;&gt;&gt; reuters.categories() # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS
['acq', 'alum', 'barley', 'bop', 'carcass', 'castor-oil', 'cocoa',
'coconut', 'coconut-oil', 'coffee', 'copper', 'copra-cake', 'corn',
'cotton', 'cotton-oil', 'cpi', 'cpu', 'crude', 'dfl', 'dlr', ...]
</pre>
</blockquote>
<p>This method has an optional argument that specifies a document or a list
of documents, allowing us to map from (one or more) documents to (one or more) categories:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; brown.categories('ca01')
['news']
&gt;&gt;&gt; brown.categories(['ca01','cb01'])
['editorial', 'news']
&gt;&gt;&gt; reuters.categories('training/9865')
['barley', 'corn', 'grain', 'wheat']
&gt;&gt;&gt; reuters.categories(['training/9865', 'training/9880'])
['barley', 'corn', 'grain', 'money-fx', 'wheat']
</pre>
</blockquote>
<p>We can go back the other way using the optional argument of the <tt class="docutils literal">fileids()</tt> method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; reuters.fileids('barley') # doctest: +ELLIPSIS
['test/15618', 'test/15649', 'test/15676', 'test/15728', 'test/15871', ...]
</pre>
</blockquote>
<p>Both the <tt class="docutils literal">categories()</tt> and <tt class="docutils literal">fileids()</tt> methods return a sorted list containing
no duplicates.</p>
<p>In addition to mapping between categories and documents, these corpora permit
direct access to their contents via the categories.  Instead of accessing a subset
of a corpus by specifying one or more fileids, we can identify one or more categories, e.g.:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; brown.tagged_words(categories='news')
[('The', 'AT'), ('Fulton', 'NP-TL'), ...]
&gt;&gt;&gt; brown.sents(categories=['editorial','reviews']) # doctest: +NORMALIZE_WHITESPACE
[['Assembly', 'session', 'brought', 'much', 'good'], ['The', 'General',
'Assembly', ',', 'which', 'adjourns', 'today', ',', 'has', 'performed',
'in', 'an', 'atmosphere', 'of', 'crisis', 'and', 'struggle', 'from',
'the', 'day', 'it', 'convened', '.'], ...]
</pre>
</blockquote>
<p>Note that it is an error to specify both documents and categories.</p>
<p>In the context of a text categorization system, we can easily test if the
category assigned to a document is correct as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def classify(doc): return 'news'   # Trivial classifier
&gt;&gt;&gt; doc = 'ca01'
&gt;&gt;&gt; classify(doc) in brown.categories(doc)
True
</pre>
</blockquote>
</div>
<div class="section" id="other-corpora">
<h2>Other Corpora</h2>
<div class="section" id="comparative-sentences">
<h3>comparative_sentences</h3>
<p>A list of sentences from various sources, especially reviews and articles. Each
line contains one sentence; sentences were separated by using a sentence tokenizer.
Comparative sentences have been annotated with their type, entities, features and
keywords.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import comparative_sentences
&gt;&gt;&gt; comparison = comparative_sentences.comparisons()[0]
&gt;&gt;&gt; comparison.text
['its', 'fast-forward', 'and', 'rewind', 'work', 'much', 'more', 'smoothly',
'and', 'consistently', 'than', 'those', 'of', 'other', 'models', 'i', &quot;'ve&quot;,
'had', '.']
&gt;&gt;&gt; comparison.entity_2
'models'
&gt;&gt;&gt; (comparison.feature, comparison.keyword)
('rewind', 'more')
&gt;&gt;&gt; len(comparative_sentences.comparisons())
853
</pre>
</blockquote>
</div>
<div class="section" id="opinion-lexicon">
<h3>opinion_lexicon</h3>
<p>A list of positive and negative opinion words or sentiment words for English.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import opinion_lexicon
&gt;&gt;&gt; opinion_lexicon.words()[:4]
    ['2-faced', '2-faces', 'abnormal', 'abolish']
</pre>
</blockquote>
<p>The OpinionLexiconCorpusReader also provides shortcuts to retrieve positive/negative
words:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; opinion_lexicon.negative()[:4]
['2-faced', '2-faces', 'abnormal', 'abolish']
</pre>
</blockquote>
<p>Note that words from <cite>words()</cite> method in opinion_lexicon are sorted by file id,
not alphabetically:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; opinion_lexicon.words()[0:10]
['2-faced', '2-faces', 'abnormal', 'abolish', 'abominable', 'abominably',
'abominate', 'abomination', 'abort', 'aborted']
&gt;&gt;&gt; sorted(opinion_lexicon.words())[0:10]
['2-faced', '2-faces', 'a+', 'abnormal', 'abolish', 'abominable', 'abominably',
'abominate', 'abomination', 'abort']
</pre>
</blockquote>
</div>
<div class="section" id="ppattach">
<h3>ppattach</h3>
<p>The Prepositional Phrase Attachment corpus is a corpus of
prepositional phrase attachment decisions.  Each instance in the
corpus is encoded as a <tt class="docutils literal">PPAttachment</tt> object:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import ppattach
&gt;&gt;&gt; ppattach.attachments('training') # doctest: +NORMALIZE_WHITESPACE
[PPAttachment(sent='0', verb='join', noun1='board',
              prep='as', noun2='director', attachment='V'),
 PPAttachment(sent='1', verb='is', noun1='chairman',
              prep='of', noun2='N.V.', attachment='N'),
 ...]
&gt;&gt;&gt; inst = ppattach.attachments('training')[0]
&gt;&gt;&gt; (inst.sent, inst.verb, inst.noun1, inst.prep, inst.noun2)
('0', 'join', 'board', 'as', 'director')
&gt;&gt;&gt; inst.attachment
'V'
</pre>
</blockquote>
</div>
<div class="section" id="product-reviews-1-and-product-reviews-2">
<h3>product_reviews_1 and product_reviews_2</h3>
<p>These two datasets respectively contain annotated customer reviews of 5 and 9
products from amazon.com.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import product_reviews_1
&gt;&gt;&gt; camera_reviews = product_reviews_1.reviews('Canon_G3.txt')
&gt;&gt;&gt; review = camera_reviews[0]
&gt;&gt;&gt; review.sents()[0]
['i', 'recently', 'purchased', 'the', 'canon', 'powershot', 'g3', 'and', 'am',
'extremely', 'satisfied', 'with', 'the', 'purchase', '.']
&gt;&gt;&gt; review.features()
[('canon powershot g3', '+3'), ('use', '+2'), ('picture', '+2'),
('picture quality', '+1'), ('picture quality', '+1'), ('camera', '+2'),
('use', '+2'), ('feature', '+1'), ('picture quality', '+3'), ('use', '+1'),
('option', '+1')]
</pre>
</blockquote>
<p>It is also possible to reach the same information directly from the stream:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; product_reviews_1.features('Canon_G3.txt')
[('canon powershot g3', '+3'), ('use', '+2'), ...]
</pre>
</blockquote>
<p>We can compute stats for specific product features:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; n_reviews = len([(feat,score) for (feat,score) in product_reviews_1.features('Canon_G3.txt') if feat=='picture'])
&gt;&gt;&gt; tot = sum([int(score) for (feat,score) in product_reviews_1.features('Canon_G3.txt') if feat=='picture'])
&gt;&gt;&gt; # We use float for backward compatibility with division in Python2.7
&gt;&gt;&gt; mean = float(tot)/n_reviews
&gt;&gt;&gt; print(n_reviews, tot, mean)
15 24 1.6
</pre>
</blockquote>
</div>
<div class="section" id="pros-cons">
<h3>pros_cons</h3>
<p>A list of pros/cons sentences for determining context (aspect) dependent
sentiment words, which are then applied to sentiment analysis of comparative
sentences.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import pros_cons
&gt;&gt;&gt; pros_cons.sents(categories='Cons')
[['East', 'batteries', '!', 'On', '-', 'off', 'switch', 'too', 'easy',
'to', 'maneuver', '.'], ['Eats', '...', 'no', ',', 'GULPS', 'batteries'],
...]
&gt;&gt;&gt; pros_cons.words('IntegratedPros.txt')
['Easy', 'to', 'use', ',', 'economical', '!', ...]
</pre>
</blockquote>
</div>
<div class="section" id="semcor">
<h3>semcor</h3>
<p>The Brown Corpus, annotated with WordNet senses.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import semcor
&gt;&gt;&gt; semcor.words('brown2/tagfiles/br-n12.xml')  # doctest: +ELLIPSIS
['When', 'several', 'minutes', 'had', 'passed', ...]
&gt;&gt;&gt; sent = semcor.xml('brown2/tagfiles/br-n12.xml').findall('context/p/s')[0]
&gt;&gt;&gt; for wordform in sent.getchildren():
...     print(wordform.text, end=' ')
...     for key in sorted(wordform.keys()):
...         print(key + '=' + wordform.get(key), end=' ')
...     print()
...
When cmd=ignore pos=WRB
several cmd=done lemma=several lexsn=5:00:00:some(a):00 pos=JJ wnsn=1
minutes cmd=done lemma=minute lexsn=1:28:00:: pos=NN wnsn=1
had cmd=done ot=notag pos=VBD
passed cmd=done lemma=pass lexsn=2:38:03:: pos=VB wnsn=4
and cmd=ignore pos=CC
Curt cmd=done lemma=person lexsn=1:03:00:: pn=person pos=NNP rdf=person wnsn=1
had cmd=done ot=notag pos=VBD
n't cmd=done lemma=n't lexsn=4:02:00:: pos=RB wnsn=0
emerged cmd=done lemma=emerge lexsn=2:30:00:: pos=VB wnsn=1
from cmd=ignore pos=IN
the cmd=ignore pos=DT
livery_stable cmd=done lemma=livery_stable lexsn=1:06:00:: pos=NN wnsn=1
,
Brenner cmd=done lemma=person lexsn=1:03:00:: pn=person pos=NNP rdf=person wnsn=1
re-entered cmd=done lemma=re-enter lexsn=2:38:00:: pos=VB wnsn=1
the cmd=ignore pos=DT
hotel cmd=done lemma=hotel lexsn=1:06:00:: pos=NN wnsn=1
and cmd=ignore pos=CC
faced cmd=done lemma=face lexsn=2:42:02:: pos=VB wnsn=4
Summers cmd=done lemma=person lexsn=1:03:00:: pn=person pos=NNP rdf=person wnsn=1
across cmd=ignore pos=IN
the cmd=ignore pos=DT
counter cmd=done lemma=counter lexsn=1:06:00:: pos=NN wnsn=1
.
</pre>
</blockquote>
</div>
<div class="section" id="senseval">
<h3>senseval</h3>
<p>The Senseval 2 corpus is a word sense disambiguation corpus.  Each
item in the corpus corresponds to a single ambiguous word.  For each
of these words, the corpus contains a list of instances, corresponding
to occurrences of that word.  Each instance provides the word; a list
of word senses that apply to the word occurrence; and the word's
context.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import senseval
&gt;&gt;&gt; senseval.fileids()
['hard.pos', 'interest.pos', 'line.pos', 'serve.pos']
&gt;&gt;&gt; senseval.instances('hard.pos')
... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[SensevalInstance(word='hard-a',
    position=20,
    context=[('``', '``'), ('he', 'PRP'), ...('hard', 'JJ'), ...],
    senses=('HARD1',)),
 SensevalInstance(word='hard-a',
    position=10,
    context=[('clever', 'NNP'), ...('hard', 'JJ'), ('time', 'NN'), ...],
    senses=('HARD1',)), ...]
</pre>
</blockquote>
<p>The following code looks at instances of the word 'interest', and
displays their local context (2 words on each side) and word sense(s):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for inst in senseval.instances('interest.pos')[:10]:
...     p = inst.position
...     left = ' '.join(w for (w,t) in inst.context[p-2:p])
...     word = ' '.join(w for (w,t) in inst.context[p:p+1])
...     right = ' '.join(w for (w,t) in inst.context[p+1:p+3])
...     senses = ' '.join(inst.senses)
...     print('%20s |%10s | %-15s -&gt; %s' % (left, word, right, senses))
         declines in |  interest | rates .         -&gt; interest_6
  indicate declining |  interest | rates because   -&gt; interest_6
       in short-term |  interest | rates .         -&gt; interest_6
                 4 % |  interest | in this         -&gt; interest_5
        company with | interests | in the          -&gt; interest_5
              , plus |  interest | .               -&gt; interest_6
             set the |  interest | rate on         -&gt; interest_6
              's own |  interest | , prompted      -&gt; interest_4
       principal and |  interest | is the          -&gt; interest_6
        increase its |  interest | to 70           -&gt; interest_5
</pre>
</blockquote>
</div>
<div class="section" id="sentence-polarity">
<h3>sentence_polarity</h3>
<p>The Sentence Polarity dataset contains 5331 positive and 5331 negative processed
sentences.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import sentence_polarity
&gt;&gt;&gt; sentence_polarity.sents()
[['simplistic', ',', 'silly', 'and', 'tedious', '.'], [&quot;it's&quot;, 'so', 'laddish',
'and', 'juvenile', ',', 'only', 'teenage', 'boys', 'could', 'possibly', 'find',
'it', 'funny', '.'], ...]
&gt;&gt;&gt; sentence_polarity.categories()
['neg', 'pos']
&gt;&gt;&gt; sentence_polarity.sents()[1]
[&quot;it's&quot;, 'so', 'laddish', 'and', 'juvenile', ',', 'only', 'teenage', 'boys',
'could', 'possibly', 'find', 'it', 'funny', '.']
</pre>
</blockquote>
</div>
<div class="section" id="shakespeare">
<h3>shakespeare</h3>
<p>The Shakespeare corpus contains a set of Shakespeare plays, formatted
as XML files.  These corpora are returned as ElementTree objects:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import shakespeare
&gt;&gt;&gt; from xml.etree import ElementTree
&gt;&gt;&gt; shakespeare.fileids() # doctest: +ELLIPSIS
['a_and_c.xml', 'dream.xml', 'hamlet.xml', 'j_caesar.xml', ...]
&gt;&gt;&gt; play = shakespeare.xml('dream.xml')
&gt;&gt;&gt; print(play) # doctest: +ELLIPSIS
&lt;Element 'PLAY' at ...&gt;
&gt;&gt;&gt; print('%s: %s' % (play[0].tag, play[0].text))
TITLE: A Midsummer Night's Dream
&gt;&gt;&gt; personae = [persona.text for persona in
...             play.findall('PERSONAE/PERSONA')]
&gt;&gt;&gt; print(personae) # doctest: +ELLIPSIS
['THESEUS, Duke of Athens.', 'EGEUS, father to Hermia.', ...]
&gt;&gt;&gt; # Find and print speakers not listed as personae
&gt;&gt;&gt; names = [persona.split(',')[0] for persona in personae]
&gt;&gt;&gt; speakers = set(speaker.text for speaker in
...                play.findall('*/*/*/SPEAKER'))
&gt;&gt;&gt; print(sorted(speakers.difference(names))) # doctest: +NORMALIZE_WHITESPACE
['ALL', 'COBWEB', 'DEMETRIUS', 'Fairy', 'HERNIA', 'LYSANDER',
 'Lion', 'MOTH', 'MUSTARDSEED', 'Moonshine', 'PEASEBLOSSOM',
 'Prologue', 'Pyramus', 'Thisbe', 'Wall']
</pre>
</blockquote>
</div>
<div class="section" id="subjectivity">
<h3>subjectivity</h3>
<p>The Subjectivity Dataset contains 5000 subjective and 5000 objective processed
sentences.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import subjectivity
&gt;&gt;&gt; subjectivity.categories()
['obj', 'subj']
&gt;&gt;&gt; subjectivity.sents()[23]
['television', 'made', 'him', 'famous', ',', 'but', 'his', 'biggest', 'hits',
'happened', 'off', 'screen', '.']
&gt;&gt;&gt; subjectivity.words(categories='subj')
['smart', 'and', 'alert', ',', 'thirteen', ...]
</pre>
</blockquote>
</div>
<div class="section" id="toolbox">
<h3>toolbox</h3>
<p>The Toolbox corpus distributed with NLTK contains a sample lexicon and
several sample texts from the Rotokas language.  The Toolbox corpus
reader returns Toolbox files as XML ElementTree objects.  The
following example loads the Rotokas dictionary, and figures out the
distribution of part-of-speech tags for reduplicated words.</p>
<!-- doctest: +SKIP

>>> from nltk.corpus import toolbox
>>> from nltk.probability import FreqDist
>>> from xml.etree import ElementTree
>>> import re
>>> rotokas = toolbox.xml('rotokas.dic')
>>> redup_pos_freqdist = FreqDist()
>>> # Note: we skip over the first record, which is actually
>>> # the header.
>>> for record in rotokas[1:]:
...     lexeme = record.find('lx').text
...     if re.match(r'(.*)\1$', lexeme):
...         redup_pos_freqdist[record.find('ps').text] += 1
>>> for item, count in redup_pos_freqdist.most_common():
...     print(item, count)
V 41
N 14
??? 4 -->
<p>This example displays some records from a Rotokas text:</p>
<!-- doctest: +SKIP

>>> river = toolbox.xml('rotokas/river.txt', key='ref')
>>> for record in river.findall('record')[:3]:
...     for piece in record:
...         if len(piece.text) > 60:
...             print('%-6s %s...' % (piece.tag, piece.text[:57]))
...         else:
...             print('%-6s %s' % (piece.tag, piece.text))
ref    Paragraph 1
t      ``Viapau oisio              ra   ovaupasi                ...
m      viapau   oisio              ra   ovau   -pa       -si    ...
g      NEG      this way/like this and  forget -PROG     -2/3.DL...
p      NEG      ???                CONJ V.I    -SUFF.V.3 -SUFF.V...
f      ``No ken lus tingting wanema samting papa i bin tok,'' Na...
fe     ``Don't forget what Dad said,'' yelled Naomi.
ref    2
t      Osa     Ira  ora  Reviti viapau uvupasiva.
m      osa     Ira  ora  Reviti viapau uvu        -pa       -si ...
g      as/like name and  name   NEG    hear/smell -PROG     -2/3...
p      CONJ    N.PN CONJ N.PN   NEG    V.T        -SUFF.V.3 -SUF...
f      Tasol Ila na David no bin harim toktok.
fe     But Ila and David took no notice.
ref    3
t      Ikaupaoro                     rokosiva                   ...
m      ikau      -pa       -oro      roko    -si       -va      ...
g      run/hurry -PROG     -SIM      go down -2/3.DL.M -RP      ...
p      V.T       -SUFF.V.3 -SUFF.V.4 ADV     -SUFF.V.4 -SUFF.VT....
f      Tupela i bin hariap i go long wara .
fe     They raced to the river. -->
</div>
<div class="section" id="timit">
<h3>timit</h3>
<p>The NLTK data package includes a fragment of the TIMIT
Acoustic-Phonetic Continuous Speech Corpus.  This corpus is broken
down into small speech samples, each of which is available as a wave
file, a phonetic transcription, and a tokenized word list.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import timit
&gt;&gt;&gt; print(timit.utteranceids()) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
['dr1-fvmh0/sa1', 'dr1-fvmh0/sa2', 'dr1-fvmh0/si1466',
'dr1-fvmh0/si2096', 'dr1-fvmh0/si836', 'dr1-fvmh0/sx116',
'dr1-fvmh0/sx206', 'dr1-fvmh0/sx26', 'dr1-fvmh0/sx296', ...]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; item = timit.utteranceids()[5]
&gt;&gt;&gt; print(timit.phones(item)) # doctest: +NORMALIZE_WHITESPACE
['h#', 'k', 'l', 'ae', 's', 'pcl', 'p', 'dh', 'ax',
 's', 'kcl', 'k', 'r', 'ux', 'ix', 'nx', 'y', 'ax',
 'l', 'eh', 'f', 'tcl', 't', 'hh', 'ae', 'n', 'dcl',
 'd', 'h#']
&gt;&gt;&gt; print(timit.words(item))
['clasp', 'the', 'screw', 'in', 'your', 'left', 'hand']
&gt;&gt;&gt; timit.play(item) # doctest: +SKIP
</pre>
</blockquote>
<p>The corpus reader can combine the word segmentation information with
the phonemes to produce a single tree structure:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for tree in timit.phone_trees(item):
...     print(tree)
(S
  h#
  (clasp k l ae s pcl p)
  (the dh ax)
  (screw s kcl k r ux)
  (in ix nx)
  (your y ax)
  (left l eh f tcl t)
  (hand hh ae n dcl d)
  h#)
</pre>
</blockquote>
<p>The start time and stop time of each phoneme, word, and sentence are
also available:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(timit.phone_times(item)) # doctest: +ELLIPSIS
[('h#', 0, 2190), ('k', 2190, 3430), ('l', 3430, 4326), ...]
&gt;&gt;&gt; print(timit.word_times(item)) # doctest: +ELLIPSIS
[('clasp', 2190, 8804), ('the', 8804, 9734), ...]
&gt;&gt;&gt; print(timit.sent_times(item))
[('Clasp the screw in your left hand.', 0, 32154)]
</pre>
</blockquote>
<p>We can use these times to play selected pieces of a speech sample:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; timit.play(item, 2190, 8804) # 'clasp'  # doctest: +SKIP
</pre>
</blockquote>
<p>The corpus reader can also be queried for information about the
speaker and sentence identifier for a given speech sample:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(timit.spkrid(item))
dr1-fvmh0
&gt;&gt;&gt; print(timit.sentid(item))
sx116
&gt;&gt;&gt; print(timit.spkrinfo(timit.spkrid(item))) # doctest: +NORMALIZE_WHITESPACE
SpeakerInfo(id='VMH0',
            sex='F',
            dr='1',
            use='TRN',
            recdate='03/11/86',
            birthdate='01/08/60',
            ht='5\'05&quot;',
            race='WHT',
            edu='BS',
            comments='BEST NEW ENGLAND ACCENT SO FAR')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # List the speech samples from the same speaker:
&gt;&gt;&gt; timit.utteranceids(spkrid=timit.spkrid(item)) # doctest: +ELLIPSIS
['dr1-fvmh0/sa1', 'dr1-fvmh0/sa2', 'dr1-fvmh0/si1466', ...]
</pre>
</blockquote>
</div>
<div class="section" id="twitter-samples">
<h3>twitter_samples</h3>
<p>Twitter is well-known microblog service that allows public data to be
collected via APIs. NLTK's twitter corpus currently contains a sample of 20k Tweets
retrieved from the Twitter Streaming API.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import twitter_samples
&gt;&gt;&gt; twitter_samples.fileids()
['negative_tweets.json', 'positive_tweets.json', 'tweets.20150430-223406.json']
</pre>
</blockquote>
<p>We follow standard practice in storing full Tweets as line-separated
JSON. These data structures can be accessed via <cite>tweets.docs()</cite>. However, in general it
is more practical to focus just on the text field of the Tweets, which
are accessed via the <cite>strings()</cite> method.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; twitter_samples.strings('tweets.20150430-223406.json')
['RT &#64;KirkKus: Indirect cost of the UK being in the EU is estimated to be costing Britain \xa3170 billion per year! #BetterOffOut #UKIP', ...]
</pre>
</blockquote>
<p>The default tokenizer for Tweets is specialised for 'casual' text, and
the <cite>tokenized()</cite> method returns a list of lists of tokens.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; twitter_samples.tokenized('tweets.20150430-223406.json')
[['RT', '&#64;KirkKus', ':', 'Indirect', 'cost', 'of', 'the', 'UK', 'being', 'in', ...],
 ['VIDEO', ':', 'Sturgeon', 'on', 'post-election', 'deals', 'http://t.co/BTJwrpbmOY'], ...]
</pre>
</blockquote>
</div>
<div class="section" id="rte">
<h3>rte</h3>
<p>The RTE (Recognizing Textual Entailment) corpus was derived from the
RTE1, RTE2 and RTE3 datasets (dev and test data), and consists of a
list of XML-formatted 'text'/'hypothesis' pairs.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import rte
&gt;&gt;&gt; print(rte.fileids()) # doctest: +ELLIPSIS
['rte1_dev.xml', 'rte1_test.xml', 'rte2_dev.xml', ..., 'rte3_test.xml']
&gt;&gt;&gt; rtepairs = rte.pairs(['rte2_test.xml', 'rte3_test.xml'])
&gt;&gt;&gt; print(rtepairs)  # doctest: +ELLIPSIS
[&lt;RTEPair: gid=2-8&gt;, &lt;RTEPair: gid=2-9&gt;, &lt;RTEPair: gid=2-15&gt;, ...]
</pre>
</blockquote>
<p>In the gold standard test sets, each pair is labeled according to
whether or not the text 'entails' the hypothesis; the
entailment value is mapped to an integer 1 (True) or 0 (False).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; rtepairs[5]
&lt;RTEPair: gid=2-23&gt;
&gt;&gt;&gt; rtepairs[5].text # doctest: +NORMALIZE_WHITESPACE
'His wife Strida won a seat in parliament after forging an alliance
with the main anti-Syrian coalition in the recent election.'
&gt;&gt;&gt; rtepairs[5].hyp
'Strida elected to parliament.'
&gt;&gt;&gt; rtepairs[5].value
1
</pre>
</blockquote>
<p>The RTE corpus also supports an <tt class="docutils literal">xml()</tt> method which produces ElementTrees.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; xmltree = rte.xml('rte3_dev.xml')
&gt;&gt;&gt; xmltree # doctest: +SKIP
&lt;Element entailment-corpus at ...&gt;
&gt;&gt;&gt; xmltree[7].findtext('t') # doctest: +NORMALIZE_WHITESPACE
&quot;Mrs. Bush's approval ratings have remained very high, above 80%,
even as her husband's have recently dropped below 50%.&quot;
</pre>
</blockquote>
</div>
<div class="section" id="verbnet">
<h3>verbnet</h3>
<p>The VerbNet corpus is a lexicon that divides verbs into classes, based
on their syntax-semantics linking behavior.  The basic elements in the
lexicon are verb lemmas, such as 'abandon' and 'accept', and verb
classes, which have identifiers such as 'remove-10.1' and
'admire-31.2-1'.  These class identifiers consist of a representative
verb selected from the class, followed by a numerical identifier.  The
list of verb lemmas, and the list of class identifiers, can be
retrieved with the following methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import verbnet
&gt;&gt;&gt; verbnet.lemmas()[20:25]
['accelerate', 'accept', 'acclaim', 'accompany', 'accrue']
&gt;&gt;&gt; verbnet.classids()[:5]
['accompany-51.7', 'admire-31.2', 'admire-31.2-1', 'admit-65', 'adopt-93']
</pre>
</blockquote>
<p>The <cite>classids()</cite> method may also be used to retrieve the classes that
a given lemma belongs to:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; verbnet.classids('accept')
['approve-77', 'characterize-29.2-1-1', 'obtain-13.5.2']
</pre>
</blockquote>
<p>The primary object in the lexicon is a class record, which is stored
as an ElementTree xml object.  The class record for a given class
identifier is returned by the <cite>vnclass()</cite> method:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; verbnet.vnclass('remove-10.1') # doctest: +ELLIPSIS
&lt;Element 'VNCLASS' at ...&gt;
</pre>
</blockquote>
<p>The <cite>vnclass()</cite> method also accepts &quot;short&quot; identifiers, such as '10.1':</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; verbnet.vnclass('10.1') # doctest: +ELLIPSIS
&lt;Element 'VNCLASS' at ...&gt;
</pre>
</blockquote>
<p>See the Verbnet documentation, or the Verbnet files, for information
about the structure of this xml.  As an example, we can retrieve a
list of thematic roles for a given Verbnet class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; vn_31_2 = verbnet.vnclass('admire-31.2')
&gt;&gt;&gt; for themrole in vn_31_2.findall('THEMROLES/THEMROLE'):
...     print(themrole.attrib['type'], end=' ')
...     for selrestr in themrole.findall('SELRESTRS/SELRESTR'):
...         print('[%(Value)s%(type)s]' % selrestr.attrib, end=' ')
...     print()
Theme
Experiencer [+animate]
Predicate
</pre>
</blockquote>
<p>The Verbnet corpus also provides a variety of pretty printing
functions that can be used to display the xml contents in a more
concise form.  The simplest such method is <cite>pprint()</cite>:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(verbnet.pprint('57'))
weather-57
  Subclasses: (none)
  Members: blow clear drizzle fog freeze gust hail howl lightning mist
    mizzle pelt pour precipitate rain roar shower sleet snow spit spot
    sprinkle storm swelter teem thaw thunder
  Thematic roles:
    * Theme[+concrete +force]
  Frames:
    Intransitive (Expletive Subject)
      Syntax: LEX[it] LEX[[+be]] VERB
      Semantics:
        * weather(during(E), Weather_type, ?Theme)
    NP (Expletive Subject, Theme Object)
      Syntax: LEX[it] LEX[[+be]] VERB NP[Theme]
      Semantics:
        * weather(during(E), Weather_type, Theme)
    PP (Expletive Subject, Theme-PP)
      Syntax: LEX[it[+be]] VERB PREP[with] NP[Theme]
      Semantics:
        * weather(during(E), Weather_type, Theme)
</pre>
</blockquote>
</div>
<div class="section" id="nps-chat">
<h3>nps_chat</h3>
<p>The NPS Chat Corpus, Release 1.0 consists of over 10,000 posts in age-specific
chat rooms, which have been anonymized, POS-tagged and dialogue-act tagged.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(nltk.corpus.nps_chat.words())
['now', 'im', 'left', 'with', 'this', 'gay', ...]
&gt;&gt;&gt; print(nltk.corpus.nps_chat.tagged_words())
[('now', 'RB'), ('im', 'PRP'), ('left', 'VBD'), ...]
&gt;&gt;&gt; print(nltk.corpus.nps_chat.tagged_posts()) # doctest: +NORMALIZE_WHITESPACE
[[('now', 'RB'), ('im', 'PRP'), ('left', 'VBD'), ('with', 'IN'),
('this', 'DT'), ('gay', 'JJ'), ('name', 'NN')], [(':P', 'UH')], ...]
</pre>
</blockquote>
<p>We can access the XML elements corresponding to individual posts.  These elements
have <tt class="docutils literal">class</tt> and <tt class="docutils literal">user</tt> attributes that we can access using <tt class="docutils literal"><span class="pre">p.attrib['class']</span></tt>
and <tt class="docutils literal"><span class="pre">p.attrib['user']</span></tt>.  They also have text content, accessed using <tt class="docutils literal">p.text</tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(nltk.corpus.nps_chat.xml_posts()) # doctest: +ELLIPSIS
[&lt;Element 'Post' at 0...&gt;, &lt;Element 'Post' at 0...&gt;, ...]
&gt;&gt;&gt; posts = nltk.corpus.nps_chat.xml_posts()
&gt;&gt;&gt; sorted(nltk.FreqDist(p.attrib['class'] for p in posts).keys())
['Accept', 'Bye', 'Clarify', 'Continuer', 'Emotion', 'Emphasis',
'Greet', 'Other', 'Reject', 'Statement', 'System', 'nAnswer',
'whQuestion', 'yAnswer', 'ynQuestion']
&gt;&gt;&gt; posts[0].text
'now im left with this gay name'
</pre>
</blockquote>
<p>In addition to the above methods for accessing tagged text, we can navigate
the XML structure directly, as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tokens = posts[0].findall('terminals/t')
&gt;&gt;&gt; [t.attrib['pos'] + &quot;/&quot; + t.attrib['word'] for t in tokens]
['RB/now', 'PRP/im', 'VBD/left', 'IN/with', 'DT/this', 'JJ/gay', 'NN/name']
</pre>
</blockquote>
</div>
<div class="section" id="multext-east">
<h3>multext_east</h3>
<p>The Multext-East Corpus consists of POS-tagged versions of George Orwell's book
1984 in 12 languages: English, Czech, Hungarian, Macedonian, Slovenian, Serbian,
Slovak, Romanian, Estonian, Farsi, Bulgarian and Polish.
The corpus can be accessed using the usual methods for tagged corpora. The tagset
can be transformed from the Multext-East specific MSD tags to the Universal tagset
using the &quot;tagset&quot; parameter of all functions returning tagged parts of the corpus.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(nltk.corpus.multext_east.words(&quot;oana-en.xml&quot;))
['It', 'was', 'a', 'bright', ...]
&gt;&gt;&gt; print(nltk.corpus.multext_east.tagged_words(&quot;oana-en.xml&quot;))
[('It', '#Pp3ns'), ('was', '#Vmis3s'), ('a', '#Di'), ...]
&gt;&gt;&gt; print(nltk.corpus.multext_east.tagged_sents(&quot;oana-en.xml&quot;, &quot;universal&quot;))
[[('It', 'PRON'), ('was', 'VERB'), ('a', 'DET'), ...]
</pre>
</blockquote>
</div>
</div>
</div>
<div class="section" id="corpus-reader-classes">
<h1>Corpus Reader Classes</h1>
<p>NLTK's <em>corpus reader</em> classes are used to access the contents of a
diverse set of corpora.  Each corpus reader class is specialized to
handle a specific corpus format.  Examples include the
<cite>PlaintextCorpusReader</cite>, which handles corpora that consist of a set
of unannotated text files, and the <cite>BracketParseCorpusReader</cite>, which
handles corpora that consist of files containing
parenthesis-delineated parse trees.</p>
<div class="section" id="automatically-created-corpus-reader-instances">
<h2>Automatically Created Corpus Reader Instances</h2>
<p>When the <cite>nltk.corpus</cite> module is imported, it automatically creates a
set of corpus reader instances that can be used to access the corpora
in the NLTK data distribution.  Here is a small sample of those
corpus reader instances:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import nltk
&gt;&gt;&gt; nltk.corpus.brown # doctest: +ELLIPSIS
&lt;CategorizedTaggedCorpusReader ...&gt;
&gt;&gt;&gt; nltk.corpus.treebank # doctest: +ELLIPSIS
&lt;BracketParseCorpusReader ...&gt;
&gt;&gt;&gt; nltk.corpus.names # doctest: +ELLIPSIS
&lt;WordListCorpusReader ...&gt;
&gt;&gt;&gt; nltk.corpus.genesis # doctest: +ELLIPSIS
&lt;PlaintextCorpusReader ...&gt;
&gt;&gt;&gt; nltk.corpus.inaugural # doctest: +ELLIPSIS
&lt;PlaintextCorpusReader ...&gt;
</pre>
</blockquote>
<p>This sample illustrates that different corpus reader classes are used
to read different corpora; but that the same corpus reader class may
be used for more than one corpus (e.g., <tt class="docutils literal">genesis</tt> and <tt class="docutils literal">inaugural</tt>).</p>
</div>
<div class="section" id="creating-new-corpus-reader-instances">
<h2>Creating New Corpus Reader Instances</h2>
<p>Although the <cite>nltk.corpus</cite> module automatically creates corpus reader
instances for the corpora in the NLTK data distribution, you may
sometimes need to create your own corpus reader.  In particular, you
would need to create your own corpus reader if you want...</p>
<ul class="simple">
<li>To access a corpus that is not included in the NLTK data
distribution.</li>
<li>To access a full copy of a corpus for which the NLTK data
distribution only provides a sample.</li>
<li>To access a corpus using a customized corpus reader (e.g., with
a customized tokenizer).</li>
</ul>
<p>To create a new corpus reader, you will first need to look up the
signature for that corpus reader's constructor.  Different corpus
readers have different constructor signatures, but most of the
constructor signatures have the basic form:</p>
<pre class="literal-block">
SomeCorpusReader(root, files, ...options...)
</pre>
<p>Where <tt class="docutils literal">root</tt> is an absolute path to the directory containing the
corpus data files; <tt class="docutils literal">files</tt> is either a list of file names (relative
to <tt class="docutils literal">root</tt>) or a regexp specifying which files should be included;
and <tt class="docutils literal">options</tt> are additional reader-specific options.  For example,
we can create a customized corpus reader for the genesis corpus that
uses a different sentence tokenizer as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; # Find the directory where the corpus lives.
&gt;&gt;&gt; genesis_dir = nltk.data.find('corpora/genesis')
&gt;&gt;&gt; # Create our custom sentence tokenizer.
&gt;&gt;&gt; my_sent_tokenizer = nltk.RegexpTokenizer('[^.!?]+')
&gt;&gt;&gt; # Create the new corpus reader object.
&gt;&gt;&gt; my_genesis = nltk.corpus.PlaintextCorpusReader(
...     genesis_dir, '.*\.txt', sent_tokenizer=my_sent_tokenizer)
&gt;&gt;&gt; # Use the new corpus reader object.
&gt;&gt;&gt; print(my_genesis.sents('english-kjv.txt')[0]) # doctest: +NORMALIZE_WHITESPACE
['In', 'the', 'beginning', 'God', 'created', 'the', 'heaven',
 'and', 'the', 'earth']
</pre>
</blockquote>
<p>If you wish to read your own plaintext corpus, which is stored in the
directory '/usr/share/some-corpus', then you can create a corpus
reader for it with:</p>
<pre class="literal-block">
&gt;&gt;&gt; my_corpus = nltk.corpus.PlaintextCorpusReader(
...     '/usr/share/some-corpus', '.*\.txt') # doctest: +SKIP
</pre>
<p>For a complete list of corpus reader subclasses, see the API
documentation for <cite>nltk.corpus.reader</cite>.</p>
</div>
<div class="section" id="corpus-types">
<h2>Corpus Types</h2>
<p>Corpora vary widely in the types of content they include.  This is
reflected in the fact that the base class <cite>CorpusReader</cite> only defines
a few general-purpose methods for listing and accessing the files that
make up a corpus.  It is up to the subclasses to define <em>data access
methods</em> that provide access to the information in the corpus.
However, corpus reader subclasses should be consistent in their
definitions of these data access methods wherever possible.</p>
<p>At a high level, corpora can be divided into three basic types:</p>
<ul class="simple">
<li>A <em>token corpus</em> contains information about specific occurences of
language use (or linguistic tokens), such as dialogues or written
texts.  Examples of token corpora are collections of written text
and collections of speech.</li>
<li>A <em>type corpus</em>, or <em>lexicon</em>, contains information about a coherent
set of lexical items (or linguistic types).  Examples of lexicons
are dictionaries and word lists.</li>
<li>A <em>language description corpus</em> contains information about a set of
non-lexical linguistic constructs, such as grammar rules.</li>
</ul>
<p>However, many individual corpora blur the distinctions between these
types.  For example, corpora that are primarily lexicons may include
token data in the form of example sentences; and corpora that are
primarily token corpora may be accompanied by one or more word lists
or other lexical data sets.</p>
<p>Because corpora vary so widely in their information content, we have
decided that it would not be wise to use separate corpus reader base
classes for different corpus types.  Instead, we simply try to make
the corpus readers consistent wherever possible, but let them differ
where the underlying data itself differs.</p>
</div>
<div class="section" id="common-corpus-reader-methods">
<h2>Common Corpus Reader Methods</h2>
<p>As mentioned above, there are only a handful of methods that all
corpus readers are guaranteed to implement.  These methods provide
access to the files that contain the corpus data.  Every corpus is
assumed to consist of one or more files, all located in a common root
directory (or in subdirectories of that root directory).  The absolute
path to the root directory is stored in the <tt class="docutils literal">root</tt> property:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import os
&gt;&gt;&gt; str(nltk.corpus.genesis.root).replace(os.path.sep,'/') # doctest: +ELLIPSIS
'.../nltk_data/corpora/genesis'
</pre>
</blockquote>
<p>Each file within the corpus is identified by a platform-independent
identifier, which is basically a path string that uses <tt class="docutils literal">/</tt> as the
path separator.  I.e., this identifier can be converted to a relative
path as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; some_corpus_file_id = nltk.corpus.reuters.fileids()[0]
&gt;&gt;&gt; import os.path
&gt;&gt;&gt; os.path.normpath(some_corpus_file_id).replace(os.path.sep,'/')
'test/14826'
</pre>
</blockquote>
<p>To get a list of all data files that make up a corpus, use the
<tt class="docutils literal">fileids()</tt> method.  In some corpora, these files will not all contain
the same type of data; for example, for the <tt class="docutils literal">nltk.corpus.timit</tt>
corpus, <tt class="docutils literal">fileids()</tt> will return a list including text files, word
segmentation files, phonetic transcription files, sound files, and
metadata files.  For corpora with diverse file types, the <tt class="docutils literal">fileids()</tt>
method will often take one or more optional arguments, which can be
used to get a list of the files with a specific file type:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.timit.fileids() # doctest: +ELLIPSIS
['dr1-fvmh0/sa1.phn', 'dr1-fvmh0/sa1.txt', 'dr1-fvmh0/sa1.wav', ...]
&gt;&gt;&gt; nltk.corpus.timit.fileids('phn') # doctest: +ELLIPSIS
['dr1-fvmh0/sa1.phn', 'dr1-fvmh0/sa2.phn', 'dr1-fvmh0/si1466.phn', ...]
</pre>
</blockquote>
<p>In some corpora, the files are divided into distinct categories.  For
these corpora, the <tt class="docutils literal">fileids()</tt> method takes an optional argument,
which can be used to get a list of the files within a specific category:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.brown.fileids('hobbies') # doctest: +ELLIPSIS
['ce01', 'ce02', 'ce03', 'ce04', 'ce05', 'ce06', 'ce07', ...]
</pre>
</blockquote>
<p>The <tt class="docutils literal">abspath()</tt> method can be used to find the absolute path to a
corpus file, given its file identifier:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str(nltk.corpus.brown.abspath('ce06')).replace(os.path.sep,'/') # doctest: +ELLIPSIS
'.../corpora/brown/ce06'
</pre>
</blockquote>
<p>The <tt class="docutils literal">abspaths()</tt> method can be used to find the absolute paths for
one corpus file, a list of corpus files, or (if no fileids are specified),
all corpus files.</p>
<p>This method is mainly useful as a helper method when defining corpus
data access methods, since data access methods can usually be called
with a string argument (to get a view for a specific file), with a
list argument (to get a view for a specific list of files), or with no
argument (to get a view for the whole corpus).</p>
</div>
<div class="section" id="data-access-methods">
<h2>Data Access Methods</h2>
<p>Individual corpus reader subclasses typically extend this basic set of
file-access methods with one or more <em>data access methods</em>, which provide
easy access to the data contained in the corpus.  The signatures for
data access methods often have the basic form:</p>
<pre class="literal-block">
corpus_reader.some_data access(fileids=None, ...options...)
</pre>
<p>Where <tt class="docutils literal">fileids</tt> can be a single file identifier string (to get a view
for a specific file); a list of file identifier strings (to get a view
for a specific list of files); or None (to get a view for the entire
corpus).  Some of the common data access methods, and their return
types, are:</p>
<blockquote>
<ul class="simple">
<li>I{corpus}.words(): list of str</li>
<li>I{corpus}.sents(): list of (list of str)</li>
<li>I{corpus}.paras(): list of (list of (list of str))</li>
<li>I{corpus}.tagged_words(): list of (str,str) tuple</li>
<li>I{corpus}.tagged_sents(): list of (list of (str,str))</li>
<li>I{corpus}.tagged_paras(): list of (list of (list of (str,str)))</li>
<li>I{corpus}.chunked_sents(): list of (Tree w/ (str,str) leaves)</li>
<li>I{corpus}.parsed_sents(): list of (Tree with str leaves)</li>
<li>I{corpus}.parsed_paras(): list of (list of (Tree with str leaves))</li>
<li>I{corpus}.xml(): A single xml ElementTree</li>
<li>I{corpus}.raw(): str (unprocessed corpus contents)</li>
</ul>
</blockquote>
<p>For example, the <cite>words()</cite> method is supported by many different
corpora, and returns a flat list of word strings:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.brown.words()
['The', 'Fulton', 'County', 'Grand', 'Jury', ...]
&gt;&gt;&gt; nltk.corpus.treebank.words()
['Pierre', 'Vinken', ',', '61', 'years', 'old', ...]
&gt;&gt;&gt; nltk.corpus.conll2002.words()
[u'Sao', u'Paulo', u'(', u'Brasil', u')', u',', u'23', ...]
&gt;&gt;&gt; nltk.corpus.genesis.words()
[u'In', u'the', u'beginning', u'God', u'created', ...]
</pre>
</blockquote>
<p>On the other hand, the <cite>tagged_words()</cite> method is only supported by
corpora that include part-of-speech annotations:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.brown.tagged_words()
[('The', 'AT'), ('Fulton', 'NP-TL'), ...]
&gt;&gt;&gt; nltk.corpus.treebank.tagged_words()
[('Pierre', 'NNP'), ('Vinken', 'NNP'), ...]
&gt;&gt;&gt; nltk.corpus.conll2002.tagged_words()
[(u'Sao', u'NC'), (u'Paulo', u'VMI'), (u'(', u'Fpa'), ...]
&gt;&gt;&gt; nltk.corpus.genesis.tagged_words()
Traceback (most recent call last):
  ...
AttributeError: 'PlaintextCorpusReader' object has no attribute 'tagged_words'
</pre>
</blockquote>
<p>Although most corpus readers use file identifiers to index their
content, some corpora use different identifiers instead.  For example,
the data access methods for the <tt class="docutils literal">timit</tt> corpus uses <em>utterance
identifiers</em> to select which corpus items should be returned:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.timit.utteranceids() # doctest: +ELLIPSIS
['dr1-fvmh0/sa1', 'dr1-fvmh0/sa2', 'dr1-fvmh0/si1466', ...]
&gt;&gt;&gt; nltk.corpus.timit.words('dr1-fvmh0/sa2')
[&quot;don't&quot;, 'ask', 'me', 'to', 'carry', 'an', 'oily', 'rag', 'like', 'that']
</pre>
</blockquote>
<p>Attempting to call <tt class="docutils literal">timit</tt>'s data access methods with a file
identifier will result in an exception:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; nltk.corpus.timit.fileids() # doctest: +ELLIPSIS
['dr1-fvmh0/sa1.phn', 'dr1-fvmh0/sa1.txt', 'dr1-fvmh0/sa1.wav', ...]
&gt;&gt;&gt; nltk.corpus.timit.words('dr1-fvmh0/sa1.txt') # doctest: +SKIP
Traceback (most recent call last):
  ...
IOError: No such file or directory: '.../dr1-fvmh0/sa1.txt.wrd'
</pre>
</blockquote>
<p>As another example, the <tt class="docutils literal">propbank</tt> corpus defines the <tt class="docutils literal">roleset()</tt>
method, which expects a roleset identifier, not a file identifier:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; roleset = nltk.corpus.propbank.roleset('eat.01')
&gt;&gt;&gt; from xml.etree import ElementTree as ET
&gt;&gt;&gt; print(ET.tostring(roleset).decode('utf8')) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
&lt;roleset id=&quot;eat.01&quot; name=&quot;consume&quot; vncls=&quot;39.1&quot;&gt;
  &lt;roles&gt;
    &lt;role descr=&quot;consumer, eater&quot; n=&quot;0&quot;&gt;...&lt;/role&gt;...
  &lt;/roles&gt;...
&lt;/roleset&gt;...
</pre>
</blockquote>
</div>
<div class="section" id="stream-backed-corpus-views">
<h2>Stream Backed Corpus Views</h2>
<p>An important feature of NLTK's corpus readers is that many of them
access the underlying data files using &quot;corpus views.&quot;  A <em>corpus
view</em> is an object that acts like a simple data structure (such as a
list), but does not store the data elements in memory; instead, data
elements are read from the underlying data files on an as-needed
basis.</p>
<p>By only loading items from the file on an as-needed basis, corpus
views maintain both memory efficiency and responsiveness.  The memory
efficiency of corpus readers is important because some corpora contain
very large amounts of data, and storing the entire data set in memory
could overwhelm many machines.  The responsiveness is important when
experimenting with corpora in interactive sessions and in in-class
demonstrations.</p>
<p>The most common corpus view is the <cite>StreamBackedCorpusView</cite>, which
acts as a read-only list of tokens.  Two additional corpus view
classes, <cite>ConcatenatedCorpusView</cite> and <cite>LazySubsequence</cite>, make it
possible to create concatenations and take slices of
<cite>StreamBackedCorpusView</cite> objects without actually storing the
resulting list-like object's elements in memory.</p>
<p>In the future, we may add additional corpus views that act like other
basic data structures, such as dictionaries.</p>
</div>
<div class="section" id="writing-new-corpus-readers">
<h2>Writing New Corpus Readers</h2>
<p>In order to add support for new corpus formats, it is necessary to
define new corpus reader classes.  For many corpus formats, writing
new corpus readers is relatively straight-forward.  In this section,
we'll describe what's involved in creating a new corpus reader.  If
you do create a new corpus reader, we encourage you to contribute it
back to the NLTK project.</p>
<div class="section" id="don-t-reinvent-the-wheel">
<h3>Don't Reinvent the Wheel</h3>
<p>Before you start writing a new corpus reader, you should check to be
sure that the desired format can't be read using an existing corpus
reader with appropriate constructor arguments.  For example, although
the <cite>TaggedCorpusReader</cite> assumes that words and tags are separated by
<tt class="docutils literal">/</tt> characters by default, an alternative tag-separation character
can be specified via the <tt class="docutils literal">sep</tt> constructor argument.  You should
also check whether the new corpus format can be handled by subclassing
an existing corpus reader, and tweaking a few methods or variables.</p>
</div>
<div class="section" id="design">
<h3>Design</h3>
<p>If you decide to write a new corpus reader from scratch, then you
should first decide which data access methods you want the reader to
provide, and what their signatures should be.  You should look at
existing corpus readers that process corpora with similar data
contents, and try to be consistent with those corpus readers whenever
possible.</p>
<p>You should also consider what sets of identifiers are appropriate for
the corpus format.  Where it's practical, file identifiers should be
used.  However, for some corpora, it may make sense to use additional
sets of identifiers.  Each set of identifiers should have a distinct
name (e.g., fileids, utteranceids, rolesets); and you should be consistent
in using that name to refer to that identifier.  Do not use parameter
names like <tt class="docutils literal">id</tt>, which leave it unclear what type of identifier is
required.</p>
<p>Once you've decided what data access methods and identifiers are
appropriate for your corpus, you should decide if there are any
customizable parameters that you'd like the corpus reader to handle.
These parameters make it possible to use a single corpus reader to
handle a wider variety of corpora.  The <tt class="docutils literal">sep</tt> argument for
<cite>TaggedCorpusReader</cite>, mentioned above, is an example of a customizable
corpus reader parameter.</p>
</div>
<div class="section" id="implementation">
<h3>Implementation</h3>
<div class="section" id="constructor">
<h4>Constructor</h4>
<p>If your corpus reader implements any customizable parameters, then
you'll need to override the constructor.  Typically, the new
constructor will first call its base class's constructor, and then
store the customizable parameters.  For example, the
<cite>ConllChunkCorpusReader</cite>'s constructor is defined as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def __init__(self, root, files, chunk_types):
...     CorpusReader.__init__(self, root, files)
...     self.chunk_types = tuple(chunk_types)
</pre>
</blockquote>
<p>If your corpus reader does not implement any customization parameters,
then you can often just inherit the base class's constructor.</p>
</div>
<div class="section" id="id1">
<h4>Data Access Methods</h4>
<p>The most common type of data access method takes an argument
identifying which files to access, and returns a view covering those
files.  This argument may be a single file identifier string (to get a
view for a specific file); a list of file identifier strings (to get a
view for a specific list of files); or None (to get a view for the
entire corpus).  The method's implementation converts this argument to
a list of path names using the <cite>abspaths()</cite> method, which handles all
three value types (string, list, and None):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print(str(nltk.corpus.brown.abspaths()).replace('\\\\','/')) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[FileSystemPathPointer('.../corpora/brown/ca01'),
 FileSystemPathPointer('.../corpora/brown/ca02'), ...]
&gt;&gt;&gt; print(str(nltk.corpus.brown.abspaths('ce06')).replace('\\\\','/')) # doctest: +ELLIPSIS
[FileSystemPathPointer('.../corpora/brown/ce06')]
&gt;&gt;&gt; print(str(nltk.corpus.brown.abspaths(['ce06', 'ce07'])).replace('\\\\','/')) # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[FileSystemPathPointer('.../corpora/brown/ce06'),
 FileSystemPathPointer('.../corpora/brown/ce07')]
</pre>
</blockquote>
<p>An example of this type of method is the <cite>words()</cite> method, defined by
the <cite>PlaintextCorpusReader</cite> as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def words(self, fileids=None):
...     return concat([self.CorpusView(fileid, self._read_word_block)
...                    for fileid in self.abspaths(fileids)])
</pre>
</blockquote>
<p>This method first uses <cite>abspaths()</cite> to convert <tt class="docutils literal">fileids</tt> to a list of
absolute paths.  It then creates a corpus view for each file, using
the <cite>PlaintextCorpusReader._read_word_block()</cite> method to read elements
from the data file (see the discussion of corpus views below).
Finally, it combines these corpus views using the
<cite>nltk.corpus.reader.util.concat()</cite> function.</p>
<p>When writing a corpus reader for a corpus that is never expected to be
very large, it can sometimes be appropriate to read the files
directly, rather than using a corpus view.  For example, the
<cite>WordListCorpusView</cite> class defines its <cite>words()</cite> method as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def words(self, fileids=None):
...     return concat([[w for w in open(fileid).read().split('\n') if w]
...                    for fileid in self.abspaths(fileids)])
</pre>
</blockquote>
<p>(This is usually more appropriate for lexicons than for token corpora.)</p>
<p>If the type of data returned by a data access method is one for which
NLTK has a conventional representation (e.g., words, tagged words, and
parse trees), then you should use that representation.  Otherwise, you
may find it necessary to define your own representation.  For data
structures that are relatively corpus-specific, it's usually best to
define new classes for these elements.  For example, the <tt class="docutils literal">propbank</tt>
corpus defines the <cite>PropbankInstance</cite> class to store the semantic role
labeling instances described by the corpus; and the <tt class="docutils literal">ppattach</tt>
corpus defines the <cite>PPAttachment</cite> class to store the prepositional
attachment instances described by the corpus.</p>
</div>
<div class="section" id="corpus-views">
<h4>Corpus Views</h4>
<!-- (Much of the content for this section is taken from the
StreamBackedCorpusView docstring.) -->
<p>The heart of a <cite>StreamBackedCorpusView</cite> is its <em>block reader</em>
function, which reads zero or more tokens from a stream, and returns
them as a list.  A very simple example of a block reader is:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; def simple_block_reader(stream):
...     return stream.readline().split()
</pre>
</blockquote>
<p>This simple block reader reads a single line at a time, and returns a
single token (consisting of a string) for each whitespace-separated
substring on the line.  A <cite>StreamBackedCorpusView</cite> built from this
block reader will act like a read-only list of all the
whitespace-separated tokens in an underlying file.</p>
<p>When deciding how to define the block reader for a given corpus,
careful consideration should be given to the size of blocks handled by
the block reader.  Smaller block sizes will increase the memory
requirements of the corpus view's internal data structures (by 2
integers per block).  On the other hand, larger block sizes may
decrease performance for random access to the corpus.  (But note that
larger block sizes will <em>not</em> decrease performance for iteration.)</p>
<p>Internally, the <cite>StreamBackedCorpusView</cite> class maintains a partial
mapping from token index to file position, with one entry per block.
When a token with a given index <em>i</em> is requested, the corpus view
constructs it as follows:</p>
<ol class="arabic simple">
<li>First, it searches the toknum/filepos mapping for the token index
closest to (but less than or equal to) <em>i</em>.</li>
<li>Then, starting at the file position corresponding to that index, it
reads one block at a time using the block reader until it reaches
the requested token.</li>
</ol>
<p>The toknum/filepos mapping is created lazily: it is initially empty,
but every time a new block is read, the block's initial token is added
to the mapping.  (Thus, the toknum/filepos map has one entry per
block.)</p>
<p>You can create your own corpus view in one of two ways:</p>
<ol class="arabic simple">
<li>Call the <cite>StreamBackedCorpusView</cite> constructor, and provide your
block reader function via the <tt class="docutils literal">block_reader</tt> argument.</li>
<li>Subclass <cite>StreamBackedCorpusView</cite>, and override the
<cite>read_block()</cite> method.</li>
</ol>
<p>The first option is usually easier, but the second option can allow
you to write a single <cite>read_block</cite> method whose behavior can be
customized by different parameters to the subclass's constructor.  For
an example of this design pattern, see the <cite>TaggedCorpusView</cite> class,
which is used by <cite>TaggedCorpusView</cite>.</p>
</div>
</div>
</div>
</div>
<div class="section" id="regression-tests">
<h1>Regression Tests</h1>
<p>The following helper functions are used to create and then delete
testing corpora that are stored in temporary directories.  These
testing corpora are used to make sure the readers work correctly.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import tempfile, os.path, textwrap
&gt;&gt;&gt; def make_testcorpus(ext='', **fileids):
...     root = tempfile.mkdtemp()
...     for fileid, contents in fileids.items():
...         fileid += ext
...         f = open(os.path.join(root, fileid), 'w')
...         f.write(textwrap.dedent(contents))
...         f.close()
...     return root
&gt;&gt;&gt; def del_testcorpus(root):
...     for fileid in os.listdir(root):
...         os.remove(os.path.join(root, fileid))
...     os.rmdir(root)
</pre>
</blockquote>
<div class="section" id="plaintext-corpus-reader">
<h2>Plaintext Corpus Reader</h2>
<p>The plaintext corpus reader is used to access corpora that consist of
unprocessed plaintext data.  It assumes that paragraph breaks are
indicated by blank lines.  Sentences and words can be tokenized using
the default tokenizers, or by custom tokenizers specified as
parameters to the constructor.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; root = make_testcorpus(ext='.txt',
...     a=&quot;&quot;&quot;\
...     This is the first sentence.  Here is another
...     sentence!  And here's a third sentence.
...
...     This is the second paragraph.  Tokenization is currently
...     fairly simple, so the period in Mr. gets tokenized.
...     &quot;&quot;&quot;,
...     b=&quot;&quot;&quot;This is the second file.&quot;&quot;&quot;)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus.reader.plaintext import PlaintextCorpusReader
</pre>
</blockquote>
<p>The list of documents can be specified explicitly, or implicitly (using a
regexp).  The <tt class="docutils literal">ext</tt> argument specifies a file extension.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; corpus = PlaintextCorpusReader(root, ['a.txt', 'b.txt'])
&gt;&gt;&gt; corpus.fileids()
['a.txt', 'b.txt']
&gt;&gt;&gt; corpus = PlaintextCorpusReader(root, '.*\.txt')
&gt;&gt;&gt; corpus.fileids()
['a.txt', 'b.txt']
</pre>
</blockquote>
<p>The directory containing the corpus is corpus.root:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; str(corpus.root) == str(root)
True
</pre>
</blockquote>
<p>We can get a list of words, or the raw string:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; corpus.words()
['This', 'is', 'the', 'first', 'sentence', '.', ...]
&gt;&gt;&gt; corpus.raw()[:40]
'This is the first sentence.  Here is ano'
</pre>
</blockquote>
<p>Check that reading individual documents works, and reading all documents at
once works:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; len(corpus.words()), [len(corpus.words(d)) for d in corpus.fileids()]
(46, [40, 6])
&gt;&gt;&gt; corpus.words('a.txt')
['This', 'is', 'the', 'first', 'sentence', '.', ...]
&gt;&gt;&gt; corpus.words('b.txt')
['This', 'is', 'the', 'second', 'file', '.']
&gt;&gt;&gt; corpus.words()[:4], corpus.words()[-4:]
(['This', 'is', 'the', 'first'], ['the', 'second', 'file', '.'])
</pre>
</blockquote>
<p>We're done with the test corpus:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; del_testcorpus(root)
</pre>
</blockquote>
<p>Test the plaintext corpora that come with nltk:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import abc, genesis, inaugural
&gt;&gt;&gt; from nltk.corpus import state_union, webtext
&gt;&gt;&gt; for corpus in (abc, genesis, inaugural, state_union,
...                webtext):
...     print(str(corpus).replace('\\\\','/'))
...     print('  ', repr(corpus.fileids())[:60])
...     print('  ', repr(corpus.words()[:10])[:60])
&lt;PlaintextCorpusReader in '.../nltk_data/corpora/ab...'&gt;
   ['rural.txt', 'science.txt']
   ['PM', 'denies', 'knowledge', 'of', 'AWB', ...
&lt;PlaintextCorpusReader in '.../nltk_data/corpora/genesi...'&gt;
   ['english-kjv.txt', 'english-web.txt', 'finnish.txt', ...
   ['In', 'the', 'beginning', 'God', 'created', 'the', ...
&lt;PlaintextCorpusReader in '.../nltk_data/corpora/inaugura...'&gt;
   ['1789-Washington.txt', '1793-Washington.txt', ...
   ['Fellow', '-', 'Citizens', 'of', 'the', 'Senate', ...
&lt;PlaintextCorpusReader in '.../nltk_data/corpora/state_unio...'&gt;
   ['1945-Truman.txt', '1946-Truman.txt', ...
   ['PRESIDENT', 'HARRY', 'S', '.', 'TRUMAN', &quot;'&quot;, ...
&lt;PlaintextCorpusReader in '.../nltk_data/corpora/webtex...'&gt;
   ['firefox.txt', 'grail.txt', 'overheard.txt', ...
   ['Cookie', 'Manager', ':', '&quot;', 'Don', &quot;'&quot;, 't', ...
</pre>
</blockquote>
</div>
<div class="section" id="tagged-corpus-reader">
<h2>Tagged Corpus Reader</h2>
<p>The Tagged Corpus reader can give us words, sentences, and paragraphs,
each tagged or untagged.  All of the read methods can take one item
(in which case they return the contents of that file) or a list of
documents (in which case they concatenate the contents of those files).
By default, they apply to all documents in the corpus.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; root = make_testcorpus(
...     a=&quot;&quot;&quot;\
...     This/det is/verb the/det first/adj sentence/noun ./punc
...     Here/det  is/verb  another/adj    sentence/noun ./punc
...     Note/verb that/comp you/pron can/verb use/verb \
...           any/noun tag/noun set/noun
...
...     This/det is/verb the/det second/adj paragraph/noun ./punc
...     word/n without/adj a/det tag/noun :/: hello ./punc
...     &quot;&quot;&quot;,
...     b=&quot;&quot;&quot;\
...     This/det is/verb the/det second/adj file/noun ./punc
...     &quot;&quot;&quot;)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus.reader.tagged import TaggedCorpusReader
&gt;&gt;&gt; corpus = TaggedCorpusReader(root, list('ab'))
&gt;&gt;&gt; corpus.fileids()
['a', 'b']
&gt;&gt;&gt; str(corpus.root) == str(root)
True
&gt;&gt;&gt; corpus.words()
['This', 'is', 'the', 'first', 'sentence', '.', ...]
&gt;&gt;&gt; corpus.sents() # doctest: +ELLIPSIS
[['This', 'is', 'the', 'first', ...], ['Here', 'is', 'another'...], ...]
&gt;&gt;&gt; corpus.paras() # doctest: +ELLIPSIS
[[['This', ...], ['Here', ...], ...], [['This', ...], ...], ...]
&gt;&gt;&gt; corpus.tagged_words() # doctest: +ELLIPSIS
[('This', 'DET'), ('is', 'VERB'), ('the', 'DET'), ...]
&gt;&gt;&gt; corpus.tagged_sents() # doctest: +ELLIPSIS
[[('This', 'DET'), ('is', 'VERB'), ...], [('Here', 'DET'), ...], ...]
&gt;&gt;&gt; corpus.tagged_paras() # doctest: +ELLIPSIS
[[[('This', 'DET'), ...], ...], [[('This', 'DET'), ...], ...], ...]
&gt;&gt;&gt; corpus.raw()[:40]
'This/det is/verb the/det first/adj sente'
&gt;&gt;&gt; len(corpus.words()), [len(corpus.words(d)) for d in corpus.fileids()]
(38, [32, 6])
&gt;&gt;&gt; len(corpus.sents()), [len(corpus.sents(d)) for d in corpus.fileids()]
(6, [5, 1])
&gt;&gt;&gt; len(corpus.paras()), [len(corpus.paras(d)) for d in corpus.fileids()]
(3, [2, 1])
&gt;&gt;&gt; print(corpus.words('a'))
['This', 'is', 'the', 'first', 'sentence', '.', ...]
&gt;&gt;&gt; print(corpus.words('b'))
['This', 'is', 'the', 'second', 'file', '.']
&gt;&gt;&gt; del_testcorpus(root)
</pre>
</blockquote>
<p>The Brown Corpus uses the tagged corpus reader:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import brown
&gt;&gt;&gt; brown.fileids() # doctest: +ELLIPSIS
['ca01', 'ca02', 'ca03', 'ca04', 'ca05', 'ca06', 'ca07', ...]
&gt;&gt;&gt; brown.categories() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
['adventure', 'belles_lettres', 'editorial', 'fiction', 'government', 'hobbies', 'humor',
'learned', 'lore', 'mystery', 'news', 'religion', 'reviews', 'romance', 'science_fiction']
&gt;&gt;&gt; print(repr(brown.root).replace('\\\\','/')) # doctest: +ELLIPSIS
FileSystemPathPointer('.../corpora/brown')
&gt;&gt;&gt; brown.words()
['The', 'Fulton', 'County', 'Grand', 'Jury', ...]
&gt;&gt;&gt; brown.sents() # doctest: +ELLIPSIS
[['The', 'Fulton', 'County', 'Grand', ...], ...]
&gt;&gt;&gt; brown.paras() # doctest: +ELLIPSIS
[[['The', 'Fulton', 'County', ...]], [['The', 'jury', ...]], ...]
&gt;&gt;&gt; brown.tagged_words() # doctest: +ELLIPSIS
[('The', 'AT'), ('Fulton', 'NP-TL'), ...]
&gt;&gt;&gt; brown.tagged_sents() # doctest: +ELLIPSIS
[[('The', 'AT'), ('Fulton', 'NP-TL'), ('County', 'NN-TL'), ...], ...]
&gt;&gt;&gt; brown.tagged_paras() # doctest: +ELLIPSIS
[[[('The', 'AT'), ...]], [[('The', 'AT'), ...]], ...]
</pre>
</blockquote>
</div>
<div class="section" id="verbnet-corpus-reader">
<h2>Verbnet Corpus Reader</h2>
<p>Make sure we're picking up the right number of elements:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import verbnet
&gt;&gt;&gt; len(verbnet.lemmas())
3621
&gt;&gt;&gt; len(verbnet.wordnetids())
4953
&gt;&gt;&gt; len(verbnet.classids())
429
</pre>
</blockquote>
<p>Selecting classids based on various selectors:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; verbnet.classids(lemma='take') # doctest: +NORMALIZE_WHITESPACE
['bring-11.3', 'characterize-29.2', 'convert-26.6.2', 'cost-54.2',
'fit-54.3', 'performance-26.7-2', 'steal-10.5']
&gt;&gt;&gt; verbnet.classids(wordnetid='lead%2:38:01')
['accompany-51.7']
&gt;&gt;&gt; verbnet.classids(fileid='approve-77.xml')
['approve-77']
&gt;&gt;&gt; verbnet.classids(classid='admire-31.2') # subclasses
['admire-31.2-1']
</pre>
</blockquote>
<p>vnclass() accepts filenames, long ids, and short ids:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = ElementTree.tostring(verbnet.vnclass('admire-31.2.xml'))
&gt;&gt;&gt; b = ElementTree.tostring(verbnet.vnclass('admire-31.2'))
&gt;&gt;&gt; c = ElementTree.tostring(verbnet.vnclass('31.2'))
&gt;&gt;&gt; a == b == c
True
</pre>
</blockquote>
<p>fileids() can be used to get files based on verbnet class ids:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; verbnet.fileids('admire-31.2')
['admire-31.2.xml']
&gt;&gt;&gt; verbnet.fileids(['admire-31.2', 'obtain-13.5.2'])
['admire-31.2.xml', 'obtain-13.5.2.xml']
&gt;&gt;&gt; verbnet.fileids('badidentifier')
Traceback (most recent call last):
  . . .
ValueError: vnclass identifier 'badidentifier' not found
</pre>
</blockquote>
<p>longid() and shortid() can be used to convert identifiers:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; verbnet.longid('31.2')
'admire-31.2'
&gt;&gt;&gt; verbnet.longid('admire-31.2')
'admire-31.2'
&gt;&gt;&gt; verbnet.shortid('31.2')
'31.2'
&gt;&gt;&gt; verbnet.shortid('admire-31.2')
'31.2'
&gt;&gt;&gt; verbnet.longid('badidentifier')
Traceback (most recent call last):
  . . .
ValueError: vnclass identifier 'badidentifier' not found
&gt;&gt;&gt; verbnet.shortid('badidentifier')
Traceback (most recent call last):
  . . .
ValueError: vnclass identifier 'badidentifier' not found
</pre>
</blockquote>
</div>
<div class="section" id="corpus-view-regression-tests">
<h2>Corpus View Regression Tests</h2>
<p>Select some corpus files to play with:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import nltk.data
&gt;&gt;&gt; # A very short file (160 chars):
&gt;&gt;&gt; f1 = nltk.data.find('corpora/inaugural/README')
&gt;&gt;&gt; # A relatively short file (791 chars):
&gt;&gt;&gt; f2 = nltk.data.find('corpora/inaugural/1793-Washington.txt')
&gt;&gt;&gt; # A longer file (32k chars):
&gt;&gt;&gt; f3 = nltk.data.find('corpora/inaugural/1909-Taft.txt')
&gt;&gt;&gt; fileids = [f1, f2, f3]
</pre>
</blockquote>
<div class="section" id="concatenation">
<h3>Concatenation</h3>
<p>Check that concatenation works as intended.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus.reader.util import *
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; c1 = StreamBackedCorpusView(f1, read_whitespace_block, encoding='utf-8')
&gt;&gt;&gt; c2 = StreamBackedCorpusView(f2, read_whitespace_block, encoding='utf-8')
&gt;&gt;&gt; c3 = StreamBackedCorpusView(f3, read_whitespace_block, encoding='utf-8')
&gt;&gt;&gt; c123 = c1+c2+c3
&gt;&gt;&gt; print(c123)
['C-Span', 'Inaugural', 'Address', 'Corpus', 'US', ...]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; l1 = f1.open(encoding='utf-8').read().split()
&gt;&gt;&gt; l2 = f2.open(encoding='utf-8').read().split()
&gt;&gt;&gt; l3 = f3.open(encoding='utf-8').read().split()
&gt;&gt;&gt; l123 = l1+l2+l3
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; list(c123) == l123
True
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; (c1+c2+c3)[100] == l123[100]
True
</pre>
</blockquote>
</div>
<div class="section" id="slicing">
<h3>Slicing</h3>
<p>First, do some tests with fairly small slices.  These will all
generate tuple values.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.util import LazySubsequence
&gt;&gt;&gt; c1 = StreamBackedCorpusView(f1, read_whitespace_block, encoding='utf-8')
&gt;&gt;&gt; l1 = f1.open(encoding='utf-8').read().split()
&gt;&gt;&gt; print(len(c1))
21
&gt;&gt;&gt; len(c1) &lt; LazySubsequence.MIN_SIZE
True
</pre>
</blockquote>
<p>Choose a list of indices, based on the length, that covers the
important corner cases:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; indices = [-60, -30, -22, -21, -20, -1,
...            0, 1, 10, 20, 21, 22, 30, 60]
</pre>
</blockquote>
<p>Test slicing with explicit start &amp; stop value:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for s in indices:
...     for e in indices:
...         assert list(c1[s:e]) == l1[s:e]
</pre>
</blockquote>
<p>Test slicing with stop=None:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for s in indices:
...     assert list(c1[s:]) == l1[s:]
</pre>
</blockquote>
<p>Test slicing with start=None:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for e in indices:
...     assert list(c1[:e]) == l1[:e]
</pre>
</blockquote>
<p>Test slicing with start=stop=None:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; list(c1[:]) == list(l1[:])
True
</pre>
</blockquote>
<p>Next, we'll do some tests with much longer slices.  These will
generate LazySubsequence objects.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c3 = StreamBackedCorpusView(f3, read_whitespace_block, encoding='utf-8')
&gt;&gt;&gt; l3 = f3.open(encoding='utf-8').read().split()
&gt;&gt;&gt; print(len(c3))
5430
&gt;&gt;&gt; len(c3) &gt; LazySubsequence.MIN_SIZE*2
True
</pre>
</blockquote>
<p>Choose a list of indices, based on the length, that covers the
important corner cases:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; indices = [-12000, -6000, -5431, -5430, -5429, -3000, -200, -1,
...            0, 1, 200, 3000, 5000, 5429, 5430, 5431, 6000, 12000]
</pre>
</blockquote>
<p>Test slicing with explicit start &amp; stop value:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for s in indices:
...     for e in indices:
...         assert list(c3[s:e]) == l3[s:e]
</pre>
</blockquote>
<p>Test slicing with stop=None:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for s in indices:
...     assert list(c3[s:]) == l3[s:]
</pre>
</blockquote>
<p>Test slicing with start=None:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; for e in indices:
...     assert list(c3[:e]) == l3[:e]
</pre>
</blockquote>
<p>Test slicing with start=stop=None:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; list(c3[:]) == list(l3[:])
True
</pre>
</blockquote>
</div>
<div class="section" id="multiple-iterators">
<h3>Multiple Iterators</h3>
<p>If multiple iterators are created for the same corpus view, their
iteration can be interleaved:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; c3 = StreamBackedCorpusView(f3, read_whitespace_block)
&gt;&gt;&gt; iterators = [c3.iterate_from(n) for n in [0,15,30,45]]
&gt;&gt;&gt; for i in range(15):
...     for iterator in iterators:
...         print('%-15s' % next(iterator), end=' ')
...     print()
My              a               duties          in
fellow          heavy           of              a
citizens:       weight          the             proper
Anyone          of              office          sense
who             responsibility. upon            of
has             If              which           the
taken           not,            he              obligation
the             he              is              which
oath            has             about           the
I               no              to              oath
have            conception      enter,          imposes.
just            of              or              The
taken           the             he              office
must            powers          is              of
feel            and             lacking         an
</pre>
</blockquote>
</div>
</div>
<div class="section" id="seekableunicodestreamreader">
<h2>SeekableUnicodeStreamReader</h2>
<p>The file-like objects provided by the <tt class="docutils literal">codecs</tt> module unfortunately
suffer from a bug that prevents them from working correctly with
corpus view objects.  In particular, although the expose <tt class="docutils literal">seek()</tt>
and <tt class="docutils literal">tell()</tt> methods, those methods do not exhibit the expected
behavior, because they are not synchronized with the internal buffers
that are kept by the file-like objects.  For example, the <tt class="docutils literal">tell()</tt>
method will return the file position at the end of the buffers (whose
contents have not yet been returned by the stream); and therefore this
file position can not be used to return to the 'current' location in
the stream (since <tt class="docutils literal">seek()</tt> has no way to reconstruct the buffers).</p>
<p>To get around these problems, we define a new class,
<cite>SeekableUnicodeStreamReader</cite>, to act as a file-like interface to
files containing encoded unicode data.  This class is loosely based on
the <tt class="docutils literal">codecs.StreamReader</tt> class.  To construct a new reader, we call
the constructor with an underlying stream and an encoding name:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from io import StringIO, BytesIO
&gt;&gt;&gt; from nltk.data import SeekableUnicodeStreamReader
&gt;&gt;&gt; stream = BytesIO(b&quot;&quot;&quot;\
... This is a test file.
... It is encoded in ascii.
... &quot;&quot;&quot;.decode('ascii').encode('ascii'))
&gt;&gt;&gt; reader = SeekableUnicodeStreamReader(stream, 'ascii')
</pre>
</blockquote>
<p><cite>SeekableUnicodeStreamReader</cite>s support all of the normal operations
supplied by a read-only stream.  Note that all of the read operations
return <tt class="docutils literal">unicode</tt> objects (not <tt class="docutils literal">str</tt> objects).</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; reader.read()         # read the entire file.
u'This is a test file.\nIt is encoded in ascii.\n'
&gt;&gt;&gt; reader.seek(0)        # rewind to the start.
&gt;&gt;&gt; reader.read(5)        # read at most 5 bytes.
u'This '
&gt;&gt;&gt; reader.readline()     # read to the end of the line.
u'is a test file.\n'
&gt;&gt;&gt; reader.seek(0)        # rewind to the start.
&gt;&gt;&gt; for line in reader:
...     print(repr(line))      # iterate over lines
u'This is a test file.\n'
u'It is encoded in ascii.\n'
&gt;&gt;&gt; reader.seek(0)        # rewind to the start.
&gt;&gt;&gt; reader.readlines()    # read a list of line strings
[u'This is a test file.\n', u'It is encoded in ascii.\n']
&gt;&gt;&gt; reader.close()
</pre>
</blockquote>
<div class="section" id="size-argument-to-read">
<h3>Size argument to <tt class="docutils literal">read()</tt></h3>
<p>The <tt class="docutils literal">size</tt> argument to <tt class="docutils literal">read()</tt> specifies the maximum number of
<em>bytes</em> to read, not the maximum number of <em>characters</em>.  Thus, for
encodings that use multiple bytes per character, it may return fewer
characters than the <tt class="docutils literal">size</tt> argument:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; stream = BytesIO(b&quot;&quot;&quot;\
... This is a test file.
... It is encoded in utf-16.
... &quot;&quot;&quot;.decode('ascii').encode('utf-16'))
&gt;&gt;&gt; reader = SeekableUnicodeStreamReader(stream, 'utf-16')
&gt;&gt;&gt; reader.read(10)
u'This '
</pre>
</blockquote>
<p>If a read block ends in the middle of the byte string encoding a
single character, then that byte string is stored in an internal
buffer, and re-used on the next call to <tt class="docutils literal">read()</tt>.  However, if the
size argument is too small to read even a single character, even
though at least one character is available, then the <tt class="docutils literal">read()</tt> method
will read additional bytes until it can return a single character.
This ensures that the <tt class="docutils literal">read()</tt> method does not return an empty
string, which could be mistaken for indicating the end of the file.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; reader.seek(0)            # rewind to the start.
&gt;&gt;&gt; reader.read(1)            # we actually need to read 4 bytes
u'T'
&gt;&gt;&gt; int(reader.tell())
4
</pre>
</blockquote>
<p>The <tt class="docutils literal">readline()</tt> method may read more than a single line of text, in
which case it stores the text that it does not return in a buffer.  If
this buffer is not empty, then its contents will be included in the
value returned by the next call to <tt class="docutils literal">read()</tt>, regardless of the
<tt class="docutils literal">size</tt> argument, since they are available without reading any new
bytes from the stream:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; reader.seek(0)            # rewind to the start.
&gt;&gt;&gt; reader.readline()         # stores extra text in a buffer
u'This is a test file.\n'
&gt;&gt;&gt; print(reader.linebuffer)   # examine the buffer contents
[u'It is encoded i']
&gt;&gt;&gt; reader.read(0)            # returns the contents of the buffer
u'It is encoded i'
&gt;&gt;&gt; print(reader.linebuffer)   # examine the buffer contents
None
</pre>
</blockquote>
</div>
<div class="section" id="seek-and-tell">
<h3>Seek and Tell</h3>
<p>In addition to these basic read operations,
<cite>SeekableUnicodeStreamReader</cite> also supports the <tt class="docutils literal">seek()</tt> and
<tt class="docutils literal">tell()</tt> operations.  However, some care must still be taken when
using these operations.  In particular, the only file offsets that
should be passed to <tt class="docutils literal">seek()</tt> are <tt class="docutils literal">0</tt> and any offset that has been
returned by <tt class="docutils literal">tell</tt>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; stream = BytesIO(b&quot;&quot;&quot;\
... This is a test file.
... It is encoded in utf-16.
... &quot;&quot;&quot;.decode('ascii').encode('utf-16'))
&gt;&gt;&gt; reader = SeekableUnicodeStreamReader(stream, 'utf-16')
&gt;&gt;&gt; reader.read(20)
u'This is a '
&gt;&gt;&gt; pos = reader.tell(); print(pos)
22
&gt;&gt;&gt; reader.read(20)
u'test file.'
&gt;&gt;&gt; reader.seek(pos)     # rewind to the position from tell.
&gt;&gt;&gt; reader.read(20)
u'test file.'
</pre>
</blockquote>
<p>The <tt class="docutils literal">seek()</tt> and <tt class="docutils literal">tell()</tt> methods work property even when
<tt class="docutils literal">readline()</tt> is used.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; stream = BytesIO(b&quot;&quot;&quot;\
... This is a test file.
... It is encoded in utf-16.
... &quot;&quot;&quot;.decode('ascii').encode('utf-16'))
&gt;&gt;&gt; reader = SeekableUnicodeStreamReader(stream, 'utf-16')
&gt;&gt;&gt; reader.readline()
u'This is a test file.\n'
&gt;&gt;&gt; pos = reader.tell(); print(pos)
44
&gt;&gt;&gt; reader.readline()
u'It is encoded in utf-16.\n'
&gt;&gt;&gt; reader.seek(pos)     # rewind to the position from tell.
&gt;&gt;&gt; reader.readline()
u'It is encoded in utf-16.\n'
</pre>
</blockquote>
</div>
</div>
<div class="section" id="squashed-bugs">
<h2>Squashed Bugs</h2>
<p>svn 5276 fixed a bug in the comment-stripping behavior of
parse_sexpr_block.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from io import StringIO
&gt;&gt;&gt; from nltk.corpus.reader.util import read_sexpr_block
&gt;&gt;&gt; f = StringIO(b&quot;&quot;&quot;
... (a b c)
... # This line is a comment.
... (d e f\ng h)&quot;&quot;&quot;.decode('ascii'))
&gt;&gt;&gt; print(read_sexpr_block(f, block_size=38, comment_char='#'))
['(a b c)']
&gt;&gt;&gt; print(read_sexpr_block(f, block_size=38, comment_char='#'))
['(d e f\ng h)']
</pre>
</blockquote>
<p>svn 5277 fixed a bug in parse_sexpr_block, which would cause it to
enter an infinite loop if a file ended mid-sexpr, or ended with a
token that was not followed by whitespace.  A related bug caused
an infinite loop if the corpus ended in an unmatched close paren --
this was fixed in svn 5279</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; f = StringIO(b&quot;&quot;&quot;
... This file ends mid-sexpr
... (hello (world&quot;&quot;&quot;.decode('ascii'))
&gt;&gt;&gt; for i in range(3): print(read_sexpr_block(f))
['This', 'file', 'ends', 'mid-sexpr']
['(hello (world']
[]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; f = StringIO(b&quot;This file has no trailing whitespace.&quot;.decode('ascii'))
&gt;&gt;&gt; for i in range(3): print(read_sexpr_block(f))
['This', 'file', 'has', 'no', 'trailing']
['whitespace.']
[]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; # Bug fixed in 5279:
&gt;&gt;&gt; f = StringIO(b&quot;a b c)&quot;.decode('ascii'))
&gt;&gt;&gt; for i in range(3): print(read_sexpr_block(f))
['a', 'b']
['c)']
[]
</pre>
</blockquote>
<p>svn 5624 &amp; 5265 fixed a bug in ConcatenatedCorpusView, which caused it
to return the wrong items when indexed starting at any index beyond
the first file.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import nltk
&gt;&gt;&gt; sents = nltk.corpus.brown.sents()
&gt;&gt;&gt; print(sents[6000])
['Cholesterol', 'and', 'thyroid']
&gt;&gt;&gt; print(sents[6000])
['Cholesterol', 'and', 'thyroid']
</pre>
</blockquote>
<p>svn 5728 fixed a bug in Categorized*CorpusReader, which caused them
to return words from <em>all</em> files when just one file was specified.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import reuters
&gt;&gt;&gt; reuters.words('training/13085')
['SNYDER', '&amp;', 'lt', ';', 'SOI', '&gt;', 'MAKES', ...]
&gt;&gt;&gt; reuters.words('training/5082')
['SHEPPARD', 'RESOURCES', 'TO', 'MERGE', 'WITH', ...]
</pre>
</blockquote>
<p>svn 7227 fixed a bug in the qc corpus reader, which prevented
access to its tuples() method</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from nltk.corpus import qc
&gt;&gt;&gt; qc.tuples('test.txt')
[('NUM:dist', 'How far is it from Denver to Aspen ?'), ('LOC:city', 'What county is Modesto , California in ?'), ...]
</pre>
</blockquote>
</div>
</div>
</div>
</body>
</html>
