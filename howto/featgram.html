<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: Sample usage for featgram</title>
  

  <link rel="stylesheet" href="../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../api/nltk.html">API Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <section id="sample-usage-for-featgram">
<h1>Sample usage for featgram<a class="headerlink" href="#sample-usage-for-featgram" title="Permalink to this heading">¶</a></h1>
<section id="feature-grammar-parsing">
<h2>Feature Grammar Parsing<a class="headerlink" href="#feature-grammar-parsing" title="Permalink to this heading">¶</a></h2>
<p>Grammars can be parsed from strings.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nltk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">parse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="gp">... </span><span class="si">% s</span><span class="s2">tart DP</span>
<span class="gp">... </span><span class="s2">DP[AGR=?a] -&gt; D[AGR=?a] N[AGR=?a]</span>
<span class="gp">... </span><span class="s2">D[AGR=[NUM=&#39;sg&#39;, PERS=3]] -&gt; &#39;this&#39; | &#39;that&#39;</span>
<span class="gp">... </span><span class="s2">D[AGR=[NUM=&#39;pl&#39;, PERS=3]] -&gt; &#39;these&#39; | &#39;those&#39;</span>
<span class="gp">... </span><span class="s2">D[AGR=[NUM=&#39;pl&#39;, PERS=1]] -&gt; &#39;we&#39;</span>
<span class="gp">... </span><span class="s2">D[AGR=[PERS=2]] -&gt; &#39;you&#39;</span>
<span class="gp">... </span><span class="s2">N[AGR=[NUM=&#39;sg&#39;, GND=&#39;m&#39;]] -&gt; &#39;boy&#39;</span>
<span class="gp">... </span><span class="s2">N[AGR=[NUM=&#39;pl&#39;, GND=&#39;m&#39;]] -&gt; &#39;boys&#39;</span>
<span class="gp">... </span><span class="s2">N[AGR=[NUM=&#39;sg&#39;, GND=&#39;f&#39;]] -&gt; &#39;girl&#39;</span>
<span class="gp">... </span><span class="s2">N[AGR=[NUM=&#39;pl&#39;, GND=&#39;f&#39;]] -&gt; &#39;girls&#39;</span>
<span class="gp">... </span><span class="s2">N[AGR=[NUM=&#39;sg&#39;]] -&gt; &#39;student&#39;</span>
<span class="gp">... </span><span class="s2">N[AGR=[NUM=&#39;pl&#39;]] -&gt; &#39;students&#39;</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grammar</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">FeatureGrammar</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span> <span class="o">=</span> <span class="s1">&#39;these girls&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parser</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">FeatureEarleyChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(DP[AGR=[GND=&#39;f&#39;, NUM=&#39;pl&#39;, PERS=3]]</span>
<span class="go">  (D[AGR=[NUM=&#39;pl&#39;, PERS=3]] these)</span>
<span class="go">  (N[AGR=[GND=&#39;f&#39;, NUM=&#39;pl&#39;]] girls))</span>
</pre></div>
</div>
<p>In general, when we are trying to develop even a very small grammar,
it is convenient to put the rules in a file where they can be edited,
tested and revised. Let’s assume that we have saved feat0cfg as a file named
<code class="docutils literal notranslate"><span class="pre">'feat0.fcfg'</span></code> and placed it in the NLTK <code class="docutils literal notranslate"><span class="pre">data</span></code> directory. We can
inspect it as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">show_cfg</span><span class="p">(</span><span class="s1">&#39;grammars/book_grammars/feat0.fcfg&#39;</span><span class="p">)</span>
<span class="go">% start S</span>
<span class="go"># ###################</span>
<span class="go"># Grammar Productions</span>
<span class="go"># ###################</span>
<span class="go"># S expansion productions</span>
<span class="go">S -&gt; NP[NUM=?n] VP[NUM=?n]</span>
<span class="go"># NP expansion productions</span>
<span class="go">NP[NUM=?n] -&gt; N[NUM=?n]</span>
<span class="go">NP[NUM=?n] -&gt; PropN[NUM=?n]</span>
<span class="go">NP[NUM=?n] -&gt; Det[NUM=?n] N[NUM=?n]</span>
<span class="go">NP[NUM=pl] -&gt; N[NUM=pl]</span>
<span class="go"># VP expansion productions</span>
<span class="go">VP[TENSE=?t, NUM=?n] -&gt; IV[TENSE=?t, NUM=?n]</span>
<span class="go">VP[TENSE=?t, NUM=?n] -&gt; TV[TENSE=?t, NUM=?n] NP</span>
<span class="go"># ###################</span>
<span class="go"># Lexical Productions</span>
<span class="go"># ###################</span>
<span class="go">Det[NUM=sg] -&gt; &#39;this&#39; | &#39;every&#39;</span>
<span class="go">Det[NUM=pl] -&gt; &#39;these&#39; | &#39;all&#39;</span>
<span class="go">Det -&gt; &#39;the&#39; | &#39;some&#39; | &#39;several&#39;</span>
<span class="go">PropN[NUM=sg]-&gt; &#39;Kim&#39; | &#39;Jody&#39;</span>
<span class="go">N[NUM=sg] -&gt; &#39;dog&#39; | &#39;girl&#39; | &#39;car&#39; | &#39;child&#39;</span>
<span class="go">N[NUM=pl] -&gt; &#39;dogs&#39; | &#39;girls&#39; | &#39;cars&#39; | &#39;children&#39;</span>
<span class="go">IV[TENSE=pres,  NUM=sg] -&gt; &#39;disappears&#39; | &#39;walks&#39;</span>
<span class="go">TV[TENSE=pres, NUM=sg] -&gt; &#39;sees&#39; | &#39;likes&#39;</span>
<span class="go">IV[TENSE=pres,  NUM=pl] -&gt; &#39;disappear&#39; | &#39;walk&#39;</span>
<span class="go">TV[TENSE=pres, NUM=pl] -&gt; &#39;see&#39; | &#39;like&#39;</span>
<span class="go">IV[TENSE=past] -&gt; &#39;disappeared&#39; | &#39;walked&#39;</span>
<span class="go">TV[TENSE=past] -&gt; &#39;saw&#39; | &#39;liked&#39;</span>
</pre></div>
</div>
<p>Assuming we have saved feat0cfg as a file named
<code class="docutils literal notranslate"><span class="pre">'feat0.fcfg'</span></code>, the function <code class="docutils literal notranslate"><span class="pre">parse.load_parser</span></code> allows us to
read the grammar into NLTK, ready for use in parsing.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">load_parser</span><span class="p">(</span><span class="s1">&#39;grammars/book_grammars/feat0.fcfg&#39;</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent</span> <span class="o">=</span> <span class="s1">&#39;Kim likes children&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span>
<span class="go">[&#39;Kim&#39;, &#39;likes&#39;, &#39;children&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="go">|.Kim .like.chil.|</span>
<span class="go">|[----]    .    .| [0:1] &#39;Kim&#39;</span>
<span class="go">|.    [----]    .| [1:2] &#39;likes&#39;</span>
<span class="go">|.    .    [----]| [2:3] &#39;children&#39;</span>
<span class="go">|[----]    .    .| [0:1] PropN[NUM=&#39;sg&#39;] -&gt; &#39;Kim&#39; *</span>
<span class="go">|[----]    .    .| [0:1] NP[NUM=&#39;sg&#39;] -&gt; PropN[NUM=&#39;sg&#39;] *</span>
<span class="go">|[----&gt;    .    .| [0:1] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: &#39;sg&#39;}</span>
<span class="go">|.    [----]    .| [1:2] TV[NUM=&#39;sg&#39;, TENSE=&#39;pres&#39;] -&gt; &#39;likes&#39; *</span>
<span class="go">|.    [----&gt;    .| [1:2] VP[NUM=?n, TENSE=?t] -&gt; TV[NUM=?n, TENSE=?t] * NP[] {?n: &#39;sg&#39;, ?t: &#39;pres&#39;}</span>
<span class="go">|.    .    [----]| [2:3] N[NUM=&#39;pl&#39;] -&gt; &#39;children&#39; *</span>
<span class="go">|.    .    [----]| [2:3] NP[NUM=&#39;pl&#39;] -&gt; N[NUM=&#39;pl&#39;] *</span>
<span class="go">|.    .    [----&gt;| [2:3] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: &#39;pl&#39;}</span>
<span class="go">|.    [---------]| [1:3] VP[NUM=&#39;sg&#39;, TENSE=&#39;pres&#39;] -&gt; TV[NUM=&#39;sg&#39;, TENSE=&#39;pres&#39;] NP[] *</span>
<span class="go">|[==============]| [0:3] S[] -&gt; NP[NUM=&#39;sg&#39;] VP[NUM=&#39;sg&#39;] *</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(S[]</span>
<span class="go">  (NP[NUM=&#39;sg&#39;] (PropN[NUM=&#39;sg&#39;] Kim))</span>
<span class="go">  (VP[NUM=&#39;sg&#39;, TENSE=&#39;pres&#39;]</span>
<span class="go">    (TV[NUM=&#39;sg&#39;, TENSE=&#39;pres&#39;] likes)</span>
<span class="go">    (NP[NUM=&#39;pl&#39;] (N[NUM=&#39;pl&#39;] children))))</span>
</pre></div>
</div>
<p>The parser works directly with
the underspecified productions given by the grammar. That is, the
Predictor rule does not attempt to compile out all admissible feature
combinations before trying to expand the non-terminals on the left hand
side of a production. However, when the Scanner matches an input word
against a lexical production that has been predicted, the new edge will
typically contain fully specified features; e.g., the edge
[PropN[<span class="feature">num</span> = <span class="fval">sg</span>] → ‘Kim’, (0, 1)]. Recall from
Chapter 8 that the Fundamental (or Completer) Rule in
standard CFGs is used to combine an incomplete edge that’s expecting a
nonterminal <em>B</em> with a following, complete edge whose left hand side
matches <em>B</em>. In our current setting, rather than checking for a
complete match, we test whether the expected category <em>B</em> will
unify with the left hand side <em>B’</em> of a following complete
edge. We will explain in more detail in Section 9.2 how
unification works; for the moment, it is enough to know that as a
result of unification, any variable values of features in <em>B</em> will be
instantiated by constant values in the corresponding feature structure
in <em>B’</em>, and these instantiated values will be used in the new edge
added by the Completer. This instantiation can be seen, for example,
in the edge
[NP [<span class="feature">num</span>=<span class="fval">sg</span>] → PropN[<span class="feature">num</span>=<span class="fval">sg</span>] •, (0, 1)]
in Example 9.2, where the feature <span class="feature">num</span> has been assigned the value <span class="fval">sg</span>.</p>
<p>Feature structures in NLTK are … Atomic feature values can be strings or
integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">TENSE</span><span class="o">=</span><span class="s1">&#39;past&#39;</span><span class="p">,</span> <span class="n">NUM</span><span class="o">=</span><span class="s1">&#39;sg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs1</span><span class="p">)</span>
<span class="go">[ NUM   = &#39;sg&#39;   ]</span>
<span class="go">[ TENSE = &#39;past&#39; ]</span>
</pre></div>
</div>
<p>We can think of a feature structure as being like a Python dictionary,
and access its values by indexing in the usual way.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">PER</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">NUM</span><span class="o">=</span><span class="s1">&#39;pl&#39;</span><span class="p">,</span> <span class="n">GND</span><span class="o">=</span><span class="s1">&#39;fem&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs1</span><span class="p">[</span><span class="s1">&#39;GND&#39;</span><span class="p">])</span>
<span class="go">fem</span>
</pre></div>
</div>
<p>We can also define feature structures which have complex values, as
discussed earlier.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs2</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">POS</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="n">AGR</span><span class="o">=</span><span class="n">fs1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs2</span><span class="p">)</span>
<span class="go">[       [ GND = &#39;fem&#39; ] ]</span>
<span class="go">[ AGR = [ NUM = &#39;pl&#39;  ] ]</span>
<span class="go">[       [ PER = 3     ] ]</span>
<span class="go">[                       ]</span>
<span class="go">[ POS = &#39;N&#39;             ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s1">&#39;AGR&#39;</span><span class="p">])</span>
<span class="go">[ GND = &#39;fem&#39; ]</span>
<span class="go">[ NUM = &#39;pl&#39;  ]</span>
<span class="go">[ PER = 3     ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs2</span><span class="p">[</span><span class="s1">&#39;AGR&#39;</span><span class="p">][</span><span class="s1">&#39;PER&#39;</span><span class="p">])</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Feature structures can also be constructed using the <code class="docutils literal notranslate"><span class="pre">parse()</span></code>
method of the <code class="docutils literal notranslate"><span class="pre">nltk.FeatStruct</span></code> class. Note that in this case, atomic
feature values do not need to be enclosed in quotes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[NUMBER = sg]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[PERSON = 3]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">))</span>
<span class="go">[ NUMBER = &#39;sg&#39; ]</span>
<span class="go">[ PERSON = 3    ]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[A = [B = b, D = d]]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[A = [C = c, D = d]]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">))</span>
<span class="go">[     [ B = &#39;b&#39; ] ]</span>
<span class="go">[ A = [ C = &#39;c&#39; ] ]</span>
<span class="go">[     [ D = &#39;d&#39; ] ]</span>
</pre></div>
</div>
<section id="feature-structures-as-graphs">
<h3>Feature Structures as Graphs<a class="headerlink" href="#feature-structures-as-graphs" title="Permalink to this heading">¶</a></h3>
<p>Feature structures are not inherently tied to linguistic objects; they are
general purpose structures for representing knowledge. For example, we
could encode information about a person in a feature structure:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">person01</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[NAME=Lee, TELNO=&#39;01 27 86 42 96&#39;,AGE=33]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">person01</span><span class="p">)</span>
<span class="go">[ AGE   = 33               ]</span>
<span class="go">[ NAME  = &#39;Lee&#39;            ]</span>
<span class="go">[ TELNO = &#39;01 27 86 42 96&#39; ]</span>
</pre></div>
</div>
<p>There are a number of notations for representing reentrancy in
matrix-style representations of feature structures. In NLTK, we adopt
the following convention: the first occurrence of a shared feature structure
is prefixed with an integer in parentheses, such as <code class="docutils literal notranslate"><span class="pre">(1)</span></code>, and any
subsequent reference to that structure uses the notation
<code class="docutils literal notranslate"><span class="pre">-&gt;(1)</span></code>, as shown below.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;[NAME=Lee, ADDRESS=(1)[NUMBER=74, STREET=&#39;rue Pascal&#39;],</span>
<span class="gp">... </span><span class="s2">                              SPOUSE=[NAME=Kim, ADDRESS-&gt;(1)]]&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
<span class="go">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="go">[               [ STREET = &#39;rue Pascal&#39; ] ]</span>
<span class="go">[                                         ]</span>
<span class="go">[ NAME    = &#39;Lee&#39;                         ]</span>
<span class="go">[                                         ]</span>
<span class="go">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="go">[           [ NAME    = &#39;Kim&#39; ]           ]</span>
</pre></div>
</div>
<p>There can be any number of tags within a single feature structure.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs3</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[A=(1)[B=b], C=(2)[], D-&gt;(1), E-&gt;(2)]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs3</span><span class="p">)</span>
<span class="go">[ A = (1) [ B = &#39;b&#39; ] ]</span>
<span class="go">[                     ]</span>
<span class="go">[ C = (2) []          ]</span>
<span class="go">[                     ]</span>
<span class="go">[ D -&gt; (1)            ]</span>
<span class="go">[ E -&gt; (2)            ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">NUMBER</span><span class="o">=</span><span class="mi">74</span><span class="p">,</span> <span class="n">STREET</span><span class="o">=</span><span class="s1">&#39;rue Pascal&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs2</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">CITY</span><span class="o">=</span><span class="s1">&#39;Paris&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">))</span>
<span class="go">[ CITY   = &#39;Paris&#39;      ]</span>
<span class="go">[ NUMBER = 74           ]</span>
<span class="go">[ STREET = &#39;rue Pascal&#39; ]</span>
</pre></div>
</div>
<p>Unification is symmetric:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">)</span> <span class="o">==</span> <span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs2</span><span class="p">,</span> <span class="n">fs1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Unification is commutative:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs3</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">TELNO</span><span class="o">=</span><span class="s1">&#39;01 27 86 42 96&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">),</span> <span class="n">fs3</span><span class="p">)</span> <span class="o">==</span> <span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs2</span><span class="p">,</span> <span class="n">fs3</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Unification between <em>FS</em><img class="math" src="../_images/math/038ec0993f916abb4206f40880fd88214621fcfb.png" alt="_0"/> and <em>FS</em><img class="math" src="../_images/math/463b9b35e153536d12f3f8998e5a849e510b3200.png" alt="_1"/> will fail if the
two feature structures share a path π,
but the value of π in <em>FS</em><img class="math" src="../_images/math/038ec0993f916abb4206f40880fd88214621fcfb.png" alt="_0"/> is a distinct
atom from the value of π in <em>FS</em><img class="math" src="../_images/math/463b9b35e153536d12f3f8998e5a849e510b3200.png" alt="_1"/>. In NLTK,
this is implemented by setting the result of unification to be
<code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs0</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs0</span><span class="p">,</span> <span class="n">fs1</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<p>Now, if we look at how unification interacts with structure-sharing,
things become really interesting.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs0</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;[NAME=Lee,</span>
<span class="gp">... </span><span class="s2">                               ADDRESS=[NUMBER=74,</span>
<span class="gp">... </span><span class="s2">                                        STREET=&#39;rue Pascal&#39;],</span>
<span class="gp">... </span><span class="s2">                               SPOUSE= [NAME=Kim,</span>
<span class="gp">... </span><span class="s2">                                        ADDRESS=[NUMBER=74,</span>
<span class="gp">... </span><span class="s2">                                                 STREET=&#39;rue Pascal&#39;]]]&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs0</span><span class="p">)</span>
<span class="go">[ ADDRESS = [ NUMBER = 74           ]               ]</span>
<span class="go">[           [ STREET = &#39;rue Pascal&#39; ]               ]</span>
<span class="go">[                                                   ]</span>
<span class="go">[ NAME    = &#39;Lee&#39;                                   ]</span>
<span class="go">[                                                   ]</span>
<span class="go">[           [ ADDRESS = [ NUMBER = 74           ] ] ]</span>
<span class="go">[ SPOUSE  = [           [ STREET = &#39;rue Pascal&#39; ] ] ]</span>
<span class="go">[           [                                     ] ]</span>
<span class="go">[           [ NAME    = &#39;Kim&#39;                     ] ]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[SPOUSE=[ADDRESS=[CITY=Paris]]]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs0</span><span class="p">,</span> <span class="n">fs1</span><span class="p">))</span>
<span class="go">[ ADDRESS = [ NUMBER = 74           ]               ]</span>
<span class="go">[           [ STREET = &#39;rue Pascal&#39; ]               ]</span>
<span class="go">[                                                   ]</span>
<span class="go">[ NAME    = &#39;Lee&#39;                                   ]</span>
<span class="go">[                                                   ]</span>
<span class="go">[           [           [ CITY   = &#39;Paris&#39;      ] ] ]</span>
<span class="go">[           [ ADDRESS = [ NUMBER = 74           ] ] ]</span>
<span class="go">[ SPOUSE  = [           [ STREET = &#39;rue Pascal&#39; ] ] ]</span>
<span class="go">[           [                                     ] ]</span>
<span class="go">[           [ NAME    = &#39;Kim&#39;                     ] ]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs2</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;[NAME=Lee, ADDRESS=(1)[NUMBER=74, STREET=&#39;rue Pascal&#39;],</span>
<span class="gp">... </span><span class="s2">                               SPOUSE=[NAME=Kim, ADDRESS-&gt;(1)]]&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs2</span><span class="p">)</span>
<span class="go">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="go">[               [ STREET = &#39;rue Pascal&#39; ] ]</span>
<span class="go">[                                         ]</span>
<span class="go">[ NAME    = &#39;Lee&#39;                         ]</span>
<span class="go">[                                         ]</span>
<span class="go">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="go">[           [ NAME    = &#39;Kim&#39; ]           ]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs2</span><span class="p">,</span> <span class="n">fs1</span><span class="p">))</span>
<span class="go">[               [ CITY   = &#39;Paris&#39;      ] ]</span>
<span class="go">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="go">[               [ STREET = &#39;rue Pascal&#39; ] ]</span>
<span class="go">[                                         ]</span>
<span class="go">[ NAME    = &#39;Lee&#39;                         ]</span>
<span class="go">[                                         ]</span>
<span class="go">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="go">[           [ NAME    = &#39;Kim&#39; ]           ]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs1</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[ADDRESS1=[NUMBER=74, STREET=&#39;rue Pascal&#39;]]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fs2</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">FeatStruct</span><span class="p">(</span><span class="s2">&quot;[ADDRESS1=?x, ADDRESS2=?x]&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fs2</span><span class="p">)</span>
<span class="go">[ ADDRESS1 = ?x ]</span>
<span class="go">[ ADDRESS2 = ?x ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nltk</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">))</span>
<span class="go">[ ADDRESS1 = (1) [ NUMBER = 74           ] ]</span>
<span class="go">[                [ STREET = &#39;rue Pascal&#39; ] ]</span>
<span class="go">[                                          ]</span>
<span class="go">[ ADDRESS2 -&gt; (1)                          ]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sent</span> <span class="o">=</span> <span class="s1">&#39;who do you claim that you like&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">load_parser</span><span class="p">(</span><span class="s1">&#39;grammars/book_grammars/feat1.fcfg&#39;</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="go">|.w.d.y.c.t.y.l.|</span>
<span class="go">|[-] . . . . . .| [0:1] &#39;who&#39;</span>
<span class="go">|. [-] . . . . .| [1:2] &#39;do&#39;</span>
<span class="go">|. . [-] . . . .| [2:3] &#39;you&#39;</span>
<span class="go">|. . . [-] . . .| [3:4] &#39;claim&#39;</span>
<span class="go">|. . . . [-] . .| [4:5] &#39;that&#39;</span>
<span class="go">|. . . . . [-] .| [5:6] &#39;you&#39;</span>
<span class="go">|. . . . . . [-]| [6:7] &#39;like&#39;</span>
<span class="go">|# . . . . . . .| [0:0] NP[]/NP[] -&gt; *</span>
<span class="go">|. # . . . . . .| [1:1] NP[]/NP[] -&gt; *</span>
<span class="go">|. . # . . . . .| [2:2] NP[]/NP[] -&gt; *</span>
<span class="go">|. . . # . . . .| [3:3] NP[]/NP[] -&gt; *</span>
<span class="go">|. . . . # . . .| [4:4] NP[]/NP[] -&gt; *</span>
<span class="go">|. . . . . # . .| [5:5] NP[]/NP[] -&gt; *</span>
<span class="go">|. . . . . . # .| [6:6] NP[]/NP[] -&gt; *</span>
<span class="go">|. . . . . . . #| [7:7] NP[]/NP[] -&gt; *</span>
<span class="go">|[-] . . . . . .| [0:1] NP[+WH] -&gt; &#39;who&#39; *</span>
<span class="go">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="go">|[-&gt; . . . . . .| [0:1] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="go">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="go">|. [-] . . . . .| [1:2] V[+AUX] -&gt; &#39;do&#39; *</span>
<span class="go">|. [-&gt; . . . . .| [1:2] S[+INV] -&gt; V[+AUX] * NP[] VP[] {}</span>
<span class="go">|. [-&gt; . . . . .| [1:2] S[+INV]/?x[] -&gt; V[+AUX] * NP[] VP[]/?x[] {}</span>
<span class="go">|. [-&gt; . . . . .| [1:2] VP[] -&gt; V[+AUX] * VP[] {}</span>
<span class="go">|. [-&gt; . . . . .| [1:2] VP[]/?x[] -&gt; V[+AUX] * VP[]/?x[] {}</span>
<span class="go">|. . [-] . . . .| [2:3] NP[-WH] -&gt; &#39;you&#39; *</span>
<span class="go">|. . [-&gt; . . . .| [2:3] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="go">|. . [-&gt; . . . .| [2:3] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="go">|. . [-&gt; . . . .| [2:3] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="go">|. [---&gt; . . . .| [1:3] S[+INV] -&gt; V[+AUX] NP[] * VP[] {}</span>
<span class="go">|. [---&gt; . . . .| [1:3] S[+INV]/?x[] -&gt; V[+AUX] NP[] * VP[]/?x[] {}</span>
<span class="go">|. . . [-] . . .| [3:4] V[-AUX, SUBCAT=&#39;clause&#39;] -&gt; &#39;claim&#39; *</span>
<span class="go">|. . . [-&gt; . . .| [3:4] VP[] -&gt; V[-AUX, SUBCAT=&#39;clause&#39;] * SBar[] {}</span>
<span class="go">|. . . [-&gt; . . .| [3:4] VP[]/?x[] -&gt; V[-AUX, SUBCAT=&#39;clause&#39;] * SBar[]/?x[] {}</span>
<span class="go">|. . . . [-] . .| [4:5] Comp[] -&gt; &#39;that&#39; *</span>
<span class="go">|. . . . [-&gt; . .| [4:5] SBar[] -&gt; Comp[] * S[-INV] {}</span>
<span class="go">|. . . . [-&gt; . .| [4:5] SBar[]/?x[] -&gt; Comp[] * S[-INV]/?x[] {}</span>
<span class="go">|. . . . . [-] .| [5:6] NP[-WH] -&gt; &#39;you&#39; *</span>
<span class="go">|. . . . . [-&gt; .| [5:6] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="go">|. . . . . [-&gt; .| [5:6] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="go">|. . . . . [-&gt; .| [5:6] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="go">|. . . . . . [-]| [6:7] V[-AUX, SUBCAT=&#39;trans&#39;] -&gt; &#39;like&#39; *</span>
<span class="go">|. . . . . . [-&gt;| [6:7] VP[] -&gt; V[-AUX, SUBCAT=&#39;trans&#39;] * NP[] {}</span>
<span class="go">|. . . . . . [-&gt;| [6:7] VP[]/?x[] -&gt; V[-AUX, SUBCAT=&#39;trans&#39;] * NP[]/?x[] {}</span>
<span class="go">|. . . . . . [-]| [6:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT=&#39;trans&#39;] NP[]/NP[] *</span>
<span class="go">|. . . . . [---]| [5:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *</span>
<span class="go">|. . . . [-----]| [4:7] SBar[]/NP[] -&gt; Comp[] S[-INV]/NP[] *</span>
<span class="go">|. . . [-------]| [3:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT=&#39;clause&#39;] SBar[]/NP[] *</span>
<span class="go">|. . [---------]| [2:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *</span>
<span class="go">|. [-----------]| [1:7] S[+INV]/NP[] -&gt; V[+AUX] NP[] VP[]/NP[] *</span>
<span class="go">|[=============]| [0:7] S[-INV] -&gt; NP[] S[]/NP[] *</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(S[-INV]</span>
<span class="go">  (NP[+WH] who)</span>
<span class="go">  (S[+INV]/NP[]</span>
<span class="go">    (V[+AUX] do)</span>
<span class="go">    (NP[-WH] you)</span>
<span class="go">    (VP[]/NP[]</span>
<span class="go">      (V[-AUX, SUBCAT=&#39;clause&#39;] claim)</span>
<span class="go">      (SBar[]/NP[]</span>
<span class="go">        (Comp[] that)</span>
<span class="go">        (S[-INV]/NP[]</span>
<span class="go">          (NP[-WH] you)</span>
<span class="go">          (VP[]/NP[] (V[-AUX, SUBCAT=&#39;trans&#39;] like) (NP[]/NP[] )))))))</span>
</pre></div>
</div>
<p>A different parser should give the same parse trees, but perhaps in a different order:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp2</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">load_parser</span><span class="p">(</span><span class="s1">&#39;grammars/book_grammars/feat1.fcfg&#39;</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                        <span class="n">parser</span><span class="o">=</span><span class="n">parse</span><span class="o">.</span><span class="n">FeatureEarleyChartParser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trees2</span> <span class="o">=</span> <span class="n">cp2</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="go">|.w.d.y.c.t.y.l.|</span>
<span class="go">|[-] . . . . . .| [0:1] &#39;who&#39;</span>
<span class="go">|. [-] . . . . .| [1:2] &#39;do&#39;</span>
<span class="go">|. . [-] . . . .| [2:3] &#39;you&#39;</span>
<span class="go">|. . . [-] . . .| [3:4] &#39;claim&#39;</span>
<span class="go">|. . . . [-] . .| [4:5] &#39;that&#39;</span>
<span class="go">|. . . . . [-] .| [5:6] &#39;you&#39;</span>
<span class="go">|. . . . . . [-]| [6:7] &#39;like&#39;</span>
<span class="go">|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * NP[] VP[] {}</span>
<span class="go">|&gt; . . . . . . .| [0:0] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}</span>
<span class="go">|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * NP[] S[]/NP[] {}</span>
<span class="go">|&gt; . . . . . . .| [0:0] S[-INV] -&gt; * Adv[+NEG] S[+INV] {}</span>
<span class="go">|&gt; . . . . . . .| [0:0] S[+INV] -&gt; * V[+AUX] NP[] VP[] {}</span>
<span class="go">|&gt; . . . . . . .| [0:0] S[+INV]/?x[] -&gt; * V[+AUX] NP[] VP[]/?x[] {}</span>
<span class="go">|&gt; . . . . . . .| [0:0] NP[+WH] -&gt; * &#39;who&#39; {}</span>
<span class="go">|[-] . . . . . .| [0:1] NP[+WH] -&gt; &#39;who&#39; *</span>
<span class="go">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * VP[] {}</span>
<span class="go">|[-&gt; . . . . . .| [0:1] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="go">|[-&gt; . . . . . .| [0:1] S[-INV] -&gt; NP[] * S[]/NP[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] S[+INV]/?x[] -&gt; * V[+AUX] NP[] VP[]/?x[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] V[+AUX] -&gt; * &#39;do&#39; {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;trans&#39;] NP[]/?x[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;clause&#39;] SBar[]/?x[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT=&#39;intrans&#39;] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT=&#39;trans&#39;] NP[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[-AUX, SUBCAT=&#39;clause&#39;] SBar[] {}</span>
<span class="go">|. &gt; . . . . . .| [1:1] VP[] -&gt; * V[+AUX] VP[] {}</span>
<span class="go">|. [-] . . . . .| [1:2] V[+AUX] -&gt; &#39;do&#39; *</span>
<span class="go">|. [-&gt; . . . . .| [1:2] S[+INV]/?x[] -&gt; V[+AUX] * NP[] VP[]/?x[] {}</span>
<span class="go">|. [-&gt; . . . . .| [1:2] VP[]/?x[] -&gt; V[+AUX] * VP[]/?x[] {}</span>
<span class="go">|. [-&gt; . . . . .| [1:2] VP[] -&gt; V[+AUX] * VP[] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT=&#39;intrans&#39;] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT=&#39;trans&#39;] NP[] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[-AUX, SUBCAT=&#39;clause&#39;] SBar[] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] VP[] -&gt; * V[+AUX] VP[] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;trans&#39;] NP[]/?x[] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;clause&#39;] SBar[]/?x[] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="go">|. . &gt; . . . . .| [2:2] NP[-WH] -&gt; * &#39;you&#39; {}</span>
<span class="go">|. . [-] . . . .| [2:3] NP[-WH] -&gt; &#39;you&#39; *</span>
<span class="go">|. [---&gt; . . . .| [1:3] S[+INV]/?x[] -&gt; V[+AUX] NP[] * VP[]/?x[] {}</span>
<span class="go">|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;trans&#39;] NP[]/?x[] {}</span>
<span class="go">|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;clause&#39;] SBar[]/?x[] {}</span>
<span class="go">|. . . &gt; . . . .| [3:3] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="go">|. . . &gt; . . . .| [3:3] V[-AUX, SUBCAT=&#39;clause&#39;] -&gt; * &#39;claim&#39; {}</span>
<span class="go">|. . . [-] . . .| [3:4] V[-AUX, SUBCAT=&#39;clause&#39;] -&gt; &#39;claim&#39; *</span>
<span class="go">|. . . [-&gt; . . .| [3:4] VP[]/?x[] -&gt; V[-AUX, SUBCAT=&#39;clause&#39;] * SBar[]/?x[] {}</span>
<span class="go">|. . . . &gt; . . .| [4:4] SBar[]/?x[] -&gt; * Comp[] S[-INV]/?x[] {}</span>
<span class="go">|. . . . &gt; . . .| [4:4] Comp[] -&gt; * &#39;that&#39; {}</span>
<span class="go">|. . . . [-] . .| [4:5] Comp[] -&gt; &#39;that&#39; *</span>
<span class="go">|. . . . [-&gt; . .| [4:5] SBar[]/?x[] -&gt; Comp[] * S[-INV]/?x[] {}</span>
<span class="go">|. . . . . &gt; . .| [5:5] S[-INV]/?x[] -&gt; * NP[] VP[]/?x[] {}</span>
<span class="go">|. . . . . &gt; . .| [5:5] NP[-WH] -&gt; * &#39;you&#39; {}</span>
<span class="go">|. . . . . [-] .| [5:6] NP[-WH] -&gt; &#39;you&#39; *</span>
<span class="go">|. . . . . [-&gt; .| [5:6] S[-INV]/?x[] -&gt; NP[] * VP[]/?x[] {}</span>
<span class="go">|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;trans&#39;] NP[]/?x[] {}</span>
<span class="go">|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[-AUX, SUBCAT=&#39;clause&#39;] SBar[]/?x[] {}</span>
<span class="go">|. . . . . . &gt; .| [6:6] VP[]/?x[] -&gt; * V[+AUX] VP[]/?x[] {}</span>
<span class="go">|. . . . . . &gt; .| [6:6] V[-AUX, SUBCAT=&#39;trans&#39;] -&gt; * &#39;like&#39; {}</span>
<span class="go">|. . . . . . [-]| [6:7] V[-AUX, SUBCAT=&#39;trans&#39;] -&gt; &#39;like&#39; *</span>
<span class="go">|. . . . . . [-&gt;| [6:7] VP[]/?x[] -&gt; V[-AUX, SUBCAT=&#39;trans&#39;] * NP[]/?x[] {}</span>
<span class="go">|. . . . . . . #| [7:7] NP[]/NP[] -&gt; *</span>
<span class="go">|. . . . . . [-]| [6:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT=&#39;trans&#39;] NP[]/NP[] *</span>
<span class="go">|. . . . . [---]| [5:7] S[-INV]/NP[] -&gt; NP[] VP[]/NP[] *</span>
<span class="go">|. . . . [-----]| [4:7] SBar[]/NP[] -&gt; Comp[] S[-INV]/NP[] *</span>
<span class="go">|. . . [-------]| [3:7] VP[]/NP[] -&gt; V[-AUX, SUBCAT=&#39;clause&#39;] SBar[]/NP[] *</span>
<span class="go">|. [-----------]| [1:7] S[+INV]/NP[] -&gt; V[+AUX] NP[] VP[]/NP[] *</span>
<span class="go">|[=============]| [0:7] S[-INV] -&gt; NP[] S[]/NP[] *</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">trees2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let’s load a German grammar:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">load_parser</span><span class="p">(</span><span class="s1">&#39;grammars/book_grammars/german.fcfg&#39;</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent</span> <span class="o">=</span> <span class="s1">&#39;die Katze sieht den Hund&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(S[]</span>
<span class="go">  (NP[AGR=[GND=&#39;fem&#39;, NUM=&#39;sg&#39;, PER=3], CASE=&#39;nom&#39;]</span>
<span class="go">    (Det[AGR=[GND=&#39;fem&#39;, NUM=&#39;sg&#39;, PER=3], CASE=&#39;nom&#39;] die)</span>
<span class="go">    (N[AGR=[GND=&#39;fem&#39;, NUM=&#39;sg&#39;, PER=3]] Katze))</span>
<span class="go">  (VP[AGR=[NUM=&#39;sg&#39;, PER=3]]</span>
<span class="go">    (TV[AGR=[NUM=&#39;sg&#39;, PER=3], OBJCASE=&#39;acc&#39;] sieht)</span>
<span class="go">    (NP[AGR=[GND=&#39;masc&#39;, NUM=&#39;sg&#39;, PER=3], CASE=&#39;acc&#39;]</span>
<span class="go">      (Det[AGR=[GND=&#39;masc&#39;, NUM=&#39;sg&#39;, PER=3], CASE=&#39;acc&#39;] den)</span>
<span class="go">      (N[AGR=[GND=&#39;masc&#39;, NUM=&#39;sg&#39;, PER=3]] Hund))))</span>
</pre></div>
</div>
</section>
<section id="grammar-with-binding-operators">
<h3>Grammar with Binding Operators<a class="headerlink" href="#grammar-with-binding-operators" title="Permalink to this heading">¶</a></h3>
<p>The bindop.fcfg grammar is a semantic grammar that uses lambda
calculus.  Each element has a core semantics, which is a single lambda
calculus expression; and a set of binding operators, which bind
variables.</p>
<p>In order to make the binding operators work right, they need to
instantiate their bound variable every time they are added to the
chart.  To do this, we use a special subclass of <cite>Chart</cite>, called
<cite>InstantiateVarsChart</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.parse.featurechart</span> <span class="kn">import</span> <span class="n">InstantiateVarsChart</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">load_parser</span><span class="p">(</span><span class="s1">&#39;grammars/sample_grammars/bindop.fcfg&#39;</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">chart_class</span><span class="o">=</span><span class="n">InstantiateVarsChart</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">grammar</span><span class="p">())</span>
<span class="go">Grammar with 15 productions (start state = S[])</span>
<span class="go">    S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] VP[SEM=[BO=?b2, CORE=?vp]]</span>
<span class="go">    VP[SEM=[BO={?b1+?b2}, CORE=&lt;?v(?obj)&gt;]] -&gt; TV[SEM=[BO=?b1, CORE=?v]] NP[SEM=[BO=?b2, CORE=?obj]]</span>
<span class="go">    VP[SEM=?s] -&gt; IV[SEM=?s]</span>
<span class="go">    NP[SEM=[BO={?b1+?b2+{bo(?det(?n),@x)}}, CORE=&lt;@x&gt;]] -&gt; Det[SEM=[BO=?b1, CORE=?det]] N[SEM=[BO=?b2, CORE=?n]]</span>
<span class="go">    Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] -&gt; &#39;a&#39;</span>
<span class="go">    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; &#39;dog&#39;</span>
<span class="go">    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; &#39;cat&#39;</span>
<span class="go">    N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; &#39;mouse&#39;</span>
<span class="go">    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; &#39;barks&#39;</span>
<span class="go">    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; &#39;eats&#39;</span>
<span class="go">    IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; &#39;walks&#39;</span>
<span class="go">    TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; &#39;feeds&#39;</span>
<span class="go">    TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; &#39;walks&#39;</span>
<span class="go">    NP[SEM=[BO={bo(\P.P(John),@x)}, CORE=&lt;@x&gt;]] -&gt; &#39;john&#39;</span>
<span class="go">    NP[SEM=[BO={bo(\P.P(John),@x)}, CORE=&lt;@x&gt;]] -&gt; &#39;alex&#39;</span>
</pre></div>
</div>
<p>A simple intransitive sentence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.sem</span> <span class="kn">import</span> <span class="n">logic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">logic</span><span class="o">.</span><span class="n">_counter</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;john barks&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">|. john.barks.|</span>
<span class="go">|[-----]     .| [0:1] &#39;john&#39;</span>
<span class="go">|.     [-----]| [1:2] &#39;barks&#39;</span>
<span class="go">|[-----]     .| [0:1] NP[SEM=[BO={bo(\P.P(John),z101)}, CORE=&lt;z101&gt;]] -&gt; &#39;john&#39; *</span>
<span class="go">|[-----&gt;     .| [0:1] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.P(John),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}</span>
<span class="go">|.     [-----]| [1:2] IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; &#39;barks&#39; *</span>
<span class="go">|.     [-----]| [1:2] VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] -&gt; IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] *</span>
<span class="go">|[===========]| [0:2] S[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;bark(z2)&gt;]] -&gt; NP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;z2&gt;]] VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] *</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(S[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;bark(z2)&gt;]]</span>
<span class="go">  (NP[SEM=[BO={bo(\P.P(John),z101)}, CORE=&lt;z101&gt;]] john)</span>
<span class="go">  (VP[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]]</span>
<span class="go">    (IV[SEM=[BO={/}, CORE=&lt;\x.bark(x)&gt;]] barks)))</span>
</pre></div>
</div>
<p>A transitive sentence:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;john feeds a dog&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">|.joh.fee. a .dog.|</span>
<span class="go">|[---]   .   .   .| [0:1] &#39;john&#39;</span>
<span class="go">|.   [---]   .   .| [1:2] &#39;feeds&#39;</span>
<span class="go">|.   .   [---]   .| [2:3] &#39;a&#39;</span>
<span class="go">|.   .   .   [---]| [3:4] &#39;dog&#39;</span>
<span class="go">|[---]   .   .   .| [0:1] NP[SEM=[BO={bo(\P.P(John),z102)}, CORE=&lt;z102&gt;]] -&gt; &#39;john&#39; *</span>
<span class="go">|[---&gt;   .   .   .| [0:1] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.P(John),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}</span>
<span class="go">|.   [---]   .   .| [1:2] TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] -&gt; &#39;feeds&#39; *</span>
<span class="go">|.   [---&gt;   .   .| [1:2] VP[SEM=[BO={?b1+?b2}, CORE=&lt;?v(?obj)&gt;]] -&gt; TV[SEM=[BO=?b1, CORE=?v]] * NP[SEM=[BO=?b2, CORE=?obj]] {?b1: {/}, ?v: &lt;LambdaExpression \x y.feed(y,x)&gt;}</span>
<span class="go">|.   .   [---]   .| [2:3] Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] -&gt; &#39;a&#39; *</span>
<span class="go">|.   .   [---&gt;   .| [2:3] NP[SEM=[BO={?b1+?b2+{bo(?det(?n),@x)}}, CORE=&lt;@x&gt;]] -&gt; Det[SEM=[BO=?b1, CORE=?det]] * N[SEM=[BO=?b2, CORE=?n]] {?b1: {/}, ?det: &lt;LambdaExpression \Q P.exists x.(Q(x) &amp; P(x))&gt;}</span>
<span class="go">|.   .   .   [---]| [3:4] N[SEM=[BO={/}, CORE=&lt;dog&gt;]] -&gt; &#39;dog&#39; *</span>
<span class="go">|.   .   [-------]| [2:4] NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z103)}, CORE=&lt;z103&gt;]] -&gt; Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] N[SEM=[BO={/}, CORE=&lt;dog&gt;]] *</span>
<span class="go">|.   .   [-------&gt;| [2:4] S[SEM=[BO={?b1+?b2}, CORE=&lt;?vp(?subj)&gt;]] -&gt; NP[SEM=[BO=?b1, CORE=?subj]] * VP[SEM=[BO=?b2, CORE=?vp]] {?b1: {bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, ?subj: &lt;IndividualVariableExpression z2&gt;}</span>
<span class="go">|.   [-----------]| [1:4] VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]] -&gt; TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;z2&gt;]] *</span>
<span class="go">|[===============]| [0:4] S[SEM=[BO={bo(\P.P(John),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]] -&gt; NP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;z2&gt;]] VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;\y.feed(y,z3)&gt;]] *</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(S[SEM=[BO={bo(\P.P(John),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]]</span>
<span class="go">  (NP[SEM=[BO={bo(\P.P(John),z102)}, CORE=&lt;z102&gt;]] john)</span>
<span class="go">  (VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]</span>
<span class="go">    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)</span>
<span class="go">    (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z103)}, CORE=&lt;z103&gt;]]</span>
<span class="go">      (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)</span>
<span class="go">      (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))))</span>
</pre></div>
</div>
<p>Turn down the verbosity:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">load_parser</span><span class="p">(</span><span class="s1">&#39;grammars/sample_grammars/bindop.fcfg&#39;</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">chart_class</span><span class="o">=</span><span class="n">InstantiateVarsChart</span><span class="p">)</span>
</pre></div>
</div>
<p>Reuse the same lexical item twice:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;john feeds john&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(S[SEM=[BO={bo(\P.P(John),z2), bo(\P.P(John),z3)}, CORE=&lt;feed(z2,z3)&gt;]]</span>
<span class="go">  (NP[SEM=[BO={bo(\P.P(John),z104)}, CORE=&lt;z104&gt;]] john)</span>
<span class="go">  (VP[SEM=[BO={bo(\P.P(John),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]</span>
<span class="go">    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)</span>
<span class="go">    (NP[SEM=[BO={bo(\P.P(John),z105)}, CORE=&lt;z105&gt;]] john)))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">trees</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;a dog feeds a dog&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="go">(S[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2), bo(\P.exists x.(dog(x) &amp; P(x)),z3)}, CORE=&lt;feed(z2,z3)&gt;]]</span>
<span class="go">  (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z106)}, CORE=&lt;z106&gt;]]</span>
<span class="go">    (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)</span>
<span class="go">    (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))</span>
<span class="go">  (VP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z2)}, CORE=&lt;\y.feed(y,z2)&gt;]]</span>
<span class="go">    (TV[SEM=[BO={/}, CORE=&lt;\x y.feed(y,x)&gt;]] feeds)</span>
<span class="go">    (NP[SEM=[BO={bo(\P.exists x.(dog(x) &amp; P(x)),z107)}, CORE=&lt;z107&gt;]]</span>
<span class="go">      (Det[SEM=[BO={/}, CORE=&lt;\Q P.exists x.(Q(x) &amp; P(x))&gt;]] a)</span>
<span class="go">      (N[SEM=[BO={/}, CORE=&lt;dog&gt;]] dog))))</span>
</pre></div>
</div>
</section>
</section>
</section>


        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            
                <li class="footer-element">
                    
                        <a href="../_sources/howto/featgram.rst.txt" rel="nofollow"> source</a>
                    
                </li>
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>