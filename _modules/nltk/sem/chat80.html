<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.sem.chat80</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.sem.chat80</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Chat-80 KB Reader</span>
<span class="c1"># See https://www.w3.org/TR/swbp-skos-core-guide/</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Ewan Klein &lt;ewan@inf.ed.ac.uk&gt;,</span>
<span class="c1"># URL: &lt;https://www.nltk.org&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Overview</span>
<span class="sd">========</span>

<span class="sd">Chat-80 was a natural language system which allowed the user to</span>
<span class="sd">interrogate a Prolog knowledge base in the domain of world</span>
<span class="sd">geography. It was developed in the early &#39;80s by Warren and Pereira; see</span>
<span class="sd">``https://www.aclweb.org/anthology/J82-3002.pdf`` for a description and</span>
<span class="sd">``http://www.cis.upenn.edu/~pereira/oldies.html`` for the source</span>
<span class="sd">files.</span>

<span class="sd">This module contains functions to extract data from the Chat-80</span>
<span class="sd">relation files (&#39;the world database&#39;), and convert then into a format</span>
<span class="sd">that can be incorporated in the FOL models of</span>
<span class="sd">``nltk.sem.evaluate``. The code assumes that the Prolog</span>
<span class="sd">input files are available in the NLTK corpora directory.</span>

<span class="sd">The Chat-80 World Database consists of the following files::</span>

<span class="sd">    world0.pl</span>
<span class="sd">    rivers.pl</span>
<span class="sd">    cities.pl</span>
<span class="sd">    countries.pl</span>
<span class="sd">    contain.pl</span>
<span class="sd">    borders.pl</span>

<span class="sd">This module uses a slightly modified version of ``world0.pl``, in which</span>
<span class="sd">a set of Prolog rules have been omitted. The modified file is named</span>
<span class="sd">``world1.pl``. Currently, the file ``rivers.pl`` is not read in, since</span>
<span class="sd">it uses a list rather than a string in the second field.</span>

<span class="sd">Reading Chat-80 Files</span>
<span class="sd">=====================</span>

<span class="sd">Chat-80 relations are like tables in a relational database. The</span>
<span class="sd">relation acts as the name of the table; the first argument acts as the</span>
<span class="sd">&#39;primary key&#39;; and subsequent arguments are further fields in the</span>
<span class="sd">table. In general, the name of the table provides a label for a unary</span>
<span class="sd">predicate whose extension is all the primary keys. For example,</span>
<span class="sd">relations in ``cities.pl`` are of the following form::</span>

<span class="sd">   &#39;city(athens,greece,1368).&#39;</span>

<span class="sd">Here, ``&#39;athens&#39;`` is the key, and will be mapped to a member of the</span>
<span class="sd">unary predicate *city*.</span>

<span class="sd">The fields in the table are mapped to binary predicates. The first</span>
<span class="sd">argument of the predicate is the primary key, while the second</span>
<span class="sd">argument is the data in the relevant field. Thus, in the above</span>
<span class="sd">example, the third field is mapped to the binary predicate</span>
<span class="sd">*population_of*, whose extension is a set of pairs such as</span>
<span class="sd">``&#39;(athens, 1368)&#39;``.</span>

<span class="sd">An exception to this general framework is required by the relations in</span>
<span class="sd">the files ``borders.pl`` and ``contains.pl``. These contain facts of the</span>
<span class="sd">following form::</span>

<span class="sd">    &#39;borders(albania,greece).&#39;</span>

<span class="sd">    &#39;contains0(africa,central_africa).&#39;</span>

<span class="sd">We do not want to form a unary concept out the element in</span>
<span class="sd">the first field of these records, and we want the label of the binary</span>
<span class="sd">relation just to be ``&#39;border&#39;``/``&#39;contain&#39;`` respectively.</span>

<span class="sd">In order to drive the extraction process, we use &#39;relation metadata bundles&#39;</span>
<span class="sd">which are Python dictionaries such as the following::</span>

<span class="sd">  city = {&#39;label&#39;: &#39;city&#39;,</span>
<span class="sd">          &#39;closures&#39;: [],</span>
<span class="sd">          &#39;schema&#39;: [&#39;city&#39;, &#39;country&#39;, &#39;population&#39;],</span>
<span class="sd">          &#39;filename&#39;: &#39;cities.pl&#39;}</span>

<span class="sd">According to this, the file ``city[&#39;filename&#39;]`` contains a list of</span>
<span class="sd">relational tuples (or more accurately, the corresponding strings in</span>
<span class="sd">Prolog form) whose predicate symbol is ``city[&#39;label&#39;]`` and whose</span>
<span class="sd">relational schema is ``city[&#39;schema&#39;]``. The notion of a ``closure`` is</span>
<span class="sd">discussed in the next section.</span>

<span class="sd">Concepts</span>
<span class="sd">========</span>
<span class="sd">In order to encapsulate the results of the extraction, a class of</span>
<span class="sd">``Concept`` objects is introduced.  A ``Concept`` object has a number of</span>
<span class="sd">attributes, in particular a ``prefLabel`` and ``extension``, which make</span>
<span class="sd">it easier to inspect the output of the extraction. In addition, the</span>
<span class="sd">``extension`` can be further processed: in the case of the ``&#39;border&#39;``</span>
<span class="sd">relation, we check that the relation is symmetric, and in the case</span>
<span class="sd">of the ``&#39;contain&#39;`` relation, we carry out the transitive</span>
<span class="sd">closure. The closure properties associated with a concept is</span>
<span class="sd">indicated in the relation metadata, as indicated earlier.</span>

<span class="sd">The ``extension`` of a ``Concept`` object is then incorporated into a</span>
<span class="sd">``Valuation`` object.</span>

<span class="sd">Persistence</span>
<span class="sd">===========</span>
<span class="sd">The functions ``val_dump`` and ``val_load`` are provided to allow a</span>
<span class="sd">valuation to be stored in a persistent database and re-loaded, rather</span>
<span class="sd">than having to be re-computed each time.</span>

<span class="sd">Individuals and Lexical Items</span>
<span class="sd">=============================</span>
<span class="sd">As well as deriving relations from the Chat-80 data, we also create a</span>
<span class="sd">set of individual constants, one for each entity in the domain. The</span>
<span class="sd">individual constants are string-identical to the entities. For</span>
<span class="sd">example, given a data item such as ``&#39;zloty&#39;``, we add to the valuation</span>
<span class="sd">a pair ``(&#39;zloty&#39;, &#39;zloty&#39;)``. In order to parse English sentences that</span>
<span class="sd">refer to these entities, we also create a lexical item such as the</span>
<span class="sd">following for each individual constant::</span>

<span class="sd">   PropN[num=sg, sem=&lt;\P.(P zloty)&gt;] -&gt; &#39;Zloty&#39;</span>

<span class="sd">The set of rules is written to the file ``chat_pnames.cfg`` in the</span>
<span class="sd">current directory.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">shelve</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">nltk.data</span>

<span class="c1">###########################################################################</span>
<span class="c1"># Chat-80 relation metadata bundles needed to build the valuation</span>
<span class="c1">###########################################################################</span>

<span class="n">borders</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;borders&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;symmetric&quot;</span><span class="p">],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="s2">&quot;border&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;borders.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">contains</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;contains0&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;transitive&quot;</span><span class="p">],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="s2">&quot;contain&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;contain.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">city</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;city&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;city&quot;</span><span class="p">,</span> <span class="s2">&quot;country&quot;</span><span class="p">,</span> <span class="s2">&quot;population&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;cities.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">country</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;country&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s2">&quot;country&quot;</span><span class="p">,</span>
        <span class="s2">&quot;region&quot;</span><span class="p">,</span>
        <span class="s2">&quot;latitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;longitude&quot;</span><span class="p">,</span>
        <span class="s2">&quot;area&quot;</span><span class="p">,</span>
        <span class="s2">&quot;population&quot;</span><span class="p">,</span>
        <span class="s2">&quot;capital&quot;</span><span class="p">,</span>
        <span class="s2">&quot;currency&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;countries.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">circle_of_lat</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;circle_of_latitude&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;circle_of_latitude&quot;</span><span class="p">,</span> <span class="s2">&quot;degrees&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;world1.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">circle_of_long</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;circle_of_longitude&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;circle_of_longitude&quot;</span><span class="p">,</span> <span class="s2">&quot;degrees&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;world1.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">continent</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;continent&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;continent&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;world1.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">region</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;in_continent&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;region&quot;</span><span class="p">,</span> <span class="s2">&quot;continent&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;world1.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">ocean</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;ocean&quot;</span><span class="p">,</span>
    <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;ocean&quot;</span><span class="p">],</span>
    <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;world1.pl&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">sea</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;rel_name&quot;</span><span class="p">:</span> <span class="s2">&quot;sea&quot;</span><span class="p">,</span> <span class="s2">&quot;closures&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;schema&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;sea&quot;</span><span class="p">],</span> <span class="s2">&quot;filename&quot;</span><span class="p">:</span> <span class="s2">&quot;world1.pl&quot;</span><span class="p">}</span>


<span class="n">items</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;borders&quot;</span><span class="p">,</span>
    <span class="s2">&quot;contains&quot;</span><span class="p">,</span>
    <span class="s2">&quot;city&quot;</span><span class="p">,</span>
    <span class="s2">&quot;country&quot;</span><span class="p">,</span>
    <span class="s2">&quot;circle_of_lat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;circle_of_long&quot;</span><span class="p">,</span>
    <span class="s2">&quot;continent&quot;</span><span class="p">,</span>
    <span class="s2">&quot;region&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ocean&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sea&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">items</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>

<span class="n">item_metadata</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;borders&quot;</span><span class="p">:</span> <span class="n">borders</span><span class="p">,</span>
    <span class="s2">&quot;contains&quot;</span><span class="p">:</span> <span class="n">contains</span><span class="p">,</span>
    <span class="s2">&quot;city&quot;</span><span class="p">:</span> <span class="n">city</span><span class="p">,</span>
    <span class="s2">&quot;country&quot;</span><span class="p">:</span> <span class="n">country</span><span class="p">,</span>
    <span class="s2">&quot;circle_of_lat&quot;</span><span class="p">:</span> <span class="n">circle_of_lat</span><span class="p">,</span>
    <span class="s2">&quot;circle_of_long&quot;</span><span class="p">:</span> <span class="n">circle_of_long</span><span class="p">,</span>
    <span class="s2">&quot;continent&quot;</span><span class="p">:</span> <span class="n">continent</span><span class="p">,</span>
    <span class="s2">&quot;region&quot;</span><span class="p">:</span> <span class="n">region</span><span class="p">,</span>
    <span class="s2">&quot;ocean&quot;</span><span class="p">:</span> <span class="n">ocean</span><span class="p">,</span>
    <span class="s2">&quot;sea&quot;</span><span class="p">:</span> <span class="n">sea</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">rels</span> <span class="o">=</span> <span class="n">item_metadata</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="n">not_unary</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;borders.pl&quot;</span><span class="p">,</span> <span class="s2">&quot;contain.pl&quot;</span><span class="p">]</span>

<span class="c1">###########################################################################</span>


<div class="viewcode-block" id="Concept"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.Concept">[docs]</a><span class="k">class</span> <span class="nc">Concept</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Concept class, loosely based on SKOS</span>
<span class="sd">    (https://www.w3.org/TR/swbp-skos-core-guide/).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Concept.__init__"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.Concept.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefLabel</span><span class="p">,</span> <span class="n">arity</span><span class="p">,</span> <span class="n">altLabels</span><span class="o">=</span><span class="p">[],</span> <span class="n">closures</span><span class="o">=</span><span class="p">[],</span> <span class="n">extension</span><span class="o">=</span><span class="nb">set</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param prefLabel: the preferred label for the concept</span>
<span class="sd">        :type prefLabel: str</span>
<span class="sd">        :param arity: the arity of the concept</span>
<span class="sd">        :type arity: int</span>
<span class="sd">        :param altLabels: other (related) labels</span>
<span class="sd">        :type altLabels: list</span>
<span class="sd">        :param closures: closure properties of the extension</span>
<span class="sd">            (list items can be ``symmetric``, ``reflexive``, ``transitive``)</span>
<span class="sd">        :type closures: list</span>
<span class="sd">        :param extension: the extensional value of the concept</span>
<span class="sd">        :type extension: set</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefLabel</span> <span class="o">=</span> <span class="n">prefLabel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arity</span> <span class="o">=</span> <span class="n">arity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">altLabels</span> <span class="o">=</span> <span class="n">altLabels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closures</span> <span class="o">=</span> <span class="n">closures</span>
        <span class="c1"># keep _extension internally as a set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span> <span class="o">=</span> <span class="n">extension</span>
        <span class="c1"># public access is via a list (for slicing)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extension</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">extension</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># _extension = &#39;&#39;</span>
        <span class="c1"># for element in sorted(self.extension):</span>
        <span class="c1"># if isinstance(element, tuple):</span>
        <span class="c1"># element = &#39;(%s, %s)&#39; % (element)</span>
        <span class="c1"># _extension += element + &#39;, &#39;</span>
        <span class="c1"># _extension = _extension[:-1]</span>

        <span class="k">return</span> <span class="s2">&quot;Label = &#39;</span><span class="si">{}</span><span class="s2">&#39;</span><span class="se">\n</span><span class="s2">Arity = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">Extension = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefLabel</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extension</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Concept(&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefLabel</span>

<div class="viewcode-block" id="Concept.augment"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.Concept.augment">[docs]</a>    <span class="k">def</span> <span class="nf">augment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add more data to the ``Concept``&#39;s extension set.</span>

<span class="sd">        :param data: a new semantic value</span>
<span class="sd">        :type data: string or pair of strings</span>
<span class="sd">        :rtype: set</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extension</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span></div>

    <span class="k">def</span> <span class="nf">_make_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a set of pairs into an adjacency linked list encoding of a graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_transclose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the transitive closure of a graph represented as a linked list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                <span class="c1"># check that adjacent is a key</span>
                <span class="k">if</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">adjacent</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]:</span>
                            <span class="n">g</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_make_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an adjacency linked list back into a set of pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">adjacent</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>

<div class="viewcode-block" id="Concept.close"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.Concept.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close a binary relation in the ``Concept``&#39;s extension set.</span>

<span class="sd">        :return: a new extension for the ``Concept`` in which the</span>
<span class="sd">                 relation is closed under a given property</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.sem</span> <span class="kn">import</span> <span class="n">is_rel</span>

        <span class="k">assert</span> <span class="n">is_rel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;symmetric&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">closures</span><span class="p">:</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">:</span>
                <span class="n">pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;transitive&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">closures</span><span class="p">:</span>
            <span class="nb">all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">)</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transclose</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_pairs</span><span class="p">(</span><span class="n">closed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extension</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="clause2concepts"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.clause2concepts">[docs]</a><span class="k">def</span> <span class="nf">clause2concepts</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">rel_name</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">closures</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a file of Prolog clauses into a list of ``Concept`` objects.</span>

<span class="sd">    :param filename: filename containing the relations</span>
<span class="sd">    :type filename: str</span>
<span class="sd">    :param rel_name: name of the relation</span>
<span class="sd">    :type rel_name: str</span>
<span class="sd">    :param schema: the schema used in a set of relational tuples</span>
<span class="sd">    :type schema: list</span>
<span class="sd">    :param closures: closure properties for the extension of the concept</span>
<span class="sd">    :type closures: list</span>
<span class="sd">    :return: a list of ``Concept`` objects</span>
<span class="sd">    :rtype: list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">concepts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># position of the subject of a binary relation</span>
    <span class="n">subj</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># label of the &#39;primary key&#39;</span>
    <span class="n">pkey</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># fields other than the primary key</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># convert a file into a list of lists</span>
    <span class="n">records</span> <span class="o">=</span> <span class="n">_str2records</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">rel_name</span><span class="p">)</span>

    <span class="c1"># add a unary concept corresponding to the set of entities</span>
    <span class="c1"># in the primary key position</span>
    <span class="c1"># relations in &#39;not_unary&#39; are more like ordinary binary relations</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">not_unary</span><span class="p">:</span>
        <span class="n">concepts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">unary_concept</span><span class="p">(</span><span class="n">pkey</span><span class="p">,</span> <span class="n">subj</span><span class="p">,</span> <span class="n">records</span><span class="p">))</span>

    <span class="c1"># add a binary concept for each non-key field</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="n">concepts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binary_concept</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">closures</span><span class="p">,</span> <span class="n">subj</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">records</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">concepts</span></div>


<div class="viewcode-block" id="cities2table"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.cities2table">[docs]</a><span class="k">def</span> <span class="nf">cities2table</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">rel_name</span><span class="p">,</span> <span class="n">dbname</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">setup</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a file of Prolog clauses into a database table.</span>

<span class="sd">    This is not generic, since it doesn&#39;t allow arbitrary</span>
<span class="sd">    schemas to be set as a parameter.</span>

<span class="sd">    Intended usage::</span>

<span class="sd">        cities2table(&#39;cities.pl&#39;, &#39;city&#39;, &#39;city.db&#39;, verbose=True, setup=True)</span>

<span class="sd">    :param filename: filename containing the relations</span>
<span class="sd">    :type filename: str</span>
<span class="sd">    :param rel_name: name of the relation</span>
<span class="sd">    :type rel_name: str</span>
<span class="sd">    :param dbname: filename of persistent store</span>
<span class="sd">    :type schema: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sqlite3</span>

    <span class="n">records</span> <span class="o">=</span> <span class="n">_str2records</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">rel_name</span><span class="p">)</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">dbname</span><span class="p">)</span>
    <span class="n">cur</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">setup</span><span class="p">:</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;CREATE TABLE city_table</span>
<span class="sd">        (City text, Country text, Population int)&quot;&quot;&quot;</span>
        <span class="p">)</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;city_table&quot;</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;insert into </span><span class="si">%s</span><span class="s2"> values (?,?,?)&quot;</span> <span class="o">%</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;inserting values into </span><span class="si">%s</span><span class="s2">: &quot;</span> <span class="o">%</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Committing update to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dbname</span><span class="p">)</span>
    <span class="n">cur</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="sql_query"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.sql_query">[docs]</a><span class="k">def</span> <span class="nf">sql_query</span><span class="p">(</span><span class="n">dbname</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Execute an SQL query over a database.</span>
<span class="sd">    :param dbname: filename of persistent store</span>
<span class="sd">    :type schema: str</span>
<span class="sd">    :param query: SQL query</span>
<span class="sd">    :type rel_name: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sqlite3</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">dbname</span><span class="p">)</span>
        <span class="n">connection</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">OperationalError</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">warnings</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Make sure the database file </span><span class="si">%s</span><span class="s2"> is installed and uncompressed.&quot;</span> <span class="o">%</span> <span class="n">dbname</span>
        <span class="p">)</span>
        <span class="k">raise</span></div>


<span class="k">def</span> <span class="nf">_str2records</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">rel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read a file into memory and convert each relation clause into a list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">recs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;corpora/chat80/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">contents</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">rel</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">rel</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\(&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\)\.$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="n">record</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="n">recs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">recs</span>


<div class="viewcode-block" id="unary_concept"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.unary_concept">[docs]</a><span class="k">def</span> <span class="nf">unary_concept</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">subj</span><span class="p">,</span> <span class="n">records</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a unary concept out of the primary key in a record.</span>

<span class="sd">    A record is a list of entities in some relation, such as</span>
<span class="sd">    ``[&#39;france&#39;, &#39;paris&#39;]``, where ``&#39;france&#39;`` is acting as the primary</span>
<span class="sd">    key.</span>

<span class="sd">    :param label: the preferred label for the concept</span>
<span class="sd">    :type label: string</span>
<span class="sd">    :param subj: position in the record of the subject of the predicate</span>
<span class="sd">    :type subj: int</span>
<span class="sd">    :param records: a list of records</span>
<span class="sd">    :type records: list of lists</span>
<span class="sd">    :return: ``Concept`` of arity 1</span>
<span class="sd">    :rtype: Concept</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Concept</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="nb">set</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">augment</span><span class="p">(</span><span class="n">record</span><span class="p">[</span><span class="n">subj</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="binary_concept"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.binary_concept">[docs]</a><span class="k">def</span> <span class="nf">binary_concept</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">closures</span><span class="p">,</span> <span class="n">subj</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">records</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a binary concept out of the primary key and another field in a record.</span>

<span class="sd">    A record is a list of entities in some relation, such as</span>
<span class="sd">    ``[&#39;france&#39;, &#39;paris&#39;]``, where ``&#39;france&#39;`` is acting as the primary</span>
<span class="sd">    key, and ``&#39;paris&#39;`` stands in the ``&#39;capital_of&#39;`` relation to</span>
<span class="sd">    ``&#39;france&#39;``.</span>

<span class="sd">    More generally, given a record such as ``[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]``, where</span>
<span class="sd">    label is bound to ``&#39;B&#39;``, and ``obj`` bound to 1, the derived</span>
<span class="sd">    binary concept will have label ``&#39;B_of&#39;``, and its extension will</span>
<span class="sd">    be a set of pairs such as ``(&#39;a&#39;, &#39;b&#39;)``.</span>


<span class="sd">    :param label: the base part of the preferred label for the concept</span>
<span class="sd">    :type label: str</span>
<span class="sd">    :param closures: closure properties for the extension of the concept</span>
<span class="sd">    :type closures: list</span>
<span class="sd">    :param subj: position in the record of the subject of the predicate</span>
<span class="sd">    :type subj: int</span>
<span class="sd">    :param obj: position in the record of the object of the predicate</span>
<span class="sd">    :type obj: int</span>
<span class="sd">    :param records: a list of records</span>
<span class="sd">    :type records: list of lists</span>
<span class="sd">    :return: ``Concept`` of arity 2</span>
<span class="sd">    :rtype: Concept</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;border&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">label</span> <span class="o">==</span> <span class="s2">&quot;contain&quot;</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">label</span> <span class="o">+</span> <span class="s2">&quot;_of&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Concept</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">arity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">closures</span><span class="o">=</span><span class="n">closures</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="nb">set</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">augment</span><span class="p">((</span><span class="n">record</span><span class="p">[</span><span class="n">subj</span><span class="p">],</span> <span class="n">record</span><span class="p">[</span><span class="n">obj</span><span class="p">]))</span>
    <span class="c1"># close the concept&#39;s extension according to the properties in closures</span>
    <span class="n">c</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="process_bundle"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.process_bundle">[docs]</a><span class="k">def</span> <span class="nf">process_bundle</span><span class="p">(</span><span class="n">rels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of relation metadata bundles, make a corresponding</span>
<span class="sd">    dictionary of concepts, indexed by the relation name.</span>

<span class="sd">    :param rels: bundle of metadata needed for constructing a concept</span>
<span class="sd">    :type rels: list(dict)</span>
<span class="sd">    :return: a dictionary of concepts, indexed by the relation name.</span>
<span class="sd">    :rtype: dict(str): Concept</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">concepts</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">rel</span> <span class="ow">in</span> <span class="n">rels</span><span class="p">:</span>
        <span class="n">rel_name</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="s2">&quot;rel_name&quot;</span><span class="p">]</span>
        <span class="n">closures</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="s2">&quot;closures&quot;</span><span class="p">]</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="s2">&quot;schema&quot;</span><span class="p">]</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="s2">&quot;filename&quot;</span><span class="p">]</span>

        <span class="n">concept_list</span> <span class="o">=</span> <span class="n">clause2concepts</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">rel_name</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">closures</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">concept_list</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">prefLabel</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">extension</span><span class="p">:</span>
                    <span class="n">concepts</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">augment</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">concepts</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">concepts</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">concepts</span></div>


<div class="viewcode-block" id="make_valuation"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.make_valuation">[docs]</a><span class="k">def</span> <span class="nf">make_valuation</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lexicon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a list of ``Concept`` objects into a list of (label, extension) pairs;</span>
<span class="sd">    optionally create a ``Valuation`` object.</span>

<span class="sd">    :param concepts: concepts</span>
<span class="sd">    :type concepts: list(Concept)</span>
<span class="sd">    :param read: if ``True``, ``(symbol, set)`` pairs are read into a ``Valuation``</span>
<span class="sd">    :type read: bool</span>
<span class="sd">    :rtype: list or Valuation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">:</span>
        <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">prefLabel</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">extension</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">lexicon</span><span class="p">:</span>
        <span class="n">read</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">read</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">nltk.sem</span> <span class="kn">import</span> <span class="n">Valuation</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">Valuation</span><span class="p">({})</span>
        <span class="n">val</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="c1"># add labels for individuals</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">label_indivs</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">lexicon</span><span class="o">=</span><span class="n">lexicon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span></div>


<div class="viewcode-block" id="val_dump"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.val_dump">[docs]</a><span class="k">def</span> <span class="nf">val_dump</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">db</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a ``Valuation`` from a list of relation metadata bundles and dump to</span>
<span class="sd">    persistent database.</span>

<span class="sd">    :param rels: bundle of metadata needed for constructing a concept</span>
<span class="sd">    :type rels: list of dict</span>
<span class="sd">    :param db: name of file to which data is written.</span>
<span class="sd">               The suffix &#39;.db&#39; will be automatically appended.</span>
<span class="sd">    :type db: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">concepts</span> <span class="o">=</span> <span class="n">process_bundle</span><span class="p">(</span><span class="n">rels</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="n">valuation</span> <span class="o">=</span> <span class="n">make_valuation</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">db_out</span> <span class="o">=</span> <span class="n">shelve</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">)</span>

    <span class="n">db_out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">valuation</span><span class="p">)</span>

    <span class="n">db_out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="val_load"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.val_load">[docs]</a><span class="k">def</span> <span class="nf">val_load</span><span class="p">(</span><span class="n">db</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a ``Valuation`` from a persistent database.</span>

<span class="sd">    :param db: name of file from which data is read.</span>
<span class="sd">               The suffix &#39;.db&#39; should be omitted from the name.</span>
<span class="sd">    :type db: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dbname</span> <span class="o">=</span> <span class="n">db</span> <span class="o">+</span> <span class="s2">&quot;.db&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">dbname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Cannot read file: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dbname</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">db_in</span> <span class="o">=</span> <span class="n">shelve</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">nltk.sem</span> <span class="kn">import</span> <span class="n">Valuation</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">Valuation</span><span class="p">(</span><span class="n">db_in</span><span class="p">)</span>
        <span class="c1">#        val.read(db_in.items())</span>
        <span class="k">return</span> <span class="n">val</span></div>


<span class="c1"># def alpha(str):</span>
<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># Utility to filter out non-alphabetic constants.</span>

<span class="c1">#:param str: candidate constant</span>
<span class="c1">#:type str: string</span>
<span class="c1">#:rtype: bool</span>
<span class="c1"># &quot;&quot;&quot;</span>
<span class="c1"># try:</span>
<span class="c1"># int(str)</span>
<span class="c1"># return False</span>
<span class="c1"># except ValueError:</span>
<span class="c1">## some unknown values in records are labeled &#39;?&#39;</span>
<span class="c1"># if not str == &#39;?&#39;:</span>
<span class="c1"># return True</span>


<div class="viewcode-block" id="label_indivs"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.label_indivs">[docs]</a><span class="k">def</span> <span class="nf">label_indivs</span><span class="p">(</span><span class="n">valuation</span><span class="p">,</span> <span class="n">lexicon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign individual constants to the individuals in the domain of a ``Valuation``.</span>

<span class="sd">    Given a valuation with an entry of the form ``{&#39;rel&#39;: {&#39;a&#39;: True}}``,</span>
<span class="sd">    add a new entry ``{&#39;a&#39;: &#39;a&#39;}``.</span>

<span class="sd">    :type valuation: Valuation</span>
<span class="sd">    :rtype: Valuation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># collect all the individuals into a domain</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">valuation</span><span class="o">.</span><span class="n">domain</span>
    <span class="c1"># convert the domain into a sorted list of alphabetic terms</span>
    <span class="c1"># use the same string as a label</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">e</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">lexicon</span><span class="p">:</span>
        <span class="n">lex</span> <span class="o">=</span> <span class="n">make_lex</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;chat_pnames.cfg&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="n">outfile</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">lex</span><span class="p">)</span>
    <span class="c1"># read the pairs into the valuation</span>
    <span class="n">valuation</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">valuation</span></div>


<div class="viewcode-block" id="make_lex"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.make_lex">[docs]</a><span class="k">def</span> <span class="nf">make_lex</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create lexical CFG rules for each individual symbol.</span>

<span class="sd">    Given a valuation with an entry of the form ``{&#39;zloty&#39;: &#39;zloty&#39;}``,</span>
<span class="sd">    create a lexical rule for the proper name &#39;Zloty&#39;.</span>

<span class="sd">    :param symbols: a list of individual constants in the semantic representation</span>
<span class="sd">    :type symbols: sequence -- set(str)</span>
<span class="sd">    :rtype: list(str)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lex</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">##################################################################</span>
<span class="s2"># Lexical rules automatically generated by running &#39;chat80.py -x&#39;.</span>
<span class="s2">##################################################################</span>

<span class="s2">&quot;&quot;&quot;</span>
    <span class="n">lex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="n">template</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;PropN[num=sg, sem=&lt;\P.(P </span><span class="si">%s</span><span class="s2">)&gt;] -&gt; &#39;</span><span class="si">%s</span><span class="s2">&#39;\n&quot;</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">caps</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">]</span>
        <span class="n">pname</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">caps</span><span class="p">)</span>
        <span class="n">rule</span> <span class="o">=</span> <span class="n">template</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pname</span><span class="p">)</span>
        <span class="n">lex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lex</span></div>


<span class="c1">###########################################################################</span>
<span class="c1"># Interface function to emulate other corpus readers</span>
<span class="c1">###########################################################################</span>


<div class="viewcode-block" id="concepts"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.concepts">[docs]</a><span class="k">def</span> <span class="nf">concepts</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">items</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a list of concepts corresponding to the relation names in ``items``.</span>

<span class="sd">    :param items: names of the Chat-80 relations to extract</span>
<span class="sd">    :type items: list(str)</span>
<span class="sd">    :return: the ``Concept`` objects which are extracted from the relations</span>
<span class="sd">    :rtype: list(Concept)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">(</span><span class="n">items</span><span class="p">,)</span>

    <span class="n">rels</span> <span class="o">=</span> <span class="p">[</span><span class="n">item_metadata</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>

    <span class="n">concept_map</span> <span class="o">=</span> <span class="n">process_bundle</span><span class="p">(</span><span class="n">rels</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">concept_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span></div>


<span class="c1">###########################################################################</span>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">optparse</span> <span class="kn">import</span> <span class="n">OptionParser</span>

    <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Extract data from the Chat-80 Prolog files and convert them into a</span>
<span class="s2">Valuation object for use in the NLTK semantics package.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="n">opts</span> <span class="o">=</span> <span class="n">OptionParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vocab</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;--store&quot;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;outdb&quot;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;store a valuation in DB&quot;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;DB&quot;</span>
    <span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-l&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--load&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;indb&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;load a stored valuation from DB&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;DB&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-c&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--concepts&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;print concepts instead of a valuation&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-r&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--relation&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;print concept with label REL (check possible labels with &#39;-v&#39; option)&quot;</span><span class="p">,</span>
        <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;REL&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-q&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--quiet&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_false&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;don&#39;t print out progress info&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-x&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--lex&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;lex&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;write a file of lexical entries for country names, then exit&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>
        <span class="s2">&quot;-v&quot;</span><span class="p">,</span>
        <span class="s2">&quot;--vocab&quot;</span><span class="p">,</span>
        <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="s2">&quot;vocab&quot;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;print out the vocabulary of concept labels and their arity, then exit&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">outdb</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">indb</span><span class="p">:</span>
        <span class="n">opts</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Options --store and --load are mutually exclusive&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">outdb</span><span class="p">:</span>
        <span class="c1"># write the valuation to a persistent database</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">outdb</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">outdb</span> <span class="o">+</span> <span class="s2">&quot;.db&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dumping a valuation to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">outdb</span><span class="p">)</span>
        <span class="n">val_dump</span><span class="p">(</span><span class="n">rels</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">outdb</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># try to read in a valuation from a database</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">indb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dbname</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">indb</span> <span class="o">+</span> <span class="s2">&quot;.db&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">dbname</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Cannot read file: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">dbname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valuation</span> <span class="o">=</span> <span class="n">val_load</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">indb</span><span class="p">)</span>
        <span class="c1"># we need to create the valuation from scratch</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># build some concepts</span>
            <span class="n">concept_map</span> <span class="o">=</span> <span class="n">process_bundle</span><span class="p">(</span><span class="n">rels</span><span class="p">)</span>
            <span class="n">concepts</span> <span class="o">=</span> <span class="n">concept_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="c1"># just print out the vocabulary</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">vocab</span><span class="p">:</span>
                <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">c</span><span class="o">.</span><span class="n">arity</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">prefLabel</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">arity</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">arity</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># show all the concepts</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">concepts</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">concepts</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">concept_map</span><span class="p">[</span><span class="n">options</span><span class="o">.</span><span class="n">label</span><span class="p">])</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># turn the concepts into a Valuation</span>
                <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">lex</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Writing out lexical rules&quot;</span><span class="p">)</span>
                    <span class="n">make_valuation</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">lexicon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">valuation</span> <span class="o">=</span> <span class="n">make_valuation</span><span class="p">(</span><span class="n">concepts</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">valuation</span><span class="p">)</span></div>


<div class="viewcode-block" id="sql_demo"><a class="viewcode-back" href="../../../api/nltk.sem.chat80.html#nltk.sem.chat80.sql_demo">[docs]</a><span class="k">def</span> <span class="nf">sql_demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print out every row from the &#39;city.db&#39; database.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using SQL to extract rows from &#39;city.db&#39; RDB.&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">sql_query</span><span class="p">(</span><span class="s2">&quot;corpora/city_database/city.db&quot;</span><span class="p">,</span> <span class="s2">&quot;SELECT * FROM city_table&quot;</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
    <span class="n">sql_demo</span><span class="p">()</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>