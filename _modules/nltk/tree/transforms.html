<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.tree.transforms</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.tree.transforms</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Tree Transformations</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2005-2007 Oregon Graduate Institute</span>
<span class="c1"># Author: Nathan Bodenstab &lt;bodenstab@cslu.ogi.edu&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A collection of methods for tree (grammar) transformations used</span>
<span class="sd">in parsing natural language.</span>

<span class="sd">Although many of these methods are technically grammar transformations</span>
<span class="sd">(ie. Chomsky Norm Form), when working with treebanks it is much more</span>
<span class="sd">natural to visualize these modifications in a tree structure.  Hence,</span>
<span class="sd">we will do all transformation directly to the tree itself.</span>
<span class="sd">Transforming the tree directly also allows us to do parent annotation.</span>
<span class="sd">A grammar can then be simply induced from the modified tree.</span>

<span class="sd">The following is a short tutorial on the available transformations.</span>

<span class="sd"> 1. Chomsky Normal Form (binarization)</span>

<span class="sd">    It is well known that any grammar has a Chomsky Normal Form (CNF)</span>
<span class="sd">    equivalent grammar where CNF is defined by every production having</span>
<span class="sd">    either two non-terminals or one terminal on its right hand side.</span>
<span class="sd">    When we have hierarchically structured data (ie. a treebank), it is</span>
<span class="sd">    natural to view this in terms of productions where the root of every</span>
<span class="sd">    subtree is the head (left hand side) of the production and all of</span>
<span class="sd">    its children are the right hand side constituents.  In order to</span>
<span class="sd">    convert a tree into CNF, we simply need to ensure that every subtree</span>
<span class="sd">    has either two subtrees as children (binarization), or one leaf node</span>
<span class="sd">    (non-terminal).  In order to binarize a subtree with more than two</span>
<span class="sd">    children, we must introduce artificial nodes.</span>

<span class="sd">    There are two popular methods to convert a tree into CNF: left</span>
<span class="sd">    factoring and right factoring.  The following example demonstrates</span>
<span class="sd">    the difference between them.  Example::</span>

<span class="sd">     Original       Right-Factored     Left-Factored</span>

<span class="sd">          A              A                      A</span>
<span class="sd">        / | \          /   \                  /   \</span>
<span class="sd">       B  C  D   ==&gt;  B    A|&lt;C-D&gt;   OR   A|&lt;B-C&gt;  D</span>
<span class="sd">                            /  \          /  \</span>
<span class="sd">                           C    D        B    C</span>

<span class="sd"> 2. Parent Annotation</span>

<span class="sd">    In addition to binarizing the tree, there are two standard</span>
<span class="sd">    modifications to node labels we can do in the same traversal: parent</span>
<span class="sd">    annotation and Markov order-N smoothing (or sibling smoothing).</span>

<span class="sd">    The purpose of parent annotation is to refine the probabilities of</span>
<span class="sd">    productions by adding a small amount of context.  With this simple</span>
<span class="sd">    addition, a CYK (inside-outside, dynamic programming chart parse)</span>
<span class="sd">    can improve from 74% to 79% accuracy.  A natural generalization from</span>
<span class="sd">    parent annotation is to grandparent annotation and beyond.  The</span>
<span class="sd">    tradeoff becomes accuracy gain vs. computational complexity.  We</span>
<span class="sd">    must also keep in mind data sparcity issues.  Example::</span>

<span class="sd">     Original       Parent Annotation</span>

<span class="sd">          A                A^&lt;?&gt;</span>
<span class="sd">        / | \             /   \</span>
<span class="sd">       B  C  D   ==&gt;  B^&lt;A&gt;    A|&lt;C-D&gt;^&lt;?&gt;     where ? is the</span>
<span class="sd">                                 /  \          parent of A</span>
<span class="sd">                             C^&lt;A&gt;   D^&lt;A&gt;</span>


<span class="sd"> 3. Markov order-N smoothing</span>

<span class="sd">    Markov smoothing combats data sparcity issues as well as decreasing</span>
<span class="sd">    computational requirements by limiting the number of children</span>
<span class="sd">    included in artificial nodes.  In practice, most people use an order</span>
<span class="sd">    2 grammar.  Example::</span>

<span class="sd">      Original       No Smoothing       Markov order 1   Markov order 2   etc.</span>

<span class="sd">       __A__            A                      A                A</span>
<span class="sd">      / /|\ \         /   \                  /   \            /   \</span>
<span class="sd">     B C D E F  ==&gt;  B    A|&lt;C-D-E-F&gt;  ==&gt;  B   A|&lt;C&gt;  ==&gt;   B  A|&lt;C-D&gt;</span>
<span class="sd">                            /   \               /   \            /   \</span>
<span class="sd">                           C    ...            C    ...         C    ...</span>



<span class="sd">    Annotation decisions can be thought about in the vertical direction</span>
<span class="sd">    (parent, grandparent, etc) and the horizontal direction (number of</span>
<span class="sd">    siblings to keep).  Parameters to the following functions specify</span>
<span class="sd">    these values.  For more information see:</span>

<span class="sd">    Dan Klein and Chris Manning (2003) &quot;Accurate Unlexicalized</span>
<span class="sd">    Parsing&quot;, ACL-03.  https://www.aclweb.org/anthology/P03-1054</span>

<span class="sd"> 4. Unary Collapsing</span>

<span class="sd">    Collapse unary productions (ie. subtrees with a single child) into a</span>
<span class="sd">    new non-terminal (Tree node).  This is useful when working with</span>
<span class="sd">    algorithms that do not allow unary productions, yet you do not wish</span>
<span class="sd">    to lose the parent information.  Example::</span>

<span class="sd">       A</span>
<span class="sd">       |</span>
<span class="sd">       B   ==&gt;   A+B</span>
<span class="sd">      / \        / \</span>
<span class="sd">     C   D      C   D</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">nltk.tree.tree</span> <span class="kn">import</span> <span class="n">Tree</span>


<div class="viewcode-block" id="chomsky_normal_form"><a class="viewcode-back" href="../../../api/nltk.tree.transforms.html#nltk.tree.chomsky_normal_form">[docs]</a><span class="k">def</span> <span class="nf">chomsky_normal_form</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">horzMarkov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertMarkov</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">childChar</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="n">parentChar</span><span class="o">=</span><span class="s2">&quot;^&quot;</span>
<span class="p">):</span>
    <span class="c1"># assume all subtrees have homogeneous children</span>
    <span class="c1"># assume all terminals have no siblings</span>

    <span class="c1"># A semi-hack to have elegant looking code below.  As a result,</span>
    <span class="c1"># any subtree with a branching factor greater than 999 will be incorrectly truncated.</span>
    <span class="k">if</span> <span class="n">horzMarkov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">horzMarkov</span> <span class="o">=</span> <span class="mi">999</span>

    <span class="c1"># Traverse the tree depth-first keeping a list of ancestor nodes to the root.</span>
    <span class="c1"># I chose not to use the tree.treepositions() method since it requires</span>
    <span class="c1"># two traversals of the tree (one to get the positions, one to iterate</span>
    <span class="c1"># over them) and node access time is proportional to the height of the node.</span>
    <span class="c1"># This method is 7x faster which helps when parsing 40,000 sentences.</span>

    <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">tree</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">()])]</span>
    <span class="k">while</span> <span class="n">nodeList</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>

            <span class="c1"># parent annotation</span>
            <span class="n">parentString</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">originalNode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">vertMarkov</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">tree</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">parentString</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parentChar</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
                <span class="n">node</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="o">+</span> <span class="n">parentString</span><span class="p">)</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">originalNode</span><span class="p">]</span> <span class="o">+</span> <span class="n">parent</span><span class="p">[:</span> <span class="n">vertMarkov</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># add children to the agenda before we mess with them</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>

            <span class="c1"># chomsky normal form factorization</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">childNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">]</span>
                <span class="n">nodeCopy</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># delete the children</span>

                <span class="n">curNode</span> <span class="o">=</span> <span class="n">node</span>
                <span class="n">numChildren</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodeCopy</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numChildren</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                        <span class="n">newHead</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&lt;</span><span class="si">{}</span><span class="s2">&gt;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">originalNode</span><span class="p">,</span>
                            <span class="n">childChar</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                <span class="n">childNodes</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="nb">min</span><span class="p">([</span><span class="n">i</span> <span class="o">+</span> <span class="n">horzMarkov</span><span class="p">,</span> <span class="n">numChildren</span><span class="p">])]</span>
                            <span class="p">),</span>
                            <span class="n">parentString</span><span class="p">,</span>
                        <span class="p">)</span>  <span class="c1"># create new head</span>
                        <span class="n">newNode</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">newHead</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="n">curNode</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodeCopy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">newNode</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newHead</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&lt;</span><span class="si">{}</span><span class="s2">&gt;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">originalNode</span><span class="p">,</span>
                            <span class="n">childChar</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                <span class="n">childNodes</span><span class="p">[</span><span class="nb">max</span><span class="p">([</span><span class="n">numChildren</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="n">horzMarkov</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="p">:</span> <span class="o">-</span><span class="n">i</span><span class="p">]</span>
                            <span class="p">),</span>
                            <span class="n">parentString</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">newNode</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">newHead</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="n">curNode</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newNode</span><span class="p">,</span> <span class="n">nodeCopy</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span>

                    <span class="n">curNode</span> <span class="o">=</span> <span class="n">newNode</span>

                <span class="n">curNode</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">nodeCopy</span><span class="p">]</span></div>


<div class="viewcode-block" id="un_chomsky_normal_form"><a class="viewcode-back" href="../../../api/nltk.tree.un_chomsky_normal_form.html#nltk.tree.un_chomsky_normal_form">[docs]</a><span class="k">def</span> <span class="nf">un_chomsky_normal_form</span><span class="p">(</span>
    <span class="n">tree</span><span class="p">,</span> <span class="n">expandUnary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">childChar</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="n">parentChar</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">unaryChar</span><span class="o">=</span><span class="s2">&quot;+&quot;</span>
<span class="p">):</span>
    <span class="c1"># Traverse the tree-depth first keeping a pointer to the parent for modification purposes.</span>
    <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">tree</span><span class="p">,</span> <span class="p">[])]</span>
    <span class="k">while</span> <span class="n">nodeList</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="c1"># if the node contains the &#39;childChar&#39; character it means that</span>
            <span class="c1"># it is an artificial node and can be removed, although we still need</span>
            <span class="c1"># to move its children to its parent</span>
            <span class="n">childIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">childChar</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">childIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">nodeIndex</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">nodeIndex</span><span class="p">])</span>
                <span class="c1"># Generated node was on the left if the nodeIndex is 0 which</span>
                <span class="c1"># means the grammar was left factored.  We must insert the children</span>
                <span class="c1"># at the beginning of the parent&#39;s children</span>
                <span class="k">if</span> <span class="n">nodeIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

                <span class="c1"># parent is now the current node so the children of parent will be added to the agenda</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parentIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parentChar</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parentIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># strip the node name of the parent annotation</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()[:</span><span class="n">parentIndex</span><span class="p">])</span>

                <span class="c1"># expand collapsed unary productions</span>
                <span class="k">if</span> <span class="n">expandUnary</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">unaryIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">unaryChar</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unaryIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">newNode</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()[</span><span class="n">unaryIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()[:</span><span class="n">unaryIndex</span><span class="p">])</span>
                        <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newNode</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span></div>


<div class="viewcode-block" id="collapse_unary"><a class="viewcode-back" href="../../../api/nltk.tree.transforms.html#nltk.tree.collapse_unary">[docs]</a><span class="k">def</span> <span class="nf">collapse_unary</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">collapsePOS</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapseRoot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">joinChar</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collapse subtrees with a single child (ie. unary productions)</span>
<span class="sd">    into a new non-terminal (Tree node) joined by &#39;joinChar&#39;.</span>
<span class="sd">    This is useful when working with algorithms that do not allow</span>
<span class="sd">    unary productions, and completely removing the unary productions</span>
<span class="sd">    would require loss of useful information.  The Tree is modified</span>
<span class="sd">    directly (since it is passed by reference) and no value is returned.</span>

<span class="sd">    :param tree: The Tree to be collapsed</span>
<span class="sd">    :type  tree: Tree</span>
<span class="sd">    :param collapsePOS: &#39;False&#39; (default) will not collapse the parent of leaf nodes (ie.</span>
<span class="sd">                        Part-of-Speech tags) since they are always unary productions</span>
<span class="sd">    :type  collapsePOS: bool</span>
<span class="sd">    :param collapseRoot: &#39;False&#39; (default) will not modify the root production</span>
<span class="sd">                         if it is unary.  For the Penn WSJ treebank corpus, this corresponds</span>
<span class="sd">                         to the TOP -&gt; productions.</span>
<span class="sd">    :type collapseRoot: bool</span>
<span class="sd">    :param joinChar: A string used to connect collapsed node values (default = &quot;+&quot;)</span>
<span class="sd">    :type  joinChar: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">collapseRoot</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>

    <span class="c1"># depth-first traversal of tree</span>
    <span class="k">while</span> <span class="n">nodeList</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">collapsePOS</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="o">+</span> <span class="n">joinChar</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
                <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># since we assigned the child&#39;s children to the current node,</span>
                <span class="c1"># evaluate the current node again</span>
                <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span></div>


<span class="c1">#################################################################</span>
<span class="c1"># Demonstration</span>
<span class="c1">#################################################################</span>


<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration showing how each tree transform can be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

    <span class="kn">from</span> <span class="nn">nltk.draw.tree</span> <span class="kn">import</span> <span class="n">draw_trees</span>
    <span class="kn">from</span> <span class="nn">nltk.tree.tree</span> <span class="kn">import</span> <span class="n">Tree</span>

    <span class="c1"># original tree from WSJ bracketed text</span>
    <span class="n">sentence</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;(TOP</span>
<span class="s2">  (S</span>
<span class="s2">    (S</span>
<span class="s2">      (VP</span>
<span class="s2">        (VBN Turned)</span>
<span class="s2">        (ADVP (RB loose))</span>
<span class="s2">        (PP</span>
<span class="s2">          (IN in)</span>
<span class="s2">          (NP</span>
<span class="s2">            (NP (NNP Shane) (NNP Longman) (POS &#39;s))</span>
<span class="s2">            (NN trading)</span>
<span class="s2">            (NN room)))))</span>
<span class="s2">    (, ,)</span>
<span class="s2">    (NP (DT the) (NN yuppie) (NNS dealers))</span>
<span class="s2">    (VP (AUX do) (NP (NP (RB little)) (ADJP (RB right))))</span>
<span class="s2">    (. .)))&quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">sentence</span><span class="p">,</span> <span class="n">remove_empty_top_bracketing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># collapse subtrees with only one child</span>
    <span class="n">collapsedTree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">collapse_unary</span><span class="p">(</span><span class="n">collapsedTree</span><span class="p">)</span>

    <span class="c1"># convert the tree to CNF</span>
    <span class="n">cnfTree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">collapsedTree</span><span class="p">)</span>
    <span class="n">chomsky_normal_form</span><span class="p">(</span><span class="n">cnfTree</span><span class="p">)</span>

    <span class="c1"># convert the tree to CNF with parent annotation (one level) and horizontal smoothing of order two</span>
    <span class="n">parentTree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">collapsedTree</span><span class="p">)</span>
    <span class="n">chomsky_normal_form</span><span class="p">(</span><span class="n">parentTree</span><span class="p">,</span> <span class="n">horzMarkov</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">vertMarkov</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># convert the tree back to its original form (used to make CYK results comparable)</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">parentTree</span><span class="p">)</span>
    <span class="n">un_chomsky_normal_form</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>

    <span class="c1"># convert tree back to bracketed text</span>
    <span class="n">sentence2</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">pprint</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sentence2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sentences the same? &quot;</span><span class="p">,</span> <span class="n">sentence</span> <span class="o">==</span> <span class="n">sentence2</span><span class="p">)</span>

    <span class="n">draw_trees</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">collapsedTree</span><span class="p">,</span> <span class="n">cnfTree</span><span class="p">,</span> <span class="n">parentTree</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chomsky_normal_form&quot;</span><span class="p">,</span> <span class="s2">&quot;un_chomsky_normal_form&quot;</span><span class="p">,</span> <span class="s2">&quot;collapse_unary&quot;</span><span class="p">]</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>