<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.tree.parented</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.tree.parented</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Text Trees</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1">#         Peter Ljungl√∂f &lt;peter.ljunglof@gu.se&gt;</span>
<span class="c1">#         Tom Aarsen &lt;&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">nltk.tree.tree</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">slice_bounds</span>


<span class="c1">######################################################################</span>
<span class="c1">## Parented trees</span>
<span class="c1">######################################################################</span>
<span class="k">class</span> <span class="nc">AbstractParentedTree</span><span class="p">(</span><span class="n">Tree</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract base class for a ``Tree`` that automatically maintains</span>
<span class="sd">    pointers to parent nodes.  These parent pointers are updated</span>
<span class="sd">    whenever any change is made to a tree&#39;s structure.  Two subclasses</span>
<span class="sd">    are currently defined:</span>

<span class="sd">      - ``ParentedTree`` is used for tree structures where each subtree</span>
<span class="sd">        has at most one parent.  This class should be used in cases</span>
<span class="sd">        where there is no&quot;sharing&quot; of subtrees.</span>

<span class="sd">      - ``MultiParentedTree`` is used for tree structures where a</span>
<span class="sd">        subtree may have zero or more parents.  This class should be</span>
<span class="sd">        used in cases where subtrees may be shared.</span>

<span class="sd">    Subclassing</span>
<span class="sd">    ===========</span>
<span class="sd">    The ``AbstractParentedTree`` class redefines all operations that</span>
<span class="sd">    modify a tree&#39;s structure to call two methods, which are used by</span>
<span class="sd">    subclasses to update parent information:</span>

<span class="sd">      - ``_setparent()`` is called whenever a new child is added.</span>
<span class="sd">      - ``_delparent()`` is called whenever a child is removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
        <span class="c1"># If children is None, the tree is read from node, and</span>
        <span class="c1"># all parents will be set during parsing.</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Otherwise we have to set the parent of the children.</span>
            <span class="c1"># Iterate over self, and *not* children, because children</span>
            <span class="c1"># might be an iterator.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Parent management</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_setparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parent pointer of ``child`` to point to ``self``.  This</span>
<span class="sd">        method is only called if the type of ``child`` is ``Tree``;</span>
<span class="sd">        i.e., it is not called when adding a leaf to a tree.  This method</span>
<span class="sd">        is always called before the child is actually added to the</span>
<span class="sd">        child list of ``self``.</span>

<span class="sd">        :type child: Tree</span>
<span class="sd">        :type index: int</span>
<span class="sd">        :param index: The index of ``child`` in ``self``.</span>
<span class="sd">        :raise TypeError: If ``child`` is a tree with an impropriate</span>
<span class="sd">            type.  Typically, if ``child`` is a tree, then its type needs</span>
<span class="sd">            to match the type of ``self``.  This prevents mixing of</span>
<span class="sd">            different tree types (single-parented, multi-parented, and</span>
<span class="sd">            non-parented).</span>
<span class="sd">        :param dry_run: If true, the don&#39;t actually set the child&#39;s</span>
<span class="sd">            parent pointer; just check for any error conditions, and</span>
<span class="sd">            raise an exception if one is found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the parent pointer of ``child`` to not point to self.  This</span>
<span class="sd">        method is only called if the type of ``child`` is ``Tree``; i.e., it</span>
<span class="sd">        is not called when removing a leaf from a tree.  This method</span>
<span class="sd">        is always called before the child is actually removed from the</span>
<span class="sd">        child list of ``self``.</span>

<span class="sd">        :type child: Tree</span>
<span class="sd">        :type index: int</span>
<span class="sd">        :param index: The index of ``child`` in ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Methods that add/remove children</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Every method that adds or removes a child must make</span>
    <span class="c1"># appropriate calls to _setparent() and _delparent().</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c1"># del ptree[start:stop]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">allow_step</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Clear all the children pointers.</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="c1"># Delete the children from our child list.</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># del ptree[i]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index out of range&quot;</span><span class="p">)</span>
            <span class="c1"># Clear the child&#39;s parent pointer.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
            <span class="c1"># Remove the child from our child list.</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># del ptree[()]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The tree position () may not be deleted.&quot;</span><span class="p">)</span>
            <span class="c1"># del ptree[(i,)]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># del ptree[i1, i2, i3]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> indices must be integers, not </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># ptree[start:stop] = value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">allow_step</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># make a copy of value, in case it&#39;s an iterator</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># Check for any error conditions, so we can avoid ending</span>
            <span class="c1"># up in an inconsistent state if an error does occur.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># clear the child pointers of all parents we&#39;re removing</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="c1"># set the child pointers of the new children.  We do this</span>
            <span class="c1"># after clearing *all* child pointers, in case we&#39;re e.g.</span>
            <span class="c1"># reversing the elements in a tree.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>
            <span class="c1"># finally, update the content of the child list itself.</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># ptree[i] = value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index out of range&quot;</span><span class="p">)</span>
            <span class="c1"># if the value is not changing, do nothing.</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                <span class="k">return</span>
            <span class="c1"># Set the new child&#39;s parent pointer.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="c1"># Remove the old child&#39;s parent pointer</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
            <span class="c1"># Update our child list.</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="c1"># ptree[()] = value</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The tree position () may not be assigned to.&quot;</span><span class="p">)</span>
            <span class="c1"># ptree[(i,)] = value</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="c1"># ptree[i1, i2, i3] = value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> indices must be integers, not </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="c1"># Handle negative indexes.  Note that if index &lt; -len(self),</span>
        <span class="c1"># we do *not* raise an IndexError, unlike __getitem__.  This</span>
        <span class="c1"># is done for consistency with list.__getitem__ and list.index.</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Set the child&#39;s parent, and update our child list.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index out of range&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># n.b.: like `list`, this is done by equality, not identity!</span>
    <span class="c1"># To remove a specific child, use del ptree[i].</span>
    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="c1"># We need to implement __getslice__ and friends, even though</span>
    <span class="c1"># they&#39;re deprecated, because otherwise list.__getslice__ will get</span>
    <span class="c1"># called (since we&#39;re subclassing from list).  Just delegate to</span>
    <span class="c1"># __getitem__ etc., but use max(0, start) and max(0, stop) because</span>
    <span class="c1"># because negative indices are already handled *before*</span>
    <span class="c1"># __getslice__ is called; and we don&#39;t want to double-count them.</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="s2">&quot;__getslice__&quot;</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">)))</span>

        <span class="k">def</span> <span class="nf">__delslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">)))</span>

        <span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">)),</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method used by the pickle module when un-pickling.</span>
<span class="sd">        This method provides the arguments passed to ``__new__``</span>
<span class="sd">        upon un-pickling. Without this method, ParentedTree instances</span>
<span class="sd">        cannot be pickled and unpickled in Python 3.7+ onwards.</span>

<span class="sd">        :return: Tuple of arguments for ``__new__``, i.e. the label</span>
<span class="sd">            and the children of this node.</span>
<span class="sd">        :rtype: Tuple[Any, List[AbstractParentedTree]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>


<div class="viewcode-block" id="ParentedTree"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree">[docs]</a><span class="k">class</span> <span class="nc">ParentedTree</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``Tree`` that automatically maintains parent pointers for</span>
<span class="sd">    single-parented trees.  The following are methods for querying</span>
<span class="sd">    the structure of a parented tree: ``parent``, ``parent_index``,</span>
<span class="sd">    ``left_sibling``, ``right_sibling``, ``root``, ``treeposition``.</span>

<span class="sd">    Each ``ParentedTree`` may have at most one parent.  In</span>
<span class="sd">    particular, subtrees may not be shared.  Any attempt to reuse a</span>
<span class="sd">    single ``ParentedTree`` as a child of more than one parent (or</span>
<span class="sd">    as multiple children of the same parent) will cause a</span>
<span class="sd">    ``ValueError`` exception to be raised.</span>

<span class="sd">    ``ParentedTrees`` should never be used in the same tree as ``Trees``</span>
<span class="sd">    or ``MultiParentedTrees``.  Mixing tree implementations may result</span>
<span class="sd">    in incorrect parent pointers and in ``TypeError`` exceptions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ParentedTree.__init__"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;The parent of this Tree, or None if it has no parent.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If children is None, the tree is read from node.</span>
            <span class="c1"># After parsing, the parent of the immediate children</span>
            <span class="c1"># will point to an intermediate tree, not self.</span>
            <span class="c1"># We fix this by brute force:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">nltk.tree.immutable</span> <span class="kn">import</span> <span class="n">ImmutableParentedTree</span>

        <span class="k">return</span> <span class="n">ImmutableParentedTree</span>

<div class="viewcode-block" id="ParentedTree.copy"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deep</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> objects do not support shallow copies. Defaulting to a deep copy.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="c1"># /////////////////////////////////////////////////////////////////</span>
    <span class="c1"># Methods</span>
    <span class="c1"># /////////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="ParentedTree.parent"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.parent">[docs]</a>    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The parent of this tree, or None if it has no parent.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span></div>

<div class="viewcode-block" id="ParentedTree.parent_index"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.parent_index">[docs]</a>    <span class="k">def</span> <span class="nf">parent_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of this tree in its parent.  I.e.,</span>
<span class="sd">        ``ptree.parent()[ptree.parent_index()] is ptree``.  Note that</span>
<span class="sd">        ``ptree.parent_index()`` is not necessarily equal to</span>
<span class="sd">        ``ptree.parent.index(ptree)``, since the ``index()`` method</span>
<span class="sd">        returns the first child that is equal to its argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;expected to find self in self._parent!&quot;</span></div>

<div class="viewcode-block" id="ParentedTree.left_sibling"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.left_sibling">[docs]</a>    <span class="k">def</span> <span class="nf">left_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left sibling of this tree, or None if it has none.&quot;&quot;&quot;</span>
        <span class="n">parent_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">parent_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">parent_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no left sibling</span></div>

<div class="viewcode-block" id="ParentedTree.right_sibling"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.right_sibling">[docs]</a>    <span class="k">def</span> <span class="nf">right_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The right sibling of this tree, or None if it has none.&quot;&quot;&quot;</span>
        <span class="n">parent_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent_index</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">parent_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">parent_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no right sibling</span></div>

<div class="viewcode-block" id="ParentedTree.root"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.root">[docs]</a>    <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The root of this tree.  I.e., the unique ancestor of this tree</span>
<span class="sd">        whose parent is None.  If ``ptree.parent()`` is None, then</span>
<span class="sd">        ``ptree`` is its own root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">root</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">root</span></div>

<div class="viewcode-block" id="ParentedTree.treeposition"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.ParentedTree.treeposition">[docs]</a>    <span class="k">def</span> <span class="nf">treeposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The tree position of this tree, relative to the root of the</span>
<span class="sd">        tree.  I.e., ``ptree.root[ptree.treeposition] is ptree``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">treeposition</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_index</span><span class="p">(),)</span></div>

    <span class="c1"># /////////////////////////////////////////////////////////////////</span>
    <span class="c1"># Parent Management</span>
    <span class="c1"># /////////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c1"># Sanity checks</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">child</span>
        <span class="k">assert</span> <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">self</span>

        <span class="c1"># Delete child&#39;s parent pointer.</span>
        <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_setparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># If the child&#39;s type is incorrect, then complain.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can not insert a non-ParentedTree into a ParentedTree&quot;</span><span class="p">)</span>

        <span class="c1"># If child already has a parent, then complain.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;_parent&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can not insert a subtree that already has a parent.&quot;</span><span class="p">)</span>

        <span class="c1"># Set child&#39;s parent pointer &amp; index.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MultiParentedTree"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree">[docs]</a><span class="k">class</span> <span class="nc">MultiParentedTree</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``Tree`` that automatically maintains parent pointers for</span>
<span class="sd">    multi-parented trees.  The following are methods for querying the</span>
<span class="sd">    structure of a multi-parented tree: ``parents()``, ``parent_indices()``,</span>
<span class="sd">    ``left_siblings()``, ``right_siblings()``, ``roots``, ``treepositions``.</span>

<span class="sd">    Each ``MultiParentedTree`` may have zero or more parents.  In</span>
<span class="sd">    particular, subtrees may be shared.  If a single</span>
<span class="sd">    ``MultiParentedTree`` is used as multiple children of the same</span>
<span class="sd">    parent, then that parent will appear multiple times in its</span>
<span class="sd">    ``parents()`` method.</span>

<span class="sd">    ``MultiParentedTrees`` should never be used in the same tree as</span>
<span class="sd">    ``Trees`` or ``ParentedTrees``.  Mixing tree implementations may</span>
<span class="sd">    result in incorrect parent pointers and in ``TypeError`` exceptions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MultiParentedTree.__init__"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;A list of this tree&#39;s parents.  This list should not</span>
<span class="sd">           contain duplicates, even if a parent contains this tree</span>
<span class="sd">           multiple times.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If children is None, the tree is read from node.</span>
            <span class="c1"># After parsing, the parent(s) of the immediate children</span>
            <span class="c1"># will point to an intermediate tree, not self.</span>
            <span class="c1"># We fix this by brute force:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">nltk.tree.immutable</span> <span class="kn">import</span> <span class="n">ImmutableMultiParentedTree</span>

        <span class="k">return</span> <span class="n">ImmutableMultiParentedTree</span>

    <span class="c1"># /////////////////////////////////////////////////////////////////</span>
    <span class="c1"># Methods</span>
    <span class="c1"># /////////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="MultiParentedTree.parents"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree.parents">[docs]</a>    <span class="k">def</span> <span class="nf">parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The set of parents of this tree.  If this tree has no parents,</span>
<span class="sd">        then ``parents`` is the empty set.  To check if a tree is used</span>
<span class="sd">        as multiple children of the same parent, use the</span>
<span class="sd">        ``parent_indices()`` method.</span>

<span class="sd">        :type: list(MultiParentedTree)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">)</span></div>

<div class="viewcode-block" id="MultiParentedTree.left_siblings"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree.left_siblings">[docs]</a>    <span class="k">def</span> <span class="nf">left_siblings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of all left siblings of this tree, in any of its parent</span>
<span class="sd">        trees.  A tree may be its own left sibling if it is used as</span>
<span class="sd">        multiple contiguous children of the same parent.  A tree may</span>
<span class="sd">        appear multiple times in this list if it is the left sibling</span>
<span class="sd">        of this tree with respect to multiple parents.</span>

<span class="sd">        :type: list(MultiParentedTree)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_indices</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="MultiParentedTree.right_siblings"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree.right_siblings">[docs]</a>    <span class="k">def</span> <span class="nf">right_siblings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of all right siblings of this tree, in any of its parent</span>
<span class="sd">        trees.  A tree may be its own right sibling if it is used as</span>
<span class="sd">        multiple contiguous children of the same parent.  A tree may</span>
<span class="sd">        appear multiple times in this list if it is the right sibling</span>
<span class="sd">        of this tree with respect to multiple parents.</span>

<span class="sd">        :type: list(MultiParentedTree)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_indices</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_get_parent_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span>
        <span class="p">]</span>

<div class="viewcode-block" id="MultiParentedTree.roots"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree.roots">[docs]</a>    <span class="k">def</span> <span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The set of all roots of this tree.  This set is formed by</span>
<span class="sd">        tracing all possible parent paths until trees with no parents</span>
<span class="sd">        are found.</span>

<span class="sd">        :type: list(MultiParentedTree)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_roots_helper</span><span class="p">({})</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_get_roots_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">_get_roots_helper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="MultiParentedTree.parent_indices"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree.parent_indices">[docs]</a>    <span class="k">def</span> <span class="nf">parent_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the indices where this tree occurs as a child</span>
<span class="sd">        of ``parent``.  If this child does not occur as a child of</span>
<span class="sd">        ``parent``, then the empty list is returned.  The following is</span>
<span class="sd">        always true::</span>

<span class="sd">          for parent_index in ptree.parent_indices(parent):</span>
<span class="sd">              parent[parent_index] is ptree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">]</span></div>

<div class="viewcode-block" id="MultiParentedTree.treepositions"><a class="viewcode-back" href="../../../api/nltk.tree.parented.html#nltk.tree.MultiParentedTree.treepositions">[docs]</a>    <span class="k">def</span> <span class="nf">treepositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all tree positions that can be used to reach</span>
<span class="sd">        this multi-parented tree starting from ``root``.  I.e., the</span>
<span class="sd">        following is always true::</span>

<span class="sd">          for treepos in ptree.treepositions(root):</span>
<span class="sd">              root[treepos] is ptree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">treepos</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span><span class="p">,)</span>
                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span>
                <span class="k">for</span> <span class="n">treepos</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span>
            <span class="p">]</span></div>

    <span class="c1"># /////////////////////////////////////////////////////////////////</span>
    <span class="c1"># Parent Management</span>
    <span class="c1"># /////////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="c1"># Sanity checks</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">MultiParentedTree</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">child</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_parents</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="c1"># If the only copy of child in self is at index, then delete</span>
        <span class="c1"># self from child&#39;s parent list.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">child</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># If the child&#39;s type is incorrect, then complain.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">MultiParentedTree</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Can not insert a non-MultiParentedTree into a MultiParentedTree&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Add self as a parent pointer if it&#39;s not already listed.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;ParentedTree&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MultiParentedTree&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>