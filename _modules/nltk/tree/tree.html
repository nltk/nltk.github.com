<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.tree.tree</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.tree.tree</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Text Trees</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1">#         Peter Ljungl√∂f &lt;peter.ljunglof@gu.se&gt;</span>
<span class="c1">#         Nathan Bodenstab &lt;bodenstab@cslu.ogi.edu&gt; (tree transforms)</span>
<span class="c1">#         Eric Kafe &lt;kafe.eric@gmail.com&gt; (Tree.fromlist())</span>
<span class="c1">#         Mohaned mashaly&lt;mohaned.mashaly12@gmail.com&gt; (Deprecating methods)</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class for representing hierarchical language structures, such as</span>
<span class="sd">syntax trees and morphological trees.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">Nonterminal</span><span class="p">,</span> <span class="n">Production</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">deprecated</span>

<span class="c1">######################################################################</span>
<span class="c1">## Trees</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="Tree"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree">[docs]</a><span class="k">class</span> <span class="nc">Tree</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Tree represents a hierarchical grouping of leaves and subtrees.</span>
<span class="sd">    For example, each constituent in a syntax tree is represented by a single Tree.</span>

<span class="sd">    A tree&#39;s children are encoded as a list of leaves and subtrees,</span>
<span class="sd">    where a leaf is a basic (non-tree) value; and a subtree is a</span>
<span class="sd">    nested Tree.</span>

<span class="sd">        &gt;&gt;&gt; from nltk.tree import Tree</span>
<span class="sd">        &gt;&gt;&gt; print(Tree(1, [2, Tree(3, [4]), 5]))</span>
<span class="sd">        (1 2 (3 4) 5)</span>
<span class="sd">        &gt;&gt;&gt; vp = Tree(&#39;VP&#39;, [Tree(&#39;V&#39;, [&#39;saw&#39;]),</span>
<span class="sd">        ...                  Tree(&#39;NP&#39;, [&#39;him&#39;])])</span>
<span class="sd">        &gt;&gt;&gt; s = Tree(&#39;S&#39;, [Tree(&#39;NP&#39;, [&#39;I&#39;]), vp])</span>
<span class="sd">        &gt;&gt;&gt; print(s)</span>
<span class="sd">        (S (NP I) (VP (V saw) (NP him)))</span>
<span class="sd">        &gt;&gt;&gt; print(s[1])</span>
<span class="sd">        (VP (V saw) (NP him))</span>
<span class="sd">        &gt;&gt;&gt; print(s[1,1])</span>
<span class="sd">        (NP him)</span>
<span class="sd">        &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP I) (VP (V saw) (NP him)))&quot;)</span>
<span class="sd">        &gt;&gt;&gt; s == t</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; t[1][1].set_label(&#39;X&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t[1][1].label()</span>
<span class="sd">        &#39;X&#39;</span>
<span class="sd">        &gt;&gt;&gt; print(t)</span>
<span class="sd">        (S (NP I) (VP (V saw) (X him)))</span>
<span class="sd">        &gt;&gt;&gt; t[0], t[1,1] = t[1,1], t[0]</span>
<span class="sd">        &gt;&gt;&gt; print(t)</span>
<span class="sd">        (S (X him) (VP (V saw) (NP I)))</span>

<span class="sd">    The length of a tree is the number of children it has.</span>

<span class="sd">        &gt;&gt;&gt; len(t)</span>
<span class="sd">        2</span>

<span class="sd">    The set_label() and label() methods allow individual constituents</span>
<span class="sd">    to be labeled.  For example, syntax trees use this label to specify</span>
<span class="sd">    phrase tags, such as &quot;NP&quot; and &quot;VP&quot;.</span>

<span class="sd">    Several Tree methods use &quot;tree positions&quot; to specify</span>
<span class="sd">    children or descendants of a tree.  Tree positions are defined as</span>
<span class="sd">    follows:</span>

<span class="sd">      - The tree position *i* specifies a Tree&#39;s *i*\ th child.</span>
<span class="sd">      - The tree position ``()`` specifies the Tree itself.</span>
<span class="sd">      - If *p* is the tree position of descendant *d*, then</span>
<span class="sd">        *p+i* specifies the *i*\ th child of *d*.</span>

<span class="sd">    I.e., every tree position is either a single index *i*,</span>
<span class="sd">    specifying ``tree[i]``; or a sequence *i1, i2, ..., iN*,</span>
<span class="sd">    specifying ``tree[i1][i2]...[iN]``.</span>

<span class="sd">    Construct a new tree.  This constructor can be called in one</span>
<span class="sd">    of two ways:</span>

<span class="sd">    - ``Tree(label, children)`` constructs a new tree with the</span>
<span class="sd">        specified label and list of children.</span>

<span class="sd">    - ``Tree.fromstring(s)`` constructs a new tree by parsing the string ``s``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Tree.__init__"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Expected a node value and child list &quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">() argument 2 should be a list, not a &quot;</span>
                <span class="s2">&quot;string&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">node</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Comparison operators</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="c1"># raise_unorderable_types(&quot;&lt;&quot;, self, other)</span>
            <span class="c1"># Sometimes children can be pure strings,</span>
            <span class="c1"># so we need to be able to compare with non-trees:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="c1"># @total_ordering doesn&#39;t work here, since the class inherits from a builtin class</span>
    <span class="fm">__ne__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
    <span class="fm">__gt__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>
    <span class="fm">__le__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span> <span class="ow">or</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>
    <span class="fm">__ge__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">&lt;</span> <span class="n">other</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Disabled list operations</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Tree does not support multiplication&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Tree does not support multiplication&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Tree does not support addition&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Tree does not support addition&quot;</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Indexing (with support for tree positions)</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> indices must be integers, not </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The tree position () may not be &quot;</span> <span class="s2">&quot;assigned to.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> indices must be integers, not </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;The tree position () may not be deleted.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> indices must be integers, not </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Basic tree operations</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use label() instead&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_get_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Outdated method to access the node value; use the label() method instead.&quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use set_label() instead&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_set_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Outdated method to set the node value; use the set_label() method instead.&quot;&quot;&quot;</span>

    <span class="n">node</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_node</span><span class="p">,</span> <span class="n">_set_node</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.label"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.label">[docs]</a>    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the node label of the tree.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&#39;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&#39;)</span>
<span class="sd">            &gt;&gt;&gt; t.label()</span>
<span class="sd">            &#39;S&#39;</span>

<span class="sd">        :return: the node label (typically a string)</span>
<span class="sd">        :rtype: any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span></div>

<div class="viewcode-block" id="Tree.set_label"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.set_label">[docs]</a>    <span class="k">def</span> <span class="nf">set_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the node label of the tree.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; t.set_label(&quot;T&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            (T (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))</span>

<span class="sd">        :param label: the node label (typically a string)</span>
<span class="sd">        :type label: any</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">label</span></div>

<div class="viewcode-block" id="Tree.leaves"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.leaves">[docs]</a>    <span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the leaves of the tree.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; t.leaves()</span>
<span class="sd">            [&#39;the&#39;, &#39;dog&#39;, &#39;chased&#39;, &#39;the&#39;, &#39;cat&#39;]</span>

<span class="sd">        :return: a list containing this tree&#39;s leaves.</span>
<span class="sd">            The order reflects the order of the</span>
<span class="sd">            leaves in the tree&#39;s hierarchical structure.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">leaves</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">leaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">leaves</span></div>

<div class="viewcode-block" id="Tree.flatten"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a flat version of the tree, with all non-root non-terminals removed.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; print(t.flatten())</span>
<span class="sd">            (S the dog chased the cat)</span>

<span class="sd">        :return: a tree consisting of this tree&#39;s root connected directly to</span>
<span class="sd">            its leaves, omitting all intervening non-terminal nodes.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span></div>

<div class="viewcode-block" id="Tree.height"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.height">[docs]</a>    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the height of the tree.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; t.height()</span>
<span class="sd">            5</span>
<span class="sd">            &gt;&gt;&gt; print(t[0,0])</span>
<span class="sd">            (D the)</span>
<span class="sd">            &gt;&gt;&gt; t[0,0].height()</span>
<span class="sd">            2</span>

<span class="sd">        :return: The height of this tree.  The height of a tree</span>
<span class="sd">            containing no children is 1; the height of a tree</span>
<span class="sd">            containing only leaves is 2; and the height of any other</span>
<span class="sd">            tree is one plus the maximum of its children&#39;s</span>
<span class="sd">            heights.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_child_height</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">max_child_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_child_height</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">height</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_child_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_child_height</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max_child_height</span></div>

<div class="viewcode-block" id="Tree.treepositions"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.treepositions">[docs]</a>    <span class="k">def</span> <span class="nf">treepositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;preorder&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; t.treepositions() # doctest: +ELLIPSIS</span>
<span class="sd">            [(), (0,), (0, 0), (0, 0, 0), (0, 1), (0, 1, 0), (1,), (1, 0), (1, 0, 0), ...]</span>
<span class="sd">            &gt;&gt;&gt; for pos in t.treepositions(&#39;leaves&#39;):</span>
<span class="sd">            ...     t[pos] = t[pos][::-1].upper()</span>
<span class="sd">            &gt;&gt;&gt; print(t)</span>
<span class="sd">            (S (NP (D EHT) (N GOD)) (VP (V DESAHC) (NP (D EHT) (N TAC))))</span>

<span class="sd">        :param order: One of: ``preorder``, ``postorder``, ``bothorder``,</span>
<span class="sd">            ``leaves``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;preorder&quot;</span><span class="p">,</span> <span class="s2">&quot;bothorder&quot;</span><span class="p">):</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">childpos</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
                <span class="n">positions</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">childpos</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;postorder&quot;</span><span class="p">,</span> <span class="s2">&quot;bothorder&quot;</span><span class="p">):</span>
            <span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
        <span class="k">return</span> <span class="n">positions</span></div>

<div class="viewcode-block" id="Tree.subtrees"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.subtrees">[docs]</a>    <span class="k">def</span> <span class="nf">subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate all the subtrees of this tree, optionally restricted</span>
<span class="sd">        to trees matching the filter function.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; for s in t.subtrees(lambda t: t.height() == 2):</span>
<span class="sd">            ...     print(s)</span>
<span class="sd">            (D the)</span>
<span class="sd">            (N dog)</span>
<span class="sd">            (V chased)</span>
<span class="sd">            (D the)</span>
<span class="sd">            (N cat)</span>

<span class="sd">        :type filter: function</span>
<span class="sd">        :param filter: the function to filter all local trees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">filter</span> <span class="ow">or</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="k">yield from</span> <span class="n">child</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="nb">filter</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.productions"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.productions">[docs]</a>    <span class="k">def</span> <span class="nf">productions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the productions that correspond to the non-terminal nodes of the tree.</span>
<span class="sd">        For each subtree of the form (P: C1 C2 ... Cn) this produces a production of the</span>
<span class="sd">        form P -&gt; C1 C2 ... Cn.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; t.productions() # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            [S -&gt; NP VP, NP -&gt; D N, D -&gt; &#39;the&#39;, N -&gt; &#39;dog&#39;, VP -&gt; V NP, V -&gt; &#39;chased&#39;,</span>
<span class="sd">            NP -&gt; D N, D -&gt; &#39;the&#39;, N -&gt; &#39;cat&#39;]</span>

<span class="sd">        :rtype: list(Production)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Productions can only be generated from trees having node labels that are strings&quot;</span>
            <span class="p">)</span>

        <span class="n">prods</span> <span class="o">=</span> <span class="p">[</span><span class="n">Production</span><span class="p">(</span><span class="n">Nonterminal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">),</span> <span class="n">_child_names</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">prods</span> <span class="o">+=</span> <span class="n">child</span><span class="o">.</span><span class="n">productions</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">prods</span></div>

<div class="viewcode-block" id="Tree.pos"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.pos">[docs]</a>    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a sequence of pos-tagged words extracted from the tree.</span>

<span class="sd">            &gt;&gt;&gt; t = Tree.fromstring(&quot;(S (NP (D the) (N dog)) (VP (V chased) (NP (D the) (N cat))))&quot;)</span>
<span class="sd">            &gt;&gt;&gt; t.pos()</span>
<span class="sd">            [(&#39;the&#39;, &#39;D&#39;), (&#39;dog&#39;, &#39;N&#39;), (&#39;chased&#39;, &#39;V&#39;), (&#39;the&#39;, &#39;D&#39;), (&#39;cat&#39;, &#39;N&#39;)]</span>

<span class="sd">        :return: a list of tuples containing leaves and pre-terminals (part-of-speech tags).</span>
<span class="sd">            The order reflects the order of the leaves in the tree&#39;s hierarchical structure.</span>
<span class="sd">        :rtype: list(tuple)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">pos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">pos</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos</span></div>

<div class="viewcode-block" id="Tree.leaf_treeposition"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.leaf_treeposition">[docs]</a>    <span class="k">def</span> <span class="nf">leaf_treeposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The tree position of the ``index``-th leaf in this</span>
<span class="sd">            tree.  I.e., if ``tp=self.leaf_treeposition(i)``, then</span>
<span class="sd">            ``self[tp]==self.leaves()[i]``.</span>

<span class="sd">        :raise IndexError: If this tree contains fewer than ``index+1``</span>
<span class="sd">            leaves, or if ``index&lt;0``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index must be non-negative&quot;</span><span class="p">)</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="p">())]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">value</span><span class="p">,</span> <span class="n">treepos</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">treepos</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">treepos</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>

        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;index must be less than or equal to len(self)&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.treeposition_spanning_leaves"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.treeposition_spanning_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">treeposition_spanning_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The tree position of the lowest descendant of this</span>
<span class="sd">            tree that dominates ``self.leaves()[start:end]``.</span>
<span class="sd">        :raise ValueError: if ``end &lt;= start``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;end must be greater than start&quot;</span><span class="p">)</span>
        <span class="c1"># Find the tree positions of the start &amp; end leaves, and</span>
        <span class="c1"># take the longest common subsequence.</span>
        <span class="n">start_treepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_treeposition</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">end_treepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_treeposition</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Find the first index where they mismatch:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_treepos</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_treepos</span><span class="p">)</span> <span class="ow">or</span> <span class="n">start_treepos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end_treepos</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">start_treepos</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">start_treepos</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Transforms</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Tree.chomsky_normal_form"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.chomsky_normal_form">[docs]</a>    <span class="k">def</span> <span class="nf">chomsky_normal_form</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">factor</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="n">horzMarkov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vertMarkov</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">childChar</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span>
        <span class="n">parentChar</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method can modify a tree in three ways:</span>

<span class="sd">          1. Convert a tree into its Chomsky Normal Form (CNF)</span>
<span class="sd">             equivalent -- Every subtree has either two non-terminals</span>
<span class="sd">             or one terminal as its children.  This process requires</span>
<span class="sd">             the creation of more&quot;artificial&quot; non-terminal nodes.</span>
<span class="sd">          2. Markov (vertical) smoothing of children in new artificial</span>
<span class="sd">             nodes</span>
<span class="sd">          3. Horizontal (parent) annotation of nodes</span>

<span class="sd">        :param factor: Right or left factoring method (default = &quot;right&quot;)</span>
<span class="sd">        :type  factor: str = [left|right]</span>
<span class="sd">        :param horzMarkov: Markov order for sibling smoothing in artificial nodes (None (default) = include all siblings)</span>
<span class="sd">        :type  horzMarkov: int | None</span>
<span class="sd">        :param vertMarkov: Markov order for parent smoothing (0 (default) = no vertical annotation)</span>
<span class="sd">        :type  vertMarkov: int | None</span>
<span class="sd">        :param childChar: A string used in construction of the artificial nodes, separating the head of the</span>
<span class="sd">                          original subtree from the child nodes that have yet to be expanded (default = &quot;|&quot;)</span>
<span class="sd">        :type  childChar: str</span>
<span class="sd">        :param parentChar: A string used to separate the node representation from its vertical annotation</span>
<span class="sd">        :type  parentChar: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.tree.transforms</span> <span class="kn">import</span> <span class="n">chomsky_normal_form</span>

        <span class="n">chomsky_normal_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">horzMarkov</span><span class="p">,</span> <span class="n">vertMarkov</span><span class="p">,</span> <span class="n">childChar</span><span class="p">,</span> <span class="n">parentChar</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.un_chomsky_normal_form"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.un_chomsky_normal_form">[docs]</a>    <span class="k">def</span> <span class="nf">un_chomsky_normal_form</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expandUnary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">childChar</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span> <span class="n">parentChar</span><span class="o">=</span><span class="s2">&quot;^&quot;</span><span class="p">,</span> <span class="n">unaryChar</span><span class="o">=</span><span class="s2">&quot;+&quot;</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method modifies the tree in three ways:</span>

<span class="sd">          1. Transforms a tree in Chomsky Normal Form back to its</span>
<span class="sd">             original structure (branching greater than two)</span>
<span class="sd">          2. Removes any parent annotation (if it exists)</span>
<span class="sd">          3. (optional) expands unary subtrees (if previously</span>
<span class="sd">             collapsed with collapseUnary(...) )</span>

<span class="sd">        :param expandUnary: Flag to expand unary or not (default = True)</span>
<span class="sd">        :type  expandUnary: bool</span>
<span class="sd">        :param childChar: A string separating the head node from its children in an artificial node (default = &quot;|&quot;)</span>
<span class="sd">        :type  childChar: str</span>
<span class="sd">        :param parentChar: A string separating the node label from its parent annotation (default = &quot;^&quot;)</span>
<span class="sd">        :type  parentChar: str</span>
<span class="sd">        :param unaryChar: A string joining two non-terminals in a unary production (default = &quot;+&quot;)</span>
<span class="sd">        :type  unaryChar: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.tree.transforms</span> <span class="kn">import</span> <span class="n">un_chomsky_normal_form</span>

        <span class="n">un_chomsky_normal_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expandUnary</span><span class="p">,</span> <span class="n">childChar</span><span class="p">,</span> <span class="n">parentChar</span><span class="p">,</span> <span class="n">unaryChar</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.collapse_unary"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.collapse_unary">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapsePOS</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">collapseRoot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">joinChar</span><span class="o">=</span><span class="s2">&quot;+&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collapse subtrees with a single child (ie. unary productions)</span>
<span class="sd">        into a new non-terminal (Tree node) joined by &#39;joinChar&#39;.</span>
<span class="sd">        This is useful when working with algorithms that do not allow</span>
<span class="sd">        unary productions, and completely removing the unary productions</span>
<span class="sd">        would require loss of useful information.  The Tree is modified</span>
<span class="sd">        directly (since it is passed by reference) and no value is returned.</span>

<span class="sd">        :param collapsePOS: &#39;False&#39; (default) will not collapse the parent of leaf nodes (ie.</span>
<span class="sd">                            Part-of-Speech tags) since they are always unary productions</span>
<span class="sd">        :type  collapsePOS: bool</span>
<span class="sd">        :param collapseRoot: &#39;False&#39; (default) will not modify the root production</span>
<span class="sd">                             if it is unary.  For the Penn WSJ treebank corpus, this corresponds</span>
<span class="sd">                             to the TOP -&gt; productions.</span>
<span class="sd">        :type collapseRoot: bool</span>
<span class="sd">        :param joinChar: A string used to connect collapsed node values (default = &quot;+&quot;)</span>
<span class="sd">        :type  joinChar: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.tree.transforms</span> <span class="kn">import</span> <span class="n">collapse_unary</span>

        <span class="n">collapse_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collapsePOS</span><span class="p">,</span> <span class="n">collapseRoot</span><span class="p">,</span> <span class="n">joinChar</span><span class="p">)</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Convert, copy</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Tree.convert"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.convert">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a tree between different subtypes of Tree.  ``cls`` determines</span>
<span class="sd">        which class will be used to encode the new tree.</span>

<span class="sd">        :type tree: Tree</span>
<span class="sd">        :param tree: The tree that should be converted.</span>
<span class="sd">        :return: The new Tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tree</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.copy"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">deep</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">nltk.tree.immutable</span> <span class="kn">import</span> <span class="n">ImmutableTree</span>

        <span class="k">return</span> <span class="n">ImmutableTree</span>

<div class="viewcode-block" id="Tree.freeze"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.freeze">[docs]</a>    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf_freezer</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">frozen_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen_class</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">leaf_freezer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">newcopy</span> <span class="o">=</span> <span class="n">frozen_class</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newcopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">newcopy</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s2">&quot;leaves&quot;</span><span class="p">):</span>
                <span class="n">newcopy</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_freezer</span><span class="p">(</span><span class="n">newcopy</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">newcopy</span> <span class="o">=</span> <span class="n">frozen_class</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">newcopy</span><span class="p">)</span>
        <span class="nb">hash</span><span class="p">(</span><span class="n">newcopy</span><span class="p">)</span>  <span class="c1"># Make sure the leaves are hashable.</span>
        <span class="k">return</span> <span class="n">newcopy</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Parsing</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Tree.fromstring"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.fromstring">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">s</span><span class="p">,</span>
        <span class="n">brackets</span><span class="o">=</span><span class="s2">&quot;()&quot;</span><span class="p">,</span>
        <span class="n">read_node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_leaf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">leaf_pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">remove_empty_top_bracketing</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a bracketed tree string and return the resulting tree.</span>
<span class="sd">        Trees are represented as nested brackettings, such as::</span>

<span class="sd">          (S (NP (NNP John)) (VP (V runs)))</span>

<span class="sd">        :type s: str</span>
<span class="sd">        :param s: The string to read</span>

<span class="sd">        :type brackets: str (length=2)</span>
<span class="sd">        :param brackets: The bracket characters used to mark the</span>
<span class="sd">            beginning and end of trees and subtrees.</span>

<span class="sd">        :type read_node: function</span>
<span class="sd">        :type read_leaf: function</span>
<span class="sd">        :param read_node, read_leaf: If specified, these functions</span>
<span class="sd">            are applied to the substrings of ``s`` corresponding to</span>
<span class="sd">            nodes and leaves (respectively) to obtain the values for</span>
<span class="sd">            those nodes and leaves.  They should have the following</span>
<span class="sd">            signature:</span>

<span class="sd">               read_node(str) -&gt; value</span>

<span class="sd">            For example, these functions could be used to process nodes</span>
<span class="sd">            and leaves whose values should be some type other than</span>
<span class="sd">            string (such as ``FeatStruct``).</span>
<span class="sd">            Note that by default, node strings and leaf strings are</span>
<span class="sd">            delimited by whitespace and brackets; to override this</span>
<span class="sd">            default, use the ``node_pattern`` and ``leaf_pattern``</span>
<span class="sd">            arguments.</span>

<span class="sd">        :type node_pattern: str</span>
<span class="sd">        :type leaf_pattern: str</span>
<span class="sd">        :param node_pattern, leaf_pattern: Regular expression patterns</span>
<span class="sd">            used to find node and leaf substrings in ``s``.  By</span>
<span class="sd">            default, both nodes patterns are defined to match any</span>
<span class="sd">            sequence of non-whitespace non-bracket characters.</span>

<span class="sd">        :type remove_empty_top_bracketing: bool</span>
<span class="sd">        :param remove_empty_top_bracketing: If the resulting tree has</span>
<span class="sd">            an empty node label, and is length one, then return its</span>
<span class="sd">            single child instead.  This is useful for treebank trees,</span>
<span class="sd">            which sometimes contain an extra level of bracketing.</span>

<span class="sd">        :return: A tree corresponding to the string representation ``s``.</span>
<span class="sd">            If this class method is called using a subclass of Tree,</span>
<span class="sd">            then it will return a tree of that type.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">brackets</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;brackets must be a length-2 string&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s&quot;</span><span class="p">,</span> <span class="n">brackets</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;whitespace brackets not allowed&quot;</span><span class="p">)</span>
        <span class="c1"># Construct a regexp that will tokenize the string.</span>
        <span class="n">open_b</span><span class="p">,</span> <span class="n">close_b</span> <span class="o">=</span> <span class="n">brackets</span>
        <span class="n">open_pattern</span><span class="p">,</span> <span class="n">close_pattern</span> <span class="o">=</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">open_b</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">close_b</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node_pattern</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_pattern</span> <span class="o">=</span> <span class="sa">rf</span><span class="s2">&quot;[^\s</span><span class="si">{</span><span class="n">open_pattern</span><span class="si">}{</span><span class="n">close_pattern</span><span class="si">}</span><span class="s2">]+&quot;</span>
        <span class="k">if</span> <span class="n">leaf_pattern</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">leaf_pattern</span> <span class="o">=</span> <span class="sa">rf</span><span class="s2">&quot;[^\s</span><span class="si">{</span><span class="n">open_pattern</span><span class="si">}{</span><span class="n">close_pattern</span><span class="si">}</span><span class="s2">]+&quot;</span>
        <span class="n">token_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">\s*(</span><span class="si">%s</span><span class="s2">)?|</span><span class="si">%s</span><span class="s2">|(</span><span class="si">%s</span><span class="s2">)&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">open_pattern</span><span class="p">,</span> <span class="n">node_pattern</span><span class="p">,</span> <span class="n">close_pattern</span><span class="p">,</span> <span class="n">leaf_pattern</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Walk through each token, updating a stack of trees.</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="p">[])]</span>  <span class="c1"># list of (node, children) tuples</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">token_re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="n">token</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="c1"># Beginning of a tree/subtree</span>
            <span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">open_b</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s2">&quot;end-of-string&quot;</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">read_node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">read_node</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="c1"># End of a tree/subtree</span>
            <span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="n">close_b</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s2">&quot;end-of-string&quot;</span><span class="p">)</span>
                <span class="n">label</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
            <span class="c1"># Leaf node</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">read_leaf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">token</span> <span class="o">=</span> <span class="n">read_leaf</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
                <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>

        <span class="c1"># check that we got exactly one complete tree.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;end-of-string&quot;</span><span class="p">,</span> <span class="n">close_b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;end-of-string&quot;</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># If the tree has an extra level with node=&#39;&#39;, then get rid of</span>
        <span class="c1"># it.  E.g.: &quot;((S (NP ...) (VP ...)))&quot;</span>
        <span class="k">if</span> <span class="n">remove_empty_top_bracketing</span> <span class="ow">and</span> <span class="n">tree</span><span class="o">.</span><span class="n">_label</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># return the tree.</span>
        <span class="k">return</span> <span class="n">tree</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_error</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">expecting</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a friendly error message when parsing a tree string fails.</span>
<span class="sd">        :param s: The string we&#39;re parsing.</span>
<span class="sd">        :param match: regexp match of the problem token.</span>
<span class="sd">        :param expecting: what we expected to see instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Construct a basic error message</span>
        <span class="k">if</span> <span class="n">match</span> <span class="o">==</span> <span class="s2">&quot;end-of-string&quot;</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">token</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;end-of-string&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span><span class="p">,</span> <span class="n">token</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.read(): expected </span><span class="si">%r</span><span class="s2"> but got </span><span class="si">%r</span><span class="se">\n</span><span class="si">%s</span><span class="s2">at index </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">expecting</span><span class="p">,</span>
            <span class="n">token</span><span class="p">,</span>
            <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">12</span><span class="p">,</span>
            <span class="n">pos</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Add a display showing the error token itsels:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;...&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">10</span> <span class="p">:]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="mi">13</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&quot;</span><span class="si">{}</span><span class="s1">&quot;</span><span class="se">\n</span><span class="si">{}</span><span class="s1">^&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.fromlist"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.fromlist">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromlist</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :type l: list</span>
<span class="sd">        :param l: a tree represented as nested lists</span>

<span class="sd">        :return: A tree corresponding to the list representation ``l``.</span>
<span class="sd">        :rtype: Tree</span>

<span class="sd">        Convert nested lists to a NLTK Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Tree</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">fromlist</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">label</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Visualization &amp; String Representation</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Tree.draw"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Open a new window containing a graphical diagram of this tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.draw.tree</span> <span class="kn">import</span> <span class="n">draw_trees</span>

        <span class="n">draw_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.pretty_print"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.pretty_print">[docs]</a>    <span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">highlight</span><span class="o">=</span><span class="p">(),</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty-print this tree as ASCII or Unicode art.</span>
<span class="sd">        For explanation of the arguments, see the documentation for</span>
<span class="sd">        `nltk.tree.prettyprinter.TreePrettyPrinter`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.tree.prettyprinter</span> <span class="kn">import</span> <span class="n">TreePrettyPrinter</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">TreePrettyPrinter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sentence</span><span class="p">,</span> <span class="n">highlight</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">childstr</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">, [</span><span class="si">{}</span><span class="s2">])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">),</span>
            <span class="n">childstr</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_svg_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">svgling</span> <span class="kn">import</span> <span class="n">draw_tree</span>

        <span class="k">return</span> <span class="n">draw_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_repr_svg_</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pformat</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.pprint"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.pprint">[docs]</a>    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print a string representation of this Tree to &#39;stream&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;stream&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;stream&quot;</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;stream&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">file</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span></div>

<div class="viewcode-block" id="Tree.pformat"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.pformat">[docs]</a>    <span class="k">def</span> <span class="nf">pformat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nodesep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">parens</span><span class="o">=</span><span class="s2">&quot;()&quot;</span><span class="p">,</span> <span class="n">quotes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A pretty-printed string representation of this tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        :param margin: The right margin at which to do line-wrapping.</span>
<span class="sd">        :type margin: int</span>
<span class="sd">        :param indent: The indentation level at which printing</span>
<span class="sd">            begins.  This number is used to decide how far to indent</span>
<span class="sd">            subsequent lines.</span>
<span class="sd">        :type indent: int</span>
<span class="sd">        :param nodesep: A string that is used to separate the node</span>
<span class="sd">            from the children.  E.g., the default value ``&#39;:&#39;`` gives</span>
<span class="sd">            trees like ``(S: (NP: I) (VP: (V: saw) (NP: it)))``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Try writing it on one line.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pformat_flat</span><span class="p">(</span><span class="n">nodesep</span><span class="p">,</span> <span class="n">parens</span><span class="p">,</span> <span class="n">quotes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">indent</span> <span class="o">&lt;</span> <span class="n">margin</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="c1"># If it doesn&#39;t fit on one line, then write it on multi-lines.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="si">}{</span><span class="n">nodesep</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">)</span><span class="si">}{</span><span class="n">nodesep</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nodesep</span><span class="p">,</span> <span class="n">parens</span><span class="p">,</span> <span class="n">quotes</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quotes</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">child</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">parens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Tree.pformat_latex_qtree"><a class="viewcode-back" href="../../../api/nltk.tree.Tree.html#nltk.tree.Tree.pformat_latex_qtree">[docs]</a>    <span class="k">def</span> <span class="nf">pformat_latex_qtree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a representation of the tree compatible with the</span>
<span class="sd">        LaTeX qtree package. This consists of the string ``\Tree``</span>
<span class="sd">        followed by the tree represented in bracketed notation.</span>

<span class="sd">        For example, the following result was generated from a parse tree of</span>
<span class="sd">        the sentence ``The announcement astounded us``::</span>

<span class="sd">          \Tree [.I&#39;&#39; [.N&#39;&#39; [.D The ] [.N&#39; [.N announcement ] ] ]</span>
<span class="sd">              [.I&#39; [.V&#39;&#39; [.V&#39; [.V astounded ] [.N&#39;&#39; [.N&#39; [.N us ] ] ] ] ] ] ]</span>

<span class="sd">        See https://www.ling.upenn.edu/advice/latex.html for the LaTeX</span>
<span class="sd">        style file for the qtree package.</span>

<span class="sd">        :return: A latex qtree representation of this tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reserved_chars</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;([#\$%&amp;~_\{\}])&quot;</span><span class="p">)</span>

        <span class="n">pformat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">nodesep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">parens</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;[.&quot;</span><span class="p">,</span> <span class="s2">&quot; ]&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;\Tree &quot;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">reserved_chars</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">\1&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_pformat_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodesep</span><span class="p">,</span> <span class="n">parens</span><span class="p">,</span> <span class="n">quotes</span><span class="p">):</span>
        <span class="n">childstrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_pformat_flat</span><span class="p">(</span><span class="n">nodesep</span><span class="p">,</span> <span class="n">parens</span><span class="p">,</span> <span class="n">quotes</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quotes</span><span class="p">:</span>
                <span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">child</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2"> </span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">parens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span>
                <span class="n">nodesep</span><span class="p">,</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childstrs</span><span class="p">),</span>
                <span class="n">parens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2"> </span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">parens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">),</span>
                <span class="n">nodesep</span><span class="p">,</span>
                <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childstrs</span><span class="p">),</span>
                <span class="n">parens</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_child_names</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Nonterminal</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_label</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">names</span>


<span class="c1">######################################################################</span>
<span class="c1">## Demonstration</span>
<span class="c1">######################################################################</span>


<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration showing how Trees and Trees can be</span>
<span class="sd">    used.  This demonstration creates a Tree, and loads a</span>
<span class="sd">    Tree from the Treebank corpus,</span>
<span class="sd">    and shows the results of calling several of their methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">ProbabilisticTree</span><span class="p">,</span> <span class="n">Tree</span>

    <span class="c1"># Demonstrate tree parsing.</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;(S (NP (DT the) (NN cat)) (VP (VBD ate) (NP (DT a) (NN cookie))))&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Convert bracketed string into tree:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Display tree properties:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>  <span class="c1"># tree&#39;s constituent type</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># tree&#39;s first child</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># tree&#39;s second child</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">height</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Demonstrate tree modification.</span>
    <span class="n">the_cat</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">the_cat</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Tree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s2">&quot;(JJ big)&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Tree modification:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Tree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s2">&quot;(NN cake)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Tree transforms</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Collapse unary:&quot;</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">collapse_unary</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Chomsky normal form:&quot;</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">chomsky_normal_form</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Demonstrate probabilistic trees.</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">ProbabilisticTree</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">],</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Probabilistic Tree:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Demonstrate parsing of treebank output format.</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Tree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">pformat</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Convert tree to bracketed string and back again:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Demonstrate LaTeX output</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LaTeX output:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">pformat_latex_qtree</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Demonstrate Productions</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Production output:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">productions</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Demonstrate tree nodes containing objects other than strings</span>
    <span class="n">t</span><span class="o">.</span><span class="n">set_label</span><span class="p">((</span><span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Tree&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>