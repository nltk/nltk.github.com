<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.tokenize.punkt</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.tokenize.punkt</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Punkt sentence tokenizer</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Algorithm: Kiss &amp; Strunk (2006)</span>
<span class="c1"># Author: Willy &lt;willy@csse.unimelb.edu.au&gt; (original Python port)</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt; (additions)</span>
<span class="c1">#         Edward Loper &lt;edloper@gmail.com&gt; (rewrite)</span>
<span class="c1">#         Joel Nothman &lt;jnothman@student.usyd.edu.au&gt; (almost rewrite)</span>
<span class="c1">#         Arthur Darcet &lt;arthur@darcet.fr&gt; (fixes)</span>
<span class="c1">#         Tom Aarsen &lt;&gt; (tackle ReDoS &amp; performance issues)</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Punkt Sentence Tokenizer</span>

<span class="sd">This tokenizer divides a text into a list of sentences</span>
<span class="sd">by using an unsupervised algorithm to build a model for abbreviation</span>
<span class="sd">words, collocations, and words that start sentences.  It must be</span>
<span class="sd">trained on a large collection of plaintext in the target language</span>
<span class="sd">before it can be used.</span>

<span class="sd">The NLTK data package includes a pre-trained Punkt tokenizer for</span>
<span class="sd">English.</span>

<span class="sd">    &gt;&gt;&gt; import nltk.data</span>
<span class="sd">    &gt;&gt;&gt; text = &#39;&#39;&#39;</span>
<span class="sd">    ... Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="sd">    ... do not mark sentence boundaries.  And sometimes sentences</span>
<span class="sd">    ... can start with non-capitalized words.  i is a good variable</span>
<span class="sd">    ... name.</span>
<span class="sd">    ... &#39;&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; sent_detector = nltk.data.load(&#39;tokenizers/punkt/english.pickle&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;\n-----\n&#39;.join(sent_detector.tokenize(text.strip())))</span>
<span class="sd">    Punkt knows that the periods in Mr. Smith and Johann S. Bach</span>
<span class="sd">    do not mark sentence boundaries.</span>
<span class="sd">    -----</span>
<span class="sd">    And sometimes sentences</span>
<span class="sd">    can start with non-capitalized words.</span>
<span class="sd">    -----</span>
<span class="sd">    i is a good variable</span>
<span class="sd">    name.</span>

<span class="sd">(Note that whitespace from the original text, including newlines, is</span>
<span class="sd">retained in the output.)</span>

<span class="sd">Punctuation following sentences is also included by default</span>
<span class="sd">(from NLTK 3.0 onwards). It can be excluded with the realign_boundaries</span>
<span class="sd">flag.</span>

<span class="sd">    &gt;&gt;&gt; text = &#39;&#39;&#39;</span>
<span class="sd">    ... (How does it deal with this parenthesis?)  &quot;It should be part of the</span>
<span class="sd">    ... previous sentence.&quot; &quot;(And the same with this one.)&quot; (&#39;And this one!&#39;)</span>
<span class="sd">    ... &quot;(&#39;(And (this)) &#39;?)&quot; [(and this. )]</span>
<span class="sd">    ... &#39;&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;\n-----\n&#39;.join(</span>
<span class="sd">    ...     sent_detector.tokenize(text.strip())))</span>
<span class="sd">    (How does it deal with this parenthesis?)</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;It should be part of the</span>
<span class="sd">    previous sentence.&quot;</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;(And the same with this one.)&quot;</span>
<span class="sd">    -----</span>
<span class="sd">    (&#39;And this one!&#39;)</span>
<span class="sd">    -----</span>
<span class="sd">    &quot;(&#39;(And (this)) &#39;?)&quot;</span>
<span class="sd">    -----</span>
<span class="sd">    [(and this. )]</span>
<span class="sd">    &gt;&gt;&gt; print(&#39;\n-----\n&#39;.join(</span>
<span class="sd">    ...     sent_detector.tokenize(text.strip(), realign_boundaries=False)))</span>
<span class="sd">    (How does it deal with this parenthesis?</span>
<span class="sd">    -----</span>
<span class="sd">    )  &quot;It should be part of the</span>
<span class="sd">    previous sentence.</span>
<span class="sd">    -----</span>
<span class="sd">    &quot; &quot;(And the same with this one.</span>
<span class="sd">    -----</span>
<span class="sd">    )&quot; (&#39;And this one!</span>
<span class="sd">    -----</span>
<span class="sd">    &#39;)</span>
<span class="sd">    &quot;(&#39;(And (this)) &#39;?</span>
<span class="sd">    -----</span>
<span class="sd">    )&quot; [(and this.</span>
<span class="sd">    -----</span>
<span class="sd">    )]</span>

<span class="sd">However, Punkt is designed to learn parameters (a list of abbreviations, etc.)</span>
<span class="sd">unsupervised from a corpus similar to the target domain. The pre-packaged models</span>
<span class="sd">may therefore be unsuitable: use ``PunktSentenceTokenizer(text)`` to learn</span>
<span class="sd">parameters from the given text.</span>

<span class="sd">:class:`.PunktTrainer` learns parameters such as a list of abbreviations</span>
<span class="sd">(without supervision) from portions of text. Using a ``PunktTrainer`` directly</span>
<span class="sd">allows for incremental training and modification of the hyper-parameters used</span>
<span class="sd">to decide what is considered an abbreviation, etc.</span>

<span class="sd">The algorithm for this tokenizer is described in::</span>

<span class="sd">  Kiss, Tibor and Strunk, Jan (2006): Unsupervised Multilingual Sentence</span>
<span class="sd">    Boundary Detection.  Computational Linguistics 32: 485-525.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># TODO: Make orthographic heuristic less susceptible to overtraining</span>
<span class="c1"># TODO: Frequent sentence starters optionally exclude always-capitalised words</span>
<span class="c1"># FIXME: Problem with ending string with e.g. &#39;!!!&#39; -&gt; &#39;!! !&#39;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Match</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">FreqDist</span>
<span class="kn">from</span> <span class="nn">nltk.tokenize.api</span> <span class="kn">import</span> <span class="n">TokenizerI</span>

<span class="c1">######################################################################</span>
<span class="c1"># { Orthographic Context Constants</span>
<span class="c1">######################################################################</span>
<span class="c1"># The following constants are used to describe the orthographic</span>
<span class="c1"># contexts in which a word can occur.  BEG=beginning, MID=middle,</span>
<span class="c1"># UNK=unknown, UC=uppercase, LC=lowercase, NC=no case.</span>

<span class="n">_ORTHO_BEG_UC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: beginning of a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MID_UC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: middle of a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UNK_UC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: unknown position in a sentence with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_BEG_LC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: beginning of a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MID_LC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: middle of a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UNK_LC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: unknown position in a sentence with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_UC</span> <span class="o">=</span> <span class="n">_ORTHO_BEG_UC</span> <span class="o">+</span> <span class="n">_ORTHO_MID_UC</span> <span class="o">+</span> <span class="n">_ORTHO_UNK_UC</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: occurs with upper case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_LC</span> <span class="o">=</span> <span class="n">_ORTHO_BEG_LC</span> <span class="o">+</span> <span class="n">_ORTHO_MID_LC</span> <span class="o">+</span> <span class="n">_ORTHO_UNK_LC</span>
<span class="sd">&quot;&quot;&quot;Orthographic context: occurs with lower case.&quot;&quot;&quot;</span>

<span class="n">_ORTHO_MAP</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="s2">&quot;initial&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">):</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;internal&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">):</span> <span class="n">_ORTHO_MID_UC</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;unknown&quot;</span><span class="p">,</span> <span class="s2">&quot;upper&quot;</span><span class="p">):</span> <span class="n">_ORTHO_UNK_UC</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;initial&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;internal&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span> <span class="n">_ORTHO_MID_LC</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;unknown&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">):</span> <span class="n">_ORTHO_UNK_LC</span><span class="p">,</span>
<span class="p">}</span>
<span class="sd">&quot;&quot;&quot;A map from context position and first-letter case to the</span>
<span class="sd">appropriate orthographic context flag.&quot;&quot;&quot;</span>

<span class="c1"># } (end orthographic context constants)</span>
<span class="c1">######################################################################</span>

<span class="c1">######################################################################</span>
<span class="c1"># { Decision reasons for debugging</span>
<span class="c1">######################################################################</span>

<span class="n">REASON_DEFAULT_DECISION</span> <span class="o">=</span> <span class="s2">&quot;default decision&quot;</span>
<span class="n">REASON_KNOWN_COLLOCATION</span> <span class="o">=</span> <span class="s2">&quot;known collocation (both words)&quot;</span>
<span class="n">REASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="s2">&quot;abbreviation + orthographic heuristic&quot;</span>
<span class="n">REASON_ABBR_WITH_SENTENCE_STARTER</span> <span class="o">=</span> <span class="s2">&quot;abbreviation + frequent sentence starter&quot;</span>
<span class="n">REASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="s2">&quot;initial + orthographic heuristic&quot;</span>
<span class="n">REASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="s2">&quot;initial + orthographic heuristic&quot;</span>
<span class="n">REASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;initial + special orthographic heuristic&quot;</span>
<span class="p">)</span>


<span class="c1"># } (end decision reasons for debugging)</span>
<span class="c1">######################################################################</span>

<span class="c1">######################################################################</span>
<span class="c1"># { Language-dependent variables</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="PunktLanguageVars"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktLanguageVars">[docs]</a><span class="k">class</span> <span class="nc">PunktLanguageVars</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores variables, mostly regular expressions, which may be</span>
<span class="sd">    language-dependent for correct application of the algorithm.</span>
<span class="sd">    An extension of this class may modify its properties to suit</span>
<span class="sd">    a language other than English; an instance can then be passed</span>
<span class="sd">    as an argument to PunktSentenceTokenizer and PunktTrainer</span>
<span class="sd">    constructors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_re_period_context&quot;</span><span class="p">,</span> <span class="s2">&quot;_re_word_tokenizer&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># All modifications to the class are performed by inheritance.</span>
        <span class="c1"># Non-default parameters to be pickled must be defined in the inherited</span>
        <span class="c1"># class.</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="n">sent_end_chars</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Characters which are candidates for sentence boundaries&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_re_sent_end_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">))</span>

    <span class="n">internal_punctuation</span> <span class="o">=</span> <span class="s2">&quot;,:;&quot;</span>  <span class="c1"># might want to extend this..</span>
    <span class="sd">&quot;&quot;&quot;sentence internal punctuation, which indicates an abbreviation if</span>
<span class="sd">    preceded by a period-final token.&quot;&quot;&quot;</span>

    <span class="n">re_boundary_realignment</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[&quot;</span><span class="se">\&#39;</span><span class="s1">)\]}]+?(?:\s+|(?=--)|$)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;Used to realign punctuation that should be included in a sentence</span>
<span class="sd">    although it follows the period (or ?, !).&quot;&quot;&quot;</span>

    <span class="n">_re_word_start</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;[^\(</span><span class="se">\&quot;</span><span class="s2">\`{\[:;&amp;\#\*@\)}\]\-,]&quot;</span>
    <span class="sd">&quot;&quot;&quot;Excludes some characters from starting word tokens&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_re_non_word_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;(?:[)</span><span class="se">\&quot;</span><span class="s2">;}\]\*:@\&#39;\({\[</span><span class="si">%s</span><span class="s2">])&quot;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span>
            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;.&quot;</span><span class="p">})</span>
        <span class="p">)</span>

    <span class="sd">&quot;&quot;&quot;Characters that cannot appear within words&quot;&quot;&quot;</span>

    <span class="n">_re_multi_char_punct</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;(?:\-{2,}|\.{2,}|(?:\.\s){2,}\.)&quot;</span>
    <span class="sd">&quot;&quot;&quot;Hyphen and ellipsis are multi-character punctuation&quot;&quot;&quot;</span>

    <span class="n">_word_tokenize_fmt</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;(</span>
<span class="s2">        </span><span class="si">%(MultiChar)s</span><span class="s2"></span>
<span class="s2">        |</span>
<span class="s2">        (?=</span><span class="si">%(WordStart)s</span><span class="s2">)\S+?  # Accept word characters until end is found</span>
<span class="s2">        (?= # Sequences marking a word&#39;s end</span>
<span class="s2">            \s|                                 # White-space</span>
<span class="s2">            $|                                  # End-of-string</span>
<span class="s2">            </span><span class="si">%(NonWord)s</span><span class="s2">|</span><span class="si">%(MultiChar)s</span><span class="s2">|          # Punctuation</span>
<span class="s2">            ,(?=$|\s|</span><span class="si">%(NonWord)s</span><span class="s2">|</span><span class="si">%(MultiChar)s</span><span class="s2">) # Comma if at end of word</span>
<span class="s2">        )</span>
<span class="s2">        |</span>
<span class="s2">        \S</span>
<span class="s2">    )&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;Format of a regular expression to split punctuation from words,</span>
<span class="sd">    excluding period.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_word_tokenizer_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compiles and returns a regular expression for word tokenization&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_word_tokenize_fmt</span>
                <span class="o">%</span> <span class="p">{</span>
                    <span class="s2">&quot;NonWord&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_non_word_chars</span><span class="p">,</span>
                    <span class="s2">&quot;MultiChar&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_multi_char_punct</span><span class="p">,</span>
                    <span class="s2">&quot;WordStart&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_start</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_word_tokenizer</span>

<div class="viewcode-block" id="PunktLanguageVars.word_tokenize"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktLanguageVars.word_tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">word_tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tokenize a string to split off punctuation other than periods&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_word_tokenizer_re</span><span class="p">()</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

    <span class="n">_period_context_fmt</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        </span><span class="si">%(SentEndChars)s</span><span class="s2">             # a potential sentence ending</span>
<span class="s2">        (?=(?P&lt;after_tok&gt;</span>
<span class="s2">            </span><span class="si">%(NonWord)s</span><span class="s2">              # either other punctuation</span>
<span class="s2">            |</span>
<span class="s2">            \s+(?P&lt;next_tok&gt;\S+)     # or whitespace and some other token</span>
<span class="s2">        ))&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;Format of a regular expression to find contexts including possible</span>
<span class="sd">    sentence boundaries. Matches token which the possible sentence boundary</span>
<span class="sd">    ends, and matches the following token within a lookahead expression.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PunktLanguageVars.period_context_re"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktLanguageVars.period_context_re">[docs]</a>    <span class="k">def</span> <span class="nf">period_context_re</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compiles and returns a regular expression to find contexts</span>
<span class="sd">        including possible sentence boundaries.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_period_context_fmt</span>
                <span class="o">%</span> <span class="p">{</span>
                    <span class="s2">&quot;NonWord&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_non_word_chars</span><span class="p">,</span>
                    <span class="s2">&quot;SentEndChars&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_sent_end_chars</span><span class="p">,</span>
                <span class="p">},</span>
                <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_period_context</span></div></div>


<span class="n">_re_non_punct</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^\W\d]&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Matches token types that are not merely punctuation. (Types for</span>
<span class="sd">numeric tokens are changed to ##number## and hence contain alpha.)&quot;&quot;&quot;</span>


<span class="c1"># }</span>
<span class="c1">######################################################################</span>


<span class="c1"># ////////////////////////////////////////////////////////////</span>
<span class="c1"># { Helper Functions</span>
<span class="c1"># ////////////////////////////////////////////////////////////</span>


<span class="k">def</span> <span class="nf">_pair_iter</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yields pairs of tokens from the given iterator such that each input</span>
<span class="sd">    token will appear as the first element in a yielded tuple. The last</span>
<span class="sd">    pair will have None as its second element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">el</span><span class="p">)</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">el</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="c1">######################################################################</span>
<span class="c1"># { Punkt Parameters</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="PunktParameters"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktParameters">[docs]</a><span class="k">class</span> <span class="nc">PunktParameters</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Stores data used to perform sentence boundary detection with Punkt.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PunktParameters.__init__"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktParameters.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word types for known abbreviations.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">collocations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word type tuples for known common collocations</span>
<span class="sd">        where the first word ends in a period.  E.g., (&#39;S.&#39;, &#39;Bach&#39;)</span>
<span class="sd">        is a common collocation in a text that discusses &#39;Johann</span>
<span class="sd">        S. Bach&#39;.  These count as negative evidence for sentence</span>
<span class="sd">        boundaries.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sent_starters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A set of word types for words that often appear at the</span>
<span class="sd">        beginning of sentences.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;A dictionary mapping word types to the set of orthographic</span>
<span class="sd">        contexts that word type appears in.  Contexts are represented</span>
<span class="sd">        by adding orthographic context flags: ...&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="PunktParameters.clear_abbrevs"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktParameters.clear_abbrevs">[docs]</a>    <span class="k">def</span> <span class="nf">clear_abbrevs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></div>

<div class="viewcode-block" id="PunktParameters.clear_collocations"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktParameters.clear_collocations">[docs]</a>    <span class="k">def</span> <span class="nf">clear_collocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collocations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></div>

<div class="viewcode-block" id="PunktParameters.clear_sent_starters"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktParameters.clear_sent_starters">[docs]</a>    <span class="k">def</span> <span class="nf">clear_sent_starters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sent_starters</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span></div>

<div class="viewcode-block" id="PunktParameters.clear_ortho_context"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktParameters.clear_ortho_context">[docs]</a>    <span class="k">def</span> <span class="nf">clear_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktParameters.add_ortho_context"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktParameters.add_ortho_context">[docs]</a>    <span class="k">def</span> <span class="nf">add_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span> <span class="o">|=</span> <span class="n">flag</span></div>

    <span class="k">def</span> <span class="nf">_debug_ortho_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s2">&quot;BEG-UC&quot;</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s2">&quot;MID-UC&quot;</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_UNK_UC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s2">&quot;UNK-UC&quot;</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s2">&quot;BEG-LC&quot;</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_LC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s2">&quot;MID-LC&quot;</span>
        <span class="k">if</span> <span class="n">context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_UNK_LC</span><span class="p">:</span>
            <span class="k">yield</span> <span class="s2">&quot;UNK-LC&quot;</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># { PunktToken</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="PunktToken"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktToken">[docs]</a><span class="k">class</span> <span class="nc">PunktToken</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Stores a token of text with annotations produced during</span>
<span class="sd">    sentence boundary detection.&quot;&quot;&quot;</span>

    <span class="n">_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;parastart&quot;</span><span class="p">,</span> <span class="s2">&quot;linestart&quot;</span><span class="p">,</span> <span class="s2">&quot;sentbreak&quot;</span><span class="p">,</span> <span class="s2">&quot;abbr&quot;</span><span class="p">,</span> <span class="s2">&quot;ellipsis&quot;</span><span class="p">]</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tok&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;period_final&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">_properties</span>

<div class="viewcode-block" id="PunktToken.__init__"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktToken.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_type</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period_final</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">k</span><span class="p">])</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Regular expressions for properties</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Note: [A-Za-z] is approximated by [^\W\d] in the general case.</span>
    <span class="n">_RE_ELLIPSIS</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\.\.+$&quot;</span><span class="p">)</span>
    <span class="n">_RE_NUMERIC</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^-?[\.,]?\d[\d,\.-]*\.?$&quot;</span><span class="p">)</span>
    <span class="n">_RE_INITIAL</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^\W\d]\.$&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
    <span class="n">_RE_ALPHA</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^\W\d]+$&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Derived properties</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_get_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a case-normalized representation of the token.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_NUMERIC</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;##number##&quot;</span><span class="p">,</span> <span class="n">tok</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type_no_period</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type with its final period removed if it has one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type_no_sentperiod</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type with its final period removed if it is marked as a</span>
<span class="sd">        sentence break.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_no_period</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token&#39;s first character is uppercase.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token&#39;s first character is lowercase.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">first_case</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_lower</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;lower&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_upper</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;upper&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;none&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_ellipsis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of an ellipsis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_ELLIPSIS</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of a number.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;##number##&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_initial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is that of an initial.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_INITIAL</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token text is all alphabetic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_RE_ALPHA</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_non_punct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if the token is either a number or is alphabetic.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_re_non_punct</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { String representation</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation of the token that can reproduce it</span>
<span class="sd">        with eval(), which lists all the token&#39;s non-default</span>
<span class="sd">        annotations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">typestr</span> <span class="o">=</span> <span class="s2">&quot; type=</span><span class="si">%s</span><span class="s2">,&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

        <span class="n">propvals</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tok</span><span class="p">),</span>
            <span class="n">typestr</span><span class="p">,</span>
            <span class="n">propvals</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation akin to that used by Kiss and Strunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tok</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abbr</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;&lt;A&gt;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ellipsis</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;&lt;E&gt;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s2">&quot;&lt;S&gt;&quot;</span>
        <span class="k">return</span> <span class="n">res</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># { Punkt base class</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="PunktBaseClass"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktBaseClass">[docs]</a><span class="k">class</span> <span class="nc">PunktBaseClass</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Includes common components of PunktTrainer and PunktSentenceTokenizer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PunktBaseClass.__init__"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktBaseClass.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lang_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lang_vars</span> <span class="o">=</span> <span class="n">PunktLanguageVars</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">PunktParameters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span> <span class="o">=</span> <span class="n">lang_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span> <span class="o">=</span> <span class="n">token_cls</span>
        <span class="sd">&quot;&quot;&quot;The collection of parameters that determines the behavior</span>
<span class="sd">        of the punkt tokenizer.&quot;&quot;&quot;</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Word tokenization</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_tokenize_words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plaintext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide the given text into tokens, using the punkt word</span>
<span class="sd">        segmentation regular expression, and generate the resulting list</span>
<span class="sd">        of tokens augmented as three-tuples with two boolean values for whether</span>
<span class="sd">        the given token occurs at the start of a paragraph or a new line,</span>
<span class="sd">        respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parastart</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">plaintext</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">line_toks</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tok</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">line_toks</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">parastart</span><span class="o">=</span><span class="n">parastart</span><span class="p">,</span> <span class="n">linestart</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">parastart</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">line_toks</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parastart</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Annotation Procedures</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_annotate_first_pass</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the first pass of annotation, which makes decisions</span>
<span class="sd">        based purely based on the word type of each word:</span>

<span class="sd">          - &#39;?&#39;, &#39;!&#39;, and &#39;.&#39; are marked as sentence breaks.</span>
<span class="sd">          - sequences of two or more periods are marked as ellipsis.</span>
<span class="sd">          - any word ending in &#39;.&#39; that&#39;s a known abbreviation is</span>
<span class="sd">            marked as an abbreviation.</span>
<span class="sd">          - any other word ending in &#39;.&#39; is marked as a sentence break.</span>

<span class="sd">        Return these annotations as a tuple of three sets:</span>

<span class="sd">          - sentbreak_toks: The indices of all sentence breaks.</span>
<span class="sd">          - abbrev_toks: The indices of all abbreviations.</span>
<span class="sd">          - ellipsis_toks: The indices of all ellipsis marks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_pass_annotation</span><span class="p">(</span><span class="n">aug_tok</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">aug_tok</span>

    <span class="k">def</span> <span class="nf">_first_pass_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok</span><span class="p">:</span> <span class="n">PunktToken</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs type-based annotation on a single token.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span>

        <span class="k">if</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">:</span>
            <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">is_ellipsis</span><span class="p">:</span>
            <span class="n">aug_tok</span><span class="o">.</span><span class="n">ellipsis</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">period_final</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tok</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;..&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">tok</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span>
                <span class="ow">or</span> <span class="n">tok</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span>
            <span class="p">):</span>

                <span class="n">aug_tok</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># { Punkt Trainer</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="PunktTrainer"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer">[docs]</a><span class="k">class</span> <span class="nc">PunktTrainer</span><span class="p">(</span><span class="n">PunktBaseClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Learns parameters used in Punkt sentence boundary detection.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="PunktTrainer.__init__"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span>
    <span class="p">):</span>

        <span class="n">PunktBaseClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">lang_vars</span><span class="p">,</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">token_cls</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of each</span>
<span class="sd">        case-normalized token type in the training data.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The number of words ending in period in the training data.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of all</span>
<span class="sd">        bigrams in the training data where the first word ends in a</span>
<span class="sd">        period.  Bigrams are encoded as tuples of word types.</span>
<span class="sd">        Especially common collocations are extracted from this</span>
<span class="sd">        frequency distribution, and stored in</span>
<span class="sd">        ``_params``.``collocations &lt;PunktParameters.collocations&gt;``.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;A frequency distribution giving the frequency of all words</span>
<span class="sd">        that occur at the training data at the beginning of a sentence</span>
<span class="sd">        (after the first pass of annotation).  Especially common</span>
<span class="sd">        sentence starters are extracted from this frequency</span>
<span class="sd">        distribution, and stored in ``_params.sent_starters``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;The total number of sentence breaks identified in training, used for</span>
<span class="sd">        calculating the frequent sentence starter heuristic.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;A flag as to whether the training has been finalized by finding</span>
<span class="sd">        collocations and sentence starters, or whether finalize_training()</span>
<span class="sd">        still needs to be called.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">train_text</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktTrainer.get_params"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates and returns parameters for sentence boundary detection as</span>
<span class="sd">        derived from training.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Customization Variables</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="n">ABBREV</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="sd">&quot;&quot;&quot;cut-off value whether a &#39;token&#39; is an abbreviation&quot;&quot;&quot;</span>

    <span class="n">IGNORE_ABBREV_PENALTY</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;allows the disabling of the abbreviation penalty heuristic, which</span>
<span class="sd">    exponentially disadvantages words that are found at times without a</span>
<span class="sd">    final period.&quot;&quot;&quot;</span>

    <span class="n">ABBREV_BACKOFF</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="sd">&quot;&quot;&quot;upper cut-off for Mikheev&#39;s(2002) abbreviation detection algorithm&quot;&quot;&quot;</span>

    <span class="n">COLLOCATION</span> <span class="o">=</span> <span class="mf">7.88</span>
    <span class="sd">&quot;&quot;&quot;minimal log-likelihood value that two tokens need to be considered</span>
<span class="sd">    as a collocation&quot;&quot;&quot;</span>

    <span class="n">SENT_STARTER</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="sd">&quot;&quot;&quot;minimal log-likelihood value that a token requires to be considered</span>
<span class="sd">    as a frequent sentence starter&quot;&quot;&quot;</span>

    <span class="n">INCLUDE_ALL_COLLOCS</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;this includes as potential collocations all word pairs where the first</span>
<span class="sd">    word ends in a period. It may be useful in corpora where there is a lot</span>
<span class="sd">    of variation that makes abbreviations like Mr difficult to identify.&quot;&quot;&quot;</span>

    <span class="n">INCLUDE_ABBREV_COLLOCS</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;this includes as potential collocations all word pairs where the first</span>
<span class="sd">    word is an abbreviation. Such collocations override the orthographic</span>
<span class="sd">    heuristic, but not the sentence starter heuristic. This is overridden by</span>
<span class="sd">    INCLUDE_ALL_COLLOCS, and if both are false, only collocations with initials</span>
<span class="sd">    and ordinals are considered.&quot;&quot;&quot;</span>
    <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>

    <span class="n">MIN_COLLOC_FREQ</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="sd">&quot;&quot;&quot;this sets a minimum bound on the number of times a bigram needs to</span>
<span class="sd">    appear before it can be considered a collocation, in addition to log</span>
<span class="sd">    likelihood statistics. This is useful when INCLUDE_ALL_COLLOCS is True.&quot;&quot;&quot;</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Training..</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="PunktTrainer.train"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects training data from a given text. If finalize is True, it</span>
<span class="sd">        will determine all the parameters for sentence boundary detection. If</span>
<span class="sd">        not, this will be delayed until get_params() or finalize_training() is</span>
<span class="sd">        called. If verbose is True, abbreviations found will be listed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Break the text into tokens; record which token indices correspond to</span>
        <span class="c1"># line starts and paragraph starts; and determine their types.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktTrainer.train_tokens"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer.train_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">finalize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects training data from a given list of tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_train_tokens</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">),</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalize_training</span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_train_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Ensure tokens are a list</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Find the frequency of each case-normalized type.  (Don&#39;t</span>
        <span class="c1"># strip off final periods.)  Also keep track of the number of</span>
        <span class="c1"># tokens that end in periods.</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">period_final</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Look for new abbreviations, and for types that no longer are</span>
        <span class="n">unique_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unique_types</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">abbr</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reclassify_abbrev_types</span><span class="p">(</span><span class="n">unique_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_add</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Abbreviation: [</span><span class="si">{</span><span class="n">score</span><span class="si">:</span><span class="s2">6.4f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">abbr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_add</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Removed abbreviation: [</span><span class="si">{</span><span class="n">score</span><span class="si">:</span><span class="s2">6.4f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">abbr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Make a preliminary pass through the document, marking likely</span>
        <span class="c1"># sentence breaks, abbreviations, and ellipsis tokens.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>

        <span class="c1"># Check what contexts each word type can appear in, given the</span>
        <span class="c1"># case of its first letter.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_orthography_data</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># We need total number of sentence breaks to find sentence starters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sentbreak_count</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># The remaining heuristics relate to pairs of tokens where the first</span>
        <span class="c1"># ends in a period.</span>
        <span class="k">for</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">period_final</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">aug_tok2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Is the first token a rare abbreviation?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_rare_abbrev_type</span><span class="p">(</span><span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Rare Abbrev: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

            <span class="c1"># Does second token have a high likelihood of starting a sentence?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_potential_sent_starter</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">[</span><span class="n">aug_tok2</span><span class="o">.</span><span class="n">type</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Is this bigram a potential collocation?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_potential_collocation</span><span class="p">(</span><span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">)</span>
                <span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_unique_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">}</span>

<div class="viewcode-block" id="PunktTrainer.finalize_training"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer.finalize_training">[docs]</a>    <span class="k">def</span> <span class="nf">finalize_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses data that has been gathered in training to determine likely</span>
<span class="sd">        collocations and sentence starters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_sent_starters</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">typ</span><span class="p">,</span> <span class="n">log_likelihood</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_sent_starters</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Sent Starter: [</span><span class="si">{</span><span class="n">log_likelihood</span><span class="si">:</span><span class="s2">6.4f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">typ</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_collocations</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">),</span> <span class="n">log_likelihood</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_collocations</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Collocation: [</span><span class="si">{</span><span class="n">log_likelihood</span><span class="si">:</span><span class="s2">6.4f</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">typ1</span><span class="si">!r}</span><span class="s2">+</span><span class="si">{</span><span class="n">typ2</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Overhead reduction</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="PunktTrainer.freq_threshold"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer.freq_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">freq_threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ortho_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">type_thresh</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">colloc_thres</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sentstart_thresh</span><span class="o">=</span><span class="mi">2</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows memory use to be reduced after much training by removing data</span>
<span class="sd">        about rare tokens that are unlikely to have a statistical effect with</span>
<span class="sd">        further training. Entries occurring above the given thresholds will be</span>
<span class="sd">        retained.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ortho_thresh</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">old_oc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_ortho_context</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">ortho_thresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_oc</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">,</span> <span class="n">type_thresh</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">,</span> <span class="n">colloc_thres</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq_threshold</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">,</span> <span class="n">sentstart_thresh</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_freq_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fdist</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a FreqDist containing only data with counts below a given</span>
<span class="sd">        threshold, as well as a mapping (None -&gt; count_removed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We assume that there is more data below the threshold than above it</span>
        <span class="c1"># and so create a new FreqDist rather than working in place.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="n">num_removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">fdist</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">fdist</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">num_removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">[</span><span class="n">tok</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span>
        <span class="n">res</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num_removed</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Orthographic data</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_get_orthography_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collect information about whether each token type occurs</span>
<span class="sd">        with different case patterns (i) overall, (ii) at</span>
<span class="sd">        sentence-initial positions, and (iii) at sentence-internal</span>
<span class="sd">        positions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># &#39;initial&#39; or &#39;internal&#39; or &#39;unknown&#39;</span>
        <span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;internal&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="c1"># If we encounter a paragraph break, then it&#39;s a good sign</span>
            <span class="c1"># that it&#39;s a sentence break.  But err on the side of</span>
            <span class="c1"># caution (by not positing a sentence break) if we just</span>
            <span class="c1"># saw an abbreviation.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">parastart</span> <span class="ow">and</span> <span class="n">context</span> <span class="o">!=</span> <span class="s2">&quot;unknown&quot;</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;initial&quot;</span>

            <span class="c1"># If we&#39;re at the beginning of a line, then we can&#39;t decide</span>
            <span class="c1"># between &#39;internal&#39; and &#39;initial&#39;.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">linestart</span> <span class="ow">and</span> <span class="n">context</span> <span class="o">==</span> <span class="s2">&quot;internal&quot;</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>

            <span class="c1"># Find the case-normalized type of the token.  If it&#39;s a</span>
            <span class="c1"># sentence-final token, strip off the period.</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>

            <span class="c1"># Update the orthographic context table.</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">_ORTHO_MAP</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">context</span><span class="p">,</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_case</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">add_ortho_context</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>

            <span class="c1"># Decide whether the next word is at a sentence boundary.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">is_initial</span><span class="p">):</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;initial&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
            <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">ellipsis</span> <span class="ow">or</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">abbr</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">=</span> <span class="s2">&quot;internal&quot;</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Abbreviations</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_reclassify_abbrev_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Re)classifies each given token if</span>
<span class="sd">          - it is period-final and not a known abbreviation; or</span>
<span class="sd">          - it is not period-final and is otherwise a known abbreviation</span>
<span class="sd">        by checking whether its previous classification still holds according</span>
<span class="sd">        to the heuristics of section 3.</span>
<span class="sd">        Yields triples (abbr, score, is_add) where abbr is the type in question,</span>
<span class="sd">        score is its log-likelihood with penalties applied, and is_add specifies</span>
<span class="sd">        whether the present type is a candidate for inclusion or exclusion as an</span>
<span class="sd">        abbreviation, such that:</span>
<span class="sd">          - (is_add and score &gt;= 0.3)    suggests a new abbreviation; and</span>
<span class="sd">          - (not is_add and score &lt; 0.3) suggests excluding an abbreviation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (While one could recalculate abbreviations from all .-final tokens at</span>
        <span class="c1"># every iteration, in cases requiring efficiency, the number of tokens</span>
        <span class="c1"># in the present training document will be much less.)</span>

        <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="c1"># Check some basic conditions, to rule out words that are</span>
            <span class="c1"># clearly not abbrev_types.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_re_non_punct</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s2">&quot;##number##&quot;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">typ</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">typ</span> <span class="o">=</span> <span class="n">typ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">is_add</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">typ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">is_add</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Count how many periods &amp; nonperiods are in the</span>
            <span class="c1"># candidate.</span>
            <span class="n">num_periods</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">num_nonperiods</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_periods</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Let &lt;a&gt; be the candidate without the period, and &lt;b&gt;</span>
            <span class="c1"># be the period.  Find a log likelihood ratio that</span>
            <span class="c1"># indicates whether &lt;ab&gt; occurs as a single unit (high</span>
            <span class="c1"># value of log_likelihood), or as two independent units &lt;a&gt; and</span>
            <span class="c1"># &lt;b&gt; (low value of log_likelihood).</span>
            <span class="n">count_with_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">]</span>
            <span class="n">count_without_period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
            <span class="n">log_likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunning_log_likelihood</span><span class="p">(</span>
                <span class="n">count_with_period</span> <span class="o">+</span> <span class="n">count_without_period</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_period_toks</span><span class="p">,</span>
                <span class="n">count_with_period</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">(),</span>
            <span class="p">)</span>

            <span class="c1"># Apply three scaling factors to &#39;tweak&#39; the basic log</span>
            <span class="c1"># likelihood ratio:</span>
            <span class="c1">#   F_length: long word -&gt; less likely to be an abbrev</span>
            <span class="c1">#   F_periods: more periods -&gt; more likely to be an abbrev</span>
            <span class="c1">#   F_penalty: penalize occurrences w/o a period</span>
            <span class="n">f_length</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">num_nonperiods</span><span class="p">)</span>
            <span class="n">f_periods</span> <span class="o">=</span> <span class="n">num_periods</span>
            <span class="n">f_penalty</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">IGNORE_ABBREV_PENALTY</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span>
                <span class="n">num_nonperiods</span><span class="p">,</span> <span class="o">-</span><span class="n">count_without_period</span>
            <span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">log_likelihood</span> <span class="o">*</span> <span class="n">f_length</span> <span class="o">*</span> <span class="n">f_periods</span> <span class="o">*</span> <span class="n">f_penalty</span>

            <span class="k">yield</span> <span class="n">typ</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">is_add</span>

<div class="viewcode-block" id="PunktTrainer.find_abbrev_types"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktTrainer.find_abbrev_types">[docs]</a>    <span class="k">def</span> <span class="nf">find_abbrev_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates abbreviations given type frequencies, despite no prior</span>
<span class="sd">        determination of abbreviations.</span>
<span class="sd">        This fails to include abbreviations otherwise found as &quot;rare&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">clear_abbrevs</span><span class="p">()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span><span class="n">typ</span> <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span> <span class="k">if</span> <span class="n">typ</span> <span class="ow">and</span> <span class="n">typ</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">abbr</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">_is_add</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reclassify_abbrev_types</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">abbr</span><span class="p">)</span></div>

    <span class="c1"># This function combines the work done by the original code&#39;s</span>
    <span class="c1"># functions `count_orthography_context`, `get_orthography_count`,</span>
    <span class="c1"># and `get_rare_abbreviations`.</span>
    <span class="k">def</span> <span class="nf">_is_rare_abbrev_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_tok</span><span class="p">,</span> <span class="n">next_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A word type is counted as a rare abbreviation if...</span>
<span class="sd">          - it&#39;s not already marked as an abbreviation</span>
<span class="sd">          - it occurs fewer than ABBREV_BACKOFF times</span>
<span class="sd">          - either it is followed by a sentence-internal punctuation</span>
<span class="sd">            mark, *or* it is followed by a lower-case word that</span>
<span class="sd">            sometimes appears with upper case, but never occurs with</span>
<span class="sd">            lower case at the beginning of sentences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">abbr</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Find the case-normalized type of the token.  If it&#39;s</span>
        <span class="c1"># a sentence-final token, strip off the period.</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>

        <span class="c1"># Proceed only if the type hasn&#39;t been categorized as an</span>
        <span class="c1"># abbreviation already, and is sufficiently rare...</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">abbrev_types</span> <span class="ow">or</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ABBREV_BACKOFF</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Record this token as an abbreviation if the next</span>
        <span class="c1"># token is a sentence-internal punctuation mark.</span>
        <span class="c1"># [XX] :1 or check the whole thing??</span>
        <span class="k">if</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">tok</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">internal_punctuation</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Record this type as an abbreviation if the next</span>
        <span class="c1"># token...  (i) starts with a lower case letter,</span>
        <span class="c1"># (ii) sometimes occurs with an uppercase letter,</span>
        <span class="c1"># and (iii) never occus with an uppercase letter</span>
        <span class="c1"># sentence-internally.</span>
        <span class="c1"># [xx] should the check for (ii) be modified??</span>
        <span class="k">if</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">first_lower</span><span class="p">:</span>
            <span class="n">typ2</span> <span class="o">=</span> <span class="n">next_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
            <span class="n">typ2ortho_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">typ2</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">typ2ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_UC</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="n">typ2ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Log Likelihoods</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="c1"># helper for _reclassify_abbrev_types:</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_dunning_log_likelihood</span><span class="p">(</span><span class="n">count_a</span><span class="p">,</span> <span class="n">count_b</span><span class="p">,</span> <span class="n">count_ab</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that calculates the modified Dunning log-likelihood</span>
<span class="sd">        ratio scores for abbreviation candidates.  The details of how</span>
<span class="sd">        this works is available in the paper.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">count_b</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="mf">0.99</span>

        <span class="n">null_hypo</span> <span class="o">=</span> <span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>
        <span class="n">alt_hypo</span> <span class="o">=</span> <span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span>

        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">null_hypo</span> <span class="o">-</span> <span class="n">alt_hypo</span>

        <span class="k">return</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">likelihood</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_col_log_likelihood</span><span class="p">(</span><span class="n">count_a</span><span class="p">,</span> <span class="n">count_b</span><span class="p">,</span> <span class="n">count_ab</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that will just compute log-likelihood estimate, in</span>
<span class="sd">        the original paper it&#39;s described in algorithm 6 and 7.</span>

<span class="sd">        This *should* be the original Dunning log-likelihood values,</span>
<span class="sd">        unlike the previous log_l function where it used modified</span>
<span class="sd">        Dunning log-likelihood values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">count_b</span> <span class="o">/</span> <span class="n">N</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">count_ab</span> <span class="o">/</span> <span class="n">count_a</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">summand1</span> <span class="o">=</span> <span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">summand1</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">summand2</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
                <span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span> <span class="o">-</span> <span class="n">count_b</span> <span class="o">+</span> <span class="n">count_ab</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">summand2</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">count_a</span> <span class="o">==</span> <span class="n">count_ab</span> <span class="ow">or</span> <span class="n">p1</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p1</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">summand3</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summand3</span> <span class="o">=</span> <span class="n">count_ab</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">count_a</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">-</span> <span class="n">p1</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">count_b</span> <span class="o">==</span> <span class="n">count_ab</span> <span class="ow">or</span> <span class="n">p2</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p2</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">summand4</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">summand4</span> <span class="o">=</span> <span class="p">(</span><span class="n">count_b</span> <span class="o">-</span> <span class="n">count_ab</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
                <span class="n">N</span> <span class="o">-</span> <span class="n">count_a</span> <span class="o">-</span> <span class="n">count_b</span> <span class="o">+</span> <span class="n">count_ab</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span>

        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">summand1</span> <span class="o">+</span> <span class="n">summand2</span> <span class="o">-</span> <span class="n">summand3</span> <span class="o">-</span> <span class="n">summand4</span>

        <span class="k">return</span> <span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">likelihood</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Collocation Finder</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_is_potential_collocation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the pair of tokens may form a collocation given</span>
<span class="sd">        log-likelihood statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">INCLUDE_ALL_COLLOCS</span>
                <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">INCLUDE_ABBREV_COLLOCS</span> <span class="ow">and</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="ow">and</span> <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_initial</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_non_punct</span>
            <span class="ow">and</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">is_non_punct</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_collocations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates likely collocations and their log-likelihood.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">types</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span> <span class="o">=</span> <span class="n">types</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># types may be None after calling freq_threshold()</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">typ2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">col_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_fdist</span><span class="p">[</span><span class="n">types</span><span class="p">]</span>
            <span class="n">typ1_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ1</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">]</span>
            <span class="n">typ2_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ2</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">typ1_count</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">typ2_count</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MIN_COLLOC_FREQ</span> <span class="o">&lt;</span> <span class="n">col_count</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">typ1_count</span><span class="p">,</span> <span class="n">typ2_count</span><span class="p">)</span>
            <span class="p">):</span>

                <span class="n">log_likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_log_likelihood</span><span class="p">(</span>
                    <span class="n">typ1_count</span><span class="p">,</span> <span class="n">typ2_count</span><span class="p">,</span> <span class="n">col_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="c1"># Filter out the not-so-collocative</span>
                <span class="k">if</span> <span class="n">log_likelihood</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COLLOCATION</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">()</span> <span class="o">/</span> <span class="n">typ1_count</span> <span class="o">&gt;</span> <span class="n">typ2_count</span> <span class="o">/</span> <span class="n">col_count</span>
                <span class="p">):</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">typ1</span><span class="p">,</span> <span class="n">typ2</span><span class="p">),</span> <span class="n">log_likelihood</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Sentence-Starter Finder</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_is_potential_sent_starter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_tok</span><span class="p">,</span> <span class="n">prev_tok</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True given a token and the token that precedes it if it</span>
<span class="sd">        seems clear that the token is beginning a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If a token (i) is preceded by a sentece break that is</span>
        <span class="c1"># not a potential ordinal number or initial, and (ii) is</span>
        <span class="c1"># alphabetic, then it is a a sentence-starter.</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">prev_tok</span><span class="o">.</span><span class="n">sentbreak</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">prev_tok</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">prev_tok</span><span class="o">.</span><span class="n">is_initial</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">cur_tok</span><span class="o">.</span><span class="n">is_alpha</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_sent_starters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses collocation heuristics for each candidate token to</span>
<span class="sd">        determine if it frequently starts sentences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">typ</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">typ_at_break_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sent_starter_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
            <span class="n">typ_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="p">[</span><span class="n">typ</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">typ_count</span> <span class="o">&lt;</span> <span class="n">typ_at_break_count</span><span class="p">:</span>
                <span class="c1"># needed after freq_threshold</span>
                <span class="k">continue</span>

            <span class="n">log_likelihood</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_log_likelihood</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span><span class="p">,</span>
                <span class="n">typ_count</span><span class="p">,</span>
                <span class="n">typ_at_break_count</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">(),</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">log_likelihood</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SENT_STARTER</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_fdist</span><span class="o">.</span><span class="n">N</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sentbreak_count</span>
                <span class="o">&gt;</span> <span class="n">typ_count</span> <span class="o">/</span> <span class="n">typ_at_break_count</span>
            <span class="p">):</span>
                <span class="k">yield</span> <span class="n">typ</span><span class="p">,</span> <span class="n">log_likelihood</span>

    <span class="k">def</span> <span class="nf">_get_sentbreak_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of sentence breaks marked in a given set of</span>
<span class="sd">        augmented tokens.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">)</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># { Punkt Sentence Tokenizer</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="PunktSentenceTokenizer"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer">[docs]</a><span class="k">class</span> <span class="nc">PunktSentenceTokenizer</span><span class="p">(</span><span class="n">PunktBaseClass</span><span class="p">,</span> <span class="n">TokenizerI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sentence tokenizer which uses an unsupervised algorithm to build</span>
<span class="sd">    a model for abbreviation words, collocations, and words that start</span>
<span class="sd">    sentences; and then uses that model to find sentence boundaries.</span>
<span class="sd">    This approach has been shown to work well for many European</span>
<span class="sd">    languages.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PunktSentenceTokenizer.__init__"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">PunktToken</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        train_text can either be the sole training text for this sentence</span>
<span class="sd">        boundary detector, or can be a PunktParameters object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">PunktBaseClass</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="n">lang_vars</span><span class="p">,</span> <span class="n">token_cls</span><span class="o">=</span><span class="n">token_cls</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">train_text</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.train"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train_text</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derives parameters from a given training text, or uses the parameters</span>
<span class="sd">        given. Repeated calls to this method destroy previous parameters. For</span>
<span class="sd">        incremental training, instantiate a separate PunktTrainer instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_text</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">train_text</span>
        <span class="k">return</span> <span class="n">PunktTrainer</span><span class="p">(</span>
            <span class="n">train_text</span><span class="p">,</span> <span class="n">lang_vars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="p">,</span> <span class="n">token_cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Tokenization</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="PunktSentenceTokenizer.tokenize"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, returns a list of the sentences in that text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sentences_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">))</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.debug_decisions"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.debug_decisions">[docs]</a>    <span class="k">def</span> <span class="nf">debug_decisions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classifies candidate periods as sentence breaks, yielding a dict for</span>
<span class="sd">        each that may be used to understand why the decision was made.</span>

<span class="sd">        See format_debug_decision() to help make this output readable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">match</span><span class="p">,</span> <span class="n">decision_text</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_potential_end_contexts</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">decision_text</span><span class="p">)</span>
            <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
            <span class="k">while</span> <span class="n">tokens</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tok</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">sent_end_chars</span><span class="p">):</span>
                <span class="n">tokens</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">{</span>
                <span class="s2">&quot;period_index&quot;</span><span class="p">:</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">decision_text</span><span class="p">,</span>
                <span class="s2">&quot;type1&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="s2">&quot;type2&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="s2">&quot;type1_in_abbrs&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abbr</span><span class="p">),</span>
                <span class="s2">&quot;type1_is_initial&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_initial</span><span class="p">),</span>
                <span class="s2">&quot;type2_is_sent_starter&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">,</span>
                <span class="s2">&quot;type2_ortho_heuristic&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="s2">&quot;type2_ortho_contexts&quot;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">_debug_ortho_context</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="s2">&quot;collocation&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">,</span>
                    <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="p">,</span>
                <span class="s2">&quot;reason&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_pass_annotation</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">or</span> <span class="n">REASON_DEFAULT_DECISION</span><span class="p">,</span>
                <span class="s2">&quot;break_decision&quot;</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">,</span>
            <span class="p">}</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.span_tokenize"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.span_tokenize">[docs]</a>    <span class="k">def</span> <span class="nf">span_tokenize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, generates (start, end) spans of sentences</span>
<span class="sd">        in the text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slices_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">realign_boundaries</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_realign_boundaries</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">slices</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">sentence</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">sentence</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_text"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.sentences_from_text">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, generates the sentences in that text by only</span>
<span class="sd">        testing candidate sentence breaks. If realign_boundaries is</span>
<span class="sd">        True, includes in the sentence closing punctuation that</span>
<span class="sd">        follows the period.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">text</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">span_tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">realign_boundaries</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="nf">_get_last_whitespace_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, find the index of the *last* occurrence of *any*</span>
<span class="sd">        whitespace character, i.e. &quot; &quot;, &quot;\n&quot;, &quot;\t&quot;, &quot;\r&quot;, etc.</span>
<span class="sd">        If none is found, return 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">whitespace</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_match_potential_end_contexts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Match</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, find the matches of potential sentence breaks,</span>
<span class="sd">        alongside the contexts surrounding these sentence breaks.</span>

<span class="sd">        Since the fix for the ReDOS discovered in issue #2866, we no longer match</span>
<span class="sd">        the word before a potential end of sentence token. Instead, we use a separate</span>
<span class="sd">        regex for this. As a consequence, `finditer`&#39;s desire to find non-overlapping</span>
<span class="sd">        matches no longer aids us in finding the single longest match.</span>
<span class="sd">        Where previously, we could use::</span>

<span class="sd">            &gt;&gt;&gt; pst = PunktSentenceTokenizer()</span>
<span class="sd">            &gt;&gt;&gt; text = &quot;Very bad acting!!! I promise.&quot;</span>
<span class="sd">            &gt;&gt;&gt; list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +SKIP</span>
<span class="sd">            [&lt;re.Match object; span=(9, 18), match=&#39;acting!!!&#39;&gt;]</span>

<span class="sd">        Now we have to find the word before (i.e. &#39;acting&#39;) separately, and `finditer`</span>
<span class="sd">        returns::</span>

<span class="sd">            &gt;&gt;&gt; pst = PunktSentenceTokenizer()</span>
<span class="sd">            &gt;&gt;&gt; text = &quot;Very bad acting!!! I promise.&quot;</span>
<span class="sd">            &gt;&gt;&gt; list(pst._lang_vars.period_context_re().finditer(text)) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            [&lt;re.Match object; span=(15, 16), match=&#39;!&#39;&gt;,</span>
<span class="sd">            &lt;re.Match object; span=(16, 17), match=&#39;!&#39;&gt;,</span>
<span class="sd">            &lt;re.Match object; span=(17, 18), match=&#39;!&#39;&gt;]</span>

<span class="sd">        So, we need to find the word before the match from right to left, and then manually remove</span>
<span class="sd">        the overlaps. That is what this method does::</span>

<span class="sd">            &gt;&gt;&gt; pst = PunktSentenceTokenizer()</span>
<span class="sd">            &gt;&gt;&gt; text = &quot;Very bad acting!!! I promise.&quot;</span>
<span class="sd">            &gt;&gt;&gt; list(pst._match_potential_end_contexts(text))</span>
<span class="sd">            [(&lt;re.Match object; span=(17, 18), match=&#39;!&#39;&gt;, &#39;acting!!! I&#39;)]</span>

<span class="sd">        :param text: String of one or more sentences</span>
<span class="sd">        :type text: str</span>
<span class="sd">        :return: Generator of match-context tuples.</span>
<span class="sd">        :rtype: Iterator[Tuple[Match, str]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">previous_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">previous_match</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">period_context_re</span><span class="p">()</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>

            <span class="c1"># Get the slice of the previous word</span>
            <span class="n">before_text</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">previous_slice</span><span class="o">.</span><span class="n">stop</span> <span class="p">:</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span>
            <span class="n">index_after_last_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_last_whitespace_index</span><span class="p">(</span><span class="n">before_text</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index_after_last_space</span><span class="p">:</span>
                <span class="c1"># + 1 to exclude the space itself</span>
                <span class="n">index_after_last_space</span> <span class="o">+=</span> <span class="n">previous_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index_after_last_space</span> <span class="o">=</span> <span class="n">previous_slice</span><span class="o">.</span><span class="n">start</span>
            <span class="n">prev_word_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index_after_last_space</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>

            <span class="c1"># If the previous slice does not overlap with this slice, then</span>
            <span class="c1"># we can yield the previous match and slice. If there is an overlap,</span>
            <span class="c1"># then we do not yield the previous match and slice.</span>
            <span class="k">if</span> <span class="n">previous_match</span> <span class="ow">and</span> <span class="n">previous_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">prev_word_slice</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span>
                    <span class="n">previous_match</span><span class="p">,</span>
                    <span class="n">text</span><span class="p">[</span><span class="n">previous_slice</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">previous_match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
                    <span class="o">+</span> <span class="n">previous_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;after_tok&quot;</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">previous_match</span> <span class="o">=</span> <span class="n">match</span>
            <span class="n">previous_slice</span> <span class="o">=</span> <span class="n">prev_word_slice</span>

        <span class="c1"># Yield the last match and context, if it exists</span>
        <span class="k">if</span> <span class="n">previous_match</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span>
                <span class="n">previous_match</span><span class="p">,</span>
                <span class="n">text</span><span class="p">[</span><span class="n">previous_slice</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">previous_match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
                <span class="o">+</span> <span class="n">previous_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;after_tok&quot;</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_slices_from_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">slice</span><span class="p">]:</span>
        <span class="n">last_break</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">match</span><span class="p">,</span> <span class="n">context</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_potential_end_contexts</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">text_contains_sentbreak</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
                <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">last_break</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;next_tok&quot;</span><span class="p">):</span>
                    <span class="c1"># next sentence starts after whitespace</span>
                    <span class="n">last_break</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;next_tok&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># next sentence starts at following punctuation</span>
                    <span class="n">last_break</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="c1"># The last sentence should not contain trailing whitespace.</span>
        <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">last_break</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_realign_boundaries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">slices</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">slice</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">slice</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to realign punctuation that falls after the period but</span>
<span class="sd">        should otherwise be included in the same sentence.</span>

<span class="sd">        For example: &quot;(Sent1.) Sent2.&quot; will otherwise be split as::</span>

<span class="sd">            [&quot;(Sent1.&quot;, &quot;) Sent1.&quot;].</span>

<span class="sd">        This method will produce::</span>

<span class="sd">            [&quot;(Sent1.)&quot;, &quot;Sent2.&quot;].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">realign</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">sentence1</span><span class="p">,</span> <span class="n">sentence2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
            <span class="n">sentence1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sentence1</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">realign</span><span class="p">,</span> <span class="n">sentence1</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sentence2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">sentence1</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="n">sentence1</span>
                <span class="k">continue</span>

            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_vars</span><span class="o">.</span><span class="n">re_boundary_realignment</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">sentence2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">yield</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sentence1</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">sentence2</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()))</span>
                <span class="n">realign</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">realign</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">sentence1</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="n">sentence1</span>

<div class="viewcode-block" id="PunktSentenceTokenizer.text_contains_sentbreak"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.text_contains_sentbreak">[docs]</a>    <span class="k">def</span> <span class="nf">text_contains_sentbreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the given text includes a sentence break.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># used to ignore last token</span>
        <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_text_legacy"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.sentences_from_text_legacy">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_text_legacy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a text, generates the sentences in that text. Annotates all</span>
<span class="sd">        tokens, rather than just those with possible sentence breaks. Should</span>
<span class="sd">        produce the same results as ``sentences_from_text``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokenize_words</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_sentence_list</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tokens</span><span class="p">)</span></div>

<div class="viewcode-block" id="PunktSentenceTokenizer.sentences_from_tokens"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.sentences_from_tokens">[docs]</a>    <span class="k">def</span> <span class="nf">sentences_from_tokens</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a sequence of tokens, generates lists of tokens, each list</span>
<span class="sd">        corresponding to a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_Token</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">))</span>
        <span class="n">sentence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">sentence</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">sentence</span>
                <span class="n">sentence</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sentence</span></div>

    <span class="k">def</span> <span class="nf">_annotate_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of tokens augmented with markers for line-start and</span>
<span class="sd">        paragraph-start, returns an iterator through those tokens with full</span>
<span class="sd">        annotation including predicted sentence breaks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a preliminary pass through the document, marking likely</span>
        <span class="c1"># sentence breaks, abbreviations, and ellipsis tokens.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_first_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Make a second pass through the document, using token context</span>
        <span class="c1"># information to change our preliminary decisions about where</span>
        <span class="c1"># sentence breaks, abbreviations, and ellipsis occurs.</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_annotate_second_pass</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1">## [XX] TESTING</span>
        <span class="c1"># tokens = list(tokens)</span>
        <span class="c1"># self.dump(tokens)</span>

        <span class="k">return</span> <span class="n">tokens</span>

    <span class="k">def</span> <span class="nf">_build_sentence_list</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the original text and the list of augmented word tokens,</span>
<span class="sd">        construct and return a tokenized list of sentence strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Most of the work here is making sure that we put the right</span>
        <span class="c1"># pieces of whitespace back in all the right places.</span>

        <span class="c1"># Our position in the source text, used to keep track of which</span>
        <span class="c1"># whitespace to add:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># A regular expression that finds pieces of whitespace:</span>
        <span class="n">white_space_regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*&quot;</span><span class="p">)</span>

        <span class="n">sentence</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span>

            <span class="c1"># Find the whitespace before this token, and update pos.</span>
            <span class="n">white_space</span> <span class="o">=</span> <span class="n">white_space_regexp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">white_space</span><span class="p">)</span>

            <span class="c1"># Some of the rules used by the punkt word tokenizer</span>
            <span class="c1"># strip whitespace out of the text, resulting in tokens</span>
            <span class="c1"># that contain whitespace in the source text.  If our</span>
            <span class="c1"># token doesn&#39;t match, see if adding whitespace helps.</span>
            <span class="c1"># If so, then use the version with whitespace.</span>
            <span class="k">if</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">tok</span><span class="p">:</span>
                <span class="n">pat</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;\s*&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tok</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pat</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">tok</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

            <span class="c1"># Move our position pointer to the end of the token.</span>
            <span class="k">assert</span> <span class="n">text</span><span class="p">[</span><span class="n">pos</span> <span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)]</span> <span class="o">==</span> <span class="n">tok</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>

            <span class="c1"># Add this token.  If it&#39;s not at the beginning of the</span>
            <span class="c1"># sentence, then include any whitespace that separated it</span>
            <span class="c1"># from the previous token.</span>
            <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
                <span class="n">sentence</span> <span class="o">+=</span> <span class="n">white_space</span>
            <span class="n">sentence</span> <span class="o">+=</span> <span class="n">tok</span>

            <span class="c1"># If we&#39;re at a sentence break, then start a new sentence.</span>
            <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">sentbreak</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">sentence</span>
                <span class="n">sentence</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># If the last sentence is empty, discard it.</span>
        <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sentence</span>

    <span class="c1"># [XX] TESTING</span>
<div class="viewcode-block" id="PunktSentenceTokenizer.dump"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.PunktSentenceTokenizer.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;writing to /tmp/punkt.new...&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/tmp/punkt.new&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">aug_tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">parastart</span><span class="p">:</span>
                    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">linestart</span><span class="p">:</span>
                    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>

                <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">aug_tok</span><span class="p">))</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Customization Variables</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="n">PUNCTUATION</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s2">&quot;;:,.!?&quot;</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Annotation Procedures</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_annotate_second_pass</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a token-based classification (section 4) over the given</span>
<span class="sd">        tokens, making use of the orthographic heuristic (4.1.1), collocation</span>
<span class="sd">        heuristic (4.1.2) and frequent sentence starter heuristic (4.1.3).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">token1</span><span class="p">,</span> <span class="n">token2</span> <span class="ow">in</span> <span class="n">_pair_iter</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_second_pass_annotation</span><span class="p">(</span><span class="n">token1</span><span class="p">,</span> <span class="n">token2</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">token1</span>

    <span class="k">def</span> <span class="nf">_second_pass_annotation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok1</span><span class="p">:</span> <span class="n">PunktToken</span><span class="p">,</span> <span class="n">aug_tok2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PunktToken</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs token-based classification over a pair of contiguous tokens</span>
<span class="sd">        updating the first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Is it the last token? We can&#39;t do anything then.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok2</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">period_final</span><span class="p">:</span>
            <span class="c1"># We only care about words ending in periods.</span>
            <span class="k">return</span>
        <span class="n">typ</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">type_no_period</span>
        <span class="n">next_typ</span> <span class="o">=</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">type_no_sentperiod</span>
        <span class="n">tok_is_initial</span> <span class="o">=</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">is_initial</span>

        <span class="c1"># [4.1.2. Collocation Heuristic] If there&#39;s a</span>
        <span class="c1"># collocation between the word before and after the</span>
        <span class="c1"># period, then label tok as an abbreviation and NOT</span>
        <span class="c1"># a sentence break. Note that collocations with</span>
        <span class="c1"># frequent sentence starters as their second word are</span>
        <span class="c1"># excluded in training.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">next_typ</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">collocations</span><span class="p">:</span>
            <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">REASON_KNOWN_COLLOCATION</span>

        <span class="c1"># [4.2. Token-Based Reclassification of Abbreviations] If</span>
        <span class="c1"># the token is an abbreviation or an ellipsis, then decide</span>
        <span class="c1"># whether we should *also* classify it as a sentbreak.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="ow">or</span> <span class="n">aug_tok1</span><span class="o">.</span><span class="n">ellipsis</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tok_is_initial</span><span class="p">):</span>
            <span class="c1"># [4.1.1. Orthographic Heuristic] Check if there&#39;s</span>
            <span class="c1"># orthogrpahic evidence about whether the next word</span>
            <span class="c1"># starts a sentence or not.</span>
            <span class="n">is_sent_starter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">REASON_ABBR_WITH_ORTHOGRAPHIC_HEURISTIC</span>

            <span class="c1"># [4.1.3. Frequent Sentence Starter Heruistic] If the</span>
            <span class="c1"># next word is capitalized, and is a member of the</span>
            <span class="c1"># frequent-sentence-starters list, then label tok as a</span>
            <span class="c1"># sentence break.</span>
            <span class="k">if</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">first_upper</span> <span class="ow">and</span> <span class="n">next_typ</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">sent_starters</span><span class="p">:</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">REASON_ABBR_WITH_SENTENCE_STARTER</span>

        <span class="c1"># [4.3. Token-Based Detection of Initials and Ordinals]</span>
        <span class="c1"># Check if any initials or ordinals tokens that are marked</span>
        <span class="c1"># as sentbreaks should be reclassified as abbreviations.</span>
        <span class="k">if</span> <span class="n">tok_is_initial</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="s2">&quot;##number##&quot;</span><span class="p">:</span>

            <span class="c1"># [4.1.1. Orthographic Heuristic] Check if there&#39;s</span>
            <span class="c1"># orthogrpahic evidence about whether the next word</span>
            <span class="c1"># starts a sentence or not.</span>
            <span class="n">is_sent_starter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ortho_heuristic</span><span class="p">(</span><span class="n">aug_tok2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">tok_is_initial</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">REASON_INITIAL_WITH_ORTHOGRAPHIC_HEURISTIC</span>
                <span class="k">return</span> <span class="n">REASON_NUMBER_WITH_ORTHOGRAPHIC_HEURISTIC</span>

            <span class="c1"># Special heuristic for initials: if orthogrpahic</span>
            <span class="c1"># heuristic is unknown, and next word is always</span>
            <span class="c1"># capitalized, then mark as abbrev (eg: J. Bach).</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">is_sent_starter</span> <span class="o">==</span> <span class="s2">&quot;unknown&quot;</span>
                <span class="ow">and</span> <span class="n">tok_is_initial</span>
                <span class="ow">and</span> <span class="n">aug_tok2</span><span class="o">.</span><span class="n">first_upper</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">next_typ</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">_ORTHO_LC</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">sentbreak</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">aug_tok1</span><span class="o">.</span><span class="n">abbr</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">REASON_INITIAL_WITH_SPECIAL_ORTHOGRAPHIC_HEURISTIC</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_ortho_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_tok</span><span class="p">:</span> <span class="n">PunktToken</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decide whether the given token is the first token in a sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sentences don&#39;t start with punctuation marks:</span>
        <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">PUNCTUATION</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">ortho_context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">ortho_context</span><span class="p">[</span><span class="n">aug_tok</span><span class="o">.</span><span class="n">type_no_sentperiod</span><span class="p">]</span>

        <span class="c1"># If the word is capitalized, occurs at least once with a</span>
        <span class="c1"># lower case first letter, and never occurs with an upper case</span>
        <span class="c1"># first letter sentence-internally, then it&#39;s a sentence starter.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_upper</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_LC</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_MID_UC</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># If the word is lower case, and either (a) we&#39;ve seen it used</span>
        <span class="c1"># with upper case, or (b) we&#39;ve never seen it used</span>
        <span class="c1"># sentence-initially with lower case, then it&#39;s not a sentence</span>
        <span class="c1"># starter.</span>
        <span class="k">if</span> <span class="n">aug_tok</span><span class="o">.</span><span class="n">first_lower</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_UC</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ortho_context</span> <span class="o">&amp;</span> <span class="n">_ORTHO_BEG_LC</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Otherwise, we&#39;re not sure.</span>
        <span class="k">return</span> <span class="s2">&quot;unknown&quot;</span></div>


<span class="n">DEBUG_DECISION_FMT</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Text: </span><span class="si">{text!r}</span><span class="s2"> (at offset </span><span class="si">{period_index}</span><span class="s2">)</span>
<span class="s2">Sentence break? </span><span class="si">{break_decision}</span><span class="s2"> (</span><span class="si">{reason}</span><span class="s2">)</span>
<span class="s2">Collocation? </span><span class="si">{collocation}</span><span class="s2"></span>
<span class="si">{type1!r}</span><span class="s2">:</span>
<span class="s2">    known abbreviation: </span><span class="si">{type1_in_abbrs}</span><span class="s2"></span>
<span class="s2">    is initial: </span><span class="si">{type1_is_initial}</span><span class="s2"></span>
<span class="si">{type2!r}</span><span class="s2">:</span>
<span class="s2">    known sentence starter: </span><span class="si">{type2_is_sent_starter}</span><span class="s2"></span>
<span class="s2">    orthographic heuristic suggests is a sentence starter? </span><span class="si">{type2_ortho_heuristic}</span><span class="s2"></span>
<span class="s2">    orthographic contexts in training: </span><span class="si">{type2_ortho_contexts}</span><span class="s2"></span>
<span class="s2">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="format_debug_decision"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.format_debug_decision">[docs]</a><span class="k">def</span> <span class="nf">format_debug_decision</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">DEBUG_DECISION_FMT</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.tokenize.punkt.html#nltk.tokenize.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">tok_cls</span><span class="o">=</span><span class="n">PunktSentenceTokenizer</span><span class="p">,</span> <span class="n">train_cls</span><span class="o">=</span><span class="n">PunktTrainer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Builds a punkt model and applies it to the same text&quot;&quot;&quot;</span>
    <span class="n">cleanup</span> <span class="o">=</span> <span class="p">(</span>
        <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?:\r|^\s+)&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">trainer</span> <span class="o">=</span> <span class="n">train_cls</span><span class="p">()</span>
    <span class="n">trainer</span><span class="o">.</span><span class="n">INCLUDE_ALL_COLLOCS</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">sbd</span> <span class="o">=</span> <span class="n">tok_cls</span><span class="p">(</span><span class="n">trainer</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">sbd</span><span class="o">.</span><span class="n">sentences_from_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cleanup</span><span class="p">(</span><span class="n">sentence</span><span class="p">))</span></div>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>