<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.stem.porter</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.stem.porter</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Porter Stemmer</span>

<span class="sd">This is the Porter stemming algorithm. It follows the algorithm</span>
<span class="sd">presented in</span>

<span class="sd">Porter, M. &quot;An algorithm for suffix stripping.&quot; Program 14.3 (1980): 130-137.</span>

<span class="sd">with some optional deviations that can be turned on or off with the</span>
<span class="sd">`mode` argument to the constructor.</span>

<span class="sd">Martin Porter, the algorithm&#39;s inventor, maintains a web page about the</span>
<span class="sd">algorithm at</span>

<span class="sd">    https://www.tartarus.org/~martin/PorterStemmer/</span>

<span class="sd">which includes another Python implementation and other implementations</span>
<span class="sd">in many languages.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;plaintext&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">nltk.stem.api</span> <span class="kn">import</span> <span class="n">StemmerI</span>


<div class="viewcode-block" id="PorterStemmer"><a class="viewcode-back" href="../../../api/nltk.stem.porter.html#nltk.stem.PorterStemmer">[docs]</a><span class="k">class</span> <span class="nc">PorterStemmer</span><span class="p">(</span><span class="n">StemmerI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A word stemmer based on the Porter stemming algorithm.</span>

<span class="sd">        Porter, M. &quot;An algorithm for suffix stripping.&quot;</span>
<span class="sd">        Program 14.3 (1980): 130-137.</span>

<span class="sd">    See https://www.tartarus.org/~martin/PorterStemmer/ for the homepage</span>
<span class="sd">    of the algorithm.</span>

<span class="sd">    Martin Porter has endorsed several modifications to the Porter</span>
<span class="sd">    algorithm since writing his original paper, and those extensions are</span>
<span class="sd">    included in the implementations on his website. Additionally, others</span>
<span class="sd">    have proposed further improvements to the algorithm, including NLTK</span>
<span class="sd">    contributors. There are thus three modes that can be selected by</span>
<span class="sd">    passing the appropriate constant to the class constructor&#39;s `mode`</span>
<span class="sd">    attribute:</span>

<span class="sd">    - PorterStemmer.ORIGINAL_ALGORITHM</span>

<span class="sd">        An implementation that is faithful to the original paper.</span>

<span class="sd">        Note that Martin Porter has deprecated this version of the</span>
<span class="sd">        algorithm. Martin distributes implementations of the Porter</span>
<span class="sd">        Stemmer in many languages, hosted at:</span>

<span class="sd">        https://www.tartarus.org/~martin/PorterStemmer/</span>

<span class="sd">        and all of these implementations include his extensions. He</span>
<span class="sd">        strongly recommends against using the original, published</span>
<span class="sd">        version of the algorithm; only use this mode if you clearly</span>
<span class="sd">        understand why you are choosing to do so.</span>

<span class="sd">    - PorterStemmer.MARTIN_EXTENSIONS</span>

<span class="sd">        An implementation that only uses the modifications to the</span>
<span class="sd">        algorithm that are included in the implementations on Martin</span>
<span class="sd">        Porter&#39;s website. He has declared Porter frozen, so the</span>
<span class="sd">        behaviour of those implementations should never change.</span>

<span class="sd">    - PorterStemmer.NLTK_EXTENSIONS (default)</span>

<span class="sd">        An implementation that includes further improvements devised by</span>
<span class="sd">        NLTK contributors or taken from other modified implementations</span>
<span class="sd">        found on the web.</span>

<span class="sd">    For the best stemming, you should use the default NLTK_EXTENSIONS</span>
<span class="sd">    version. However, if you need to get the same results as either the</span>
<span class="sd">    original algorithm or one of Martin Porter&#39;s hosted versions for</span>
<span class="sd">    compatibility with an existing implementation or dataset, you can use</span>
<span class="sd">    one of the other modes instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Modes the Stemmer can be instantiated in</span>
    <span class="n">NLTK_EXTENSIONS</span> <span class="o">=</span> <span class="s2">&quot;NLTK_EXTENSIONS&quot;</span>
    <span class="n">MARTIN_EXTENSIONS</span> <span class="o">=</span> <span class="s2">&quot;MARTIN_EXTENSIONS&quot;</span>
    <span class="n">ORIGINAL_ALGORITHM</span> <span class="o">=</span> <span class="s2">&quot;ORIGINAL_ALGORITHM&quot;</span>

<div class="viewcode-block" id="PorterStemmer.__init__"><a class="viewcode-back" href="../../../api/nltk.stem.porter.html#nltk.stem.PorterStemmer.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">NLTK_EXTENSIONS</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MARTIN_EXTENSIONS</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ORIGINAL_ALGORITHM</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Mode must be one of PorterStemmer.NLTK_EXTENSIONS, &quot;</span>
                <span class="s2">&quot;PorterStemmer.MARTIN_EXTENSIONS, or &quot;</span>
                <span class="s2">&quot;PorterStemmer.ORIGINAL_ALGORITHM&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span><span class="p">:</span>
            <span class="c1"># This is a table of irregular forms. It is quite short,</span>
            <span class="c1"># but still reflects the errors actually drawn to Martin</span>
            <span class="c1"># Porter&#39;s attention over a 20 year period!</span>
            <span class="n">irregular_forms</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;sky&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;sky&quot;</span><span class="p">,</span> <span class="s2">&quot;skies&quot;</span><span class="p">],</span>
                <span class="s2">&quot;die&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;dying&quot;</span><span class="p">],</span>
                <span class="s2">&quot;lie&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;lying&quot;</span><span class="p">],</span>
                <span class="s2">&quot;tie&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;tying&quot;</span><span class="p">],</span>
                <span class="s2">&quot;news&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;news&quot;</span><span class="p">],</span>
                <span class="s2">&quot;inning&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;innings&quot;</span><span class="p">,</span> <span class="s2">&quot;inning&quot;</span><span class="p">],</span>
                <span class="s2">&quot;outing&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;outings&quot;</span><span class="p">,</span> <span class="s2">&quot;outing&quot;</span><span class="p">],</span>
                <span class="s2">&quot;canning&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cannings&quot;</span><span class="p">,</span> <span class="s2">&quot;canning&quot;</span><span class="p">],</span>
                <span class="s2">&quot;howe&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;howe&quot;</span><span class="p">],</span>
                <span class="s2">&quot;proceed&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;proceed&quot;</span><span class="p">],</span>
                <span class="s2">&quot;exceed&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;exceed&quot;</span><span class="p">],</span>
                <span class="s2">&quot;succeed&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;succeed&quot;</span><span class="p">],</span>
            <span class="p">}</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">irregular_forms</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">irregular_forms</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vowels</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_is_consonant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if word[i] is a consonant, False otherwise</span>

<span class="sd">        A consonant is defined in the paper as follows:</span>

<span class="sd">            A consonant in a word is a letter other than A, E, I, O or</span>
<span class="sd">            U, and other than Y preceded by a consonant. (The fact that</span>
<span class="sd">            the term `consonant&#39; is defined to some extent in terms of</span>
<span class="sd">            itself does not make it ambiguous.) So in TOY the consonants</span>
<span class="sd">            are T and Y, and in SYZYGY they are S, Z and G. If a letter</span>
<span class="sd">            is not a consonant it is a vowel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">vowels</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the &#39;measure&#39; of stem, per definition in the paper</span>

<span class="sd">        From the paper:</span>

<span class="sd">            A consonant will be denoted by c, a vowel by v. A list</span>
<span class="sd">            ccc... of length greater than 0 will be denoted by C, and a</span>
<span class="sd">            list vvv... of length greater than 0 will be denoted by V.</span>
<span class="sd">            Any word, or part of a word, therefore has one of the four</span>
<span class="sd">            forms:</span>

<span class="sd">                CVCV ... C</span>
<span class="sd">                CVCV ... V</span>
<span class="sd">                VCVC ... C</span>
<span class="sd">                VCVC ... V</span>

<span class="sd">            These may all be represented by the single form</span>

<span class="sd">                [C]VCVC ... [V]</span>

<span class="sd">            where the square brackets denote arbitrary presence of their</span>
<span class="sd">            contents. Using (VC){m} to denote VC repeated m times, this</span>
<span class="sd">            may again be written as</span>

<span class="sd">                [C](VC){m}[V].</span>

<span class="sd">            m will be called the \measure\ of any word or word part when</span>
<span class="sd">            represented in this form. The case m = 0 covers the null</span>
<span class="sd">            word. Here are some examples:</span>

<span class="sd">                m=0    TR,  EE,  TREE,  Y,  BY.</span>
<span class="sd">                m=1    TROUBLE,  OATS,  TREES,  IVY.</span>
<span class="sd">                m=2    TROUBLES,  PRIVATE,  OATEN,  ORRERY.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cv_sequence</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Construct a string of &#39;c&#39;s and &#39;v&#39;s representing whether each</span>
        <span class="c1"># character in `stem` is a consonant or a vowel.</span>
        <span class="c1"># e.g. &#39;falafel&#39; becomes &#39;cvcvcvc&#39;,</span>
        <span class="c1">#      &#39;architecture&#39; becomes &#39;vcccvcvccvcv&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stem</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">cv_sequence</span> <span class="o">+=</span> <span class="s2">&quot;c&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cv_sequence</span> <span class="o">+=</span> <span class="s2">&quot;v&quot;</span>

        <span class="c1"># Count the number of &#39;vc&#39; occurrences, which is equivalent to</span>
        <span class="c1"># the number of &#39;VC&#39; occurrences in Porter&#39;s reduced form in the</span>
        <span class="c1"># docstring above, which is in turn equivalent to `m`</span>
        <span class="k">return</span> <span class="n">cv_sequence</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;vc&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_has_positive_measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_contains_vowel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if stem contains a vowel, else False&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stem</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_ends_double_consonant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements condition *d from the paper</span>

<span class="sd">        Returns True if word ends with a double consonant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ends_cvc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements condition *o from the paper</span>

<span class="sd">        From the paper:</span>

<span class="sd">            *o  - the stem ends cvc, where the second c is not W, X or Y</span>
<span class="sd">                  (e.g. -WIL, -HOP).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">word</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replace_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">replacement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replaces `suffix` of `word` with `replacement&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffix</span><span class="p">),</span> <span class="s2">&quot;Given word doesn&#39;t end with given suffix&quot;</span>
        <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">word</span> <span class="o">+</span> <span class="n">replacement</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">word</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">suffix</span><span class="p">)]</span> <span class="o">+</span> <span class="n">replacement</span>

    <span class="k">def</span> <span class="nf">_apply_rule_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">rules</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies the first applicable suffix-removal rule to the word</span>

<span class="sd">        Takes a word and a list of suffix-removal rules represented as</span>
<span class="sd">        3-tuples, with the first element being the suffix to remove,</span>
<span class="sd">        the second element being the string to replace it with, and the</span>
<span class="sd">        final element being the condition for the rule to be applicable,</span>
<span class="sd">        or None if the rule is unconditional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
            <span class="n">suffix</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">rule</span>
            <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;*d&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ends_double_consonant</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
                <span class="n">stem</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">condition</span><span class="p">(</span><span class="n">stem</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">stem</span> <span class="o">+</span> <span class="n">replacement</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t try any further rules</span>
                    <span class="k">return</span> <span class="n">word</span>
            <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
                <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">condition</span><span class="p">(</span><span class="n">stem</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">stem</span> <span class="o">+</span> <span class="n">replacement</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t try any further rules</span>
                    <span class="k">return</span> <span class="n">word</span>

        <span class="k">return</span> <span class="n">word</span>

    <span class="k">def</span> <span class="nf">_step1a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 1a from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        From the paper:</span>

<span class="sd">            SSES -&gt; SS                         caresses  -&gt;  caress</span>
<span class="sd">            IES  -&gt; I                          ponies    -&gt;  poni</span>
<span class="sd">                                               ties      -&gt;  ti</span>
<span class="sd">            SS   -&gt; SS                         caress    -&gt;  caress</span>
<span class="sd">            S    -&gt;                            cats      -&gt;  cat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this NLTK-only rule extends the original algorithm, so</span>
        <span class="c1"># that &#39;flies&#39;-&gt;&#39;fli&#39; but &#39;dies&#39;-&gt;&#39;die&#39; etc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;ies&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;ies&quot;</span><span class="p">,</span> <span class="s2">&quot;ie&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rule_list</span><span class="p">(</span>
            <span class="n">word</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;sses&quot;</span><span class="p">,</span> <span class="s2">&quot;ss&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># SSES -&gt; SS</span>
                <span class="p">(</span><span class="s2">&quot;ies&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># IES  -&gt; I</span>
                <span class="p">(</span><span class="s2">&quot;ss&quot;</span><span class="p">,</span> <span class="s2">&quot;ss&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># SS   -&gt; SS</span>
                <span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># S    -&gt;</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step1b</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 1b from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        From the paper:</span>

<span class="sd">            (m&gt;0) EED -&gt; EE                    feed      -&gt;  feed</span>
<span class="sd">                                               agreed    -&gt;  agree</span>
<span class="sd">            (*v*) ED  -&gt;                       plastered -&gt;  plaster</span>
<span class="sd">                                               bled      -&gt;  bled</span>
<span class="sd">            (*v*) ING -&gt;                       motoring  -&gt;  motor</span>
<span class="sd">                                               sing      -&gt;  sing</span>

<span class="sd">        If the second or third of the rules in Step 1b is successful,</span>
<span class="sd">        the following is done:</span>

<span class="sd">            AT -&gt; ATE                       conflat(ed)  -&gt;  conflate</span>
<span class="sd">            BL -&gt; BLE                       troubl(ed)   -&gt;  trouble</span>
<span class="sd">            IZ -&gt; IZE                       siz(ed)      -&gt;  size</span>
<span class="sd">            (*d and not (*L or *S or *Z))</span>
<span class="sd">               -&gt; single letter</span>
<span class="sd">                                            hopp(ing)    -&gt;  hop</span>
<span class="sd">                                            tann(ed)     -&gt;  tan</span>
<span class="sd">                                            fall(ing)    -&gt;  fall</span>
<span class="sd">                                            hiss(ing)    -&gt;  hiss</span>
<span class="sd">                                            fizz(ed)     -&gt;  fizz</span>
<span class="sd">            (m=1 and *o) -&gt; E               fail(ing)    -&gt;  fail</span>
<span class="sd">                                            fil(ing)     -&gt;  file</span>

<span class="sd">        The rule to map to a single letter causes the removal of one of</span>
<span class="sd">        the double letter pair. The -E is put back on -AT, -BL and -IZ,</span>
<span class="sd">        so that the suffixes -ATE, -BLE and -IZE can be recognised</span>
<span class="sd">        later. This E may be removed in step 4.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this NLTK-only block extends the original algorithm, so that</span>
        <span class="c1"># &#39;spied&#39;-&gt;&#39;spi&#39; but &#39;died&#39;-&gt;&#39;die&#39; etc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;ied&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;ied&quot;</span><span class="p">,</span> <span class="s2">&quot;ie&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;ied&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">)</span>

        <span class="c1"># (m&gt;0) EED -&gt; EE</span>
        <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;eed&quot;</span><span class="p">):</span>
            <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;eed&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;ee&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">word</span>

        <span class="n">rule_2_or_3_succeeded</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ed&quot;</span><span class="p">,</span> <span class="s2">&quot;ing&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
                <span class="n">intermediate_stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_vowel</span><span class="p">(</span><span class="n">intermediate_stem</span><span class="p">):</span>
                    <span class="n">rule_2_or_3_succeeded</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rule_2_or_3_succeeded</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">word</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rule_list</span><span class="p">(</span>
            <span class="n">intermediate_stem</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;at&quot;</span><span class="p">,</span> <span class="s2">&quot;ate&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># AT -&gt; ATE</span>
                <span class="p">(</span><span class="s2">&quot;bl&quot;</span><span class="p">,</span> <span class="s2">&quot;ble&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># BL -&gt; BLE</span>
                <span class="p">(</span><span class="s2">&quot;iz&quot;</span><span class="p">,</span> <span class="s2">&quot;ize&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>  <span class="c1"># IZ -&gt; IZE</span>
                <span class="c1"># (*d and not (*L or *S or *Z))</span>
                <span class="c1"># -&gt; single letter</span>
                <span class="p">(</span>
                    <span class="s2">&quot;*d&quot;</span><span class="p">,</span>
                    <span class="n">intermediate_stem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="k">lambda</span> <span class="n">stem</span><span class="p">:</span> <span class="n">intermediate_stem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="c1"># (m=1 and *o) -&gt; E</span>
                <span class="p">(</span>
                    <span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;e&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">stem</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ends_cvc</span><span class="p">(</span><span class="n">stem</span><span class="p">)),</span>
                <span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step1c</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 1c from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        From the paper:</span>

<span class="sd">        Step 1c</span>

<span class="sd">            (*v*) Y -&gt; I                    happy        -&gt;  happi</span>
<span class="sd">                                            sky          -&gt;  sky</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">nltk_condition</span><span class="p">(</span><span class="n">stem</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This has been modified from the original Porter algorithm so</span>
<span class="sd">            that y-&gt;i is only done when y is preceded by a consonant,</span>
<span class="sd">            but not if the stem is only a single consonant, i.e.</span>

<span class="sd">               (*c and not c) Y -&gt; I</span>

<span class="sd">            So &#39;happy&#39; -&gt; &#39;happi&#39;, but</span>
<span class="sd">               &#39;enjoy&#39; -&gt; &#39;enjoy&#39;  etc</span>

<span class="sd">            This is a much better rule. Formerly &#39;enjoy&#39;-&gt;&#39;enjoi&#39; and</span>
<span class="sd">            &#39;enjoyment&#39;-&gt;&#39;enjoy&#39;. Step 1c is perhaps done too soon; but</span>
<span class="sd">            with this modification that no longer really matters.</span>

<span class="sd">            Also, the removal of the contains_vowel(z) condition means</span>
<span class="sd">            that &#39;spy&#39;, &#39;fly&#39;, &#39;try&#39; ... stem to &#39;spi&#39;, &#39;fli&#39;, &#39;tri&#39; and</span>
<span class="sd">            conflate with &#39;spied&#39;, &#39;tried&#39;, &#39;flies&#39; ...</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_consonant</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">original_condition</span><span class="p">(</span><span class="n">stem</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_vowel</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rule_list</span><span class="p">(</span>
            <span class="n">word</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="s2">&quot;y&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;i&quot;</span><span class="p">,</span>
                    <span class="n">nltk_condition</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span>
                    <span class="k">else</span> <span class="n">original_condition</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 2 from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        From the paper:</span>

<span class="sd">        Step 2</span>

<span class="sd">            (m&gt;0) ATIONAL -&gt;  ATE       relational     -&gt;  relate</span>
<span class="sd">            (m&gt;0) TIONAL  -&gt;  TION      conditional    -&gt;  condition</span>
<span class="sd">                                        rational       -&gt;  rational</span>
<span class="sd">            (m&gt;0) ENCI    -&gt;  ENCE      valenci        -&gt;  valence</span>
<span class="sd">            (m&gt;0) ANCI    -&gt;  ANCE      hesitanci      -&gt;  hesitance</span>
<span class="sd">            (m&gt;0) IZER    -&gt;  IZE       digitizer      -&gt;  digitize</span>
<span class="sd">            (m&gt;0) ABLI    -&gt;  ABLE      conformabli    -&gt;  conformable</span>
<span class="sd">            (m&gt;0) ALLI    -&gt;  AL        radicalli      -&gt;  radical</span>
<span class="sd">            (m&gt;0) ENTLI   -&gt;  ENT       differentli    -&gt;  different</span>
<span class="sd">            (m&gt;0) ELI     -&gt;  E         vileli        - &gt;  vile</span>
<span class="sd">            (m&gt;0) OUSLI   -&gt;  OUS       analogousli    -&gt;  analogous</span>
<span class="sd">            (m&gt;0) IZATION -&gt;  IZE       vietnamization -&gt;  vietnamize</span>
<span class="sd">            (m&gt;0) ATION   -&gt;  ATE       predication    -&gt;  predicate</span>
<span class="sd">            (m&gt;0) ATOR    -&gt;  ATE       operator       -&gt;  operate</span>
<span class="sd">            (m&gt;0) ALISM   -&gt;  AL        feudalism      -&gt;  feudal</span>
<span class="sd">            (m&gt;0) IVENESS -&gt;  IVE       decisiveness   -&gt;  decisive</span>
<span class="sd">            (m&gt;0) FULNESS -&gt;  FUL       hopefulness    -&gt;  hopeful</span>
<span class="sd">            (m&gt;0) OUSNESS -&gt;  OUS       callousness    -&gt;  callous</span>
<span class="sd">            (m&gt;0) ALITI   -&gt;  AL        formaliti      -&gt;  formal</span>
<span class="sd">            (m&gt;0) IVITI   -&gt;  IVE       sensitiviti    -&gt;  sensitive</span>
<span class="sd">            (m&gt;0) BILITI  -&gt;  BLE       sensibiliti    -&gt;  sensible</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span><span class="p">:</span>
            <span class="c1"># Instead of applying the ALLI -&gt; AL rule after &#39;(a)bli&#39; per</span>
            <span class="c1"># the published algorithm, instead we apply it first, and,</span>
            <span class="c1"># if it succeeds, run the result through step2 again.</span>
            <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;alli&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;alli&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;alli&quot;</span><span class="p">,</span> <span class="s2">&quot;al&quot;</span><span class="p">))</span>

        <span class="n">bli_rule</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;bli&quot;</span><span class="p">,</span> <span class="s2">&quot;ble&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">)</span>
        <span class="n">abli_rule</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;abli&quot;</span><span class="p">,</span> <span class="s2">&quot;able&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">)</span>

        <span class="n">rules</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;ational&quot;</span><span class="p">,</span> <span class="s2">&quot;ate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;tional&quot;</span><span class="p">,</span> <span class="s2">&quot;tion&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;enci&quot;</span><span class="p">,</span> <span class="s2">&quot;ence&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;anci&quot;</span><span class="p">,</span> <span class="s2">&quot;ance&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;izer&quot;</span><span class="p">,</span> <span class="s2">&quot;ize&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="n">abli_rule</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ORIGINAL_ALGORITHM</span> <span class="k">else</span> <span class="n">bli_rule</span><span class="p">,</span>
            <span class="p">(</span><span class="s2">&quot;alli&quot;</span><span class="p">,</span> <span class="s2">&quot;al&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;entli&quot;</span><span class="p">,</span> <span class="s2">&quot;ent&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;eli&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ousli&quot;</span><span class="p">,</span> <span class="s2">&quot;ous&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ization&quot;</span><span class="p">,</span> <span class="s2">&quot;ize&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ation&quot;</span><span class="p">,</span> <span class="s2">&quot;ate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ator&quot;</span><span class="p">,</span> <span class="s2">&quot;ate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;alism&quot;</span><span class="p">,</span> <span class="s2">&quot;al&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;iveness&quot;</span><span class="p">,</span> <span class="s2">&quot;ive&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;fulness&quot;</span><span class="p">,</span> <span class="s2">&quot;ful&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ousness&quot;</span><span class="p">,</span> <span class="s2">&quot;ous&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;aliti&quot;</span><span class="p">,</span> <span class="s2">&quot;al&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;iviti&quot;</span><span class="p">,</span> <span class="s2">&quot;ive&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;biliti&quot;</span><span class="p">,</span> <span class="s2">&quot;ble&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;fulli&quot;</span><span class="p">,</span> <span class="s2">&quot;ful&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">))</span>

            <span class="c1"># The &#39;l&#39; of the &#39;logi&#39; -&gt; &#39;log&#39; rule is put with the stem,</span>
            <span class="c1"># so that short stems like &#39;geo&#39; &#39;theo&#39; etc work like</span>
            <span class="c1"># &#39;archaeo&#39; &#39;philo&#39; etc.</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">&quot;logi&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">stem</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]))</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">MARTIN_EXTENSIONS</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;logi&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rule_list</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">rules</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 3 from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        From the paper:</span>

<span class="sd">        Step 3</span>

<span class="sd">            (m&gt;0) ICATE -&gt;  IC              triplicate     -&gt;  triplic</span>
<span class="sd">            (m&gt;0) ATIVE -&gt;                  formative      -&gt;  form</span>
<span class="sd">            (m&gt;0) ALIZE -&gt;  AL              formalize      -&gt;  formal</span>
<span class="sd">            (m&gt;0) ICITI -&gt;  IC              electriciti    -&gt;  electric</span>
<span class="sd">            (m&gt;0) ICAL  -&gt;  IC              electrical     -&gt;  electric</span>
<span class="sd">            (m&gt;0) FUL   -&gt;                  hopeful        -&gt;  hope</span>
<span class="sd">            (m&gt;0) NESS  -&gt;                  goodness       -&gt;  good</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rule_list</span><span class="p">(</span>
            <span class="n">word</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;icate&quot;</span><span class="p">,</span> <span class="s2">&quot;ic&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ative&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;alize&quot;</span><span class="p">,</span> <span class="s2">&quot;al&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;iciti&quot;</span><span class="p">,</span> <span class="s2">&quot;ic&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ical&quot;</span><span class="p">,</span> <span class="s2">&quot;ic&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ful&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ness&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_positive_measure</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 4 from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        Step 4</span>

<span class="sd">            (m&gt;1) AL    -&gt;                  revival        -&gt;  reviv</span>
<span class="sd">            (m&gt;1) ANCE  -&gt;                  allowance      -&gt;  allow</span>
<span class="sd">            (m&gt;1) ENCE  -&gt;                  inference      -&gt;  infer</span>
<span class="sd">            (m&gt;1) ER    -&gt;                  airliner       -&gt;  airlin</span>
<span class="sd">            (m&gt;1) IC    -&gt;                  gyroscopic     -&gt;  gyroscop</span>
<span class="sd">            (m&gt;1) ABLE  -&gt;                  adjustable     -&gt;  adjust</span>
<span class="sd">            (m&gt;1) IBLE  -&gt;                  defensible     -&gt;  defens</span>
<span class="sd">            (m&gt;1) ANT   -&gt;                  irritant       -&gt;  irrit</span>
<span class="sd">            (m&gt;1) EMENT -&gt;                  replacement    -&gt;  replac</span>
<span class="sd">            (m&gt;1) MENT  -&gt;                  adjustment     -&gt;  adjust</span>
<span class="sd">            (m&gt;1) ENT   -&gt;                  dependent      -&gt;  depend</span>
<span class="sd">            (m&gt;1 and (*S or *T)) ION -&gt;     adoption       -&gt;  adopt</span>
<span class="sd">            (m&gt;1) OU    -&gt;                  homologou      -&gt;  homolog</span>
<span class="sd">            (m&gt;1) ISM   -&gt;                  communism      -&gt;  commun</span>
<span class="sd">            (m&gt;1) ATE   -&gt;                  activate       -&gt;  activ</span>
<span class="sd">            (m&gt;1) ITI   -&gt;                  angulariti     -&gt;  angular</span>
<span class="sd">            (m&gt;1) OUS   -&gt;                  homologous     -&gt;  homolog</span>
<span class="sd">            (m&gt;1) IVE   -&gt;                  effective      -&gt;  effect</span>
<span class="sd">            (m&gt;1) IZE   -&gt;                  bowdlerize     -&gt;  bowdler</span>

<span class="sd">        The suffixes are now removed. All that remains is a little</span>
<span class="sd">        tidying up.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">measure_gt_1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">stem</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rule_list</span><span class="p">(</span>
            <span class="n">word</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;al&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ance&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ence&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;er&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ic&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;able&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ible&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ant&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ement&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ment&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ent&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="c1"># (m&gt;1 and (*S or *T)) ION -&gt;</span>
                <span class="p">(</span>
                    <span class="s2">&quot;ion&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;&quot;</span><span class="p">,</span>
                    <span class="k">lambda</span> <span class="n">stem</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">stem</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">),</span>
                <span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ou&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ism&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ate&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;iti&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ous&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ive&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;ize&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">measure_gt_1</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step5a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 5a from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        From the paper:</span>

<span class="sd">        Step 5a</span>

<span class="sd">            (m&gt;1) E     -&gt;                  probate        -&gt;  probat</span>
<span class="sd">                                            rate           -&gt;  rate</span>
<span class="sd">            (m=1 and not *o) E -&gt;           cease          -&gt;  ceas</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note that Martin&#39;s test vocabulary and reference</span>
        <span class="c1"># implementations are inconsistent in how they handle the case</span>
        <span class="c1"># where two rules both refer to a suffix that matches the word</span>
        <span class="c1"># to be stemmed, but only the condition of the second one is</span>
        <span class="c1"># true.</span>
        <span class="c1"># Earlier in step2b we had the rules:</span>
        <span class="c1">#     (m&gt;0) EED -&gt; EE</span>
        <span class="c1">#     (*v*) ED  -&gt;</span>
        <span class="c1"># but the examples in the paper included &quot;feed&quot;-&gt;&quot;feed&quot;, even</span>
        <span class="c1"># though (*v*) is true for &quot;fe&quot; and therefore the second rule</span>
        <span class="c1"># alone would map &quot;feed&quot;-&gt;&quot;fe&quot;.</span>
        <span class="c1"># However, in THIS case, we need to handle the consecutive rules</span>
        <span class="c1"># differently and try both conditions (obviously; the second</span>
        <span class="c1"># rule here would be redundant otherwise). Martin&#39;s paper makes</span>
        <span class="c1"># no explicit mention of the inconsistency; you have to infer it</span>
        <span class="c1"># from the examples.</span>
        <span class="c1"># For this reason, we can&#39;t use _apply_rule_list here.</span>
        <span class="k">if</span> <span class="n">word</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">):</span>
            <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_suffix</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">stem</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ends_cvc</span><span class="p">(</span><span class="n">stem</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">stem</span>
        <span class="k">return</span> <span class="n">word</span>

    <span class="k">def</span> <span class="nf">_step5b</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements Step 5a from &quot;An algorithm for suffix stripping&quot;</span>

<span class="sd">        From the paper:</span>

<span class="sd">        Step 5b</span>

<span class="sd">            (m &gt; 1 and *d and *L) -&gt; single letter</span>
<span class="sd">                                    controll       -&gt;  control</span>
<span class="sd">                                    roll           -&gt;  roll</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_rule_list</span><span class="p">(</span>
            <span class="n">word</span><span class="p">,</span> <span class="p">[(</span><span class="s2">&quot;ll&quot;</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">stem</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_measure</span><span class="p">(</span><span class="n">word</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="PorterStemmer.stem"><a class="viewcode-back" href="../../../api/nltk.stem.porter.html#nltk.stem.PorterStemmer.stem">[docs]</a>    <span class="k">def</span> <span class="nf">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">to_lowercase</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param to_lowercase: if `to_lowercase=True` the word always lowercase</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">if</span> <span class="n">to_lowercase</span> <span class="k">else</span> <span class="n">word</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NLTK_EXTENSIONS</span> <span class="ow">and</span> <span class="n">word</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ORIGINAL_ALGORITHM</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># With this line, strings of length 1 or 2 don&#39;t go through</span>
            <span class="c1"># the stemming process, although no mention is made of this</span>
            <span class="c1"># in the published algorithm.</span>
            <span class="k">return</span> <span class="n">stem</span>

        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step1a</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step1b</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step1c</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step2</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step3</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step4</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step5a</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">stem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step5b</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stem</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;PorterStemmer&gt;&quot;</span></div>


<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.stem.porter.html#nltk.stem.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration of the porter stemmer on a sample from</span>
<span class="sd">    the Penn Treebank corpus.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">stem</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">treebank</span>

    <span class="n">stemmer</span> <span class="o">=</span> <span class="n">stem</span><span class="o">.</span><span class="n">PorterStemmer</span><span class="p">()</span>

    <span class="n">orig</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stemmed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">treebank</span><span class="o">.</span><span class="n">fileids</span><span class="p">()[:</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">treebank</span><span class="o">.</span><span class="n">tagged_words</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">orig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">stemmed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stemmer</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>

    <span class="c1"># Convert the results to a string, and word-wrap them.</span>
    <span class="n">results</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stemmed</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.{,70})\s&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\1\n&quot;</span><span class="p">,</span> <span class="n">results</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

    <span class="c1"># Convert the original to a string, and word wrap it.</span>
    <span class="n">original</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">orig</span><span class="p">)</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.{,70})\s&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\1\n&quot;</span><span class="p">,</span> <span class="n">original</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

    <span class="c1"># Print the results.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-Original-&quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-Results-&quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*&quot;</span> <span class="o">*</span> <span class="mi">70</span><span class="p">)</span></div>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>