<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.tgrep</title>
  

  <link rel="stylesheet" href="../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.tgrep</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1">#</span>
<span class="c1"># Natural Language Toolkit: TGrep search</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Will Roberts &lt;wildwilhelm@gmail.com&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">============================================</span>
<span class="sd"> TGrep search implementation for NLTK trees</span>
<span class="sd">============================================</span>

<span class="sd">This module supports TGrep2 syntax for matching parts of NLTK Trees.</span>
<span class="sd">Note that many tgrep operators require the tree passed to be a</span>
<span class="sd">``ParentedTree``.</span>

<span class="sd">External links:</span>

<span class="sd">- `Tgrep tutorial &lt;https://www.stanford.edu/dept/linguistics/corpora/cas-tut-tgrep.html&gt;`_</span>
<span class="sd">- `Tgrep2 manual &lt;http://tedlab.mit.edu/~dr/Tgrep2/tgrep2.pdf&gt;`_</span>
<span class="sd">- `Tgrep2 source &lt;http://tedlab.mit.edu/~dr/Tgrep2/&gt;`_</span>

<span class="sd">Usage</span>
<span class="sd">=====</span>

<span class="sd">&gt;&gt;&gt; from nltk.tree import ParentedTree</span>
<span class="sd">&gt;&gt;&gt; from nltk.tgrep import tgrep_nodes, tgrep_positions</span>
<span class="sd">&gt;&gt;&gt; tree = ParentedTree.fromstring(&#39;(S (NP (DT the) (JJ big) (NN dog)) (VP bit) (NP (DT a) (NN cat)))&#39;)</span>
<span class="sd">&gt;&gt;&gt; list(tgrep_nodes(&#39;NN&#39;, [tree]))</span>
<span class="sd">[[ParentedTree(&#39;NN&#39;, [&#39;dog&#39;]), ParentedTree(&#39;NN&#39;, [&#39;cat&#39;])]]</span>
<span class="sd">&gt;&gt;&gt; list(tgrep_positions(&#39;NN&#39;, [tree]))</span>
<span class="sd">[[(0, 2), (2, 1)]]</span>
<span class="sd">&gt;&gt;&gt; list(tgrep_nodes(&#39;DT&#39;, [tree]))</span>
<span class="sd">[[ParentedTree(&#39;DT&#39;, [&#39;the&#39;]), ParentedTree(&#39;DT&#39;, [&#39;a&#39;])]]</span>
<span class="sd">&gt;&gt;&gt; list(tgrep_nodes(&#39;DT $ JJ&#39;, [tree]))</span>
<span class="sd">[[ParentedTree(&#39;DT&#39;, [&#39;the&#39;])]]</span>

<span class="sd">This implementation adds syntax to select nodes based on their NLTK</span>
<span class="sd">tree position.  This syntax is ``N`` plus a Python tuple representing</span>
<span class="sd">the tree position.  For instance, ``N()``, ``N(0,)``, ``N(0,0)`` are</span>
<span class="sd">valid node selectors.  Example:</span>

<span class="sd">&gt;&gt;&gt; tree = ParentedTree.fromstring(&#39;(S (NP (DT the) (JJ big) (NN dog)) (VP bit) (NP (DT a) (NN cat)))&#39;)</span>
<span class="sd">&gt;&gt;&gt; tree[0,0]</span>
<span class="sd">ParentedTree(&#39;DT&#39;, [&#39;the&#39;])</span>
<span class="sd">&gt;&gt;&gt; tree[0,0].treeposition()</span>
<span class="sd">(0, 0)</span>
<span class="sd">&gt;&gt;&gt; list(tgrep_nodes(&#39;N(0,0)&#39;, [tree]))</span>
<span class="sd">[[ParentedTree(&#39;DT&#39;, [&#39;the&#39;])]]</span>

<span class="sd">Caveats:</span>
<span class="sd">========</span>

<span class="sd">- Link modifiers: &quot;?&quot; and &quot;=&quot; are not implemented.</span>
<span class="sd">- Tgrep compatibility: Using &quot;@&quot; for &quot;!&quot;, &quot;{&quot; for &quot;&lt;&quot;, &quot;}&quot; for &quot;&gt;&quot; are</span>
<span class="sd">  not implemented.</span>
<span class="sd">- The &quot;=&quot; and &quot;~&quot; links are not implemented.</span>

<span class="sd">Known Issues:</span>
<span class="sd">=============</span>

<span class="sd">- There are some issues with link relations involving leaf nodes</span>
<span class="sd">  (which are represented as bare strings in NLTK trees).  For</span>
<span class="sd">  instance, consider the tree::</span>

<span class="sd">      (S (A x))</span>

<span class="sd">  The search string ``* !&gt;&gt; S`` should select all nodes which are not</span>
<span class="sd">  dominated in some way by an ``S`` node (i.e., all nodes which are</span>
<span class="sd">  not descendants of an ``S``).  Clearly, in this tree, the only node</span>
<span class="sd">  which fulfills this criterion is the top node (since it is not</span>
<span class="sd">  dominated by anything).  However, the code here will find both the</span>
<span class="sd">  top node and the leaf node ``x``.  This is because we cannot recover</span>
<span class="sd">  the parent of the leaf, since it is stored as a bare string.</span>

<span class="sd">  A possible workaround, when performing this kind of search, would be</span>
<span class="sd">  to filter out all leaf nodes.</span>

<span class="sd">Implementation notes</span>
<span class="sd">====================</span>

<span class="sd">This implementation is (somewhat awkwardly) based on lambda functions</span>
<span class="sd">which are predicates on a node.  A predicate is a function which is</span>
<span class="sd">either True or False; using a predicate function, we can identify sets</span>
<span class="sd">of nodes with particular properties.  A predicate function, could, for</span>
<span class="sd">instance, return True only if a particular node has a label matching a</span>
<span class="sd">particular regular expression, and has a daughter node which has no</span>
<span class="sd">sisters.  Because tgrep2 search strings can do things statefully (such</span>
<span class="sd">as substituting in macros, and binding nodes with node labels), the</span>
<span class="sd">actual predicate function is declared with three arguments::</span>

<span class="sd">    pred = lambda n, m, l: return True # some logic here</span>

<span class="sd">``n``</span>
<span class="sd">    is a node in a tree; this argument must always be given</span>

<span class="sd">``m``</span>
<span class="sd">    contains a dictionary, mapping macro names onto predicate functions</span>

<span class="sd">``l``</span>
<span class="sd">    is a dictionary to map node labels onto nodes in the tree</span>

<span class="sd">``m`` and ``l`` are declared to default to ``None``, and so need not be</span>
<span class="sd">specified in a call to a predicate.  Predicates which call other</span>
<span class="sd">predicates must always pass the value of these arguments on.  The</span>
<span class="sd">top-level predicate (constructed by ``_tgrep_exprs_action``) binds the</span>
<span class="sd">macro definitions to ``m`` and initialises ``l`` to an empty dictionary.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyparsing</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: nltk.tgrep will not work without the `pyparsing` package&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;installed.&quot;</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">nltk.tree</span>


<div class="viewcode-block" id="TgrepException"><a class="viewcode-back" href="../../api/nltk.tgrep.html#nltk.tgrep.TgrepException">[docs]</a><span class="k">class</span> <span class="nc">TgrepException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tgrep exception type.&quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<div class="viewcode-block" id="ancestors"><a class="viewcode-back" href="../../api/nltk.tgrep.ancestors.html#nltk.tgrep.ancestors">[docs]</a><span class="k">def</span> <span class="nf">ancestors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the list of all nodes dominating the given tree node.</span>
<span class="sd">    This method will not work with leaf nodes, since there is no way</span>
<span class="sd">    to recover the parent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># if node is a leaf, we cannot retrieve its parent</span>
        <span class="k">return</span> <span class="n">results</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="unique_ancestors"><a class="viewcode-back" href="../../api/nltk.tgrep.unique_ancestors.html#nltk.tgrep.unique_ancestors">[docs]</a><span class="k">def</span> <span class="nf">unique_ancestors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the list of all nodes dominating the given node, where</span>
<span class="sd">    there is only a single path of descent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># if node is a leaf, we cannot retrieve its parent</span>
        <span class="k">return</span> <span class="n">results</span>
    <span class="k">while</span> <span class="n">current</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">results</span></div>


<span class="k">def</span> <span class="nf">_descendants</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the list of all nodes which are descended from the given</span>
<span class="sd">    tree node in some way.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">treepos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">treepositions</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">treepos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>


<span class="k">def</span> <span class="nf">_leftmost_descendants</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the set of all nodes descended in some way through</span>
<span class="sd">    left branches from this node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">treepos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">treepositions</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">treepos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_rightmost_descendants</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the set of all nodes descended in some way through</span>
<span class="sd">    right branches from this node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rightmost_leaf</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">treepositions</span><span class="p">())</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="n">rightmost_leaf</span><span class="p">[:</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rightmost_leaf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_istree</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Predicate to check whether `obj` is a nltk.tree.Tree.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">nltk</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">Tree</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unique_descendants</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the list of all nodes descended from the given node, where</span>
<span class="sd">    there is only a single path of descent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">node</span>
    <span class="k">while</span> <span class="n">current</span> <span class="ow">and</span> <span class="n">_istree</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span> <span class="nf">_before</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the set of all nodes that are before the given node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">treeposition</span><span class="p">()</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">root</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]]</span>


<span class="k">def</span> <span class="nf">_immediately_before</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the set of all nodes that are immediately before the given</span>
<span class="sd">    node.</span>

<span class="sd">    Tree node A immediately precedes node B if the last terminal</span>
<span class="sd">    symbol (word) produced by A immediately precedes the first</span>
<span class="sd">    terminal symbol produced by B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">treeposition</span><span class="p">()</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">root</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="c1"># go &quot;upwards&quot; from pos until there is a place we can go to the left</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="ow">and</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pos</span><span class="p">[:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">before</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">before</span><span class="p">]</span> <span class="o">+</span> <span class="n">_rightmost_descendants</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_after</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the set of all nodes that are after the given node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">treeposition</span><span class="p">()</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">root</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="n">pos</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]]</span>


<span class="k">def</span> <span class="nf">_immediately_after</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the set of all nodes that are immediately after the given</span>
<span class="sd">    node.</span>

<span class="sd">    Tree node A immediately follows node B if the first terminal</span>
<span class="sd">    symbol (word) produced by A immediately follows the last</span>
<span class="sd">    terminal symbol produced by B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">treeposition</span><span class="p">()</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">root</span><span class="p">()</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="c1"># go &quot;upwards&quot; from pos until there is a place we can go to the</span>
    <span class="c1"># right</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="ow">and</span> <span class="n">pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pos</span><span class="p">[:</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">after</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">after</span><span class="p">]</span> <span class="o">+</span> <span class="n">_leftmost_descendants</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tgrep_node_literal_value</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets the string value of a given parse tree node, for comparison</span>
<span class="sd">    using the tgrep node literal predicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">()</span> <span class="k">if</span> <span class="n">_istree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tgrep_macro_use_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function which looks up the macro name used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;@&quot;</span>
    <span class="n">macro_name</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">macro_use</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">macro_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TgrepException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;macro </span><span class="si">{</span><span class="n">macro_name</span><span class="si">}</span><span class="s2"> not defined&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">macro_name</span><span class="p">](</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">macro_use</span>


<span class="k">def</span> <span class="nf">_tgrep_node_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    depending on the name of its node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span>
        <span class="c1"># strip initial apostrophe (tgrep2 print command)</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># disjunctive definition of a node name</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;|&quot;</span><span class="p">]</span>
        <span class="c1"># recursively call self to interpret each node name definition</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">_tgrep_node_action</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">[::</span><span class="mi">2</span><span class="p">]]</span>
        <span class="c1"># capture tokens and return the disjunction</span>
        <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">t</span><span class="p">))(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;__call__&quot;</span><span class="p">):</span>
            <span class="c1"># this is a previously interpreted parenthetical node</span>
            <span class="c1"># definition (lambda function)</span>
            <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span> <span class="ow">or</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;__&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>
            <span class="n">node_lit</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">_tgrep_node_literal_value</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span>
            <span class="p">)(</span><span class="n">node_lit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">node_lit</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
                    <span class="n">_tgrep_node_literal_value</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">node_lit</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;i@&quot;</span><span class="p">):</span>
            <span class="n">node_func</span> <span class="o">=</span> <span class="n">_tgrep_node_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="p">[</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()])</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span>
                    <span class="n">_tgrep_node_literal_value</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)(</span><span class="n">node_func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">_tgrep_node_literal_value</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span>
            <span class="p">)(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_tgrep_parens_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    from a parenthetical notation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;(&quot;</span>
    <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span>
    <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_tgrep_nltk_tree_pos_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    which returns true if the node is located at a specific tree</span>
<span class="sd">    position.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># recover the tuple from the parsed string</span>
    <span class="n">node_tree_position</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">isdigit</span><span class="p">())</span>
    <span class="c1"># capture the node&#39;s tree position</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;treeposition&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">treeposition</span><span class="p">()</span> <span class="o">==</span> <span class="n">i</span>
        <span class="p">)</span>
    <span class="p">)(</span><span class="n">node_tree_position</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tgrep_relation_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    depending on its relation to other nodes in the tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># process negation first if needed</span>
    <span class="n">negated</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;!&quot;</span><span class="p">:</span>
        <span class="n">negated</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;[&quot;</span><span class="p">:</span>
        <span class="c1"># process square-bracketed relation expressions</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;]&quot;</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># process operator-node relation expressions</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">operator</span><span class="p">,</span> <span class="n">predicate</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="c1"># A &lt; B       A is the parent of (immediately dominates) B.</span>
        <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &gt; B       A is the child of B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &lt;, B      Synonymous with A &lt;1 B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;,&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;1&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &gt;, B      Synonymous with A &gt;1 B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;,&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;1&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &lt;N B      B is the Nth child of A (the first child is &lt;1).</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&lt;&quot;</span> <span class="ow">and</span> <span class="n">operator</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">operator</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c1"># capture the index parameter</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                    <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># A &gt;N B      A is the Nth child of B (the first child is &gt;1).</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span> <span class="ow">and</span> <span class="n">operator</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">operator</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c1"># capture the index parameter</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                    <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>
                    <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)(</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># A &lt;&#39; B      B is the last child of A (also synonymous with A &lt;-1 B).</span>
        <span class="c1"># A &lt;- B      B is the last child of A (synonymous with A &lt;-1 B).</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;&#39;&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;-1&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &gt;&#39; B      A is the last child of B (also synonymous with A &gt;-1 B).</span>
        <span class="c1"># A &gt;- B      A is the last child of B (synonymous with A &gt;-1 B).</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;&#39;&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;-&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;-1&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &lt;-N B 	  B is the N th-to-last child of A (the last child is &lt;-1).</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&lt;-&quot;</span> <span class="ow">and</span> <span class="n">operator</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">operator</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="c1"># capture the index parameter</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                    <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)],</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1"># A &gt;-N B 	  A is the N th-to-last child of B (the last child is &gt;-1).</span>
        <span class="k">elif</span> <span class="n">operator</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&gt;-&quot;</span> <span class="ow">and</span> <span class="n">operator</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">operator</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="c1"># capture the index parameter</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                    <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                    <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()[</span><span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())])</span>
                    <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)(</span><span class="n">idx</span><span class="p">)</span>
        <span class="c1"># A &lt;: B      B is the only child of A</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;:&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &gt;: B      A is the only child of B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;:&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &lt;&lt; B      A dominates B (A is an ancestor of B).</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;&lt;&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_descendants</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1"># A &gt;&gt; B      A is dominated by B (A is a descendant of B).</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;&gt;&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &lt;&lt;, B     B is a left-most descendant of A.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;&lt;,&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;&lt;1&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_leftmost_descendants</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1"># A &gt;&gt;, B     A is a left-most descendant of B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;&gt;,&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">_leftmost_descendants</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &lt;&lt;&#39; B     B is a right-most descendant of A.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;&lt;&#39;&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_rightmost_descendants</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1"># A &gt;&gt;&#39; B     A is a right-most descendant of B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;&gt;&#39;&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">_rightmost_descendants</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A &lt;&lt;: B     There is a single path of descent from A and B is on it.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&lt;&lt;:&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">_istree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_unique_descendants</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="c1"># A &gt;&gt;: B     There is a single path of descent from B and A is on it.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;&gt;&gt;:&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">unique_ancestors</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A . B       A immediately precedes B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_immediately_after</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A , B       A immediately follows B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;,&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_immediately_before</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A .. B      A precedes B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;..&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_after</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A ,, B      A follows B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;,,&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_before</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A $ B       A is a sister of B (and A != B).</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;$&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A $. B      A is a sister of and immediately precedes B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;$.&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;%.&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;right_sibling&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">right_sibling</span><span class="p">())</span>
                <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">right_sibling</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A $, B      A is a sister of and immediately follows B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;$,&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;%,&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;left_sibling&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">left_sibling</span><span class="p">())</span>
                <span class="ow">and</span> <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">left_sibling</span><span class="p">(),</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># A $.. B     A is a sister of and precedes B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;$..&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;%..&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent_index&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()[</span><span class="n">n</span><span class="o">.</span><span class="n">parent_index</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="p">)</span>
        <span class="c1"># A $,, B     A is a sister of and follows B.</span>
        <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;$,,&quot;</span> <span class="ow">or</span> <span class="n">operator</span> <span class="o">==</span> <span class="s2">&quot;%,,&quot;</span><span class="p">:</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;parent_index&quot;</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">())</span>
                <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">()[:</span> <span class="n">n</span><span class="o">.</span><span class="n">parent_index</span><span class="p">()])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TgrepException</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cannot interpret tgrep operator &quot;</span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
    <span class="c1"># now return the built function</span>
    <span class="k">if</span> <span class="n">negated</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="ow">not</span> <span class="n">r</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)))(</span><span class="n">retval</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">retval</span>


<span class="k">def</span> <span class="nf">_tgrep_conjunction_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">join_char</span><span class="o">=</span><span class="s2">&quot;&amp;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    from the conjunction of several other such lambda functions.</span>

<span class="sd">    This is prototypically called for expressions like</span>
<span class="sd">    (`tgrep_rel_conjunction`)::</span>

<span class="sd">        &lt; NP &amp; &lt; AP &lt; VP</span>

<span class="sd">    where tokens is a list of predicates representing the relations</span>
<span class="sd">    (`&lt; NP`, `&lt; AP`, and `&lt; VP`), possibly with the character `&amp;`</span>
<span class="sd">    included (as in the example here).</span>

<span class="sd">    This is also called for expressions like (`tgrep_node_expr2`)::</span>

<span class="sd">        NP &lt; NN</span>
<span class="sd">        S=s &lt; /NP/=n : s &lt; /VP/=v : n .. v</span>

<span class="sd">    tokens[0] is a tgrep_expr predicate; tokens[1:] are an (optional)</span>
<span class="sd">    list of segmented patterns (`tgrep_expr_labeled`, processed by</span>
<span class="sd">    `_tgrep_segmented_pattern_action`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># filter out the ampersand</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">join_char</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ts</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">predicate</span> <span class="ow">in</span> <span class="n">ts</span>
            <span class="p">)</span>
        <span class="p">)(</span><span class="n">tokens</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tgrep_segmented_pattern_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a segmented pattern.</span>

<span class="sd">    Called for expressions like (`tgrep_expr_labeled`)::</span>

<span class="sd">        =s .. =v &lt; =n</span>

<span class="sd">    This is a segmented pattern, a tgrep2 expression which begins with</span>
<span class="sd">    a node label.</span>

<span class="sd">    The problem is that for segemented_pattern_action (&#39;: =v &lt; =s&#39;),</span>
<span class="sd">    the first element (in this case, =v) is specifically selected by</span>
<span class="sd">    virtue of matching a particular node in the tree; to retrieve</span>
<span class="sd">    the node, we need the label, not a lambda function.  For node</span>
<span class="sd">    labels inside a tgrep_node_expr, we need a lambda function which</span>
<span class="sd">    returns true if the node visited is the same as =v.</span>

<span class="sd">    We solve this by creating two copies of a node_label_use in the</span>
<span class="sd">    grammar; the label use inside a tgrep_expr_labeled has a separate</span>
<span class="sd">    parse action to the pred use inside a node_expr.  See</span>
<span class="sd">    `_tgrep_node_label_use_action` and</span>
<span class="sd">    `_tgrep_node_label_pred_use_action`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># tokens[0] is a string containing the node label</span>
    <span class="n">node_label</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># tokens[1:] is an (optional) list of predicates which must all</span>
    <span class="c1"># hold of the bound node</span>
    <span class="n">reln_preds</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">pattern_segment_pred</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This predicate function ignores its node argument.&quot;&quot;&quot;</span>
        <span class="c1"># look up the bound node using its label</span>
        <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node_label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TgrepException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_label =</span><span class="si">{</span><span class="n">node_label</span><span class="si">}</span><span class="s2"> not bound in pattern&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">node_label</span><span class="p">]</span>
        <span class="c1"># match the relation predicates against the node</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">pred</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">reln_preds</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pattern_segment_pred</span>


<span class="k">def</span> <span class="nf">_tgrep_node_label_use_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the node label used to begin a tgrep_expr_labeled.  See</span>
<span class="sd">    `_tgrep_segmented_pattern_action`.</span>

<span class="sd">    Called for expressions like (`tgrep_node_label_use`)::</span>

<span class="sd">        =s</span>

<span class="sd">    when they appear as the first element of a `tgrep_expr_labeled`</span>
<span class="sd">    expression (see `_tgrep_segmented_pattern_action`).</span>

<span class="sd">    It returns the node label.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>


<span class="k">def</span> <span class="nf">_tgrep_node_label_pred_use_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    which describes the use of a previously bound node label.</span>

<span class="sd">    Called for expressions like (`tgrep_node_label_use_pred`)::</span>

<span class="sd">        =s</span>

<span class="sd">    when they appear inside a tgrep_node_expr (for example, inside a</span>
<span class="sd">    relation).  The predicate returns true if and only if its node</span>
<span class="sd">    argument is identical the the node looked up in the node label</span>
<span class="sd">    dictionary using the node&#39;s label.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>
    <span class="n">node_label</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">def</span> <span class="nf">node_label_use_pred</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># look up the bound node using its label</span>
        <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node_label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TgrepException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;node_label =</span><span class="si">{</span><span class="n">node_label</span><span class="si">}</span><span class="s2"> not bound in pattern&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">node_label</span><span class="p">]</span>
        <span class="c1"># truth means the given node is this node</span>
        <span class="k">return</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">node</span>

    <span class="k">return</span> <span class="n">node_label_use_pred</span>


<span class="k">def</span> <span class="nf">_tgrep_bind_node_label_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    which can optionally bind a matching node into the tgrep2 string&#39;s</span>
<span class="sd">    label_dict.</span>

<span class="sd">    Called for expressions like (`tgrep_node_expr2`)::</span>

<span class="sd">        /NP/</span>
<span class="sd">        @NP=n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># tokens[0] is a tgrep_node_expr</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if present, tokens[1] is the character &#39;=&#39;, and tokens[2] is</span>
        <span class="c1"># a tgrep_node_label, a string value containing the node label</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;=&quot;</span>
        <span class="n">node_pred</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node_label</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">node_label_bind_pred</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node_pred</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
                <span class="c1"># bind `n` into the dictionary `l`</span>
                <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">TgrepException</span><span class="p">(</span>
                        <span class="s2">&quot;cannot bind node_label </span><span class="si">{}</span><span class="s2">: label_dict is None&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">node_label</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">l</span><span class="p">[</span><span class="n">node_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">node_label_bind_pred</span>


<span class="k">def</span> <span class="nf">_tgrep_rel_disjunction_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    from the disjunction of several other such lambda functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># filter out the pipe</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s2">&quot;|&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">))(</span>
            <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_macro_defn_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a dictionary structure which defines the given macro.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;@&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>


<span class="k">def</span> <span class="nf">_tgrep_exprs_action</span><span class="p">(</span><span class="n">_s</span><span class="p">,</span> <span class="n">_l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the top-lebel node in a tgrep2 search string; the</span>
<span class="sd">    predicate function it returns binds together all the state of a</span>
<span class="sd">    tgrep2 search string.</span>

<span class="sd">    Builds a lambda function representing a predicate on a tree node</span>
<span class="sd">    from the disjunction of several tgrep expressions.  Also handles</span>
<span class="sd">    macro definitions and macro name binding, and node label</span>
<span class="sd">    definitions and node label binding.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">{})</span>
    <span class="c1"># filter out all the semicolons</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s2">&quot;;&quot;</span><span class="p">]</span>
    <span class="c1"># collect all macro definitions</span>
    <span class="n">macro_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">macro_defs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tok</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">macro_def</span> <span class="ow">in</span> <span class="n">macro_defs</span><span class="p">:</span>
        <span class="n">macro_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">macro_def</span><span class="p">)</span>
    <span class="c1"># collect all tgrep expressions</span>
    <span class="n">tgrep_exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tok</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)]</span>
    <span class="c1"># create a new scope for the node label dictionary</span>
    <span class="k">def</span> <span class="nf">top_level_pred</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">macro_dict</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">label_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># bind macro definitions and OR together all tgrep_exprs</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">predicate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">label_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">predicate</span> <span class="ow">in</span> <span class="n">tgrep_exprs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">top_level_pred</span>


<span class="k">def</span> <span class="nf">_build_tgrep_parser</span><span class="p">(</span><span class="n">set_parse_actions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a pyparsing-based parser object for tokenizing and</span>
<span class="sd">    interpreting tgrep search strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tgrep_op</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Regex</span><span class="p">(</span><span class="s2">&quot;[$%,.&lt;&gt;][%,.&lt;&gt;0-9-&#39;:]*&quot;</span><span class="p">)</span>
    <span class="n">tgrep_qstring</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">QuotedString</span><span class="p">(</span>
        <span class="n">quoteChar</span><span class="o">=</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="n">escChar</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">unquoteResults</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">tgrep_node_regex</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">QuotedString</span><span class="p">(</span>
        <span class="n">quoteChar</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">escChar</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">unquoteResults</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">tgrep_qstring_icase</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Regex</span><span class="p">(</span><span class="s1">&#39;i@</span><span class="se">\\</span><span class="s1">&quot;(?:[^&quot;</span><span class="se">\\</span><span class="s1">n</span><span class="se">\\</span><span class="s1">r</span><span class="se">\\\\</span><span class="s1">]|(?:</span><span class="se">\\\\</span><span class="s1">.))*</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
    <span class="n">tgrep_node_regex_icase</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Regex</span><span class="p">(</span><span class="s2">&quot;i@</span><span class="se">\\</span><span class="s2">/(?:[^/</span><span class="se">\\</span><span class="s2">n</span><span class="se">\\</span><span class="s2">r</span><span class="se">\\\\</span><span class="s2">]|(?:</span><span class="se">\\\\</span><span class="s2">.))*</span><span class="se">\\</span><span class="s2">/&quot;</span><span class="p">)</span>
    <span class="n">tgrep_node_literal</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Regex</span><span class="p">(</span><span class="s2">&quot;[^][ </span><span class="se">\r\t\n</span><span class="s2">;:.,&amp;|&lt;&gt;()$!@%&#39;^=]+&quot;</span><span class="p">)</span>
    <span class="n">tgrep_expr</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Forward</span><span class="p">()</span>
    <span class="n">tgrep_relations</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Forward</span><span class="p">()</span>
    <span class="n">tgrep_parens</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;(&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tgrep_expr</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
    <span class="n">tgrep_nltk_tree_pos</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pyparsing</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;N(&quot;</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span>
            <span class="n">pyparsing</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pyparsing</span><span class="o">.</span><span class="n">nums</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;,&quot;</span>
            <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span>
                <span class="n">pyparsing</span><span class="o">.</span><span class="n">delimitedList</span><span class="p">(</span><span class="n">pyparsing</span><span class="o">.</span><span class="n">Word</span><span class="p">(</span><span class="n">pyparsing</span><span class="o">.</span><span class="n">nums</span><span class="p">),</span> <span class="n">delim</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
    <span class="p">)</span>
    <span class="n">tgrep_node_label</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Regex</span><span class="p">(</span><span class="s2">&quot;[A-Za-z0-9]+&quot;</span><span class="p">)</span>
    <span class="n">tgrep_node_label_use</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Combine</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">+</span> <span class="n">tgrep_node_label</span><span class="p">)</span>
    <span class="c1"># see _tgrep_segmented_pattern_action</span>
    <span class="n">tgrep_node_label_use_pred</span> <span class="o">=</span> <span class="n">tgrep_node_label_use</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">macro_name</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Regex</span><span class="p">(</span><span class="s2">&quot;[^];:.,&amp;|&lt;&gt;()[$!@%&#39;^=</span><span class="se">\r\t\n</span><span class="s2"> ]+&quot;</span><span class="p">)</span>
    <span class="n">macro_name</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">macro_use</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Combine</span><span class="p">(</span><span class="s2">&quot;@&quot;</span> <span class="o">+</span> <span class="n">macro_name</span><span class="p">)</span>
    <span class="n">tgrep_node_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">tgrep_node_label_use_pred</span>
        <span class="o">|</span> <span class="n">macro_use</span>
        <span class="o">|</span> <span class="n">tgrep_nltk_tree_pos</span>
        <span class="o">|</span> <span class="n">tgrep_qstring_icase</span>
        <span class="o">|</span> <span class="n">tgrep_node_regex_icase</span>
        <span class="o">|</span> <span class="n">tgrep_qstring</span>
        <span class="o">|</span> <span class="n">tgrep_node_regex</span>
        <span class="o">|</span> <span class="s2">&quot;*&quot;</span>
        <span class="o">|</span> <span class="n">tgrep_node_literal</span>
    <span class="p">)</span>
    <span class="n">tgrep_node_expr2</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">tgrep_node_expr</span>
        <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">tgrep_node_label</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">|</span> <span class="n">tgrep_node_expr</span>
    <span class="n">tgrep_node</span> <span class="o">=</span> <span class="n">tgrep_parens</span> <span class="o">|</span> <span class="p">(</span>
        <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">tgrep_node_expr2</span>
        <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="n">tgrep_node_expr</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">tgrep_brackets</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">tgrep_relations</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
    <span class="n">tgrep_relation</span> <span class="o">=</span> <span class="n">tgrep_brackets</span> <span class="o">|</span> <span class="p">(</span><span class="n">tgrep_op</span> <span class="o">+</span> <span class="n">tgrep_node</span><span class="p">)</span>
    <span class="n">tgrep_rel_conjunction</span> <span class="o">=</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Forward</span><span class="p">()</span>
    <span class="n">tgrep_rel_conjunction</span> <span class="o">&lt;&lt;</span> <span class="p">(</span>
        <span class="n">tgrep_relation</span>
        <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tgrep_rel_conjunction</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">tgrep_relations</span> <span class="o">&lt;&lt;</span> <span class="n">tgrep_rel_conjunction</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ZeroOrMore</span><span class="p">(</span>
        <span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="n">tgrep_relations</span>
    <span class="p">)</span>
    <span class="n">tgrep_expr</span> <span class="o">&lt;&lt;</span> <span class="n">tgrep_node</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="n">tgrep_relations</span><span class="p">)</span>
    <span class="n">tgrep_expr_labeled</span> <span class="o">=</span> <span class="n">tgrep_node_label_use</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="n">tgrep_relations</span><span class="p">)</span>
    <span class="n">tgrep_expr2</span> <span class="o">=</span> <span class="n">tgrep_expr</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">tgrep_expr_labeled</span><span class="p">)</span>
    <span class="n">macro_defn</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pyparsing</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">White</span><span class="p">()</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span> <span class="o">+</span> <span class="n">macro_name</span> <span class="o">+</span> <span class="n">tgrep_expr2</span>
    <span class="p">)</span>
    <span class="n">tgrep_exprs</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">pyparsing</span><span class="o">.</span><span class="n">Optional</span><span class="p">(</span><span class="n">macro_defn</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="s2">&quot;;&quot;</span> <span class="o">+</span> <span class="n">macro_defn</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">tgrep_expr2</span>
        <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="s2">&quot;;&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">macro_defn</span> <span class="o">|</span> <span class="n">tgrep_expr2</span><span class="p">))</span>
        <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">set_parse_actions</span><span class="p">:</span>
        <span class="n">tgrep_node_label_use</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_node_label_use_action</span><span class="p">)</span>
        <span class="n">tgrep_node_label_use_pred</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_node_label_pred_use_action</span><span class="p">)</span>
        <span class="n">macro_use</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_macro_use_action</span><span class="p">)</span>
        <span class="n">tgrep_node</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_node_action</span><span class="p">)</span>
        <span class="n">tgrep_node_expr2</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_bind_node_label_action</span><span class="p">)</span>
        <span class="n">tgrep_parens</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_parens_action</span><span class="p">)</span>
        <span class="n">tgrep_nltk_tree_pos</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_nltk_tree_pos_action</span><span class="p">)</span>
        <span class="n">tgrep_relation</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_relation_action</span><span class="p">)</span>
        <span class="n">tgrep_rel_conjunction</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_conjunction_action</span><span class="p">)</span>
        <span class="n">tgrep_relations</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_rel_disjunction_action</span><span class="p">)</span>
        <span class="n">macro_defn</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_macro_defn_action</span><span class="p">)</span>
        <span class="c1"># the whole expression is also the conjunction of two</span>
        <span class="c1"># predicates: the first node predicate, and the remaining</span>
        <span class="c1"># relation predicates</span>
        <span class="n">tgrep_expr</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_conjunction_action</span><span class="p">)</span>
        <span class="n">tgrep_expr_labeled</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_segmented_pattern_action</span><span class="p">)</span>
        <span class="n">tgrep_expr2</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span>
            <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">_tgrep_conjunction_action</span><span class="p">,</span> <span class="n">join_char</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">tgrep_exprs</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">_tgrep_exprs_action</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tgrep_exprs</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="s2">&quot;#&quot;</span> <span class="o">+</span> <span class="n">pyparsing</span><span class="o">.</span><span class="n">restOfLine</span><span class="p">)</span>


<div class="viewcode-block" id="tgrep_tokenize"><a class="viewcode-back" href="../../api/nltk.tgrep.tgrep_tokenize.html#nltk.tgrep.tgrep_tokenize">[docs]</a><span class="k">def</span> <span class="nf">tgrep_tokenize</span><span class="p">(</span><span class="n">tgrep_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tokenizes a TGrep search string into separate tokens.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">_build_tgrep_parser</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tgrep_string</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">tgrep_string</span> <span class="o">=</span> <span class="n">tgrep_string</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">tgrep_string</span><span class="p">))</span></div>


<div class="viewcode-block" id="tgrep_compile"><a class="viewcode-back" href="../../api/nltk.tgrep.tgrep_compile.html#nltk.tgrep.tgrep_compile">[docs]</a><span class="k">def</span> <span class="nf">tgrep_compile</span><span class="p">(</span><span class="n">tgrep_string</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses (and tokenizes, if necessary) a TGrep search string into a</span>
<span class="sd">    lambda function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">_build_tgrep_parser</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tgrep_string</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">tgrep_string</span> <span class="o">=</span> <span class="n">tgrep_string</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">tgrep_string</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="treepositions_no_leaves"><a class="viewcode-back" href="../../api/nltk.tgrep.treepositions_no_leaves.html#nltk.tgrep.treepositions_no_leaves">[docs]</a><span class="k">def</span> <span class="nf">treepositions_no_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all the tree positions in the given tree which are not</span>
<span class="sd">    leaf nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">treepositions</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">()</span>
    <span class="c1"># leaves are treeposition tuples that are not prefixes of any</span>
    <span class="c1"># other treeposition</span>
    <span class="n">prefixes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">treepositions</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)):</span>
            <span class="n">prefixes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pos</span><span class="p">[:</span><span class="n">length</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">pos</span> <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">treepositions</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="p">]</span></div>


<div class="viewcode-block" id="tgrep_positions"><a class="viewcode-back" href="../../api/nltk.tgrep.tgrep_positions.html#nltk.tgrep.tgrep_positions">[docs]</a><span class="k">def</span> <span class="nf">tgrep_positions</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">trees</span><span class="p">,</span> <span class="n">search_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the tree positions in the trees which match the given pattern.</span>

<span class="sd">    :param pattern: a tgrep search pattern</span>
<span class="sd">    :type pattern: str or output of tgrep_compile()</span>
<span class="sd">    :param trees: a sequence of NLTK trees (usually ParentedTrees)</span>
<span class="sd">    :type trees: iter(ParentedTree) or iter(Tree)</span>
<span class="sd">    :param search_leaves: whether to return matching leaf nodes</span>
<span class="sd">    :type search_leaves: bool</span>
<span class="sd">    :rtype: iter(tree positions)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">tgrep_compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">search_leaves</span><span class="p">:</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">treepositions_no_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">[</span><span class="n">position</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span> <span class="k">if</span> <span class="n">pattern</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">position</span><span class="p">])]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="tgrep_nodes"><a class="viewcode-back" href="../../api/nltk.tgrep.tgrep_nodes.html#nltk.tgrep.tgrep_nodes">[docs]</a><span class="k">def</span> <span class="nf">tgrep_nodes</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">trees</span><span class="p">,</span> <span class="n">search_leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the tree nodes in the trees which match the given pattern.</span>

<span class="sd">    :param pattern: a tgrep search pattern</span>
<span class="sd">    :type pattern: str or output of tgrep_compile()</span>
<span class="sd">    :param trees: a sequence of NLTK trees (usually ParentedTrees)</span>
<span class="sd">    :type trees: iter(ParentedTree) or iter(Tree)</span>
<span class="sd">    :param search_leaves: whether to return matching leaf nodes</span>
<span class="sd">    :type search_leaves: bool</span>
<span class="sd">    :rtype: iter(tree nodes)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">tgrep_compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">search_leaves</span><span class="p">:</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="n">treepositions_no_leaves</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">yield</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span> <span class="k">if</span> <span class="n">pattern</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">position</span><span class="p">])]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">[]</span></div>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>