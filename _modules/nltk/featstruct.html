<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.featstruct</title>
  

  <link rel="stylesheet" href="../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.featstruct</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Feature Structures</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Edward Loper &lt;edloper@gmail.com&gt;,</span>
<span class="c1">#         Rob Speer,</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Basic data classes for representing feature structures, and for</span>
<span class="sd">performing basic operations on those feature structures.  A feature</span>
<span class="sd">structure is a mapping from feature identifiers to feature values,</span>
<span class="sd">where each feature value is either a basic value (such as a string or</span>
<span class="sd">an integer), or a nested feature structure.  There are two types of</span>
<span class="sd">feature structure, implemented by two subclasses of ``FeatStruct``:</span>

<span class="sd">    - feature dictionaries, implemented by ``FeatDict``, act like</span>
<span class="sd">      Python dictionaries.  Feature identifiers may be strings or</span>
<span class="sd">      instances of the ``Feature`` class.</span>
<span class="sd">    - feature lists, implemented by ``FeatList``, act like Python</span>
<span class="sd">      lists.  Feature identifiers are integers.</span>

<span class="sd">Feature structures are typically used to represent partial information</span>
<span class="sd">about objects.  A feature identifier that is not mapped to a value</span>
<span class="sd">stands for a feature whose value is unknown (*not* a feature without</span>
<span class="sd">a value).  Two feature structures that represent (potentially</span>
<span class="sd">overlapping) information about the same object can be combined by</span>
<span class="sd">unification.  When two inconsistent feature structures are unified,</span>
<span class="sd">the unification fails and returns None.</span>

<span class="sd">Features can be specified using &quot;feature paths&quot;, or tuples of feature</span>
<span class="sd">identifiers that specify path through the nested feature structures to</span>
<span class="sd">a value.  Feature structures may contain reentrant feature values.  A</span>
<span class="sd">&quot;reentrant feature value&quot; is a single feature value that can be</span>
<span class="sd">accessed via multiple feature paths.  Unification preserves the</span>
<span class="sd">reentrance relations imposed by both of the unified feature</span>
<span class="sd">structures.  In the feature structure resulting from unification, any</span>
<span class="sd">modifications to a reentrant feature value will be visible using any</span>
<span class="sd">of its feature paths.</span>

<span class="sd">Feature structure variables are encoded using the ``nltk.sem.Variable``</span>
<span class="sd">class.  The variables&#39; values are tracked using a bindings</span>
<span class="sd">dictionary, which maps variables to their values.  When two feature</span>
<span class="sd">structures are unified, a fresh bindings dictionary is created to</span>
<span class="sd">track their values; and before unification completes, all bound</span>
<span class="sd">variables are replaced by their values.  Thus, the bindings</span>
<span class="sd">dictionaries are usually strictly internal to the unification process.</span>
<span class="sd">However, it is possible to track the bindings of variables if you</span>
<span class="sd">choose to, by supplying your own initial bindings dictionary to the</span>
<span class="sd">``unify()`` function.</span>

<span class="sd">When unbound variables are unified with one another, they become</span>
<span class="sd">aliased.  This is encoded by binding one variable to the other.</span>

<span class="sd">Lightweight Feature Structures</span>
<span class="sd">==============================</span>
<span class="sd">Many of the functions defined by ``nltk.featstruct`` can be applied</span>
<span class="sd">directly to simple Python dictionaries and lists, rather than to</span>
<span class="sd">full-fledged ``FeatDict`` and ``FeatList`` objects.  In other words,</span>
<span class="sd">Python ``dicts`` and ``lists`` can be used as &quot;light-weight&quot; feature</span>
<span class="sd">structures.</span>

<span class="sd">    &gt;&gt;&gt; from nltk.featstruct import unify</span>
<span class="sd">    &gt;&gt;&gt; unify(dict(x=1, y=dict()), dict(a=&#39;a&#39;, y=dict(b=&#39;b&#39;)))  # doctest: +SKIP</span>
<span class="sd">    {&#39;y&#39;: {&#39;b&#39;: &#39;b&#39;}, &#39;x&#39;: 1, &#39;a&#39;: &#39;a&#39;}</span>

<span class="sd">However, you should keep in mind the following caveats:</span>

<span class="sd">  - Python dictionaries &amp; lists ignore reentrance when checking for</span>
<span class="sd">    equality between values.  But two FeatStructs with different</span>
<span class="sd">    reentrances are considered nonequal, even if all their base</span>
<span class="sd">    values are equal.</span>

<span class="sd">  - FeatStructs can be easily frozen, allowing them to be used as</span>
<span class="sd">    keys in hash tables.  Python dictionaries and lists can not.</span>

<span class="sd">  - FeatStructs display reentrance in their string representations;</span>
<span class="sd">    Python dictionaries and lists do not.</span>

<span class="sd">  - FeatStructs may *not* be mixed with Python dictionaries and lists</span>
<span class="sd">    (e.g., when performing unification).</span>

<span class="sd">  - FeatStructs provide a number of useful methods, such as ``walk()``</span>
<span class="sd">    and ``cyclic()``, which are not available for Python dicts and lists.</span>

<span class="sd">In general, if your feature structures will contain any reentrances,</span>
<span class="sd">or if you plan to use them as dictionary keys, it is strongly</span>
<span class="sd">recommended that you use full-fledged ``FeatStruct`` objects.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>

<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">raise_unorderable_types</span><span class="p">,</span> <span class="n">read_str</span>
<span class="kn">from</span> <span class="nn">nltk.sem.logic</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Expression</span><span class="p">,</span>
    <span class="n">LogicalExpressionException</span><span class="p">,</span>
    <span class="n">LogicParser</span><span class="p">,</span>
    <span class="n">SubstituteBindingsI</span><span class="p">,</span>
    <span class="n">Variable</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1">######################################################################</span>
<span class="c1"># Feature Structure</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="FeatStruct"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct">[docs]</a><span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">FeatStruct</span><span class="p">(</span><span class="n">SubstituteBindingsI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mapping from feature identifiers to feature values, where each</span>
<span class="sd">    feature value is either a basic value (such as a string or an</span>
<span class="sd">    integer), or a nested feature structure.  There are two types of</span>
<span class="sd">    feature structure:</span>

<span class="sd">      - feature dictionaries, implemented by ``FeatDict``, act like</span>
<span class="sd">        Python dictionaries.  Feature identifiers may be strings or</span>
<span class="sd">        instances of the ``Feature`` class.</span>
<span class="sd">      - feature lists, implemented by ``FeatList``, act like Python</span>
<span class="sd">        lists.  Feature identifiers are integers.</span>

<span class="sd">    Feature structures may be indexed using either simple feature</span>
<span class="sd">    identifiers or &#39;feature paths.&#39;  A feature path is a sequence</span>
<span class="sd">    of feature identifiers that stand for a corresponding sequence of</span>
<span class="sd">    indexing operations.  In particular, ``fstruct[(f1,f2,...,fn)]`` is</span>
<span class="sd">    equivalent to ``fstruct[f1][f2]...[fn]``.</span>

<span class="sd">    Feature structures may contain reentrant feature structures.  A</span>
<span class="sd">    &quot;reentrant feature structure&quot; is a single feature structure</span>
<span class="sd">    object that can be accessed via multiple feature paths.  Feature</span>
<span class="sd">    structures may also be cyclic.  A feature structure is &quot;cyclic&quot;</span>
<span class="sd">    if there is any feature path from the feature structure to itself.</span>

<span class="sd">    Two feature structures are considered equal if they assign the</span>
<span class="sd">    same values to all features, and have the same reentrancies.</span>

<span class="sd">    By default, feature structures are mutable.  They may be made</span>
<span class="sd">    immutable with the ``freeze()`` method.  Once they have been</span>
<span class="sd">    frozen, they may be hashed, and thus used as dictionary keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_frozen</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;:ivar: A flag indicating whether this feature structure is</span>
<span class="sd">       frozen or not.  Once this flag is set, it should never be</span>
<span class="sd">       un-set; and no further modification should be made to this</span>
<span class="sd">       feature structure.&quot;&quot;&quot;</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Constructor</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.__new__"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.__new__">[docs]</a>    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct and return a new feature structure.  If this</span>
<span class="sd">        constructor is called directly, then the returned feature</span>
<span class="sd">        structure will be an instance of either the ``FeatDict`` class</span>
<span class="sd">        or the ``FeatList`` class.</span>

<span class="sd">        :param features: The initial feature values for this feature</span>
<span class="sd">            structure:</span>

<span class="sd">            - FeatStruct(string) -&gt; FeatStructReader().read(string)</span>
<span class="sd">            - FeatStruct(mapping) -&gt; FeatDict(mapping)</span>
<span class="sd">            - FeatStruct(sequence) -&gt; FeatList(sequence)</span>
<span class="sd">            - FeatStruct() -&gt; FeatDict()</span>
<span class="sd">        :param morefeatures: If ``features`` is a mapping or None,</span>
<span class="sd">            then ``morefeatures`` provides additional features for the</span>
<span class="sd">            ``FeatDict`` constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the FeatStruct constructor is called directly, then decide</span>
        <span class="c1"># whether to create a FeatDict or a FeatList, based on the</span>
        <span class="c1"># contents of the `features` argument.</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">FeatStruct</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">FeatDict</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">FeatDict</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">FeatDict</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">FeatDict</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">morefeatures</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Keyword arguments may only be specified &quot;</span>
                    <span class="s2">&quot;if features is None or is a mapping.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">FeatStructReader</span><span class="o">.</span><span class="n">_START_FDICT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">FeatDict</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">FeatDict</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">FeatList</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">FeatList</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">features</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">FeatList</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">FeatList</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected string or mapping or sequence&quot;</span><span class="p">)</span>

        <span class="c1"># Otherwise, construct the object as normal.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span></div>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Uniform Accessor Methods</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># These helper functions allow the methods defined by FeatStruct</span>
    <span class="c1"># to treat all feature structures as mappings, even if they&#39;re</span>
    <span class="c1"># really lists.  (Lists are treated as mappings from ints to vals)</span>

    <span class="k">def</span> <span class="nf">_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterable of the feature identifiers used by this</span>
<span class="sd">        FeatStruct.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># Implemented by subclasses.</span>

    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterable of the feature values directly defined</span>
<span class="sd">        by this FeatStruct.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># Implemented by subclasses.</span>

    <span class="k">def</span> <span class="nf">_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterable of (fid,fval) pairs, where fid is a</span>
<span class="sd">        feature identifier and fval is the corresponding feature</span>
<span class="sd">        value, for all features defined by this FeatStruct.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># Implemented by subclasses.</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Equality &amp; Hashing</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.equal_values"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.equal_values">[docs]</a>    <span class="k">def</span> <span class="nf">equal_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">check_reentrance</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if ``self`` and ``other`` assign the same value to</span>
<span class="sd">        to every feature.  In particular, return true if</span>
<span class="sd">        ``self[p]==other[p]`` for every feature path *p* such</span>
<span class="sd">        that ``self[p]`` or ``other[p]`` is a base value (i.e.,</span>
<span class="sd">        not a nested feature structure).</span>

<span class="sd">        :param check_reentrance: If True, then also return False if</span>
<span class="sd">            there is any difference between the reentrances of ``self``</span>
<span class="sd">            and ``other``.</span>
<span class="sd">        :note: the ``==`` is equivalent to ``equal_values()`` with</span>
<span class="sd">            ``check_reentrance=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">check_reentrance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return true if ``self`` and ``other`` are both feature structures,</span>
<span class="sd">        assign the same values to all features, and contain the same</span>
<span class="sd">        reentrances.  I.e., return</span>
<span class="sd">        ``self.equal_values(other, check_reentrance=True)``.</span>

<span class="sd">        :see: ``equal_values()``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">set</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
            <span class="c1"># raise_unorderable_types(&quot;&lt;&quot;, self, other)</span>
            <span class="c1"># Sometimes feature values can be pure strings,</span>
            <span class="c1"># so we need to be able to compare with non-featstructs:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If this feature structure is frozen, return its hash value;</span>
<span class="sd">        otherwise, raise ``TypeError``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;FeatStructs must be frozen before they &quot;</span> <span class="s2">&quot;can be hashed.&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_hashvalue</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="nf">_equal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">check_reentrance</span><span class="p">,</span> <span class="n">visited_self</span><span class="p">,</span> <span class="n">visited_other</span><span class="p">,</span> <span class="n">visited_pairs</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True iff self and other have equal values.</span>

<span class="sd">        :param visited_self: A set containing the ids of all ``self``</span>
<span class="sd">            feature structures we&#39;ve already visited.</span>
<span class="sd">        :param visited_other: A set containing the ids of all ``other``</span>
<span class="sd">            feature structures we&#39;ve already visited.</span>
<span class="sd">        :param visited_pairs: A set containing ``(selfid, otherid)`` pairs</span>
<span class="sd">            for all pairs of feature structures we&#39;ve already visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we&#39;re the same object, then we&#39;re equal.</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># If we have different classes, we&#39;re definitely not equal.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we define different features, we&#39;re definitely not equal.</span>
        <span class="c1"># (Perform len test first because it&#39;s faster -- we should</span>
        <span class="c1"># do profiling to see if this actually helps)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_keys</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># If we&#39;re checking reentrance, then any time we revisit a</span>
        <span class="c1"># structure, make sure that it was paired with the same</span>
        <span class="c1"># feature structure that it is now.  Note: if check_reentrance,</span>
        <span class="c1"># then visited_pairs will never contain two pairs whose first</span>
        <span class="c1"># values are equal, or two pairs whose second values are equal.</span>
        <span class="k">if</span> <span class="n">check_reentrance</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited_self</span> <span class="ow">or</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited_other</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">in</span> <span class="n">visited_pairs</span>

        <span class="c1"># If we&#39;re not checking reentrance, then we still need to deal</span>
        <span class="c1"># with cycles.  If we encounter the same (self, other) pair a</span>
        <span class="c1"># second time, then we won&#39;t learn anything more by examining</span>
        <span class="c1"># their children a second time, so just return true.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">in</span> <span class="n">visited_pairs</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># Keep track of which nodes we&#39;ve visited.</span>
        <span class="n">visited_self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">visited_other</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="n">visited_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

        <span class="c1"># Now we have to check all values.  If any of them don&#39;t match,</span>
        <span class="c1"># then return false.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">self_fval</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">():</span>
            <span class="n">other_fval</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">self_fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">self_fval</span><span class="o">.</span><span class="n">_equal</span><span class="p">(</span>
                    <span class="n">other_fval</span><span class="p">,</span>
                    <span class="n">check_reentrance</span><span class="p">,</span>
                    <span class="n">visited_self</span><span class="p">,</span>
                    <span class="n">visited_other</span><span class="p">,</span>
                    <span class="n">visited_pairs</span><span class="p">,</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">self_fval</span> <span class="o">!=</span> <span class="n">other_fval</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Everything matched up; return true.</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_calculate_hashvalue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for this feature structure.</span>

<span class="sd">        :require: ``self`` must be frozen.</span>
<span class="sd">        :param visited: A set containing the ids of all feature</span>
<span class="sd">            structures we&#39;ve already visited while hashing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">hashval</span> <span class="o">=</span> <span class="mi">5831</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">()):</span>
            <span class="n">hashval</span> <span class="o">*=</span> <span class="mi">37</span>
            <span class="n">hashval</span> <span class="o">+=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">hashval</span> <span class="o">*=</span> <span class="mi">37</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">hashval</span> <span class="o">+=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_calculate_hashvalue</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hashval</span> <span class="o">+=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span>
            <span class="c1"># Convert to a 32 bit int.</span>
            <span class="n">hashval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hashval</span> <span class="o">&amp;</span> <span class="mh">0x7FFFFFFF</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hashval</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Freezing</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="c1">#: Error message used by mutating methods when called on a frozen</span>
    <span class="c1">#: feature structure.</span>
    <span class="n">_FROZEN_ERROR</span> <span class="o">=</span> <span class="s2">&quot;Frozen FeatStructs may not be modified.&quot;</span>

<div class="viewcode-block" id="FeatStruct.freeze"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.freeze">[docs]</a>    <span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make this feature structure, and any feature structures it</span>
<span class="sd">        contains, immutable.  Note: this method does not attempt to</span>
<span class="sd">        &#39;freeze&#39; any feature value that is not a ``FeatStruct``; it</span>
<span class="sd">        is recommended that you use only immutable feature values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freeze</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span></div>

<div class="viewcode-block" id="FeatStruct.frozen"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this feature structure is immutable.  Feature</span>
<span class="sd">        structures can be made immutable with the ``freeze()`` method.</span>
<span class="sd">        Immutable feature structures may not be made mutable again,</span>
<span class="sd">        but new mutable copies can be produced with the ``copy()`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span></div>

    <span class="k">def</span> <span class="nf">_freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make this feature structure, and any feature structure it</span>
<span class="sd">        contains, immutable.</span>

<span class="sd">        :param visited: A set containing the ids of all feature</span>
<span class="sd">            structures we&#39;ve already visited while freezing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">fval</span><span class="o">.</span><span class="n">_freeze</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Copying</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.copy"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new copy of ``self``.  The new copy will not be frozen.</span>

<span class="sd">        :param deep: If true, create a deep copy; if false, create</span>
<span class="sd">            a shallow copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="c1"># Subclasses should define __deepcopy__ to ensure that the new</span>
    <span class="c1"># copy will not be frozen.</span>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># Implemented by subclasses.</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Structural Information</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.cyclic"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.cyclic">[docs]</a>    <span class="k">def</span> <span class="nf">cyclic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this feature structure contains itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">({})[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span></div>

<div class="viewcode-block" id="FeatStruct.walk"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.walk">[docs]</a>    <span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator that generates this feature structure, and</span>
<span class="sd">        each feature structure it contains.  Each feature structure will</span>
<span class="sd">        be generated exactly once.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_walk</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator that generates this feature structure, and</span>
<span class="sd">        each feature structure it contains.</span>

<span class="sd">        :param visited: A set containing the ids of all feature</span>
<span class="sd">            structures we&#39;ve already visited while freezing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>  <span class="c1"># Implemented by subclasses.</span>

    <span class="k">def</span> <span class="nf">_walk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="k">yield from</span> <span class="n">fval</span><span class="o">.</span><span class="n">_walk</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>

    <span class="c1"># Walk through the feature tree.  The first time we see a feature</span>
    <span class="c1"># value, map it to False (not reentrant).  If we see a feature</span>
    <span class="c1"># value more than once, then map it to True (reentrant).</span>
    <span class="k">def</span> <span class="nf">_find_reentrances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary that maps from the ``id`` of each feature</span>
<span class="sd">        structure contained in ``self`` (including ``self``) to a</span>
<span class="sd">        boolean value, indicating whether it is reentrant or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
            <span class="c1"># We&#39;ve seen it more than once.</span>
            <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This is the first time we&#39;ve seen it.</span>
            <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Recurse to contained feature structures.</span>
            <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="n">fval</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">(</span><span class="n">reentrances</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">reentrances</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Variables &amp; Bindings</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.substitute_bindings"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.substitute_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.substitute_bindings()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatStruct.retract_bindings"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.retract_bindings">[docs]</a>    <span class="k">def</span> <span class="nf">retract_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.retract_bindings()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">retract_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatStruct.variables"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.variables">[docs]</a>    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.find_variables()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">find_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatStruct.rename_variables"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.rename_variables">[docs]</a>    <span class="k">def</span> <span class="nf">rename_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">used_vars</span><span class="o">=</span><span class="p">(),</span> <span class="n">new_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;:see: ``nltk.featstruct.rename_variables()``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">rename_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatStruct.remove_variables"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.remove_variables">[docs]</a>    <span class="k">def</span> <span class="nf">remove_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the feature structure that is obtained by deleting</span>
<span class="sd">        any feature whose value is a ``Variable``.</span>

<span class="sd">        :rtype: FeatStruct</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">remove_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Unification</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="FeatStruct.unify"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.unify">[docs]</a>    <span class="k">def</span> <span class="nf">unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">bindings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rename_vars</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">rename_vars</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatStruct.subsumes"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStruct.html#nltk.featstruct.FeatStruct.subsumes">[docs]</a>    <span class="k">def</span> <span class="nf">subsumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if ``self`` subsumes ``other``.  I.e., return true</span>
<span class="sd">        If unifying ``self`` with ``other`` would result in a feature</span>
<span class="sd">        structure equal to ``other``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">subsumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { String Representations</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a single-line representation of this feature structure,</span>
<span class="sd">        suitable for embedding in other representations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">({}),</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation of this feature structure.</span>

<span class="sd">        :param reentrances: A dictionary that maps from the ``id`` of</span>
<span class="sd">            each feature value in self, indicating whether that value</span>
<span class="sd">            is reentrant or not.</span>
<span class="sd">        :param reentrance_ids: A dictionary mapping from each ``id``</span>
<span class="sd">            of a feature value to a unique identifier.  This is modified</span>
<span class="sd">            by ``repr``: the first time a reentrant feature value is</span>
<span class="sd">            displayed, an identifier is added to ``reentrance_ids`` for it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<span class="c1"># Mutation: disable if frozen.</span>
<span class="n">_FROZEN_ERROR</span> <span class="o">=</span> <span class="s2">&quot;Frozen FeatStructs may not be modified.&quot;</span>
<span class="n">_FROZEN_NOTICE</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s2">If self is frozen, raise ValueError.&quot;</span>


<span class="k">def</span> <span class="nf">_check_frozen</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a method function, return a new method function that first</span>
<span class="sd">    checks if ``self._frozen`` is true; and if so, raises ``ValueError``</span>
<span class="sd">    with an appropriate message.  Otherwise, call the method and return</span>
<span class="sd">    its result.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">wrapped</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">wrapped</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">_FROZEN_NOTICE</span> <span class="o">%</span> <span class="n">indent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span>


<span class="c1">######################################################################</span>
<span class="c1"># Feature Dictionary</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="FeatDict"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatDict.html#nltk.featstruct.FeatDict">[docs]</a><span class="k">class</span> <span class="nc">FeatDict</span><span class="p">(</span><span class="n">FeatStruct</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A feature structure that acts like a Python dictionary.  I.e., a</span>
<span class="sd">    mapping from feature identifiers to feature values, where a feature</span>
<span class="sd">    identifier can be a string or a ``Feature``; and where a feature value</span>
<span class="sd">    can be either a basic value (such as a string or an integer), or a nested</span>
<span class="sd">    feature structure.  A feature identifiers for a ``FeatDict`` is</span>
<span class="sd">    sometimes called a &quot;feature name&quot;.</span>

<span class="sd">    Two feature dicts are considered equal if they assign the same</span>
<span class="sd">    values to all features, and have the same reentrances.</span>

<span class="sd">    :see: ``FeatStruct`` for information about feature paths, reentrance,</span>
<span class="sd">        cyclic feature structures, mutability, freezing, and hashing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FeatDict.__init__"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatDict.html#nltk.featstruct.FeatDict.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new feature dictionary, with the specified features.</span>

<span class="sd">        :param features: The initial value for this feature</span>
<span class="sd">            dictionary.  If ``features`` is a ``FeatStruct``, then its</span>
<span class="sd">            features are copied (shallow copy).  If ``features`` is a</span>
<span class="sd">            dict, then a feature is created for each item, mapping its</span>
<span class="sd">            key to its value.  If ``features`` is a string, then it is</span>
<span class="sd">            processed using ``FeatStructReader``.  If ``features`` is a list of</span>
<span class="sd">            tuples ``(name, val)``, then a feature is created for each tuple.</span>
<span class="sd">        :param morefeatures: Additional features for the new feature</span>
<span class="sd">            dictionary.  If a feature is listed under both ``features`` and</span>
<span class="sd">            ``morefeatures``, then the value from ``morefeatures`` will be</span>
<span class="sd">            used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">FeatStructReader</span><span class="p">()</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># update() checks the types of features.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">)</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Dict methods</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="n">_INDEX_ERROR</span> <span class="o">=</span> <span class="s2">&quot;Expected feature name or path.  Got </span><span class="si">%r</span><span class="s2">.&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, return</span>
<span class="sd">        its value; otherwise, raise ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">for</span> <span class="n">fid</span> <span class="ow">in</span> <span class="n">name_or_path</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span>  <span class="c1"># path contains base value</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">fid</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">val</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

<div class="viewcode-block" id="FeatDict.get"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatDict.html#nltk.featstruct.FeatDict.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, return its</span>
<span class="sd">        value; otherwise, return ``default``.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span></div>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if a feature with the given name or path exists.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">]</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="FeatDict.has_key"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatDict.html#nltk.featstruct.FeatDict.has_key">[docs]</a>    <span class="k">def</span> <span class="nf">has_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return true if a feature with the given name or path exists.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">name_or_path</span> <span class="ow">in</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, delete</span>
<span class="sd">        its value; otherwise, raise ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span>  <span class="c1"># path contains base value</span>
                <span class="k">del</span> <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value for the feature with the given name or path</span>
<span class="sd">        to ``value``.  If ``name_or_path`` is an invalid path, raise</span>
<span class="sd">        ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span>  <span class="c1"># path contains base value</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="n">clear</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">clear</span><span class="p">)</span>
    <span class="n">pop</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
    <span class="n">popitem</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">popitem</span><span class="p">)</span>
    <span class="n">setdefault</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">)</span>

<div class="viewcode-block" id="FeatDict.update"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatDict.html#nltk.featstruct.FeatDict.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">morefeatures</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">items</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">features</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">features</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected mapping or list of tuples&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Feature names must be strings&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">morefeatures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Feature</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Feature names must be strings&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Copying</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">selfcopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_items</span><span class="p">():</span>
            <span class="n">selfcopy</span><span class="p">[</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">memo</span><span class="p">)]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">selfcopy</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Uniform Accessor Methods</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { String Representations</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a multi-line representation of this feature dictionary</span>
<span class="sd">        as an FVM (feature value matrix).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_find_reentrances</span><span class="p">({}),</span> <span class="p">{}))</span>

    <span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># If this is the first time we&#39;ve seen a reentrant structure,</span>
        <span class="c1"># then assign it a unique identifier.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrance_ids</span>
            <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reentrance_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># sorting note: keys are unique strings, so we&#39;ll never fall</span>
        <span class="c1"># through to comparing values.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">display</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;display&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrance_ids</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">-&gt;(</span><span class="si">{</span><span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">display</span> <span class="o">==</span> <span class="s2">&quot;prefix&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">prefix</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fval</span>
            <span class="k">elif</span> <span class="n">display</span> <span class="o">==</span> <span class="s2">&quot;slash&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                    <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fval</span><span class="o">.</span><span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot;/</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">fval</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fval</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;+</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fval</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">=&lt;</span><span class="si">{</span><span class="n">fval</span><span class="si">}</span><span class="s2">&gt;&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fval_repr</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">)</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">fval_repr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># If it&#39;s reentrant, then add on an identifier tag.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">[</span><span class="si">{}</span><span class="s2">]</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">segments</span><span class="p">),</span> <span class="n">suffix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: A list of lines composing a string representation of</span>
<span class="sd">            this feature dictionary.</span>
<span class="sd">        :param reentrances: A dictionary that maps from the ``id`` of</span>
<span class="sd">            each feature value in self, indicating whether that value</span>
<span class="sd">            is reentrant or not.</span>
<span class="sd">        :param reentrance_ids: A dictionary mapping from each ``id``</span>
<span class="sd">            of a feature value to a unique identifier.  This is modified</span>
<span class="sd">            by ``repr``: the first time a reentrant feature value is</span>
<span class="sd">            displayed, an identifier is added to ``reentrance_ids`` for</span>
<span class="sd">            it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If this is the first time we&#39;ve seen a reentrant structure,</span>
        <span class="c1"># then tack on an id string.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrance_ids</span>
            <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reentrance_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Special case: empty feature dict.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
                <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">) []&quot;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;[]&quot;</span><span class="p">]</span>

        <span class="c1"># What&#39;s the longest feature name?  Use this to align names.</span>
        <span class="n">maxfnamelen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># sorting note: keys are unique strings, so we&#39;ll never fall</span>
        <span class="c1"># through to comparing values.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">maxfnamelen</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">fval</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> = &lt;</span><span class="si">{</span><span class="n">fval</span><span class="si">}</span><span class="s2">&gt;&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatList</span><span class="p">):</span>
                <span class="n">fval_repr</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">fval_repr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatDict</span><span class="p">):</span>
                <span class="c1"># It&#39;s not a nested feature structure -- just print it.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrance_ids</span><span class="p">:</span>
                <span class="c1"># It&#39;s a feature structure we&#39;ve seen before -- print</span>
                <span class="c1"># the reentrance id.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> -&gt; (</span><span class="si">{</span><span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># It&#39;s a new feature structure.  Separate it from</span>
                <span class="c1"># other values by a blank line.</span>
                <span class="k">if</span> <span class="n">lines</span> <span class="ow">and</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="c1"># Recursively print the feature&#39;s value (fval).</span>
                <span class="n">fval_lines</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">_str</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">)</span>

                <span class="c1"># Indent each line to make room for fname.</span>
                <span class="n">fval_lines</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxfnamelen</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">fval_lines</span><span class="p">]</span>

                <span class="c1"># Pick which line we&#39;ll display fname on, &amp; splice it in.</span>
                <span class="n">nameline</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fval_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">fval_lines</span><span class="p">[</span><span class="n">nameline</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot; =&quot;</span> <span class="o">+</span> <span class="n">fval_lines</span><span class="p">[</span><span class="n">nameline</span><span class="p">][</span><span class="n">maxfnamelen</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:]</span>
                <span class="p">)</span>

                <span class="c1"># Add the feature structure to the output.</span>
                <span class="n">lines</span> <span class="o">+=</span> <span class="n">fval_lines</span>

                <span class="c1"># Separate FeatStructs by a blank line.</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Get rid of any excess blank lines.</span>
        <span class="k">if</span> <span class="n">lines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c1"># Add brackets around everything.</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;[ </span><span class="si">{}{}</span><span class="s2"> ]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">maxlen</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>

        <span class="c1"># If it&#39;s reentrant, then add on an identifier tag.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="n">idstr</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">) &quot;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">idstr</span><span class="p">))</span> <span class="o">+</span> <span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">]</span>
            <span class="n">idline</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">lines</span><span class="p">[</span><span class="n">idline</span><span class="p">]</span> <span class="o">=</span> <span class="n">idstr</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="n">idline</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">idstr</span><span class="p">)</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">lines</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># Feature List</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="FeatList"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatList.html#nltk.featstruct.FeatList">[docs]</a><span class="k">class</span> <span class="nc">FeatList</span><span class="p">(</span><span class="n">FeatStruct</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list of feature values, where each feature value is either a</span>
<span class="sd">    basic value (such as a string or an integer), or a nested feature</span>
<span class="sd">    structure.</span>

<span class="sd">    Feature lists may contain reentrant feature values.  A &quot;reentrant</span>
<span class="sd">    feature value&quot; is a single feature value that can be accessed via</span>
<span class="sd">    multiple feature paths.  Feature lists may also be cyclic.</span>

<span class="sd">    Two feature lists are considered equal if they assign the same</span>
<span class="sd">    values to all features, and have the same reentrances.</span>

<span class="sd">    :see: ``FeatStruct`` for information about feature paths, reentrance,</span>
<span class="sd">        cyclic feature structures, mutability, freezing, and hashing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FeatList.__init__"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatList.html#nltk.featstruct.FeatList.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new feature list, with the specified features.</span>

<span class="sd">        :param features: The initial list of features for this feature</span>
<span class="sd">            list.  If ``features`` is a string, then it is paresd using</span>
<span class="sd">            ``FeatStructReader``.  Otherwise, it should be a sequence</span>
<span class="sd">            of basic values and nested feature structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">FeatStructReader</span><span class="p">()</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { List methods</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="n">_INDEX_ERROR</span> <span class="o">=</span> <span class="s2">&quot;Expected int or feature path.  Got </span><span class="si">%r</span><span class="s2">.&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">for</span> <span class="n">fid</span> <span class="ow">in</span> <span class="n">name_or_path</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span>  <span class="c1"># path contains base value</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">fid</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">val</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If the feature with the given name or path exists, delete</span>
<span class="sd">        its value; otherwise, raise ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span>  <span class="c1"># path contains base value</span>
                <span class="k">del</span> <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the value for the feature with the given name or path</span>
<span class="sd">        to ``value``.  If ``name_or_path`` is an invalid path, raise</span>
<span class="sd">        ``KeyError``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_FROZEN_ERROR</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_or_path</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The path () can not be set&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">name_or_path</span><span class="p">)</span>  <span class="c1"># path contains base value</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">name_or_path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_INDEX_ERROR</span> <span class="o">%</span> <span class="n">name_or_path</span><span class="p">)</span>

    <span class="c1">#    __delslice__ = _check_frozen(list.__delslice__, &#39;               &#39;)</span>
    <span class="c1">#    __setslice__ = _check_frozen(list.__setslice__, &#39;               &#39;)</span>
    <span class="fm">__iadd__</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="fm">__iadd__</span><span class="p">)</span>
    <span class="fm">__imul__</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="fm">__imul__</span><span class="p">)</span>
    <span class="n">append</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
    <span class="n">extend</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">extend</span><span class="p">)</span>
    <span class="n">insert</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">insert</span><span class="p">)</span>
    <span class="n">pop</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
    <span class="n">remove</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">remove</span><span class="p">)</span>
    <span class="n">reverse</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">reverse</span><span class="p">)</span>
    <span class="n">sort</span> <span class="o">=</span> <span class="n">_check_frozen</span><span class="p">(</span><span class="nb">list</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Copying</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">selfcopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">selfcopy</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">selfcopy</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Uniform Accessor Methods</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="nf">_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1">##////////////////////////////////////////////////////////////</span>
    <span class="c1"># { String Representations</span>
    <span class="c1">##////////////////////////////////////////////////////////////</span>

    <span class="c1"># Special handling for: reentrances, variables, expressions.</span>
    <span class="k">def</span> <span class="nf">_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">):</span>
        <span class="c1"># If this is the first time we&#39;ve seen a reentrant structure,</span>
        <span class="c1"># then assign it a unique identifier.</span>
        <span class="k">if</span> <span class="n">reentrances</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]:</span>
            <span class="k">assert</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrance_ids</span>
            <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reentrance_ids</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fval</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">reentrance_ids</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;-&gt;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">reentrance_ids</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fval</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fval</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fval</span><span class="o">.</span><span class="n">_repr</span><span class="p">(</span><span class="n">reentrances</span><span class="p">,</span> <span class="n">reentrance_ids</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fval</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">segments</span><span class="p">))</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># Variables &amp; Bindings</span>
<span class="c1">######################################################################</span>


<span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the feature structure that is obtained by replacing each</span>
<span class="sd">    variable bound by ``bindings`` with its binding.  If a variable is</span>
<span class="sd">    aliased to a bound variable, then it will be replaced by that</span>
<span class="sd">    variable&#39;s value.  If a variable is aliased to an unbound</span>
<span class="sd">    variable, then it will be replaced by that variable.</span>

<span class="sd">    :type bindings: dict(Variable -&gt; any)</span>
<span class="sd">    :param bindings: A dictionary mapping from variables to values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
        <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="n">fstruct</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="n">_substitute_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">fstruct</span>


<span class="k">def</span> <span class="nf">_substitute_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="c1"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected mapping or sequence&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
            <span class="n">fval</span> <span class="o">=</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_substitute_bindings</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">retract_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the feature structure that is obtained by replacing each</span>
<span class="sd">    feature structure value that is bound by ``bindings`` with the</span>
<span class="sd">    variable that binds it.  A feature structure value must be</span>
<span class="sd">    identical to a bound value (i.e., have equal id) to be replaced.</span>

<span class="sd">    ``bindings`` is modified to point to this new feature structure,</span>
<span class="sd">    rather than the original feature structure.  Feature structure</span>
<span class="sd">    values in ``bindings`` may be modified if they are contained in</span>
<span class="sd">    ``fstruct``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
        <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">new_bindings</span><span class="p">)</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">((</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">bindings</span><span class="p">))</span>
    <span class="n">bindings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_bindings</span><span class="p">)</span>
    <span class="n">inv_bindings</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">val</span><span class="p">):</span> <span class="n">var</span> <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">_retract_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">inv_bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">fstruct</span>


<span class="k">def</span> <span class="nf">_retract_bindings</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">inv_bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="c1"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected mapping or sequence&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">inv_bindings</span><span class="p">:</span>
                <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_bindings</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]</span>
            <span class="n">_retract_bindings</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">inv_bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">find_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: The set of variables used by this feature structure.</span>
<span class="sd">    :rtype: set(Variable)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
        <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="c1"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected mapping or sequence&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_variables</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="nb">vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fval</span><span class="o">.</span><span class="n">variables</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">vars</span>


<span class="k">def</span> <span class="nf">rename_variables</span><span class="p">(</span>
    <span class="n">fstruct</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">used_vars</span><span class="o">=</span><span class="p">(),</span> <span class="n">new_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s2">&quot;default&quot;</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the feature structure that is obtained by replacing</span>
<span class="sd">    any of this feature structure&#39;s variables that are in ``vars``</span>
<span class="sd">    with new variables.  The names for these new variables will be</span>
<span class="sd">    names that are not used by any variable in ``vars``, or in</span>
<span class="sd">    ``used_vars``, or in this feature structure.</span>

<span class="sd">    :type vars: set</span>
<span class="sd">    :param vars: The set of variables that should be renamed.</span>
<span class="sd">        If not specified, ``find_variables(fstruct)`` is used; i.e., all</span>
<span class="sd">        variables will be given new names.</span>
<span class="sd">    :type used_vars: set</span>
<span class="sd">    :param used_vars: A set of variables whose names should not be</span>
<span class="sd">        used by the new variables.</span>
<span class="sd">    :type new_vars: dict(Variable -&gt; Variable)</span>
<span class="sd">    :param new_vars: A dictionary that is used to hold the mapping</span>
<span class="sd">        from old variables to new variables.  For each variable *v*</span>
<span class="sd">        in this feature structure:</span>

<span class="sd">        - If ``new_vars`` maps *v* to *v&#39;*, then *v* will be</span>
<span class="sd">          replaced by *v&#39;*.</span>
<span class="sd">        - If ``new_vars`` does not contain *v*, but ``vars``</span>
<span class="sd">          does contain *v*, then a new entry will be added to</span>
<span class="sd">          ``new_vars``, mapping *v* to the new variable that is used</span>
<span class="sd">          to replace it.</span>

<span class="sd">    To consistently rename the variables in a set of feature</span>
<span class="sd">    structures, simply apply rename_variables to each one, using</span>
<span class="sd">    the same dictionary:</span>

<span class="sd">        &gt;&gt;&gt; from nltk.featstruct import FeatStruct</span>
<span class="sd">        &gt;&gt;&gt; fstruct1 = FeatStruct(&#39;[subj=[agr=[gender=?y]], obj=[agr=[gender=?y]]]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; fstruct2 = FeatStruct(&#39;[subj=[agr=[number=?z,gender=?y]], obj=[agr=[number=?z,gender=?y]]]&#39;)</span>
<span class="sd">        &gt;&gt;&gt; new_vars = {}  # Maps old vars to alpha-renamed vars</span>
<span class="sd">        &gt;&gt;&gt; fstruct1.rename_variables(new_vars=new_vars)</span>
<span class="sd">        [obj=[agr=[gender=?y2]], subj=[agr=[gender=?y2]]]</span>
<span class="sd">        &gt;&gt;&gt; fstruct2.rename_variables(new_vars=new_vars)</span>
<span class="sd">        [obj=[agr=[gender=?y2, number=?z2]], subj=[agr=[gender=?y2, number=?z2]]]</span>

<span class="sd">    If new_vars is not specified, then an empty dictionary is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
        <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>

    <span class="c1"># Default values:</span>
    <span class="k">if</span> <span class="n">new_vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">new_vars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">vars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>

    <span class="c1"># Add our own variables to used_vars.</span>
    <span class="n">used_vars</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">used_vars</span><span class="p">)</span>

    <span class="c1"># Copy ourselves, and rename variables in the copy.</span>
    <span class="k">return</span> <span class="n">_rename_variables</span><span class="p">(</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fstruct</span><span class="p">),</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">()</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_rename_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected mapping or sequence&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="c1"># If it&#39;s in new_vars, then rebind it.</span>
            <span class="k">if</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">new_vars</span><span class="p">:</span>
                <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span>
            <span class="c1"># If it&#39;s in vars, pick a new name for it.</span>
            <span class="k">elif</span> <span class="n">fval</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                <span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rename_variable</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">)</span>
                <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">]</span>
                <span class="n">used_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_vars</span><span class="p">[</span><span class="n">fval</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_rename_variables</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">,</span> <span class="n">new_vars</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="c1"># Pick new names for any variables in `vars`</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">fval</span><span class="o">.</span><span class="n">variables</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">vars</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_vars</span><span class="p">:</span>
                    <span class="n">new_vars</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rename_variable</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">)</span>
                    <span class="n">used_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_vars</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>
            <span class="c1"># Replace all variables in `new_vars`.</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">new_vars</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fstruct</span>


<span class="k">def</span> <span class="nf">_rename_variable</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">used_vars</span><span class="p">):</span>
    <span class="n">name</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;?&quot;</span>
    <span class="k">while</span> <span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">used_vars</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">remove_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :rtype: FeatStruct</span>
<span class="sd">    :return: The feature structure that is obtained by deleting</span>
<span class="sd">        all features whose values are ``Variables``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
        <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_remove_variables</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">fstruct</span><span class="p">),</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_remove_variables</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected mapping or sequence&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="n">_remove_variables</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fstruct</span>


<span class="c1">######################################################################</span>
<span class="c1"># Unification</span>
<span class="c1">######################################################################</span>


<span class="k">class</span> <span class="nc">_UnificationFailure</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;nltk.featstruct.UnificationFailure&quot;</span>


<span class="n">UnificationFailure</span> <span class="o">=</span> <span class="n">_UnificationFailure</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;A unique value used to indicate unification failure.  It can be</span>
<span class="sd">   returned by ``Feature.unify_base_values()`` or by custom ``fail()``</span>
<span class="sd">   functions to indicate that unificaiton should fail.&quot;&quot;&quot;</span>


<span class="c1"># The basic unification algorithm:</span>
<span class="c1">#   1. Make copies of self and other (preserving reentrance)</span>
<span class="c1">#   2. Destructively unify self and other</span>
<span class="c1">#   3. Apply forward pointers, to preserve reentrance.</span>
<span class="c1">#   4. Replace bound variables with their values.</span>
<div class="viewcode-block" id="unify"><a class="viewcode-back" href="../../api/nltk.featstruct.unify.html#nltk.featstruct.unify">[docs]</a><span class="k">def</span> <span class="nf">unify</span><span class="p">(</span>
    <span class="n">fstruct1</span><span class="p">,</span>
    <span class="n">fstruct2</span><span class="p">,</span>
    <span class="n">bindings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">fail</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">rename_vars</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">fs_class</span><span class="o">=</span><span class="s2">&quot;default&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unify ``fstruct1`` with ``fstruct2``, and return the resulting feature</span>
<span class="sd">    structure.  This unified feature structure is the minimal</span>
<span class="sd">    feature structure that contains all feature value assignments from both</span>
<span class="sd">    ``fstruct1`` and ``fstruct2``, and that preserves all reentrancies.</span>

<span class="sd">    If no such feature structure exists (because ``fstruct1`` and</span>
<span class="sd">    ``fstruct2`` specify incompatible values for some feature), then</span>
<span class="sd">    unification fails, and ``unify`` returns None.</span>

<span class="sd">    Bound variables are replaced by their values.  Aliased</span>
<span class="sd">    variables are replaced by their representative variable</span>
<span class="sd">    (if unbound) or the value of their representative variable</span>
<span class="sd">    (if bound).  I.e., if variable *v* is in ``bindings``,</span>
<span class="sd">    then *v* is replaced by ``bindings[v]``.  This will</span>
<span class="sd">    be repeated until the variable is replaced by an unbound</span>
<span class="sd">    variable or a non-variable value.</span>

<span class="sd">    Unbound variables are bound when they are unified with</span>
<span class="sd">    values; and aliased when they are unified with variables.</span>
<span class="sd">    I.e., if variable *v* is not in ``bindings``, and is</span>
<span class="sd">    unified with a variable or value *x*, then</span>
<span class="sd">    ``bindings[v]`` is set to *x*.</span>

<span class="sd">    If ``bindings`` is unspecified, then all variables are</span>
<span class="sd">    assumed to be unbound.  I.e., ``bindings`` defaults to an</span>
<span class="sd">    empty dict.</span>

<span class="sd">        &gt;&gt;&gt; from nltk.featstruct import FeatStruct</span>
<span class="sd">        &gt;&gt;&gt; FeatStruct(&#39;[a=?x]&#39;).unify(FeatStruct(&#39;[b=?x]&#39;))</span>
<span class="sd">        [a=?x, b=?x2]</span>

<span class="sd">    :type bindings: dict(Variable -&gt; any)</span>
<span class="sd">    :param bindings: A set of variable bindings to be used and</span>
<span class="sd">        updated during unification.</span>
<span class="sd">    :type trace: bool</span>
<span class="sd">    :param trace: If true, generate trace output.</span>
<span class="sd">    :type rename_vars: bool</span>
<span class="sd">    :param rename_vars: If True, then rename any variables in</span>
<span class="sd">        ``fstruct2`` that are also used in ``fstruct1``, in order to</span>
<span class="sd">        avoid collisions on variable names.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Decide which class(es) will be treated as feature structures,</span>
    <span class="c1"># for the purposes of unification.</span>
    <span class="k">if</span> <span class="n">fs_class</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
        <span class="n">fs_class</span> <span class="o">=</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_default_fs_class</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fs_class</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Mixing FeatStruct objects with Python &quot;</span>
                <span class="s2">&quot;dicts and lists is not supported.&quot;</span>
            <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>

    <span class="c1"># If bindings are unspecified, use an empty set of bindings.</span>
    <span class="n">user_bindings</span> <span class="o">=</span> <span class="n">bindings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">bindings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bindings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Make copies of fstruct1 and fstruct2 (since the unification</span>
    <span class="c1"># algorithm is destructive). Do it all at once, to preserve</span>
    <span class="c1"># reentrance links between fstruct1 and fstruct2.  Copy bindings</span>
    <span class="c1"># as well, in case there are any bound vars that contain parts</span>
    <span class="c1"># of fstruct1 or fstruct2.</span>
    <span class="p">(</span><span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">bindings_copy</span><span class="p">)</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span>
        <span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Copy the bindings back to the original bindings dict.</span>
    <span class="n">bindings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bindings_copy</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rename_vars</span><span class="p">:</span>
        <span class="n">vars1</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
        <span class="n">vars2</span> <span class="o">=</span> <span class="n">find_variables</span><span class="p">(</span><span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span>
        <span class="n">_rename_variables</span><span class="p">(</span><span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">vars1</span><span class="p">,</span> <span class="n">vars2</span><span class="p">,</span> <span class="p">{},</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

    <span class="c1"># Do the actual unification.  If it fails, return None.</span>
    <span class="n">forward</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
        <span class="n">_trace_unify_start</span><span class="p">((),</span> <span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_destructively_unify</span><span class="p">(</span>
            <span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="p">()</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="n">_UnificationFailureError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># _destructively_unify might return UnificationFailure, e.g. if we</span>
    <span class="c1"># tried to unify a mapping with a sequence.</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fail</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fail</span><span class="p">(</span><span class="n">fstruct1copy</span><span class="p">,</span> <span class="n">fstruct2copy</span><span class="p">,</span> <span class="p">())</span>

    <span class="c1"># Replace any feature structure that has a forward pointer</span>
    <span class="c1"># with the target of its forward pointer.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">_apply_forwards</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">user_bindings</span><span class="p">:</span>
        <span class="n">_apply_forwards_to_bindings</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>

    <span class="c1"># Replace bound vars with values.</span>
    <span class="n">_resolve_aliases</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>
    <span class="n">_substitute_bindings</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

    <span class="c1"># Return the result.</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
        <span class="n">_trace_unify_succeed</span><span class="p">((),</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
        <span class="n">_trace_bindings</span><span class="p">((),</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">class</span> <span class="nc">_UnificationFailureError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An exception that is used by ``_destructively_unify`` to abort</span>
<span class="sd">    unification when a failure is encountered.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_destructively_unify</span><span class="p">(</span>
    <span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">path</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempt to unify ``fstruct1`` and ``fstruct2`` by modifying them</span>
<span class="sd">    in-place.  If the unification succeeds, then ``fstruct1`` will</span>
<span class="sd">    contain the unified value, the value of ``fstruct2`` is undefined,</span>
<span class="sd">    and forward[id(fstruct2)] is set to fstruct1.  If the unification</span>
<span class="sd">    fails, then a _UnificationFailureError is raised, and the</span>
<span class="sd">    values of ``fstruct1`` and ``fstruct2`` are undefined.</span>

<span class="sd">    :param bindings: A dictionary mapping variables to values.</span>
<span class="sd">    :param forward: A dictionary mapping feature structures ids</span>
<span class="sd">        to replacement structures.  When two feature structures</span>
<span class="sd">        are merged, a mapping from one to the other will be added</span>
<span class="sd">        to the forward dictionary; and changes will be made only</span>
<span class="sd">        to the target of the forward dictionary.</span>
<span class="sd">        ``_destructively_unify`` will always &#39;follow&#39; any links</span>
<span class="sd">        in the forward dictionary for fstruct1 and fstruct2 before</span>
<span class="sd">        actually unifying them.</span>
<span class="sd">    :param trace: If true, generate trace output</span>
<span class="sd">    :param path: The feature path that led us to this unification</span>
<span class="sd">        step.  Used for trace output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If fstruct1 is already identical to fstruct2, we&#39;re done.</span>
    <span class="c1"># Note: this, together with the forward pointers, ensures</span>
    <span class="c1"># that unification will terminate even for cyclic structures.</span>
    <span class="k">if</span> <span class="n">fstruct1</span> <span class="ow">is</span> <span class="n">fstruct2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
            <span class="n">_trace_unify_identity</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fstruct1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fstruct1</span>

    <span class="c1"># Set fstruct2&#39;s forward pointer to point to fstruct1; this makes</span>
    <span class="c1"># fstruct1 the canonical copy for fstruct2.  Note that we need to</span>
    <span class="c1"># do this before we recurse into any child structures, in case</span>
    <span class="c1"># they&#39;re cyclic.</span>
    <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fstruct1</span>

    <span class="c1"># Unifying two mappings:</span>
    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fstruct1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fstruct2</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fname</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fstruct2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fstruct1</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fname</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>

        <span class="c1"># Unify any values that are defined in both fstruct1 and</span>
        <span class="c1"># fstruct2.  Copy any values that are defined in fstruct2 but</span>
        <span class="c1"># not in fstruct1 to fstruct1.  Note: sorting fstruct2&#39;s</span>
        <span class="c1"># features isn&#39;t actually necessary; but we do it to give</span>
        <span class="c1"># deterministic behavior, e.g. for tracing.</span>
        <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fval2</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">fstruct2</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fstruct1</span><span class="p">:</span>
                <span class="n">fstruct1</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unify_feature_values</span><span class="p">(</span>
                    <span class="n">fname</span><span class="p">,</span>
                    <span class="n">fstruct1</span><span class="p">[</span><span class="n">fname</span><span class="p">],</span>
                    <span class="n">fval2</span><span class="p">,</span>
                    <span class="n">bindings</span><span class="p">,</span>
                    <span class="n">forward</span><span class="p">,</span>
                    <span class="n">trace</span><span class="p">,</span>
                    <span class="n">fail</span><span class="p">,</span>
                    <span class="n">fs_class</span><span class="p">,</span>
                    <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="n">fname</span><span class="p">,),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fstruct1</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval2</span>

        <span class="k">return</span> <span class="n">fstruct1</span>  <span class="c1"># Contains the unified value.</span>

    <span class="c1"># Unifying two sequences:</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">):</span>
        <span class="c1"># If the lengths don&#39;t match, fail.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">UnificationFailure</span>

        <span class="c1"># Unify corresponding values in fstruct1 and fstruct2.</span>
        <span class="k">for</span> <span class="n">findex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)):</span>
            <span class="n">fstruct1</span><span class="p">[</span><span class="n">findex</span><span class="p">]</span> <span class="o">=</span> <span class="n">_unify_feature_values</span><span class="p">(</span>
                <span class="n">findex</span><span class="p">,</span>
                <span class="n">fstruct1</span><span class="p">[</span><span class="n">findex</span><span class="p">],</span>
                <span class="n">fstruct2</span><span class="p">[</span><span class="n">findex</span><span class="p">],</span>
                <span class="n">bindings</span><span class="p">,</span>
                <span class="n">forward</span><span class="p">,</span>
                <span class="n">trace</span><span class="p">,</span>
                <span class="n">fail</span><span class="p">,</span>
                <span class="n">fs_class</span><span class="p">,</span>
                <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="n">findex</span><span class="p">,),</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fstruct1</span>  <span class="c1"># Contains the unified value.</span>

    <span class="c1"># Unifying sequence &amp; mapping: fail.  The failure function</span>
    <span class="c1"># doesn&#39;t get a chance to recover in this case.</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct2</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">UnificationFailure</span>

    <span class="c1"># Unifying anything else: not allowed!</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected mappings or sequences&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_unify_feature_values</span><span class="p">(</span>
    <span class="n">fname</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">fpath</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempt to unify ``fval1`` and and ``fval2``, and return the</span>
<span class="sd">    resulting unified value.  The method of unification will depend on</span>
<span class="sd">    the types of ``fval1`` and ``fval2``:</span>

<span class="sd">      1. If they&#39;re both feature structures, then destructively</span>
<span class="sd">         unify them (see ``_destructively_unify()``.</span>
<span class="sd">      2. If they&#39;re both unbound variables, then alias one variable</span>
<span class="sd">         to the other (by setting bindings[v2]=v1).</span>
<span class="sd">      3. If one is an unbound variable, and the other is a value,</span>
<span class="sd">         then bind the unbound variable to the value.</span>
<span class="sd">      4. If one is a feature structure, and the other is a base value,</span>
<span class="sd">         then fail.</span>
<span class="sd">      5. If they&#39;re both base values, then unify them.  By default,</span>
<span class="sd">         this will succeed if they are equal, and fail otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
        <span class="n">_trace_unify_start</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">)</span>

    <span class="c1"># Look up the &quot;canonical&quot; copy of fval1 and fval2</span>
    <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
        <span class="n">fval1</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval1</span><span class="p">)]</span>
    <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
        <span class="n">fval2</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval2</span><span class="p">)]</span>

    <span class="c1"># If fval1 or fval2 is a bound variable, then</span>
    <span class="c1"># replace it by the variable&#39;s bound value.  This</span>
    <span class="c1"># includes aliased variables, which are encoded as</span>
    <span class="c1"># variables bound to other variables.</span>
    <span class="n">fvar1</span> <span class="o">=</span> <span class="n">fvar2</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fval1</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
        <span class="n">fvar1</span> <span class="o">=</span> <span class="n">fval1</span>
        <span class="n">fval1</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">fval1</span><span class="p">]</span>
    <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">fval2</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
        <span class="n">fvar2</span> <span class="o">=</span> <span class="n">fval2</span>
        <span class="n">fval2</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">fval2</span><span class="p">]</span>

    <span class="c1"># Case 1: Two feature structures (recursive case)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_destructively_unify</span><span class="p">(</span>
            <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">fail</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">fpath</span>
        <span class="p">)</span>

    <span class="c1"># Case 2: Two unbound variables (create alias)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fval1</span> <span class="o">!=</span> <span class="n">fval2</span><span class="p">:</span>
            <span class="n">bindings</span><span class="p">[</span><span class="n">fval2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span>

    <span class="c1"># Case 3: An unbound variable and a value (bind)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="n">bindings</span><span class="p">[</span><span class="n">fval1</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval2</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="n">bindings</span><span class="p">[</span><span class="n">fval2</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval1</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">fval2</span>

    <span class="c1"># Case 4: A feature structure &amp; a base value (fail)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">UnificationFailure</span>

    <span class="c1"># Case 5: Two base values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Case 5a: Feature defines a custom unification method for base values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">Feature</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">unify_base_values</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>
        <span class="c1"># Case 5b: Feature value defines custom unification method</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">CustomFeatureValue</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval2</span><span class="p">)</span>
            <span class="c1"># Sanity check: unify value should be symmetric</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">CustomFeatureValue</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span> <span class="o">!=</span> <span class="n">fval2</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="s2">&quot;CustomFeatureValue objects </span><span class="si">%r</span><span class="s2"> and </span><span class="si">%r</span><span class="s2"> disagree &quot;</span>
                    <span class="s2">&quot;about unification value: </span><span class="si">%r</span><span class="s2"> vs. </span><span class="si">%r</span><span class="s2">&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">fval2</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval1</span><span class="p">))</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval2</span><span class="p">,</span> <span class="n">CustomFeatureValue</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fval2</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fval1</span><span class="p">)</span>
        <span class="c1"># Case 5c: Simple values -- check if they&#39;re equal.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fval1</span> <span class="o">==</span> <span class="n">fval2</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">fval1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">UnificationFailure</span>

        <span class="c1"># If either value was a bound variable, then update the</span>
        <span class="c1"># bindings.  (This is really only necessary if fname is a</span>
        <span class="c1"># Feature or if either value is a CustomFeatureValue.)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">UnificationFailure</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fvar1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bindings</span><span class="p">[</span><span class="n">fvar1</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">fvar1</span>
            <span class="k">if</span> <span class="n">fvar2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fvar2</span> <span class="o">!=</span> <span class="n">fvar1</span><span class="p">:</span>
                <span class="n">bindings</span><span class="p">[</span><span class="n">fvar2</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">fvar2</span>

    <span class="c1"># If we unification failed, call the failure function; it</span>
    <span class="c1"># might decide to continue anyway.</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fail</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">fpath</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
            <span class="n">_trace_unify_fail</span><span class="p">(</span><span class="n">fpath</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">_UnificationFailureError</span>

    <span class="c1"># Normalize the result.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_apply_forwards</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
        <span class="n">_trace_unify_succeed</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">trace</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
        <span class="n">_trace_bindings</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_apply_forwards_to_bindings</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace any feature structure that has a forward pointer with</span>
<span class="sd">    the target of its forward pointer (to preserve reentrancy).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="n">bindings</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_apply_forwards</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace any feature structure that has a forward pointer with</span>
<span class="sd">    the target of its forward pointer (to preserve reentrancy).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Follow our own forwards pointers (if any)</span>
    <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
        <span class="n">fstruct</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)]</span>

    <span class="c1"># Visit each node only once:</span>
    <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">fstruct</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">_is_mapping</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">fstruct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">_is_sequence</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fstruct</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected mapping or sequence&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">):</span>
            <span class="c1"># Replace w/ forwarded value.</span>
            <span class="k">while</span> <span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span> <span class="ow">in</span> <span class="n">forward</span><span class="p">:</span>
                <span class="n">fval</span> <span class="o">=</span> <span class="n">forward</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">fval</span><span class="p">)]</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">fname</span><span class="p">]</span> <span class="o">=</span> <span class="n">fval</span>
            <span class="c1"># Recurse to child.</span>
            <span class="n">_apply_forwards</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">forward</span><span class="p">,</span> <span class="n">fs_class</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fstruct</span>


<span class="k">def</span> <span class="nf">_resolve_aliases</span><span class="p">(</span><span class="n">bindings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace any bound aliased vars with their binding; and replace</span>
<span class="sd">    any unbound aliased vars with their representative var.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">bindings</span><span class="p">[</span><span class="n">value</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_trace_unify_start</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Unification trace:&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fullname</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">path</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;| Unify feature: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fullname</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; / &quot;</span> <span class="o">+</span> <span class="n">_trace_valrepr</span><span class="p">(</span><span class="n">fval1</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;|</span><span class="se">\\</span><span class="s2"> &quot;</span> <span class="o">+</span> <span class="n">_trace_valrepr</span><span class="p">(</span><span class="n">fval2</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_trace_unify_identity</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fval1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;| (identical objects)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;+--&gt;&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fval1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_trace_unify_fail</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="n">UnificationFailure</span><span class="p">:</span>
        <span class="n">resume</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resume</span> <span class="o">=</span> <span class="s2">&quot; (nonfatal)&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;|   |&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;X   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;X   X &lt;-- FAIL&quot;</span> <span class="o">+</span> <span class="n">resume</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_trace_unify_succeed</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">fval1</span><span class="p">):</span>
    <span class="c1"># Print the result.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;+--&gt;&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fval1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_trace_bindings</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
    <span class="c1"># Print the bindings (if any).</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">binditems</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">bindings</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">bindstr</span> <span class="o">=</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">_trace_valrepr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">binditems</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;|   &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;    Bindings: &quot;</span> <span class="o">+</span> <span class="n">bindstr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_trace_valrepr</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Variable</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<div class="viewcode-block" id="subsumes"><a class="viewcode-back" href="../../api/nltk.featstruct.subsumes.html#nltk.featstruct.subsumes">[docs]</a><span class="k">def</span> <span class="nf">subsumes</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if ``fstruct1`` subsumes ``fstruct2``.  I.e., return</span>
<span class="sd">    true if unifying ``fstruct1`` with ``fstruct2`` would result in a</span>
<span class="sd">    feature structure equal to ``fstruct2.``</span>

<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">fstruct2</span> <span class="o">==</span> <span class="n">unify</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">)</span></div>


<div class="viewcode-block" id="conflicts"><a class="viewcode-back" href="../../api/nltk.featstruct.conflicts.html#nltk.featstruct.conflicts">[docs]</a><span class="k">def</span> <span class="nf">conflicts</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of the feature paths of all features which are</span>
<span class="sd">    assigned incompatible values by ``fstruct1`` and ``fstruct2``.</span>

<span class="sd">    :rtype: list(tuple)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">conflict_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_conflict</span><span class="p">(</span><span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="n">conflict_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fval1</span>

    <span class="n">unify</span><span class="p">(</span><span class="n">fstruct1</span><span class="p">,</span> <span class="n">fstruct2</span><span class="p">,</span> <span class="n">fail</span><span class="o">=</span><span class="n">add_conflict</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">conflict_list</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># Helper Functions</span>
<span class="c1">######################################################################</span>


<span class="k">def</span> <span class="nf">_is_mapping</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;__contains__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;keys&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_sequence</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_default_fs_class</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FeatStruct</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;To unify objects of type </span><span class="si">%s</span><span class="s2">, you must specify &quot;</span>
            <span class="s2">&quot;fs_class explicitly.&quot;</span> <span class="o">%</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">)</span>


<span class="c1">######################################################################</span>
<span class="c1"># FeatureValueSet &amp; FeatureValueTuple</span>
<span class="c1">######################################################################</span>


<span class="k">class</span> <span class="nc">SubstituteBindingsSequence</span><span class="p">(</span><span class="n">SubstituteBindingsI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mixin class for sequence classes that distributes variables() and</span>
<span class="sd">    substitute_bindings() over the object&#39;s elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">elt</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="n">elt</span><span class="o">.</span><span class="n">variables</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="p">[],</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">substitute_bindings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">subst</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">subst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">SubstituteBindingsI</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">substitute_bindings</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bindings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FeatureValueTuple</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that is a tuple of other base feature values.</span>
<span class="sd">    FeatureValueTuple implements ``SubstituteBindingsI``, so it any</span>
<span class="sd">    variable substitutions will be propagated to the elements</span>
<span class="sd">    contained by the set.  A ``FeatureValueTuple`` is immutable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># [xx] really use %s here?</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;()&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FeatureValueSet</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that is a set of other base feature values.</span>
<span class="sd">    FeatureValueSet implements ``SubstituteBindingsI``, so it any</span>
<span class="sd">    variable substitutions will be propagated to the elements</span>
<span class="sd">    contained by the set.  A ``FeatureValueSet`` is immutable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># [xx] really use %s here?</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;{/}&quot;</span>  <span class="c1"># distinguish from dict.</span>
        <span class="c1"># n.b., we sort the string reprs of our elements, to ensure</span>
        <span class="c1"># that our own repr is deterministic.</span>
        <span class="k">return</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>

    <span class="fm">__str__</span> <span class="o">=</span> <span class="fm">__repr__</span>


<span class="k">class</span> <span class="nc">FeatureValueUnion</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that represents the union of two or more</span>
<span class="sd">    ``FeatureValueSet`` or ``Variable``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># If values contains FeatureValueUnions, then collapse them.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueUnion</span><span class="p">)</span>

        <span class="c1"># If the resulting list contains no variables, then</span>
        <span class="c1"># use a simple FeatureValueSet instead.</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueSet</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FeatureValueSet</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># If we contain a single variable, return that variable.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Otherwise, build the FeatureValueUnion.</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># n.b., we sort the string reprs of our elements, to ensure</span>
        <span class="c1"># that our own repr is deterministic.  also, note that len(self)</span>
        <span class="c1"># is guaranteed to be 2 or more.</span>
        <span class="k">return</span> <span class="s2">&quot;{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">FeatureValueConcat</span><span class="p">(</span><span class="n">SubstituteBindingsSequence</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A base feature value that represents the concatenation of two or</span>
<span class="sd">    more ``FeatureValueTuple`` or ``Variable``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># If values contains FeatureValueConcats, then collapse them.</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueConcat</span><span class="p">)</span>

        <span class="c1"># If the resulting list contains no variables, then</span>
        <span class="c1"># use a simple FeatureValueTuple instead.</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">FeatureValueTuple</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FeatureValueTuple</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="c1"># If we contain a single variable, return that variable.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Otherwise, build the FeatureValueConcat.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># n.b.: len(self) is guaranteed to be 2 or more.</span>
        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function -- return a copy of list, with all elements of</span>
<span class="sd">    type ``cls`` spliced in rather than appended in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1">######################################################################</span>
<span class="c1"># Specialized Features</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="Feature"><a class="viewcode-back" href="../../api/nltk.featstruct.Feature.html#nltk.featstruct.Feature">[docs]</a><span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Feature</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A feature identifier that&#39;s specialized to put additional</span>
<span class="sd">    constraints, default values, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Feature.__init__"><a class="viewcode-back" href="../../api/nltk.featstruct.Feature.html#nltk.featstruct.Feature.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">display</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;prefix&quot;</span><span class="p">,</span> <span class="s2">&quot;slash&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># [xx] rename to .identifier?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">default</span>  <span class="c1"># [xx] not implemented yet.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">=</span> <span class="n">display</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">==</span> <span class="s2">&quot;prefix&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">==</span> <span class="s2">&quot;slash&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The name of this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default value for this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Custom display location: can be prefix, or slash.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;*</span><span class="si">%s</span><span class="s2">*&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Feature</span><span class="p">):</span>
            <span class="n">raise_unorderable_types</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sortkey</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_sortkey</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># These can be overridden by subclasses:</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Feature.read_value"><a class="viewcode-back" href="../../api/nltk.featstruct.Feature.html#nltk.featstruct.Feature.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span></div>

<div class="viewcode-block" id="Feature.unify_base_values"><a class="viewcode-back" href="../../api/nltk.featstruct.Feature.html#nltk.featstruct.Feature.unify_base_values">[docs]</a>    <span class="k">def</span> <span class="nf">unify_base_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If possible, return a single value..  If not, return</span>
<span class="sd">        the value ``UnificationFailure``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fval1</span> <span class="o">==</span> <span class="n">fval2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fval1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnificationFailure</span></div></div>


<div class="viewcode-block" id="SlashFeature"><a class="viewcode-back" href="../../api/nltk.featstruct.SlashFeature.html#nltk.featstruct.SlashFeature">[docs]</a><span class="k">class</span> <span class="nc">SlashFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
<div class="viewcode-block" id="SlashFeature.read_value"><a class="viewcode-back" href="../../api/nltk.featstruct.SlashFeature.html#nltk.featstruct.SlashFeature.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RangeFeature"><a class="viewcode-back" href="../../api/nltk.featstruct.RangeFeature.html#nltk.featstruct.RangeFeature">[docs]</a><span class="k">class</span> <span class="nc">RangeFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
    <span class="n">RANGE_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(-?\d+):(-?\d+)&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RangeFeature.read_value"><a class="viewcode-back" href="../../api/nltk.featstruct.RangeFeature.html#nltk.featstruct.RangeFeature.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">parser</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RANGE_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;range&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span></div>

<div class="viewcode-block" id="RangeFeature.unify_base_values"><a class="viewcode-back" href="../../api/nltk.featstruct.RangeFeature.html#nltk.featstruct.RangeFeature.unify_base_values">[docs]</a>    <span class="k">def</span> <span class="nf">unify_base_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fval1</span><span class="p">,</span> <span class="n">fval2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">fval1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fval2</span>
        <span class="k">if</span> <span class="n">fval2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fval1</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fval1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fval2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">fval1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fval2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">UnificationFailure</span>
        <span class="k">return</span> <span class="n">rng</span></div></div>


<span class="n">SLASH</span> <span class="o">=</span> <span class="n">SlashFeature</span><span class="p">(</span><span class="s2">&quot;slash&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="s2">&quot;slash&quot;</span><span class="p">)</span>
<span class="n">TYPE</span> <span class="o">=</span> <span class="n">Feature</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="s2">&quot;prefix&quot;</span><span class="p">)</span>


<span class="c1">######################################################################</span>
<span class="c1"># Specialized Feature Values</span>
<span class="c1">######################################################################</span>


<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">CustomFeatureValue</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract base class for base values that define a custom</span>
<span class="sd">    unification method.  The custom unification method of</span>
<span class="sd">    ``CustomFeatureValue`` will be used during unification if:</span>

<span class="sd">      - The ``CustomFeatureValue`` is unified with another base value.</span>
<span class="sd">      - The ``CustomFeatureValue`` is not the value of a customized</span>
<span class="sd">        ``Feature`` (which defines its own unification method).</span>

<span class="sd">    If two ``CustomFeatureValue`` objects are unified with one another</span>
<span class="sd">    during feature structure unification, then the unified base values</span>
<span class="sd">    they return *must* be equal; otherwise, an ``AssertionError`` will</span>
<span class="sd">    be raised.</span>

<span class="sd">    Subclasses must define ``unify()``, ``__eq__()`` and ``__lt__()``.</span>
<span class="sd">    Subclasses may also wish to define ``__hash__()``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">unify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If this base value unifies with ``other``, then return the</span>
<span class="sd">        unified value.  Otherwise, return ``UnificationFailure``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;abstract base class&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> objects or unhashable&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1">######################################################################</span>
<span class="c1"># Feature Structure Reader</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="FeatStructReader"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader">[docs]</a><span class="k">class</span> <span class="nc">FeatStructReader</span><span class="p">:</span>
<div class="viewcode-block" id="FeatStructReader.__init__"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">features</span><span class="o">=</span><span class="p">(</span><span class="n">SLASH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">),</span>
        <span class="n">fdict_class</span><span class="o">=</span><span class="n">FeatStruct</span><span class="p">,</span>
        <span class="n">flist_class</span><span class="o">=</span><span class="n">FeatList</span><span class="p">,</span>
        <span class="n">logic_parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fdict_class</span> <span class="o">=</span> <span class="n">fdict_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flist_class</span> <span class="o">=</span> <span class="n">flist_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="s2">&quot;slash&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiple features w/ display=slash&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span> <span class="o">=</span> <span class="n">feature</span>
            <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="s2">&quot;prefix&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiple features w/ display=prefix&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span> <span class="o">=</span> <span class="n">feature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features_with_defaults</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">feature</span> <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span> <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="n">logic_parser</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logic_parser</span> <span class="o">=</span> <span class="n">LogicParser</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logic_parser</span> <span class="o">=</span> <span class="n">logic_parser</span></div>

<div class="viewcode-block" id="FeatStructReader.fromstring"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.fromstring">[docs]</a>    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fstruct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a string representation of a feature structure (as</span>
<span class="sd">        displayed by repr) into a ``FeatStruct``.  This process</span>
<span class="sd">        imposes the following restrictions on the string</span>
<span class="sd">        representation:</span>

<span class="sd">        - Feature names cannot contain any of the following:</span>
<span class="sd">          whitespace, parentheses, quote marks, equals signs,</span>
<span class="sd">          dashes, commas, and square brackets.  Feature names may</span>
<span class="sd">          not begin with plus signs or minus signs.</span>
<span class="sd">        - Only the following basic feature value are supported:</span>
<span class="sd">          strings, integers, variables, None, and unquoted</span>
<span class="sd">          alphanumeric strings.</span>
<span class="sd">        - For reentrant values, the first mention must specify</span>
<span class="sd">          a reentrance identifier and a value; and any subsequent</span>
<span class="sd">          mentions must use arrows (``&#39;-&gt;&#39;``) to reference the</span>
<span class="sd">          reentrance identifier.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{},</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s2">&quot;end of string&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

    <span class="n">_START_FSTRUCT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(?:\((\d+)\)\s*)?(\??[\w-]+)?(\[)&quot;</span><span class="p">)</span>
    <span class="n">_END_FSTRUCT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*]\s*&quot;</span><span class="p">)</span>
    <span class="n">_SLASH_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
    <span class="n">_FEATURE_NAME_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\s*([+-]?)([^\s\(\)&lt;&gt;&quot;</span><span class="se">\&#39;</span><span class="s1">\-=\[\],]+)\s*&#39;</span><span class="p">)</span>
    <span class="n">_REENTRANCE_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*-&gt;\s*&quot;</span><span class="p">)</span>
    <span class="n">_TARGET_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*\((\d+)\)\s*&quot;</span><span class="p">)</span>
    <span class="n">_ASSIGN_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*=\s*&quot;</span><span class="p">)</span>
    <span class="n">_COMMA_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*,\s*&quot;</span><span class="p">)</span>
    <span class="n">_BARE_PREFIX_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(?:\((\d+)\)\s*)?(\??[\w-]+\s*)()&quot;</span><span class="p">)</span>
    <span class="c1"># This one is used to distinguish fdicts from flists:</span>
    <span class="n">_START_FDICT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)|(</span><span class="si">%s</span><span class="s2">\s*(</span><span class="si">%s</span><span class="s2">\s*(=|-&gt;)|[+-]</span><span class="si">%s</span><span class="s2">|\]))&quot;</span>
        <span class="o">%</span> <span class="p">(</span>
            <span class="n">_BARE_PREFIX_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span>
            <span class="n">_START_FSTRUCT_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span>
            <span class="n">_FEATURE_NAME_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span>
            <span class="n">_FEATURE_NAME_RE</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

<div class="viewcode-block" id="FeatStructReader.read_partial"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_partial">[docs]</a>    <span class="k">def</span> <span class="nf">read_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">reentrances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fstruct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that reads in a feature structure.</span>

<span class="sd">        :param s: The string to read.</span>
<span class="sd">        :param position: The position in the string to start parsing.</span>
<span class="sd">        :param reentrances: A dictionary from reentrance ids to values.</span>
<span class="sd">            Defaults to an empty dictionary.</span>
<span class="sd">        :return: A tuple (val, pos) of the feature structure created by</span>
<span class="sd">            parsing and the position where the parsed feature structure ends.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reentrances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reentrances</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_read_partial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Create the new feature structure</span>
        <span class="k">if</span> <span class="n">fstruct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_START_FDICT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
                <span class="n">fstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fdict_class</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fstruct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flist_class</span><span class="p">()</span>

        <span class="c1"># Read up to the open bracket.</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_START_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BARE_PREFIX_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;open bracket or identifier&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c1"># If there as an identifier, record it.</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">identifier</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">identifier</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new identifier&quot;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">reentrances</span><span class="p">[</span><span class="n">identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">fstruct</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fstruct</span><span class="p">,</span> <span class="n">FeatDict</span><span class="p">):</span>
            <span class="n">fstruct</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial_featdict</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">fstruct</span><span class="p">[:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_partial_featlist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_partial_featlist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="c1"># Prefix features are not allowed:</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;open bracket&quot;</span><span class="p">)</span>
        <span class="c1"># Bare prefixes are not allowed:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;open bracket&quot;</span><span class="p">)</span>

        <span class="c1"># Build a list of the features defined by the structure.</span>
        <span class="k">while</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="c1"># Check for the close bracket.</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fstruct</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

            <span class="c1"># Reentances have the form &quot;-&gt; (target)&quot;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_REENTRANCE_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TARGET_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;identifier&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bound identifier&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="n">fstruct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reentrances</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

            <span class="c1"># Anything else is a value.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_value</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>
                <span class="n">fstruct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="c1"># If there&#39;s a close bracket, handle it at the top of the loop.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Otherwise, there should be a comma</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COMMA_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;comma&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c1"># We never saw a close bracket.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;close bracket&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_partial_featdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="c1"># If there was a prefix feature, record it.</span>
        <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;open bracket or identifier&quot;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">prefixval</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">prefixval</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">):</span>
                <span class="n">prefixval</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">prefixval</span><span class="p">)</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix_feature</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefixval</span>

        <span class="c1"># If group 3 is empty, then we just have a bare prefix, so</span>
        <span class="c1"># we&#39;re done.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

        <span class="c1"># Build a list of the features defined by the structure.</span>
        <span class="c1"># Each feature has one of the three following forms:</span>
        <span class="c1">#     name = value</span>
        <span class="c1">#     name -&gt; (target)</span>
        <span class="c1">#     +name</span>
        <span class="c1">#     -name</span>
        <span class="k">while</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="c1"># Use these variables to hold info about each feature:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Check for the close bracket.</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_finalize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">)</span>

            <span class="c1"># Get the feature name&#39;s name</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FEATURE_NAME_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;feature name&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

            <span class="c1"># Check if it&#39;s a special feature.</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;known special feature&quot;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Check if this feature has a value already.</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fstruct</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new name&quot;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

            <span class="c1"># Boolean value (&quot;+name&quot; or &quot;-name&quot;)</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Reentrance link (&quot;-&gt; (target)&quot;)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_REENTRANCE_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TARGET_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;identifier&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reentrances</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bound identifier&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">reentrances</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

            <span class="c1"># Assignment (&quot;= value&quot;).</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ASSIGN_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                    <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                    <span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>
                <span class="c1"># None of the above: error.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;equals sign&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

            <span class="c1"># Store the value.</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># If there&#39;s a close bracket, handle it at the top of the loop.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_END_FSTRUCT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Otherwise, there should be a comma</span>
            <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_COMMA_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;comma&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c1"># We never saw a close bracket.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;close bracket&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">fstruct</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called when we see the close brace -- checks for a slash feature,</span>
<span class="sd">        and adds in default values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add the slash feature (if any)</span>
        <span class="n">match</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SLASH_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slash_feature</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">reentrances</span><span class="p">)</span>
            <span class="n">fstruct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1">## Add any default features.  -- handle in unficiation instead?</span>
        <span class="c1"># for feature in self._features_with_defaults:</span>
        <span class="c1">#    fstruct.setdefault(feature, feature.default)</span>
        <span class="c1"># Return the value.</span>
        <span class="k">return</span> <span class="n">fstruct</span><span class="p">,</span> <span class="n">pos</span>

    <span class="k">def</span> <span class="nf">_read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Feature</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>

<div class="viewcode-block" id="FeatStructReader.read_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">regexp</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">VALUE_HANDLERS</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">handler_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">handler_func</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">position</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># +1 for the newline.</span>
        <span class="n">estr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Error parsing feature structure</span><span class="se">\n</span><span class="s2">    &quot;</span>
            <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span>
            <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">position</span>
            <span class="o">+</span> <span class="s2">&quot;^ &quot;</span>
            <span class="o">+</span> <span class="s2">&quot;Expected </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">expected</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">estr</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># { Value Readers</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="c1">#: A table indicating how feature values should be processed.  Each</span>
    <span class="c1">#: entry in the table is a pair (handler, regexp).  The first entry</span>
    <span class="c1">#: with a matching regexp will have its handler called.  Handlers</span>
    <span class="c1">#: should have the following signature::</span>
    <span class="c1">#:</span>
    <span class="c1">#:    def handler(s, position, reentrances, match): ...</span>
    <span class="c1">#:</span>
    <span class="c1">#: and should return a tuple (value, position), where position is</span>
    <span class="c1">#: the string position where the value ended.  (n.b.: order is</span>
    <span class="c1">#: important here!)</span>
    <span class="n">VALUE_HANDLERS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;read_fstruct_value&quot;</span><span class="p">,</span> <span class="n">_START_FSTRUCT_RE</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;read_var_value&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\?[a-zA-Z_][a-zA-Z0-9_]*&quot;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s2">&quot;read_str_value&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;[uU]?[rR]?([&#39;</span><span class="se">\&quot;</span><span class="s2">])&quot;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s2">&quot;read_int_value&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;-?\d+&quot;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s2">&quot;read_sym_value&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[a-zA-Z_][a-zA-Z0-9_]*&quot;</span><span class="p">)),</span>
        <span class="p">(</span>
            <span class="s2">&quot;read_app_value&quot;</span><span class="p">,</span>
            <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&lt;(app)\((\?[a-z][a-z]*)\s*,&quot;</span> <span class="sa">r</span><span class="s2">&quot;\s*(\?[a-z][a-z]*)\)&gt;&quot;</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="c1">#       (&#39;read_logic_value&#39;, re.compile(r&#39;&lt;([^&gt;]*)&gt;&#39;)),</span>
        <span class="c1"># lazily match any character after &#39;&lt;&#39; until we hit a &#39;&gt;&#39; not preceded by &#39;-&#39;</span>
        <span class="p">(</span><span class="s2">&quot;read_logic_value&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&lt;(.*?)(?&lt;!-)&gt;&quot;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s2">&quot;read_set_value&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;{&quot;</span><span class="p">)),</span>
        <span class="p">(</span><span class="s2">&quot;read_tuple_value&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\(&quot;</span><span class="p">)),</span>
    <span class="p">]</span>

<div class="viewcode-block" id="FeatStructReader.read_fstruct_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_fstruct_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_fstruct_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_partial</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatStructReader.read_str_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_str_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_str_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">read_str</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatStructReader.read_int_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_int_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_int_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span></div>

    <span class="c1"># Note: the &#39;?&#39; is included in the variable name.</span>
<div class="viewcode-block" id="FeatStructReader.read_var_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_var_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_var_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Variable</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span></div>

    <span class="n">_SYM_CONSTS</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;None&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

<div class="viewcode-block" id="FeatStructReader.read_sym_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_sym_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_sym_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="n">val</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SYM_CONSTS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">),</span> <span class="n">end</span></div>

<div class="viewcode-block" id="FeatStructReader.read_app_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_app_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_app_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mainly included for backwards compat.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span></div>

<div class="viewcode-block" id="FeatStructReader.read_logic_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_logic_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_logic_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logic_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">LogicalExpressionException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;logic expression&quot;</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">e</span></div>

<div class="viewcode-block" id="FeatStructReader.read_tuple_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_tuple_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_tuple_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_seq_value</span><span class="p">(</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">FeatureValueTuple</span><span class="p">,</span> <span class="n">FeatureValueConcat</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="FeatStructReader.read_set_value"><a class="viewcode-back" href="../../api/nltk.featstruct.FeatStructReader.html#nltk.featstruct.FeatStructReader.read_set_value">[docs]</a>    <span class="k">def</span> <span class="nf">read_set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_seq_value</span><span class="p">(</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">,</span> <span class="n">FeatureValueSet</span><span class="p">,</span> <span class="n">FeatureValueUnion</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_read_seq_value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">close_paren</span><span class="p">,</span> <span class="n">seq_class</span><span class="p">,</span> <span class="n">plus_class</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function used by read_tuple_value and read_set_value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">close_paren</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="c1"># Special syntax of empty tuples:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*/?\s*</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seq_class</span><span class="p">(),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="c1"># Read values:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen_plus</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Close paren: return value.</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seen_plus</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">plus_class</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">seq_class</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

            <span class="c1"># Read the next value.</span>
            <span class="n">val</span><span class="p">,</span> <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_value</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">reentrances</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># Comma or looking at close paren</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s*(,|\+|(?=</span><span class="si">%s</span><span class="s2">))\s*&quot;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;,&#39; or &#39;+&#39; or &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">cp</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span><span class="p">:</span>
                <span class="n">seen_plus</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># { Demo</span>
<span class="c1">######################################################################</span>


<span class="k">def</span> <span class="nf">display_unification</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;  &quot;</span><span class="p">):</span>
    <span class="c1"># Print the two input feature structures, side by side.</span>
    <span class="n">fs1_lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fs1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">fs2_lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fs2</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">):</span>
        <span class="n">blankline</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="n">fs2_lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">blankline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">blankline</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="n">fs1_lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">blankline</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fs1_line</span><span class="p">,</span> <span class="n">fs2_line</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">,</span> <span class="n">fs2_lines</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">fs1_line</span> <span class="o">+</span> <span class="s2">&quot;   &quot;</span> <span class="o">+</span> <span class="n">fs2_line</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;   &quot;</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs2_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">linelen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs1_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;|               |&quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;+-----UNIFY-----+&quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;V&quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>

    <span class="n">bindings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">fs1</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">fs2</span><span class="p">,</span> <span class="n">bindings</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;(FAILED)&quot;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">bindings</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bindings</span><span class="o">.</span><span class="n">bound_variables</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">bindings</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">linelen</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">interactive_demo</span><span class="p">(</span><span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="kn">import</span> <span class="nn">sys</span>

    <span class="n">HELP</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    1-</span><span class="si">%d</span><span class="s2">: Select the corresponding feature structure</span>
<span class="s2">    q: Quit</span>
<span class="s2">    t: Turn tracing on or off</span>
<span class="s2">    l: List all feature structures</span>
<span class="s2">    ?: Help</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This demo will repeatedly present you with a list of feature</span>
<span class="sd">    structures, and ask you to choose two for unification.  Whenever a</span>
<span class="sd">    new feature structure is generated, it is added to the list of</span>
<span class="sd">    choices that you can pick from.  However, since this can be a</span>
<span class="sd">    large number of feature structures, the demo will only print out a</span>
<span class="sd">    random subset for you to choose between at a given time.  If you</span>
<span class="sd">    want to see the complete lists, type &quot;l&quot;.  For a list of valid</span>
<span class="sd">    commands, type &quot;?&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Press &quot;Enter&quot; to continue...&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

    <span class="n">fstruct_strings</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;[agr=[number=sing, gender=masc]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[agr=[gender=masc, person=3]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[agr=[gender=fem, person=3]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[subj=[agr=(1)[]], agr-&gt;(1)]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[obj=?x]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[subj=?x]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[/=None]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[/=NP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[cat=NP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[cat=VP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[cat=PP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[subj=[agr=[gender=?y]], obj=[agr=[gender=?y]]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[gender=masc, agr=?C]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[gender=?S, agr=[gender=?S,person=3]]&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">all_fstructs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">(</span><span class="n">fstruct_strings</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fstruct_strings</span><span class="p">))</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">list_fstructs</span><span class="p">(</span><span class="n">fstructs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fstruct</span> <span class="ow">in</span> <span class="n">fstructs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">()</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fstruct</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%3d</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Pick 5 feature structures at random from the master list.</span>
        <span class="n">MAX_CHOICES</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_CHOICES</span><span class="p">:</span>
            <span class="n">fstructs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">,</span> <span class="n">MAX_CHOICES</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fstructs</span> <span class="o">=</span> <span class="n">all_fstructs</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_&quot;</span> <span class="o">*</span> <span class="mi">75</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Choose two feature structures to unify:&quot;</span><span class="p">)</span>
        <span class="n">list_fstructs</span><span class="p">(</span><span class="n">fstructs</span><span class="p">)</span>

        <span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">nth</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">in</span> <span class="p">((</span><span class="s2">&quot;First&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;Second&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">while</span> <span class="n">selected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> feature structure (1-</span><span class="si">%d</span><span class="s2">,q,t,l,?): &quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">nth</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">))</span>
                    <span class="p">),</span>
                    <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">):</span>
                        <span class="k">return</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">):</span>
                        <span class="n">trace</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">trace</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   Trace = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">trace</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">HELP</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">fstructs</span><span class="p">))</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">):</span>
                        <span class="n">list_fstructs</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">selected</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_fstructs</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="nb">print</span><span class="p">()</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bad sentence number&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>

        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">selected</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">trace</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">display_unification</span><span class="p">(</span><span class="n">selected</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">selected</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fstruct</span> <span class="ow">in</span> <span class="n">all_fstructs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">fstruct</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_fstructs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">all_fstructs</span><span class="p">),</span> <span class="n">result</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Type &quot;Enter&quot; to continue unifying; or &quot;q&quot; to quit.&#39;</span><span class="p">)</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">):</span>
            <span class="k">return</span>


<span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">trace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Just for testing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># import random</span>

    <span class="c1"># processor breaks with values like &#39;3rd&#39;</span>
    <span class="n">fstruct_strings</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;[agr=[number=sing, gender=masc]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[agr=[gender=masc, person=3]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[agr=[gender=fem, person=3]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[subj=[agr=(1)[]], agr-&gt;(1)]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[obj=?x]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[subj=?x]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[/=None]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[/=NP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[cat=NP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[cat=VP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[cat=PP]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[subj=[agr=[gender=?y]], obj=[agr=[gender=?y]]]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[gender=masc, agr=?C]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;[gender=?S, agr=[gender=?S,person=3]]&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">all_fstructs</span> <span class="o">=</span> <span class="p">[</span><span class="n">FeatStruct</span><span class="p">(</span><span class="n">fss</span><span class="p">)</span> <span class="k">for</span> <span class="n">fss</span> <span class="ow">in</span> <span class="n">fstruct_strings</span><span class="p">]</span>
    <span class="c1"># MAX_CHOICES = 5</span>
    <span class="c1"># if len(all_fstructs) &gt; MAX_CHOICES:</span>
    <span class="c1"># fstructs = random.sample(all_fstructs, MAX_CHOICES)</span>
    <span class="c1"># fstructs.sort()</span>
    <span class="c1"># else:</span>
    <span class="c1"># fstructs = all_fstructs</span>

    <span class="k">for</span> <span class="n">fs1</span> <span class="ow">in</span> <span class="n">all_fstructs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">fs2</span> <span class="ow">in</span> <span class="n">all_fstructs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">*******************</span><span class="se">\n</span><span class="s2">fs1 is:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s2">fs2 is:</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s2">result is:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">,</span> <span class="n">unify</span><span class="p">(</span><span class="n">fs1</span><span class="p">,</span> <span class="n">fs2</span><span class="p">))</span>
            <span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;FeatStruct&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FeatDict&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FeatList&quot;</span><span class="p">,</span>
    <span class="s2">&quot;unify&quot;</span><span class="p">,</span>
    <span class="s2">&quot;subsumes&quot;</span><span class="p">,</span>
    <span class="s2">&quot;conflicts&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Feature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SlashFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;RangeFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SLASH&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TYPE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FeatStructReader&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>