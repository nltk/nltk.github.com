<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.translate.lepor</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/sphinx_highlight.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.translate.lepor</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: LEPOR Score</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Ikram Ul Haq (ulhaqi12)</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;LEPOR score implementation.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">nltk</span>


<div class="viewcode-block" id="length_penalty">
<a class="viewcode-back" href="../../../api/nltk.translate.lepor.html#nltk.translate.lepor.length_penalty">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">length_penalty</span><span class="p">(</span><span class="n">reference</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">hypothesis</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the length penalty(LP) for the LEPOR metric, which is defined to embrace the penaltyvfor</span>
<span class="sd">    both longer and shorter hypothesis compared with the reference translations.</span>
<span class="sd">    Refer from Eq (2) on https://aclanthology.org/C12-2044</span>

<span class="sd">    :param reference: Reference sentence</span>
<span class="sd">    :type reference: str</span>
<span class="sd">    :param hypothesis: Hypothesis sentence</span>
<span class="sd">    :type hypothesis: str</span>

<span class="sd">    :return: Penalty of difference in length in reference and hypothesis sentence.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ref_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>
    <span class="n">hyp_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ref_len</span> <span class="o">==</span> <span class="n">hyp_len</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">ref_len</span> <span class="o">&lt;</span> <span class="n">hyp_len</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">ref_len</span> <span class="o">/</span> <span class="n">hyp_len</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># i.e. r_len &gt; hyp_len</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">hyp_len</span> <span class="o">/</span> <span class="n">ref_len</span><span class="p">))</span></div>



<div class="viewcode-block" id="alignment">
<a class="viewcode-back" href="../../../api/nltk.translate.lepor.html#nltk.translate.lepor.alignment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">alignment</span><span class="p">(</span><span class="n">ref_tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">hyp_tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes the context-dependent n-gram word alignment tasks that</span>
<span class="sd">    takes into account the surrounding context (neighbouring words) of the potential</span>
<span class="sd">    word to select a better matching pairs between the output and the reference.</span>

<span class="sd">    This alignment task is used to compute the ngram positional difference penalty</span>
<span class="sd">    component of the LEPOR score. Generally, the function finds the matching tokens</span>
<span class="sd">    between the reference and hypothesis, then find the indices of longest matching</span>
<span class="sd">    n-grams by checking the left and right unigram window of the matching tokens.</span>

<span class="sd">    :param ref_tokens: A list of tokens in reference sentence.</span>
<span class="sd">    :type ref_tokens: List[str]</span>
<span class="sd">    :param hyp_tokens: A list of tokens in hypothesis sentence.</span>
<span class="sd">    :type hyp_tokens: List[str]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">alignments</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Store the reference and hypothesis tokens length.</span>
    <span class="n">hyp_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp_tokens</span><span class="p">)</span>
    <span class="n">ref_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_tokens</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">hyp_index</span><span class="p">,</span> <span class="n">hyp_token</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hyp_tokens</span><span class="p">):</span>
        <span class="c1"># If no match.</span>
        <span class="k">if</span> <span class="n">ref_tokens</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">hyp_token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># If only one match.</span>
        <span class="k">elif</span> <span class="n">ref_tokens</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">hyp_token</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_tokens</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">hyp_token</span><span class="p">))</span>
        <span class="c1"># Otherwise, compute the multiple possibilities.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Keeps an index of where the hypothesis token matches the reference.</span>
            <span class="n">ref_indexes</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ref_token</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_tokens</span><span class="p">)</span> <span class="k">if</span> <span class="n">ref_token</span> <span class="o">==</span> <span class="n">hyp_token</span>
            <span class="p">]</span>

            <span class="c1"># Iterate through the matched tokens, and check if</span>
            <span class="c1"># the one token to the left/right also matches.</span>
            <span class="n">is_matched</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">ref_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_indexes</span><span class="p">):</span>
                <span class="c1"># The one to the left token also matches.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">ref_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ref_len</span>
                    <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">hyp_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hyp_len</span>
                    <span class="ow">and</span> <span class="n">ref_tokens</span><span class="p">[</span><span class="n">ref_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">hyp_tokens</span><span class="p">[</span><span class="n">hyp_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">is_matched</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># The one to the right token also matches.</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">ref_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">ref_len</span>
                    <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">hyp_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">hyp_len</span>
                    <span class="ow">and</span> <span class="n">ref_tokens</span><span class="p">[</span><span class="n">ref_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">hyp_tokens</span><span class="p">[</span><span class="n">hyp_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">is_matched</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># If the left and right tokens don&#39;t match.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">is_matched</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Stores the alignments that have matching phrases.</span>
            <span class="c1"># If there&#39;s only a single matched alignment.</span>
            <span class="k">if</span> <span class="n">is_matched</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_indexes</span><span class="p">[</span><span class="n">is_matched</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)])</span>
            <span class="c1"># If there&#39;s multiple matched alignments that have matching</span>
            <span class="c1"># tokens in the left/right window, we shift the index of the</span>
            <span class="c1"># alignment to the right most matching token.</span>
            <span class="k">elif</span> <span class="n">is_matched</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">match</span><span class="p">,</span> <span class="n">ref_index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">is_matched</span><span class="p">,</span> <span class="n">ref_indexes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                        <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">hyp_index</span> <span class="o">-</span> <span class="n">ref_index</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;</span> <span class="n">min_distance</span><span class="p">:</span>
                            <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                            <span class="n">min_index</span> <span class="o">=</span> <span class="n">ref_index</span>
                <span class="n">alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span>
            <span class="c1"># If there&#39;s no matched alignments,</span>
            <span class="c1"># we still keep indexes of the matching tokens</span>
            <span class="c1"># without explicitly checking for the left/right window.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_distance</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">ref_index</span> <span class="ow">in</span> <span class="n">ref_indexes</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">hyp_index</span> <span class="o">-</span> <span class="n">ref_index</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;</span> <span class="n">min_distance</span><span class="p">:</span>
                        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                        <span class="n">min_index</span> <span class="o">=</span> <span class="n">ref_index</span>
                <span class="n">alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ref_index</span> <span class="ow">in</span> <span class="n">ref_indexes</span><span class="p">:</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">hyp_index</span> <span class="o">-</span> <span class="n">ref_index</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;</span> <span class="n">min_distance</span><span class="p">:</span>
                        <span class="n">min_distance</span> <span class="o">=</span> <span class="n">distance</span>
                        <span class="n">min_index</span> <span class="o">=</span> <span class="n">ref_index</span>
                <span class="n">alignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_index</span><span class="p">)</span>

    <span class="c1"># The alignments are one indexed to keep track of the ending slice pointer of the matching ngrams.</span>
    <span class="n">alignments</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alignments</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">alignments</span></div>



<div class="viewcode-block" id="ngram_positional_penalty">
<a class="viewcode-back" href="../../../api/nltk.translate.lepor.html#nltk.translate.lepor.ngram_positional_penalty">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ngram_positional_penalty</span><span class="p">(</span>
    <span class="n">ref_tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">hyp_tokens</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function calculates the n-gram position difference penalty (NPosPenal) described in the LEPOR paper.</span>
<span class="sd">    The NPosPenal is an exponential of the length normalized n-gram matches between the reference and the hypothesis.</span>

<span class="sd">    :param ref_tokens: A list of words in reference sentence.</span>
<span class="sd">    :type ref_tokens: List[str]</span>
<span class="sd">    :param hyp_tokens: A list of words in hypothesis sentence.</span>
<span class="sd">    :type hyp_tokens: List[str]</span>

<span class="sd">    :return: A tuple containing two elements:</span>
<span class="sd">             - NPosPenal: N-gram positional penalty.</span>
<span class="sd">             - match_count: Count of matched n-grams.</span>
<span class="sd">    :rtype: tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">alignments</span> <span class="o">=</span> <span class="n">alignment</span><span class="p">(</span><span class="n">ref_tokens</span><span class="p">,</span> <span class="n">hyp_tokens</span><span class="p">)</span>
    <span class="n">match_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alignments</span><span class="p">)</span>

    <span class="c1"># Stores the n-gram position values (difference values) of aligned words</span>
    <span class="c1"># between output and reference sentences,</span>
    <span class="c1"># aka |PD| of eq (4) in https://aclanthology.org/C12-2044</span>
    <span class="n">pd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alignments</span><span class="p">):</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp_tokens</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref_tokens</span><span class="p">)))</span>

    <span class="n">npd</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">hyp_tokens</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">npd</span><span class="p">),</span> <span class="n">match_count</span></div>



<div class="viewcode-block" id="harmonic">
<a class="viewcode-back" href="../../../api/nltk.translate.lepor.html#nltk.translate.lepor.harmonic">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">harmonic</span><span class="p">(</span>
    <span class="n">match_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">reference_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">hypothesis_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function will calculate the precision and recall of matched words and calculate a final score on wighting</span>
<span class="sd">    using alpha and beta parameters.</span>

<span class="sd">    :param match_count: Number of words in hypothesis aligned with reference.</span>
<span class="sd">    :type match_count: int</span>
<span class="sd">    :param reference_length: Length of the reference sentence</span>
<span class="sd">    :type reference_length: int</span>
<span class="sd">    :param hypothesis_length: Length of the hypothesis sentence</span>
<span class="sd">    :type hypothesis_length: int</span>
<span class="sd">    :param alpha: A parameter to set weight fot recall.</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :param beta: A parameter to set weight fot precision.</span>
<span class="sd">    :type beta: float</span>

<span class="sd">    :return: Harmonic mean.</span>
<span class="sd">    :rtype: float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span>

    <span class="n">precision</span> <span class="o">=</span> <span class="n">match_count</span> <span class="o">/</span> <span class="n">hypothesis_length</span>
    <span class="n">recall</span> <span class="o">=</span> <span class="n">match_count</span> <span class="o">/</span> <span class="n">reference_length</span>

    <span class="n">harmonic_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="p">(</span><span class="n">recall</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">beta</span> <span class="o">/</span> <span class="p">(</span><span class="n">precision</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">harmonic_score</span></div>



<div class="viewcode-block" id="sentence_lepor">
<a class="viewcode-back" href="../../../api/nltk.translate.lepor.html#nltk.translate.lepor.sentence_lepor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sentence_lepor</span><span class="p">(</span>
    <span class="n">references</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">hypothesis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate LEPOR score a sentence from Han, A. L.-F. (2017).</span>
<span class="sd">    LEPOR: An Augmented Machine Translation Evaluation Metric. https://arxiv.org/abs/1703.08748v2</span>

<span class="sd">    &gt;&gt;&gt; hypothesis = &#39;a bird is on a stone.&#39;</span>

<span class="sd">    &gt;&gt;&gt; reference1 = &#39;a bird behind the stone.&#39;</span>
<span class="sd">    &gt;&gt;&gt; reference2 = &#39;a bird is on the rock.&#39;</span>

<span class="sd">    &gt;&gt;&gt; sentence_lepor([reference1, reference2], hypothesis)</span>
<span class="sd">    [0.7824248013113159, 0.7739937377760259]</span>

<span class="sd">    :param references: Reference sentences</span>
<span class="sd">    :type references: list(str)</span>
<span class="sd">    :param hypothesis: Hypothesis sentence</span>
<span class="sd">    :type hypothesis: str</span>
<span class="sd">    :param alpha: A parameter to set weight fot recall.</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :param beta: A parameter to set weight fot precision.</span>
<span class="sd">    :type beta: float</span>
<span class="sd">    :param tokenizer: A callable tokenizer that will accept a string and returns a list of tokens.</span>
<span class="sd">    :type tokenizer: Callable[[str], List[str]]</span>

<span class="sd">    :return: The list of Lepor scores for a hypothesis with all references.</span>
<span class="sd">    :rtype: list(float)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lepor_scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="c1"># Tokenize sentences.</span>
    <span class="k">if</span> <span class="n">tokenizer</span><span class="p">:</span>
        <span class="n">hypothesis</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">reference</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">references</span><span class="p">):</span>
            <span class="n">references</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># If tokenizer is not provided, use the one in NLTK.</span>
        <span class="n">hypothesis</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">reference</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">references</span><span class="p">):</span>
            <span class="n">references</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">word_tokenize</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">reference</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of the sentence is empty. Exit.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate the length penalty due to the difference in the length of reference and hypothesis.</span>
        <span class="n">lp</span> <span class="o">=</span> <span class="n">length_penalty</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>

        <span class="c1"># Calculate the penalty on different positions of same word in translation.</span>
        <span class="n">npd</span><span class="p">,</span> <span class="n">match_count</span> <span class="o">=</span> <span class="n">ngram_positional_penalty</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">)</span>

        <span class="n">harmonic_score</span> <span class="o">=</span> <span class="n">harmonic</span><span class="p">(</span>
            <span class="n">match_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">),</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span>
        <span class="p">)</span>

        <span class="n">lepor_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp</span> <span class="o">*</span> <span class="n">npd</span> <span class="o">*</span> <span class="n">harmonic_score</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lepor_scores</span></div>



<div class="viewcode-block" id="corpus_lepor">
<a class="viewcode-back" href="../../../api/nltk.translate.lepor.html#nltk.translate.lepor.corpus_lepor">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">corpus_lepor</span><span class="p">(</span>
    <span class="n">references</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">hypothesis</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">beta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">tokenizer</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate LEPOR score for list of sentences from Han, A. L.-F. (2017).</span>
<span class="sd">    LEPOR: An Augmented Machine Translation Evaluation Metric. https://arxiv.org/abs/1703.08748v2</span>

<span class="sd">    &gt;&gt;&gt; hypothesis = [&#39;a bird is on a stone.&#39;, &#39;scary crow was not bad.&#39;]</span>

<span class="sd">    &gt;&gt;&gt; references = [[&#39;a bird behind the stone.&#39;, &#39;a bird is on the rock&#39;],</span>
<span class="sd">    ...              [&#39;scary cow was good.&#39;, &#39;scary crow was elegant.&#39;]]</span>

<span class="sd">    &gt;&gt;&gt; corpus_lepor(references, hypothesis)</span>
<span class="sd">    [[0.7824248013113159, 0.7931427828105261], [0.5639427891892225, 0.7860963170056643]]</span>


<span class="sd">    :param references: Reference sentences</span>
<span class="sd">    :type references: list(list(str))</span>
<span class="sd">    :param hypothesis: Hypothesis sentences</span>
<span class="sd">    :type hypothesis: list(str)</span>
<span class="sd">    :param alpha: A parameter to set weight fot recall.</span>
<span class="sd">    :type alpha: float</span>
<span class="sd">    :param beta: A parameter to set weight fot precision.</span>
<span class="sd">    :type beta: float</span>
<span class="sd">    :param tokenizer: A callable tokenizer that will accept a string and returns a list of tokens.</span>
<span class="sd">    :type tokenizer: Callable[[str], List[str]]</span>

<span class="sd">    :return: The Lepor score. Returns a list for all sentences</span>
<span class="sd">    :rtype: list(list(float))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There is an Empty list. Exit.&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypothesis</span><span class="p">),</span> <span class="p">(</span>
        <span class="s2">&quot;The number of hypothesis and their reference(s) should be the &quot;</span> <span class="s2">&quot;same &quot;</span>
    <span class="p">)</span>

    <span class="n">lepor_scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">reference_sen</span><span class="p">,</span> <span class="n">hypothesis_sen</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">references</span><span class="p">,</span> <span class="n">hypothesis</span><span class="p">):</span>
        <span class="c1"># Calculate Lepor for each sentence separately and append in a list.</span>
        <span class="n">lepor_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">sentence_lepor</span><span class="p">(</span><span class="n">reference_sen</span><span class="p">,</span> <span class="n">hypothesis_sen</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">tokenizer</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">lepor_scores</span></div>

</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.9.2">3.9.2</a>
                </li>
            

            
                <li class="footer-element">
                    Oct 01, 2025
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2025, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>