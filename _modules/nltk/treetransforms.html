

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nltk.treetransforms &mdash; NLTK 2.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="NLTK 2.0 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="../../index.html">NLTK 2.0 documentation</a></div>
        <div class="rel">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for nltk.treetransforms</h1><div class="highlight"><pre>
<span class="c"># Natural Language Toolkit: Tree Transformations</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2005-2007 Oregon Graduate Institute</span>
<span class="c"># Author: Nathan Bodenstab &lt;bodenstab@cslu.ogi.edu&gt;</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A collection of methods for tree (grammar) transformations used</span>
<span class="sd">in parsing natural language.</span>

<span class="sd">Although many of these methods are technically grammar transformations</span>
<span class="sd">(ie. Chomsky Norm Form), when working with treebanks it is much more</span>
<span class="sd">natural to visualize these modifications in a tree structure.  Hence,</span>
<span class="sd">we will do all transformation directly to the tree itself.</span>
<span class="sd">Transforming the tree directly also allows us to do parent annotation.</span>
<span class="sd">A grammar can then be simply induced from the modified tree.</span>

<span class="sd">The following is a short tutorial on the available transformations.</span>

<span class="sd"> 1. Chomsky Normal Form (binarization)</span>

<span class="sd">    It is well known that any grammar has a Chomsky Normal Form (CNF)</span>
<span class="sd">    equivalent grammar where CNF is defined by every production having</span>
<span class="sd">    either two non-terminals or one terminal on its right hand side.</span>
<span class="sd">    When we have hierarchically structured data (ie. a treebank), it is</span>
<span class="sd">    natural to view this in terms of productions where the root of every</span>
<span class="sd">    subtree is the head (left hand side) of the production and all of</span>
<span class="sd">    its children are the right hand side constituents.  In order to</span>
<span class="sd">    convert a tree into CNF, we simply need to ensure that every subtree</span>
<span class="sd">    has either two subtrees as children (binarization), or one leaf node</span>
<span class="sd">    (non-terminal).  In order to binarize a subtree with more than two</span>
<span class="sd">    children, we must introduce artificial nodes.</span>

<span class="sd">    There are two popular methods to convert a tree into CNF: left</span>
<span class="sd">    factoring and right factoring.  The following example demonstrates</span>
<span class="sd">    the difference between them.  Example::</span>

<span class="sd">     Original       Right-Factored     Left-Factored</span>

<span class="sd">          A              A                      A</span>
<span class="sd">        / | \          /   \                  /   \</span>
<span class="sd">       B  C  D   ==&gt;  B    A|&lt;C-D&gt;   OR   A|&lt;B-C&gt;  D</span>
<span class="sd">                            /  \          /  \</span>
<span class="sd">                           C    D        B    C</span>

<span class="sd"> 2. Parent Annotation</span>

<span class="sd">    In addition to binarizing the tree, there are two standard</span>
<span class="sd">    modifications to node labels we can do in the same traversal: parent</span>
<span class="sd">    annotation and Markov order-N smoothing (or sibling smoothing).</span>

<span class="sd">    The purpose of parent annotation is to refine the probabilities of</span>
<span class="sd">    productions by adding a small amount of context.  With this simple</span>
<span class="sd">    addition, a CYK (inside-outside, dynamic programming chart parse)</span>
<span class="sd">    can improve from 74% to 79% accuracy.  A natural generalization from</span>
<span class="sd">    parent annotation is to grandparent annotation and beyond.  The</span>
<span class="sd">    tradeoff becomes accuracy gain vs. computational complexity.  We</span>
<span class="sd">    must also keep in mind data sparcity issues.  Example::</span>

<span class="sd">     Original       Parent Annotation</span>

<span class="sd">          A                A^&lt;?&gt;</span>
<span class="sd">        / | \             /   \</span>
<span class="sd">       B  C  D   ==&gt;  B^&lt;A&gt;    A|&lt;C-D&gt;^&lt;?&gt;     where ? is the</span>
<span class="sd">                                 /  \          parent of A</span>
<span class="sd">                             C^&lt;A&gt;   D^&lt;A&gt;</span>


<span class="sd"> 3. Markov order-N smoothing</span>

<span class="sd">    Markov smoothing combats data sparcity issues as well as decreasing</span>
<span class="sd">    computational requirements by limiting the number of children</span>
<span class="sd">    included in artificial nodes.  In practice, most people use an order</span>
<span class="sd">    2 grammar.  Example::</span>

<span class="sd">      Original       No Smoothing       Markov order 1   Markov order 2   etc.</span>

<span class="sd">       __A__            A                      A                A</span>
<span class="sd">      / /|\ \         /   \                  /   \            /   \</span>
<span class="sd">     B C D E F  ==&gt;  B    A|&lt;C-D-E-F&gt;  ==&gt;  B   A|&lt;C&gt;  ==&gt;   B  A|&lt;C-D&gt;</span>
<span class="sd">                            /   \               /   \            /   \</span>
<span class="sd">                           C    ...            C    ...         C    ...</span>



<span class="sd">    Annotation decisions can be thought about in the vertical direction</span>
<span class="sd">    (parent, grandparent, etc) and the horizontal direction (number of</span>
<span class="sd">    siblings to keep).  Parameters to the following functions specify</span>
<span class="sd">    these values.  For more information see:</span>

<span class="sd">    Dan Klein and Chris Manning (2003) &quot;Accurate Unlexicalized</span>
<span class="sd">    Parsing&quot;, ACL-03.  http://www.aclweb.org/anthology/P03-1054</span>

<span class="sd"> 4. Unary Collapsing</span>

<span class="sd">    Collapse unary productions (ie. subtrees with a single child) into a</span>
<span class="sd">    new non-terminal (Tree node).  This is useful when working with</span>
<span class="sd">    algorithms that do not allow unary productions, yet you do not wish</span>
<span class="sd">    to lose the parent information.  Example::</span>

<span class="sd">       A</span>
<span class="sd">       |</span>
<span class="sd">       B   ==&gt;   A+B</span>
<span class="sd">      / \        / \</span>
<span class="sd">     C   D      C   D</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">nltk.tree</span> <span class="kn">import</span> <span class="n">Tree</span>

<div class="viewcode-block" id="chomsky_normal_form"><a class="viewcode-back" href="../../api/nltk.html#nltk.treetransforms.chomsky_normal_form">[docs]</a><span class="k">def</span> <span class="nf">chomsky_normal_form</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">factor</span> <span class="o">=</span> <span class="s">&quot;right&quot;</span><span class="p">,</span> <span class="n">horzMarkov</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">vertMarkov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">childChar</span> <span class="o">=</span> <span class="s">&quot;|&quot;</span><span class="p">,</span> <span class="n">parentChar</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span><span class="p">):</span>
    <span class="c"># assume all subtrees have homogeneous children</span>
    <span class="c"># assume all terminals have no siblings</span>

    <span class="c"># A semi-hack to have elegant looking code below.  As a result,</span>
    <span class="c"># any subtree with a branching factor greater than 999 will be incorrectly truncated.</span>
    <span class="k">if</span> <span class="n">horzMarkov</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">horzMarkov</span> <span class="o">=</span> <span class="mi">999</span>

    <span class="c"># Traverse the tree depth-first keeping a list of ancestor nodes to the root.</span>
    <span class="c"># I chose not to use the tree.treepositions() method since it requires</span>
    <span class="c"># two traversals of the tree (one to get the positions, one to iterate</span>
    <span class="c"># over them) and node access time is proportional to the height of the node.</span>
    <span class="c"># This method is 7x faster which helps when parsing 40,000 sentences.</span>

    <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">tree</span><span class="p">,</span> <span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">node</span><span class="p">])]</span>
    <span class="k">while</span> <span class="n">nodeList</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Tree</span><span class="p">):</span>

            <span class="c"># parent annotation</span>
            <span class="n">parentString</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
            <span class="n">originalNode</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="n">vertMarkov</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">tree</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Tree</span><span class="p">):</span>
                <span class="n">parentString</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">&lt;</span><span class="si">%s</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">parentChar</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
                <span class="n">node</span><span class="o">.</span><span class="n">node</span> <span class="o">+=</span> <span class="n">parentString</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">originalNode</span><span class="p">]</span> <span class="o">+</span> <span class="n">parent</span><span class="p">[:</span><span class="n">vertMarkov</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c"># add children to the agenda before we mess with them</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">parent</span><span class="p">))</span>

            <span class="c"># chomsky normal form factorization</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">childNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">node</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">]</span>
                <span class="n">nodeCopy</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># delete the children</span>

                <span class="n">curNode</span> <span class="o">=</span> <span class="n">node</span>
                <span class="n">numChildren</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodeCopy</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">numChildren</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="s">&quot;right&quot;</span><span class="p">:</span>
                        <span class="n">newHead</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s%s</span><span class="s">&lt;</span><span class="si">%s</span><span class="s">&gt;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">originalNode</span><span class="p">,</span> <span class="n">childChar</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childNodes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="nb">min</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="n">horzMarkov</span><span class="p">,</span><span class="n">numChildren</span><span class="p">])]),</span><span class="n">parentString</span><span class="p">)</span> <span class="c"># create new head</span>
                        <span class="n">newNode</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">newHead</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="n">curNode</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodeCopy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">newNode</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newHead</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s%s</span><span class="s">&lt;</span><span class="si">%s</span><span class="s">&gt;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">originalNode</span><span class="p">,</span> <span class="n">childChar</span><span class="p">,</span> <span class="s">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childNodes</span><span class="p">[</span><span class="nb">max</span><span class="p">([</span><span class="n">numChildren</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="n">horzMarkov</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span><span class="o">-</span><span class="n">i</span><span class="p">]),</span><span class="n">parentString</span><span class="p">)</span>
                        <span class="n">newNode</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">newHead</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="n">curNode</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newNode</span><span class="p">,</span> <span class="n">nodeCopy</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span>

                    <span class="n">curNode</span> <span class="o">=</span> <span class="n">newNode</span>

                <span class="n">curNode</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">nodeCopy</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="un_chomsky_normal_form"><a class="viewcode-back" href="../../api/nltk.html#nltk.treetransforms.un_chomsky_normal_form">[docs]</a><span class="k">def</span> <span class="nf">un_chomsky_normal_form</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">expandUnary</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> <span class="n">childChar</span> <span class="o">=</span> <span class="s">&quot;|&quot;</span><span class="p">,</span> <span class="n">parentChar</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span><span class="p">,</span> <span class="n">unaryChar</span> <span class="o">=</span> <span class="s">&quot;+&quot;</span><span class="p">):</span>
    <span class="c"># Traverse the tree-depth first keeping a pointer to the parent for modification purposes.</span>
    <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[(</span><span class="n">tree</span><span class="p">,[])]</span>
    <span class="k">while</span> <span class="n">nodeList</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">node</span><span class="p">,</span><span class="n">parent</span> <span class="o">=</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Tree</span><span class="p">):</span>
            <span class="c"># if the node contains the &#39;childChar&#39; character it means that</span>
            <span class="c"># it is an artificial node and can be removed, although we still need</span>
            <span class="c"># to move its children to its parent</span>
            <span class="n">childIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">childChar</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">childIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">nodeIndex</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">nodeIndex</span><span class="p">])</span>
                <span class="c"># Generated node was on the left if the nodeIndex is 0 which</span>
                <span class="c"># means the grammar was left factored.  We must insert the children</span>
                <span class="c"># at the beginning of the parent&#39;s children</span>
                <span class="k">if</span> <span class="n">nodeIndex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">parent</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

                <span class="c"># parent is now the current node so the children of parent will be added to the agenda</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parentIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">parentChar</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parentIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="c"># strip the node name of the parent annotation</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node</span><span class="p">[:</span><span class="n">parentIndex</span><span class="p">]</span>

                <span class="c"># expand collapsed unary productions</span>
                <span class="k">if</span> <span class="n">expandUnary</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">unaryIndex</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">unaryChar</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unaryIndex</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">newNode</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">unaryIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">node</span><span class="p">])</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">node</span><span class="p">[:</span><span class="n">unaryIndex</span><span class="p">]</span>
                        <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">newNode</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span><span class="n">node</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="collapse_unary"><a class="viewcode-back" href="../../api/nltk.html#nltk.treetransforms.collapse_unary">[docs]</a><span class="k">def</span> <span class="nf">collapse_unary</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">collapsePOS</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">collapseRoot</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span> <span class="n">joinChar</span> <span class="o">=</span> <span class="s">&quot;+&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collapse subtrees with a single child (ie. unary productions)</span>
<span class="sd">    into a new non-terminal (Tree node) joined by &#39;joinChar&#39;.</span>
<span class="sd">    This is useful when working with algorithms that do not allow</span>
<span class="sd">    unary productions, and completely removing the unary productions</span>
<span class="sd">    would require loss of useful information.  The Tree is modified</span>
<span class="sd">    directly (since it is passed by reference) and no value is returned.</span>

<span class="sd">    :param tree: The Tree to be collapsed</span>
<span class="sd">    :type  tree: Tree</span>
<span class="sd">    :param collapsePOS: &#39;False&#39; (default) will not collapse the parent of leaf nodes (ie.</span>
<span class="sd">                        Part-of-Speech tags) since they are always unary productions</span>
<span class="sd">    :type  collapsePOS: bool</span>
<span class="sd">    :param collapseRoot: &#39;False&#39; (default) will not modify the root production</span>
<span class="sd">                         if it is unary.  For the Penn WSJ treebank corpus, this corresponds</span>
<span class="sd">                         to the TOP -&gt; productions.</span>
<span class="sd">    :type collapseRoot: bool</span>
<span class="sd">    :param joinChar: A string used to connect collapsed node values (default = &quot;+&quot;)</span>
<span class="sd">    :type  joinChar: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">collapseRoot</span> <span class="o">==</span> <span class="bp">False</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nodeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">]</span>

    <span class="c"># depth-first traversal of tree</span>
    <span class="k">while</span> <span class="n">nodeList</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">nodeList</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Tree</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">collapsePOS</span> <span class="o">==</span> <span class="bp">True</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">node</span> <span class="o">+=</span> <span class="n">joinChar</span> <span class="o">+</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node</span>
                <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c"># since we assigned the child&#39;s children to the current node,</span>
                <span class="c"># evaluate the current node again</span>
                <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="n">nodeList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="c">#################################################################</span>
<span class="c"># Demonstration</span>
<span class="c">#################################################################</span>
</div>
<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration showing how each tree transform can be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltk.draw.tree</span> <span class="kn">import</span> <span class="n">draw_trees</span>
    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">tree</span><span class="p">,</span> <span class="n">treetransforms</span>
    <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

    <span class="c"># original tree from WSJ bracketed text</span>
    <span class="n">sentence</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;(TOP</span>
<span class="s">  (S</span>
<span class="s">    (S</span>
<span class="s">      (VP</span>
<span class="s">        (VBN Turned)</span>
<span class="s">        (ADVP (RB loose))</span>
<span class="s">        (PP</span>
<span class="s">          (IN in)</span>
<span class="s">          (NP</span>
<span class="s">            (NP (NNP Shane) (NNP Longman) (POS &#39;s))</span>
<span class="s">            (NN trading)</span>
<span class="s">            (NN room)))))</span>
<span class="s">    (, ,)</span>
<span class="s">    (NP (DT the) (NN yuppie) (NNS dealers))</span>
<span class="s">    (VP (AUX do) (NP (NP (RB little)) (ADJP (RB right))))</span>
<span class="s">    (. .)))&quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">Tree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sentence</span><span class="p">,</span> <span class="n">remove_empty_top_bracketing</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># collapse subtrees with only one child</span>
    <span class="n">collapsedTree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">treetransforms</span><span class="o">.</span><span class="n">collapse_unary</span><span class="p">(</span><span class="n">collapsedTree</span><span class="p">)</span>

    <span class="c"># convert the tree to CNF</span>
    <span class="n">cnfTree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">collapsedTree</span><span class="p">)</span>
    <span class="n">treetransforms</span><span class="o">.</span><span class="n">chomsky_normal_form</span><span class="p">(</span><span class="n">cnfTree</span><span class="p">)</span>

    <span class="c"># convert the tree to CNF with parent annotation (one level) and horizontal smoothing of order two</span>
    <span class="n">parentTree</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">collapsedTree</span><span class="p">)</span>
    <span class="n">treetransforms</span><span class="o">.</span><span class="n">chomsky_normal_form</span><span class="p">(</span><span class="n">parentTree</span><span class="p">,</span> <span class="n">horzMarkov</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">vertMarkov</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># convert the tree back to its original form (used to make CYK results comparable)</span>
    <span class="n">original</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">parentTree</span><span class="p">)</span>
    <span class="n">treetransforms</span><span class="o">.</span><span class="n">un_chomsky_normal_form</span><span class="p">(</span><span class="n">original</span><span class="p">)</span>

    <span class="c"># convert tree back to bracketed text</span>
    <span class="n">sentence2</span> <span class="o">=</span> <span class="n">original</span><span class="o">.</span><span class="n">pprint</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">sentence</span>
    <span class="k">print</span> <span class="n">sentence2</span>
    <span class="k">print</span> <span class="s">&quot;Sentences the same? &quot;</span><span class="p">,</span> <span class="n">sentence</span> <span class="o">==</span> <span class="n">sentence2</span>

    <span class="n">draw_trees</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">collapsedTree</span><span class="p">,</span> <span class="n">cnfTree</span><span class="p">,</span> <span class="n">parentTree</span><span class="p">,</span> <span class="n">original</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;chomsky_normal_form&quot;</span><span class="p">,</span> <span class="s">&quot;un_chomsky_normal_form&quot;</span><span class="p">,</span> <span class="s">&quot;collapse_unary&quot;</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/nltk.html">nltk Package</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="../../search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../../genindex.html" title="General Index"
             >index</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2012, NLTK Project.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>