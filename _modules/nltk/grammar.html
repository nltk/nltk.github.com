<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.grammar</title>
  

  <link rel="stylesheet" href="../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.grammar</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Context Free Grammars</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1">#         Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Jason Narad &lt;jason.narad@gmail.com&gt;</span>
<span class="c1">#         Peter Ljungl√∂f &lt;peter.ljunglof@heatherleaf.se&gt;</span>
<span class="c1">#         Tom Aarsen &lt;&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>
<span class="c1">#</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Basic data classes for representing context free grammars.  A</span>
<span class="sd">&quot;grammar&quot; specifies which trees can represent the structure of a</span>
<span class="sd">given text.  Each of these trees is called a &quot;parse tree&quot; for the</span>
<span class="sd">text (or simply a &quot;parse&quot;).  In a &quot;context free&quot; grammar, the set of</span>
<span class="sd">parse trees for any piece of a text can depend only on that piece, and</span>
<span class="sd">not on the rest of the text (i.e., the piece&#39;s context).  Context free</span>
<span class="sd">grammars are often used to find possible syntactic structures for</span>
<span class="sd">sentences.  In this context, the leaves of a parse tree are word</span>
<span class="sd">tokens; and the node values are phrasal categories, such as ``NP``</span>
<span class="sd">and ``VP``.</span>

<span class="sd">The ``CFG`` class is used to encode context free grammars.  Each</span>
<span class="sd">``CFG`` consists of a start symbol and a set of productions.</span>
<span class="sd">The &quot;start symbol&quot; specifies the root node value for parse trees.  For example,</span>
<span class="sd">the start symbol for syntactic parsing is usually ``S``.  Start</span>
<span class="sd">symbols are encoded using the ``Nonterminal`` class, which is discussed</span>
<span class="sd">below.</span>

<span class="sd">A Grammar&#39;s &quot;productions&quot; specify what parent-child relationships a parse</span>
<span class="sd">tree can contain.  Each production specifies that a particular</span>
<span class="sd">node can be the parent of a particular set of children.  For example,</span>
<span class="sd">the production ``&lt;S&gt; -&gt; &lt;NP&gt; &lt;VP&gt;`` specifies that an ``S`` node can</span>
<span class="sd">be the parent of an ``NP`` node and a ``VP`` node.</span>

<span class="sd">Grammar productions are implemented by the ``Production`` class.</span>
<span class="sd">Each ``Production`` consists of a left hand side and a right hand</span>
<span class="sd">side.  The &quot;left hand side&quot; is a ``Nonterminal`` that specifies the</span>
<span class="sd">node type for a potential parent; and the &quot;right hand side&quot; is a list</span>
<span class="sd">that specifies allowable children for that parent.  This lists</span>
<span class="sd">consists of ``Nonterminals`` and text types: each ``Nonterminal``</span>
<span class="sd">indicates that the corresponding child may be a ``TreeToken`` with the</span>
<span class="sd">specified node type; and each text type indicates that the</span>
<span class="sd">corresponding child may be a ``Token`` with the with that type.</span>

<span class="sd">The ``Nonterminal`` class is used to distinguish node values from leaf</span>
<span class="sd">values.  This prevents the grammar from accidentally using a leaf</span>
<span class="sd">value (such as the English word &quot;A&quot;) as the node of a subtree.  Within</span>
<span class="sd">a ``CFG``, all node values are wrapped in the ``Nonterminal``</span>
<span class="sd">class. Note, however, that the trees that are specified by the grammar do</span>
<span class="sd">*not* include these ``Nonterminal`` wrappers.</span>

<span class="sd">Grammars can also be given a more procedural interpretation.  According to</span>
<span class="sd">this interpretation, a Grammar specifies any tree structure *tree* that</span>
<span class="sd">can be produced by the following procedure:</span>

<span class="sd">| Set tree to the start symbol</span>
<span class="sd">| Repeat until tree contains no more nonterminal leaves:</span>
<span class="sd">|   Choose a production prod with whose left hand side</span>
<span class="sd">|     lhs is a nonterminal leaf of tree.</span>
<span class="sd">|   Replace the nonterminal leaf with a subtree, whose node</span>
<span class="sd">|     value is the value wrapped by the nonterminal lhs, and</span>
<span class="sd">|     whose children are the right hand side of prod.</span>

<span class="sd">The operation of replacing the left hand side (*lhs*) of a production</span>
<span class="sd">with the right hand side (*rhs*) in a tree (*tree*) is known as</span>
<span class="sd">&quot;expanding&quot; *lhs* to *rhs* in *tree*.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>

<span class="kn">from</span> <span class="nn">nltk.featstruct</span> <span class="kn">import</span> <span class="n">SLASH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">FeatDict</span><span class="p">,</span> <span class="n">FeatStruct</span><span class="p">,</span> <span class="n">FeatStructReader</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">raise_unorderable_types</span>
<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">ImmutableProbabilisticMixIn</span>
<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">invert_graph</span><span class="p">,</span> <span class="n">transitive_closure</span>

<span class="c1">#################################################################</span>
<span class="c1"># Nonterminal</span>
<span class="c1">#################################################################</span>


<div class="viewcode-block" id="Nonterminal"><a class="viewcode-back" href="../../api/nltk.grammar.Nonterminal.html#nltk.grammar.Nonterminal">[docs]</a><span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Nonterminal</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A non-terminal symbol for a context free grammar.  ``Nonterminal``</span>
<span class="sd">    is a wrapper class for node values; it is used by ``Production``</span>
<span class="sd">    objects to distinguish node values from leaf values.</span>
<span class="sd">    The node value that is wrapped by a ``Nonterminal`` is known as its</span>
<span class="sd">    &quot;symbol&quot;.  Symbols are typically strings representing phrasal</span>
<span class="sd">    categories (such as ``&quot;NP&quot;`` or ``&quot;VP&quot;``).  However, more complex</span>
<span class="sd">    symbol types are sometimes used (e.g., for lexicalized grammars).</span>
<span class="sd">    Since symbols are node values, they must be immutable and</span>
<span class="sd">    hashable.  Two ``Nonterminals`` are considered equal if their</span>
<span class="sd">    symbols are equal.</span>

<span class="sd">    :see: ``CFG``, ``Production``</span>
<span class="sd">    :type _symbol: any</span>
<span class="sd">    :ivar _symbol: The node value corresponding to this</span>
<span class="sd">        ``Nonterminal``.  This value must be immutable and hashable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Nonterminal.__init__"><a class="viewcode-back" href="../../api/nltk.grammar.Nonterminal.html#nltk.grammar.Nonterminal.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new non-terminal from the given symbol.</span>

<span class="sd">        :type symbol: any</span>
<span class="sd">        :param symbol: The node value corresponding to this</span>
<span class="sd">            ``Nonterminal``.  This value must be immutable and</span>
<span class="sd">            hashable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span> <span class="o">=</span> <span class="n">symbol</span></div>

<div class="viewcode-block" id="Nonterminal.symbol"><a class="viewcode-back" href="../../api/nltk.grammar.Nonterminal.html#nltk.grammar.Nonterminal.symbol">[docs]</a>    <span class="k">def</span> <span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the node value corresponding to this ``Nonterminal``.</span>

<span class="sd">        :rtype: (any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this non-terminal is equal to ``other``.  In</span>
<span class="sd">        particular, return True if ``other`` is a ``Nonterminal``</span>
<span class="sd">        and this non-terminal&#39;s symbol is equal to ``other`` &#39;s symbol.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_symbol</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Nonterminal</span><span class="p">):</span>
            <span class="n">raise_unorderable_types</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_symbol</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for this ``Nonterminal``.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for this ``Nonterminal``.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new nonterminal whose symbol is ``A/B``, where ``A`` is</span>
<span class="sd">        the symbol for this nonterminal, and ``B`` is the symbol for rhs.</span>

<span class="sd">        :param rhs: The nonterminal used to form the right hand side</span>
<span class="sd">            of the new nonterminal.</span>
<span class="sd">        :type rhs: Nonterminal</span>
<span class="sd">        :rtype: Nonterminal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Nonterminal</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbol</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">rhs</span><span class="o">.</span><span class="n">_symbol</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new nonterminal whose symbol is ``A/B``, where ``A`` is</span>
<span class="sd">        the symbol for this nonterminal, and ``B`` is the symbol for rhs.</span>
<span class="sd">        This function allows use of the slash ``/`` operator with</span>
<span class="sd">        the future import of division.</span>

<span class="sd">        :param rhs: The nonterminal used to form the right hand side</span>
<span class="sd">            of the new nonterminal.</span>
<span class="sd">        :type rhs: Nonterminal</span>
<span class="sd">        :rtype: Nonterminal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>


<div class="viewcode-block" id="nonterminals"><a class="viewcode-back" href="../../api/nltk.grammar.nonterminals.html#nltk.grammar.nonterminals">[docs]</a><span class="k">def</span> <span class="nf">nonterminals</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a string containing a list of symbol names, return a list of</span>
<span class="sd">    ``Nonterminals`` constructed from those symbols.</span>

<span class="sd">    :param symbols: The symbol name string.  This string can be</span>
<span class="sd">        delimited by either spaces or commas.</span>
<span class="sd">    :type symbols: str</span>
<span class="sd">    :return: A list of ``Nonterminals`` constructed from the symbol</span>
<span class="sd">        names given in ``symbols``.  The ``Nonterminals`` are sorted</span>
<span class="sd">        in the same order as the symbols names.</span>
<span class="sd">    :rtype: list(Nonterminal)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">symbol_list</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">symbol_list</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Nonterminal</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbol_list</span><span class="p">]</span></div>


<span class="k">class</span> <span class="nc">FeatStructNonterminal</span><span class="p">(</span><span class="n">FeatDict</span><span class="p">,</span> <span class="n">Nonterminal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A feature structure that&#39;s also a nonterminal.  It acts as its</span>
<span class="sd">    own symbol, and automatically freezes itself when hashed.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">FeatStruct</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">def</span> <span class="nf">is_nonterminal</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :return: True if the item is a ``Nonterminal``.</span>
<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Nonterminal</span><span class="p">)</span>


<span class="c1">#################################################################</span>
<span class="c1"># Terminals</span>
<span class="c1">#################################################################</span>


<span class="k">def</span> <span class="nf">is_terminal</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the item is a terminal, which currently is</span>
<span class="sd">    if it is hashable and not a ``Nonterminal``.</span>

<span class="sd">    :rtype: bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="s2">&quot;__hash__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Nonterminal</span><span class="p">)</span>


<span class="c1">#################################################################</span>
<span class="c1"># Productions</span>
<span class="c1">#################################################################</span>


<div class="viewcode-block" id="Production"><a class="viewcode-back" href="../../api/nltk.grammar.Production.html#nltk.grammar.Production">[docs]</a><span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">Production</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A grammar production.  Each production maps a single symbol</span>
<span class="sd">    on the &quot;left-hand side&quot; to a sequence of symbols on the</span>
<span class="sd">    &quot;right-hand side&quot;.  (In the case of context-free productions,</span>
<span class="sd">    the left-hand side must be a ``Nonterminal``, and the right-hand</span>
<span class="sd">    side is a sequence of terminals and ``Nonterminals``.)</span>
<span class="sd">    &quot;terminals&quot; can be any immutable hashable object that is</span>
<span class="sd">    not a ``Nonterminal``.  Typically, terminals are strings</span>
<span class="sd">    representing words, such as ``&quot;dog&quot;`` or ``&quot;under&quot;``.</span>

<span class="sd">    :see: ``CFG``</span>
<span class="sd">    :see: ``DependencyGrammar``</span>
<span class="sd">    :see: ``Nonterminal``</span>
<span class="sd">    :type _lhs: Nonterminal</span>
<span class="sd">    :ivar _lhs: The left-hand side of the production.</span>
<span class="sd">    :type _rhs: tuple(Nonterminal, terminal)</span>
<span class="sd">    :ivar _rhs: The right-hand side of the production.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Production.__init__"><a class="viewcode-back" href="../../api/nltk.grammar.Production.html#nltk.grammar.Production.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new ``Production``.</span>

<span class="sd">        :param lhs: The left-hand side of the new ``Production``.</span>
<span class="sd">        :type lhs: Nonterminal</span>
<span class="sd">        :param rhs: The right-hand side of the new ``Production``.</span>
<span class="sd">        :type rhs: sequence(Nonterminal and terminal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;production right hand side should be a list, &quot;</span> <span class="s2">&quot;not a string&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Production.lhs"><a class="viewcode-back" href="../../api/nltk.grammar.Production.html#nltk.grammar.Production.lhs">[docs]</a>    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the left-hand side of this ``Production``.</span>

<span class="sd">        :rtype: Nonterminal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span></div>

<div class="viewcode-block" id="Production.rhs"><a class="viewcode-back" href="../../api/nltk.grammar.Production.html#nltk.grammar.Production.rhs">[docs]</a>    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the right-hand side of this ``Production``.</span>

<span class="sd">        :rtype: sequence(Nonterminal and terminal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the length of the right-hand side.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span>

<div class="viewcode-block" id="Production.is_nonlexical"><a class="viewcode-back" href="../../api/nltk.grammar.Production.html#nltk.grammar.Production.is_nonlexical">[docs]</a>    <span class="k">def</span> <span class="nf">is_nonlexical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the right-hand side only contains ``Nonterminals``</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_nonterminal</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Production.is_lexical"><a class="viewcode-back" href="../../api/nltk.grammar.Production.html#nltk.grammar.Production.is_lexical">[docs]</a>    <span class="k">def</span> <span class="nf">is_lexical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the right-hand contain at least one terminal token.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonlexical</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a verbose string representation of the ``Production``.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> -&gt; &quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a concise string representation of the ``Production``.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this ``Production`` is equal to ``other``.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_lhs</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_rhs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Production</span><span class="p">):</span>
            <span class="n">raise_unorderable_types</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a hash value for the ``Production``.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">))</span></div>


<div class="viewcode-block" id="DependencyProduction"><a class="viewcode-back" href="../../api/nltk.grammar.DependencyProduction.html#nltk.grammar.DependencyProduction">[docs]</a><span class="k">class</span> <span class="nc">DependencyProduction</span><span class="p">(</span><span class="n">Production</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A dependency grammar production.  Each production maps a single</span>
<span class="sd">    head word to an unordered list of one or more modifier words.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a verbose string representation of the ``DependencyProduction``.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="si">}</span><span class="s2">&#39; -&gt;&quot;</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; &#39;</span><span class="si">{</span><span class="n">elt</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="ProbabilisticProduction"><a class="viewcode-back" href="../../api/nltk.grammar.ProbabilisticProduction.html#nltk.grammar.ProbabilisticProduction">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticProduction</span><span class="p">(</span><span class="n">Production</span><span class="p">,</span> <span class="n">ImmutableProbabilisticMixIn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A probabilistic context free grammar production.</span>
<span class="sd">    A PCFG ``ProbabilisticProduction`` is essentially just a ``Production`` that</span>
<span class="sd">    has an associated probability, which represents how likely it is that</span>
<span class="sd">    this production will be used.  In particular, the probability of a</span>
<span class="sd">    ``ProbabilisticProduction`` records the likelihood that its right-hand side is</span>
<span class="sd">    the correct instantiation for any given occurrence of its left-hand side.</span>

<span class="sd">    :see: ``Production``</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProbabilisticProduction.__init__"><a class="viewcode-back" href="../../api/nltk.grammar.ProbabilisticProduction.html#nltk.grammar.ProbabilisticProduction.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">**</span><span class="n">prob</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new ``ProbabilisticProduction``.</span>

<span class="sd">        :param lhs: The left-hand side of the new ``ProbabilisticProduction``.</span>
<span class="sd">        :type lhs: Nonterminal</span>
<span class="sd">        :param rhs: The right-hand side of the new ``ProbabilisticProduction``.</span>
<span class="sd">        :type rhs: sequence(Nonterminal and terminal)</span>
<span class="sd">        :param prob: Probability parameters of the new ``ProbabilisticProduction``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ImmutableProbabilisticMixIn</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">prob</span><span class="p">)</span>
        <span class="n">Production</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="p">(</span>
            <span class="s2">&quot; [1.0]&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot; [</span><span class="si">%g</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_lhs</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_rhs</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">()))</span></div>


<span class="c1">#################################################################</span>
<span class="c1"># Grammars</span>
<span class="c1">#################################################################</span>


<div class="viewcode-block" id="CFG"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG">[docs]</a><span class="k">class</span> <span class="nc">CFG</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A context-free grammar.  A grammar consists of a start state and</span>
<span class="sd">    a set of productions.  The set of terminals and nonterminals is</span>
<span class="sd">    implicitly specified by the productions.</span>

<span class="sd">    If you need efficient key-based access to productions, you</span>
<span class="sd">    can use a subclass to implement it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CFG.__init__"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">,</span> <span class="n">calculate_leftcorners</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new context-free grammar, from the given start state</span>
<span class="sd">        and set of ``Production`` instances.</span>

<span class="sd">        :param start: The start symbol</span>
<span class="sd">        :type start: Nonterminal</span>
<span class="sd">        :param productions: The list of productions that defines the grammar</span>
<span class="sd">        :type productions: list(Production)</span>
<span class="sd">        :param calculate_leftcorners: False if we don&#39;t want to calculate the</span>
<span class="sd">            leftcorner relation. In that case, some optimized chart parsers won&#39;t work.</span>
<span class="sd">        :type calculate_leftcorners: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;start should be a Nonterminal object,&quot;</span>
                <span class="s2">&quot; not a </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span> <span class="o">=</span> <span class="n">productions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_categories</span> <span class="o">=</span> <span class="p">{</span><span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span> <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_indexes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_grammar_forms</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">calculate_leftcorners</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_leftcorners</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_calculate_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexical_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">:</span>
            <span class="c1"># Left hand side.</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">_lhs</span>
            <span class="k">if</span> <span class="n">lhs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">_rhs</span><span class="p">:</span>
                <span class="c1"># First item in right hand side.</span>
                <span class="n">rhs0</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rhs0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="p">[</span><span class="n">rhs0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="p">[</span><span class="n">rhs0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The right hand side is empty.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">()]</span> <span class="o">=</span> <span class="n">prod</span>
            <span class="c1"># Lexical tokens in the right hand side.</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">prod</span><span class="o">.</span><span class="n">_rhs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lexical_index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_leftcorners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Calculate leftcorner relations, for use in optimized parsing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_categories</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span><span class="p">:</span> <span class="p">{</span><span class="n">cat</span><span class="p">}</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_categories</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_words</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_categories</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cat</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_categories</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_words</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

        <span class="n">lc</span> <span class="o">=</span> <span class="n">transitive_closure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_categories</span><span class="p">,</span> <span class="n">reflexive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorners</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorner_parents</span> <span class="o">=</span> <span class="n">invert_graph</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="n">nr_leftcorner_categories</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_categories</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">nr_leftcorner_words</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_words</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">nr_leftcorner_words</span> <span class="o">&gt;</span> <span class="n">nr_leftcorner_categories</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
            <span class="c1"># If the grammar is big, the leftcorner-word dictionary will be too large.</span>
            <span class="c1"># In that case it is better to calculate the relation on demand.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorner_words</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorner_words</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorners</span><span class="p">:</span>
            <span class="n">lefts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorners</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorner_words</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="n">lefts</span><span class="p">:</span>
                <span class="n">lc</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_words</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>

<div class="viewcode-block" id="CFG.fromstring"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.fromstring">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the grammar instance corresponding to the input string(s).</span>

<span class="sd">        :param input: a grammar, either in the form of a string or as a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">productions</span> <span class="o">=</span> <span class="n">read_grammar</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="n">standard_nonterm_parser</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">)</span></div>

<div class="viewcode-block" id="CFG.start"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the start symbol of the grammar</span>

<span class="sd">        :rtype: Nonterminal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span></div>

    <span class="c1"># tricky to balance readability and efficiency here!</span>
    <span class="c1"># can&#39;t use set operations as they don&#39;t preserve ordering</span>
<div class="viewcode-block" id="CFG.productions"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.productions">[docs]</a>    <span class="k">def</span> <span class="nf">productions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the grammar productions, filtered by the left-hand side</span>
<span class="sd">        or the first item in the right-hand side.</span>

<span class="sd">        :param lhs: Only return productions with the given left-hand side.</span>
<span class="sd">        :param rhs: Only return productions with the given first item</span>
<span class="sd">            in the right-hand side.</span>
<span class="sd">        :param empty: Only return productions with an empty right-hand side.</span>
<span class="sd">        :return: A list of productions matching the given constraints.</span>
<span class="sd">        :rtype: list(Production)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You cannot select empty and non-empty &quot;</span> <span class="s2">&quot;productions at the same time.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># no constraints so return everything</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lhs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="c1"># only lhs specified so look up its index</span>
        <span class="k">elif</span> <span class="n">lhs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">elif</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="p">[</span><span class="n">lhs</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># only rhs specified so look up its index</span>
        <span class="k">elif</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># intersect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">prod</span>
                <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">if</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="p">[])</span>
            <span class="p">]</span></div>

<div class="viewcode-block" id="CFG.leftcorners"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.leftcorners">[docs]</a>    <span class="k">def</span> <span class="nf">leftcorners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of all nonterminals that the given nonterminal</span>
<span class="sd">        can start with, including itself.</span>

<span class="sd">        This is the reflexive, transitive closure of the immediate</span>
<span class="sd">        leftcorner relation:  (A &gt; B)  iff  (A -&gt; B beta)</span>

<span class="sd">        :param cat: the parent of the leftcorners</span>
<span class="sd">        :type cat: Nonterminal</span>
<span class="sd">        :return: the set of all leftcorners</span>
<span class="sd">        :rtype: set(Nonterminal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorners</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="p">{</span><span class="n">cat</span><span class="p">})</span></div>

<div class="viewcode-block" id="CFG.is_leftcorner"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.is_leftcorner">[docs]</a>    <span class="k">def</span> <span class="nf">is_leftcorner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if left is a leftcorner of cat, where left can be a</span>
<span class="sd">        terminal or a nonterminal.</span>

<span class="sd">        :param cat: the parent of the leftcorner</span>
<span class="sd">        :type cat: Nonterminal</span>
<span class="sd">        :param left: the suggested leftcorner</span>
<span class="sd">        :type left: Terminal or Nonterminal</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">left</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">left</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leftcorners</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorner_words</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorner_words</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
                <span class="n">left</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immediate_leftcorner_words</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leftcorners</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="CFG.leftcorner_parents"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.leftcorner_parents">[docs]</a>    <span class="k">def</span> <span class="nf">leftcorner_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of all nonterminals for which the given category</span>
<span class="sd">        is a left corner. This is the inverse of the leftcorner relation.</span>

<span class="sd">        :param cat: the suggested leftcorner</span>
<span class="sd">        :type cat: Nonterminal</span>
<span class="sd">        :return: the set of all parents to the leftcorner</span>
<span class="sd">        :rtype: set(Nonterminal)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftcorner_parents</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="p">{</span><span class="n">cat</span><span class="p">})</span></div>

<div class="viewcode-block" id="CFG.check_coverage"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.check_coverage">[docs]</a>    <span class="k">def</span> <span class="nf">check_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the grammar rules cover the given list of tokens.</span>
<span class="sd">        If not, then raise an exception.</span>

<span class="sd">        :type tokens: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">tok</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">tokens</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lexical_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tok</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">w</span><span class="si">!r}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">missing</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Grammar does not cover some of the &quot;</span> <span class="s2">&quot;input words: </span><span class="si">%r</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="n">missing</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_calculate_grammar_forms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pre-calculate of which form(s) the grammar is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_lexical</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_lexical</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_nonlexical</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_nonlexical</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_unary_are_lexical</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_lexical</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="CFG.is_lexical"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.is_lexical">[docs]</a>    <span class="k">def</span> <span class="nf">is_lexical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if all productions are lexicalised.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_lexical</span></div>

<div class="viewcode-block" id="CFG.is_nonlexical"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.is_nonlexical">[docs]</a>    <span class="k">def</span> <span class="nf">is_nonlexical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if all lexical rules are &quot;preterminals&quot;, that is,</span>
<span class="sd">        unary rules which can be separated in a preprocessing step.</span>

<span class="sd">        This means that all productions are of the forms</span>
<span class="sd">        A -&gt; B1 ... Bn (n&gt;=0), or A -&gt; &quot;s&quot;.</span>

<span class="sd">        Note: is_lexical() and is_nonlexical() are not opposites.</span>
<span class="sd">        There are grammars which are neither, and grammars which are both.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_nonlexical</span></div>

<div class="viewcode-block" id="CFG.min_len"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.min_len">[docs]</a>    <span class="k">def</span> <span class="nf">min_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the right-hand side length of the shortest grammar production.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span></div>

<div class="viewcode-block" id="CFG.max_len"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.max_len">[docs]</a>    <span class="k">def</span> <span class="nf">max_len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the right-hand side length of the longest grammar production.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span></div>

<div class="viewcode-block" id="CFG.is_nonempty"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.is_nonempty">[docs]</a>    <span class="k">def</span> <span class="nf">is_nonempty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if there are no empty productions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_len</span> <span class="o">&gt;</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="CFG.is_binarised"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.is_binarised">[docs]</a>    <span class="k">def</span> <span class="nf">is_binarised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if all productions are at most binary.</span>
<span class="sd">        Note that there can still be empty and unary productions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_len</span> <span class="o">&lt;=</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="CFG.is_flexible_chomsky_normal_form"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.is_flexible_chomsky_normal_form">[docs]</a>    <span class="k">def</span> <span class="nf">is_flexible_chomsky_normal_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if all productions are of the forms</span>
<span class="sd">        A -&gt; B C, A -&gt; B, or A -&gt; &quot;s&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonempty</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nonlexical</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_binarised</span><span class="p">()</span></div>

<div class="viewcode-block" id="CFG.is_chomsky_normal_form"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.is_chomsky_normal_form">[docs]</a>    <span class="k">def</span> <span class="nf">is_chomsky_normal_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if the grammar is of Chomsky Normal Form, i.e. all productions</span>
<span class="sd">        are of the form A -&gt; B C, or A -&gt; &quot;s&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_flexible_chomsky_normal_form</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_unary_are_lexical</span></div>

<div class="viewcode-block" id="CFG.chomsky_normal_form"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.chomsky_normal_form">[docs]</a>    <span class="k">def</span> <span class="nf">chomsky_normal_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_token_padding</span><span class="o">=</span><span class="s2">&quot;@$@&quot;</span><span class="p">,</span> <span class="n">flexible</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Grammar that is in chomsky normal</span>

<span class="sd">        :param: new_token_padding</span>
<span class="sd">            Customise new rule formation during binarisation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_chomsky_normal_form</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">empty</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Grammar has Empty rules. &quot;</span> <span class="s2">&quot;Cannot deal with them at the moment&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check for mixed rules</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">is_lexical</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot handled mixed rule </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span><span class="si">}</span><span class="s2"> =&gt; </span><span class="si">{</span><span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">step1</span> <span class="o">=</span> <span class="n">CFG</span><span class="o">.</span><span class="n">eliminate_start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">step2</span> <span class="o">=</span> <span class="n">CFG</span><span class="o">.</span><span class="n">binarize</span><span class="p">(</span><span class="n">step1</span><span class="p">,</span> <span class="n">new_token_padding</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flexible</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">step2</span>
        <span class="n">step3</span> <span class="o">=</span> <span class="n">CFG</span><span class="o">.</span><span class="n">remove_unitary_rules</span><span class="p">(</span><span class="n">step2</span><span class="p">)</span>
        <span class="n">step4</span> <span class="o">=</span> <span class="n">CFG</span><span class="p">(</span><span class="n">step3</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">step3</span><span class="o">.</span><span class="n">productions</span><span class="p">())))</span>
        <span class="k">return</span> <span class="n">step4</span></div>

<div class="viewcode-block" id="CFG.remove_unitary_rules"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.remove_unitary_rules">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">remove_unitary_rules</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove nonlexical unitary rules and convert them to</span>
<span class="sd">        lexical</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unitary</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">rule</span><span class="o">.</span><span class="n">is_nonlexical</span><span class="p">():</span>
                <span class="n">unitary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">unitary</span><span class="p">:</span>
            <span class="n">rule</span> <span class="o">=</span> <span class="n">unitary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">new_rule</span> <span class="o">=</span> <span class="n">Production</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">item</span><span class="o">.</span><span class="n">rhs</span><span class="p">())</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_rule</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">new_rule</span><span class="o">.</span><span class="n">is_lexical</span><span class="p">():</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_rule</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unitary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_rule</span><span class="p">)</span>

        <span class="n">n_grammar</span> <span class="o">=</span> <span class="n">CFG</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_grammar</span></div>

<div class="viewcode-block" id="CFG.binarize"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.binarize">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">binarize</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s2">&quot;@$@&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert all non-binary rules into binary by introducing</span>
<span class="sd">        new tokens.</span>
<span class="sd">        Example::</span>

<span class="sd">            Original:</span>
<span class="sd">                A =&gt; B C D</span>
<span class="sd">            After Conversion:</span>
<span class="sd">                A =&gt; B A@$@B</span>
<span class="sd">                A@$@B =&gt; C D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># this rule needs to be broken down</span>
                <span class="n">left_side</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">())</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">tsym</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">new_sym</span> <span class="o">=</span> <span class="n">Nonterminal</span><span class="p">(</span><span class="n">left_side</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span> <span class="o">+</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">tsym</span><span class="o">.</span><span class="n">symbol</span><span class="p">())</span>
                    <span class="n">new_production</span> <span class="o">=</span> <span class="n">Production</span><span class="p">(</span><span class="n">left_side</span><span class="p">,</span> <span class="p">(</span><span class="n">tsym</span><span class="p">,</span> <span class="n">new_sym</span><span class="p">))</span>
                    <span class="n">left_side</span> <span class="o">=</span> <span class="n">new_sym</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_production</span><span class="p">)</span>
                <span class="n">last_prd</span> <span class="o">=</span> <span class="n">Production</span><span class="p">(</span><span class="n">left_side</span><span class="p">,</span> <span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_prd</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>

        <span class="n">n_grammar</span> <span class="o">=</span> <span class="n">CFG</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n_grammar</span></div>

<div class="viewcode-block" id="CFG.eliminate_start"><a class="viewcode-back" href="../../api/nltk.grammar.CFG.html#nltk.grammar.CFG.eliminate_start">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eliminate_start</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Eliminate start rule in case it appears on RHS</span>
<span class="sd">        Example: S -&gt; S0 S1 and S0 -&gt; S1 S</span>
<span class="sd">        Then another rule S0_Sigma -&gt; S is added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">need_to_add</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">rhs</span><span class="p">():</span>
                <span class="n">need_to_add</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">need_to_add</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">Nonterminal</span><span class="p">(</span><span class="s2">&quot;S0_SIGMA&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">[</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()]))</span>
            <span class="n">n_grammar</span> <span class="o">=</span> <span class="n">CFG</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n_grammar</span>
        <span class="k">return</span> <span class="n">grammar</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Grammar with </span><span class="si">%d</span><span class="s2"> productions&gt;&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;Grammar with </span><span class="si">%d</span><span class="s2"> productions&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot; (start state = </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="k">for</span> <span class="n">production</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">production</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="k">class</span> <span class="nc">FeatureGrammar</span><span class="p">(</span><span class="n">CFG</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A feature-based grammar.  This is equivalent to a</span>
<span class="sd">    ``CFG`` whose nonterminals are all</span>
<span class="sd">    ``FeatStructNonterminal``.</span>

<span class="sd">    A grammar consists of a start state and a set of</span>
<span class="sd">    productions.  The set of terminals and nonterminals</span>
<span class="sd">    is implicitly specified by the productions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new feature-based grammar, from the given start</span>
<span class="sd">        state and set of ``Productions``.</span>

<span class="sd">        :param start: The start symbol</span>
<span class="sd">        :type start: FeatStructNonterminal</span>
<span class="sd">        :param productions: The list of productions that defines the grammar</span>
<span class="sd">        :type productions: list(Production)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CFG</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">)</span>

    <span class="c1"># The difference with CFG is that the productions are</span>
    <span class="c1"># indexed on the TYPE feature of the nonterminals.</span>
    <span class="c1"># This is calculated by the method _get_type_if_possible().</span>

    <span class="k">def</span> <span class="nf">_calculate_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_empty_productions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexical_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">:</span>
            <span class="c1"># Left hand side.</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_type_if_possible</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">_lhs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lhs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">_rhs</span><span class="p">:</span>
                <span class="c1"># First item in right hand side.</span>
                <span class="n">rhs0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_type_if_possible</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">rhs0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="p">[</span><span class="n">rhs0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="p">[</span><span class="n">rhs0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The right hand side is empty.</span>
                <span class="k">if</span> <span class="n">lhs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_empty_productions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
            <span class="c1"># Lexical tokens in the right hand side.</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">prod</span><span class="o">.</span><span class="n">_rhs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">token</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lexical_index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logic_parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fstruct_reader</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a feature structure based grammar.</span>

<span class="sd">        :param input: a grammar, either in the form of a string or else</span>
<span class="sd">        as a list of strings.</span>
<span class="sd">        :param features: a tuple of features (default: SLASH, TYPE)</span>
<span class="sd">        :param logic_parser: a parser for lambda-expressions,</span>
<span class="sd">        by default, ``LogicParser()``</span>
<span class="sd">        :param fstruct_reader: a feature structure parser</span>
<span class="sd">        (only if features and logic_parser is None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">features</span> <span class="o">=</span> <span class="p">(</span><span class="n">SLASH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fstruct_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fstruct_reader</span> <span class="o">=</span> <span class="n">FeatStructReader</span><span class="p">(</span>
                <span class="n">features</span><span class="p">,</span> <span class="n">FeatStructNonterminal</span><span class="p">,</span> <span class="n">logic_parser</span><span class="o">=</span><span class="n">logic_parser</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">logic_parser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;&#39;logic_parser&#39; and &#39;fstruct_reader&#39; must &quot;</span> <span class="s2">&quot;not both be set&quot;</span>
            <span class="p">)</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">productions</span> <span class="o">=</span> <span class="n">read_grammar</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="n">fstruct_reader</span><span class="o">.</span><span class="n">read_partial</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">productions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the grammar productions, filtered by the left-hand side</span>
<span class="sd">        or the first item in the right-hand side.</span>

<span class="sd">        :param lhs: Only return productions with the given left-hand side.</span>
<span class="sd">        :param rhs: Only return productions with the given first item</span>
<span class="sd">            in the right-hand side.</span>
<span class="sd">        :param empty: Only return productions with an empty right-hand side.</span>
<span class="sd">        :rtype: list(Production)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">empty</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You cannot select empty and non-empty &quot;</span> <span class="s2">&quot;productions at the same time.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># no constraints so return everything</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lhs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_empty_productions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span>

        <span class="c1"># only lhs specified so look up its index</span>
        <span class="k">elif</span> <span class="n">lhs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_empty_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_type_if_possible</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_type_if_possible</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="p">[])</span>

        <span class="c1"># only rhs specified so look up its index</span>
        <span class="k">elif</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_type_if_possible</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="p">[])</span>

        <span class="c1"># intersect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">prod</span>
                <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_type_if_possible</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="p">[])</span>
                <span class="k">if</span> <span class="n">prod</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_type_if_possible</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="p">[])</span>
            <span class="p">]</span>

    <span class="k">def</span> <span class="nf">leftcorners</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of all words that the given category can start with.</span>
<span class="sd">        Also called the &quot;first set&quot; in compiler construction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not implemented yet&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leftcorner_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of all categories for which the given category</span>
<span class="sd">        is a left corner.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Not implemented yet&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_type_if_possible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function which returns the ``TYPE`` feature of the ``item``,</span>
<span class="sd">        if it exists, otherwise it returns the ``item`` itself</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">TYPE</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FeatureValueType</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="n">TYPE</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">item</span>


<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">FeatureValueType</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper class for ``FeatureGrammars``, designed to be different</span>
<span class="sd">    from ordinary strings.  This is to stop the ``FeatStruct``</span>
<span class="sd">    ``FOO[]`` from being compare equal to the terminal &quot;FOO&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FeatureValueType</span><span class="p">):</span>
            <span class="n">raise_unorderable_types</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span>


<div class="viewcode-block" id="DependencyGrammar"><a class="viewcode-back" href="../../api/nltk.grammar.DependencyGrammar.html#nltk.grammar.DependencyGrammar">[docs]</a><span class="k">class</span> <span class="nc">DependencyGrammar</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A dependency grammar.  A DependencyGrammar consists of a set of</span>
<span class="sd">    productions.  Each production specifies a head/modifier relationship</span>
<span class="sd">    between a pair of words.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DependencyGrammar.__init__"><a class="viewcode-back" href="../../api/nltk.grammar.DependencyGrammar.html#nltk.grammar.DependencyGrammar.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">productions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new dependency grammar, from the set of ``Productions``.</span>

<span class="sd">        :param productions: The list of productions that defines the grammar</span>
<span class="sd">        :type productions: list(Production)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span> <span class="o">=</span> <span class="n">productions</span></div>

<div class="viewcode-block" id="DependencyGrammar.fromstring"><a class="viewcode-back" href="../../api/nltk.grammar.DependencyGrammar.html#nltk.grammar.DependencyGrammar.fromstring">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="n">productions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">linenum</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">productions</span> <span class="o">+=</span> <span class="n">_read_dependency_production</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to parse line </span><span class="si">{</span><span class="n">linenum</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">productions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No productions found!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">productions</span><span class="p">)</span></div>

<div class="viewcode-block" id="DependencyGrammar.contains"><a class="viewcode-back" href="../../api/nltk.grammar.DependencyGrammar.html#nltk.grammar.DependencyGrammar.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param head: A head word.</span>
<span class="sd">        :type head: str</span>
<span class="sd">        :param mod: A mod word, to test as a modifier of &#39;head&#39;.</span>
<span class="sd">        :type mod: str</span>

<span class="sd">        :return: true if this ``DependencyGrammar`` contains a</span>
<span class="sd">            ``DependencyProduction`` mapping &#39;head&#39; to &#39;mod&#39;.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">production</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">possibleMod</span> <span class="ow">in</span> <span class="n">production</span><span class="o">.</span><span class="n">_rhs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">production</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">==</span> <span class="n">head</span> <span class="ow">and</span> <span class="n">possibleMod</span> <span class="o">==</span> <span class="n">mod</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head_mod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this ``DependencyGrammar`` contains a</span>
<span class="sd">        ``DependencyProduction`` mapping &#39;head&#39; to &#39;mod&#39;.</span>

<span class="sd">        :param head_mod: A tuple of a head word and a mod word,</span>
<span class="sd">            to test as a modifier of &#39;head&#39;.</span>
<span class="sd">        :type head: Tuple[str, str]</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">head</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">head_mod</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must use a tuple of strings, e.g. `(&#39;price&#39;, &#39;of&#39;) in grammar`&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span>

    <span class="c1">#   # should be rewritten, the set comp won&#39;t work in all comparisons</span>
    <span class="c1"># def contains_exactly(self, head, modlist):</span>
    <span class="c1">#   for production in self._productions:</span>
    <span class="c1">#       if(len(production._rhs) == len(modlist)):</span>
    <span class="c1">#           if(production._lhs == head):</span>
    <span class="c1">#               set1 = Set(production._rhs)</span>
    <span class="c1">#               set2 = Set(modlist)</span>
    <span class="c1">#               if(set1 == set2):</span>
    <span class="c1">#                   return True</span>
    <span class="c1">#   return False</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a verbose string representation of the ``DependencyGrammar``</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Dependency grammar with </span><span class="si">%d</span><span class="s2"> productions&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">production</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">production</span>
        <span class="k">return</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a concise string representation of the ``DependencyGrammar``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Dependency grammar with </span><span class="si">%d</span><span class="s2"> productions&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProbabilisticDependencyGrammar"><a class="viewcode-back" href="../../api/nltk.grammar.ProbabilisticDependencyGrammar.html#nltk.grammar.ProbabilisticDependencyGrammar">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticDependencyGrammar</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProbabilisticDependencyGrammar.__init__"><a class="viewcode-back" href="../../api/nltk.grammar.ProbabilisticDependencyGrammar.html#nltk.grammar.ProbabilisticDependencyGrammar.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">productions</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">tags</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span> <span class="o">=</span> <span class="n">productions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events</span> <span class="o">=</span> <span class="n">events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span> <span class="o">=</span> <span class="n">tags</span></div>

<div class="viewcode-block" id="ProbabilisticDependencyGrammar.contains"><a class="viewcode-back" href="../../api/nltk.grammar.ProbabilisticDependencyGrammar.html#nltk.grammar.ProbabilisticDependencyGrammar.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">mod</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this ``DependencyGrammar`` contains a</span>
<span class="sd">        ``DependencyProduction`` mapping &#39;head&#39; to &#39;mod&#39;.</span>

<span class="sd">        :param head: A head word.</span>
<span class="sd">        :type head: str</span>
<span class="sd">        :param mod: A mod word, to test as a modifier of &#39;head&#39;.</span>
<span class="sd">        :type mod: str</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">production</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">possibleMod</span> <span class="ow">in</span> <span class="n">production</span><span class="o">.</span><span class="n">_rhs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">production</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">==</span> <span class="n">head</span> <span class="ow">and</span> <span class="n">possibleMod</span> <span class="o">==</span> <span class="n">mod</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a verbose string representation of the ``ProbabilisticDependencyGrammar``</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Statistical dependency grammar with </span><span class="si">%d</span><span class="s2"> productions&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">production</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">production</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Events:&quot;</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">%d</span><span class="s2">:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_events</span><span class="p">[</span><span class="n">event</span><span class="p">],</span> <span class="n">event</span><span class="p">)</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tags:&quot;</span>
        <span class="k">for</span> <span class="n">tag_word</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">tag_word</span><span class="si">}</span><span class="s2">:</span><span class="se">\t</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_tags</span><span class="p">[</span><span class="n">tag_word</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a concise string representation of the ``ProbabilisticDependencyGrammar``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Statistical Dependency grammar with </span><span class="si">%d</span><span class="s2"> productions&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_productions</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PCFG"><a class="viewcode-back" href="../../api/nltk.grammar.PCFG.html#nltk.grammar.PCFG">[docs]</a><span class="k">class</span> <span class="nc">PCFG</span><span class="p">(</span><span class="n">CFG</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A probabilistic context-free grammar.  A PCFG consists of a</span>
<span class="sd">    start state and a set of productions with probabilities.  The set of</span>
<span class="sd">    terminals and nonterminals is implicitly specified by the productions.</span>

<span class="sd">    PCFG productions use the ``ProbabilisticProduction`` class.</span>
<span class="sd">    ``PCFGs`` impose the constraint that the set of productions with</span>
<span class="sd">    any given left-hand-side must have probabilities that sum to 1</span>
<span class="sd">    (allowing for a small margin of error).</span>

<span class="sd">    If you need efficient key-based access to productions, you can use</span>
<span class="sd">    a subclass to implement it.</span>

<span class="sd">    :type EPSILON: float</span>
<span class="sd">    :cvar EPSILON: The acceptable margin of error for checking that</span>
<span class="sd">        productions with a given left-hand side have probabilities</span>
<span class="sd">        that sum to 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EPSILON</span> <span class="o">=</span> <span class="mf">0.01</span>

<div class="viewcode-block" id="PCFG.__init__"><a class="viewcode-back" href="../../api/nltk.grammar.PCFG.html#nltk.grammar.PCFG.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">,</span> <span class="n">calculate_leftcorners</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new context-free grammar, from the given start state</span>
<span class="sd">        and set of ``ProbabilisticProductions``.</span>

<span class="sd">        :param start: The start symbol</span>
<span class="sd">        :type start: Nonterminal</span>
<span class="sd">        :param productions: The list of productions that defines the grammar</span>
<span class="sd">        :type productions: list(Production)</span>
<span class="sd">        :raise ValueError: if the set of productions with any left-hand-side</span>
<span class="sd">            do not have probabilities that sum to a value within</span>
<span class="sd">            EPSILON of 1.</span>
<span class="sd">        :param calculate_leftcorners: False if we don&#39;t want to calculate the</span>
<span class="sd">            leftcorner relation. In that case, some optimized chart parsers won&#39;t work.</span>
<span class="sd">        :type calculate_leftcorners: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">CFG</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">,</span> <span class="n">calculate_leftcorners</span><span class="p">)</span>

        <span class="c1"># Make sure that the probabilities sum to one.</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">production</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
            <span class="n">probs</span><span class="p">[</span><span class="n">production</span><span class="o">.</span><span class="n">lhs</span><span class="p">()]</span> <span class="o">=</span> <span class="n">probs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">production</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">production</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">in</span> <span class="n">probs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">PCFG</span><span class="o">.</span><span class="n">EPSILON</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">PCFG</span><span class="o">.</span><span class="n">EPSILON</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Productions for </span><span class="si">%r</span><span class="s2"> do not sum to 1&quot;</span> <span class="o">%</span> <span class="n">lhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PCFG.fromstring"><a class="viewcode-back" href="../../api/nltk.grammar.PCFG.html#nltk.grammar.PCFG.fromstring">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a probabilistic context-free grammar corresponding to the</span>
<span class="sd">        input string(s).</span>

<span class="sd">        :param input: a grammar, either in the form of a string or else</span>
<span class="sd">             as a list of strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">productions</span> <span class="o">=</span> <span class="n">read_grammar</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="n">standard_nonterm_parser</span><span class="p">,</span> <span class="n">probabilistic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">)</span></div></div>


<span class="c1">#################################################################</span>
<span class="c1"># Inducing Grammars</span>
<span class="c1">#################################################################</span>

<span class="c1"># Contributed by Nathan Bodenstab &lt;bodenstab@cslu.ogi.edu&gt;</span>


<div class="viewcode-block" id="induce_pcfg"><a class="viewcode-back" href="../../api/nltk.grammar.induce_pcfg.html#nltk.grammar.induce_pcfg">[docs]</a><span class="k">def</span> <span class="nf">induce_pcfg</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Induce a PCFG grammar from a list of productions.</span>

<span class="sd">    The probability of a production A -&gt; B C in a PCFG is:</span>

<span class="sd">    |                count(A -&gt; B C)</span>
<span class="sd">    |  P(B, C | A) = ---------------       where \* is any right hand side</span>
<span class="sd">    |                 count(A -&gt; \*)</span>

<span class="sd">    :param start: The start symbol</span>
<span class="sd">    :type start: Nonterminal</span>
<span class="sd">    :param productions: The list of productions that defines the grammar</span>
<span class="sd">    :type productions: list(Production)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Production count: the number of times a given production occurs</span>
    <span class="n">pcount</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># LHS-count: counts the number of times a given lhs occurs</span>
    <span class="n">lcount</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
        <span class="n">lcount</span><span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">()]</span> <span class="o">=</span> <span class="n">lcount</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">pcount</span><span class="p">[</span><span class="n">prod</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcount</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">prods</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ProbabilisticProduction</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">prob</span><span class="o">=</span><span class="n">pcount</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">lcount</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">lhs</span><span class="p">()])</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcount</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">PCFG</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">prods</span><span class="p">)</span></div>


<span class="c1">#################################################################</span>
<span class="c1"># Helper functions for reading productions</span>
<span class="c1">#################################################################</span>


<span class="k">def</span> <span class="nf">_read_cfg_production</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of context-free ``Productions``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_read_production</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">standard_nonterm_parser</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_pcfg_production</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of PCFG ``ProbabilisticProductions``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_read_production</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">standard_nonterm_parser</span><span class="p">,</span> <span class="n">probabilistic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_fcfg_production</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">fstruct_reader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a list of feature-based ``Productions``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_read_production</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">fstruct_reader</span><span class="p">)</span>


<span class="c1"># Parsing generic grammars</span>

<span class="n">_ARROW_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s* -&gt; \s*&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="n">_PROBABILITY_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;( \[ [\d\.]+ \] ) \s*&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="n">_TERMINAL_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;( &quot;[^&quot;]*&quot; | </span><span class="se">\&#39;</span><span class="s1">[^</span><span class="se">\&#39;</span><span class="s1">]*</span><span class="se">\&#39;</span><span class="s1"> ) \s*&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>
<span class="n">_DISJUNCTION_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\| \s*&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_production</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">nonterm_parser</span><span class="p">,</span> <span class="n">probabilistic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a grammar rule, given as a string, and return</span>
<span class="sd">    a list of productions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Parse the left-hand side.</span>
    <span class="n">lhs</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">nonterm_parser</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>

    <span class="c1"># Skip over the arrow.</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">_ARROW_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected an arrow&quot;</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

    <span class="c1"># Parse the right hand side.</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
    <span class="n">rhsides</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        <span class="c1"># Probability.</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">_PROBABILITY_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">probabilistic</span> <span class="ow">and</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">probabilities</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">probabilities</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Production probability </span><span class="si">%f</span><span class="s2">, &quot;</span>
                    <span class="s2">&quot;should not be greater than 1.0&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">probabilities</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>
                <span class="p">)</span>

        <span class="c1"># String -- add terminal.</span>
        <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;&#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">_TERMINAL_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unterminated string&quot;</span><span class="p">)</span>
            <span class="n">rhsides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c1"># Vertical bar -- start new rhside.</span>
        <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;|&quot;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">_DISJUNCTION_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="n">rhsides</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c1"># Anything else -- nonterminal.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nonterm</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">nonterm_parser</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="n">rhsides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonterm</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">probabilistic</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">ProbabilisticProduction</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="n">probability</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">probability</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rhsides</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Production</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhsides</span><span class="p">]</span>


<span class="c1">#################################################################</span>
<span class="c1"># Reading Phrase Structure Grammars</span>
<span class="c1">#################################################################</span>


<div class="viewcode-block" id="read_grammar"><a class="viewcode-back" href="../../api/nltk.grammar.read_grammar.html#nltk.grammar.read_grammar">[docs]</a><span class="k">def</span> <span class="nf">read_grammar</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">nonterm_parser</span><span class="p">,</span> <span class="n">probabilistic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a pair consisting of a starting category and a list of</span>
<span class="sd">    ``Productions``.</span>

<span class="sd">    :param input: a grammar, either in the form of a string or else</span>
<span class="sd">        as a list of strings.</span>
<span class="sd">    :param nonterm_parser: a function for parsing nonterminals.</span>
<span class="sd">        It should take a ``(string, position)`` as argument and</span>
<span class="sd">        return a ``(nonterminal, position)`` as result.</span>
<span class="sd">    :param probabilistic: are the grammar rules probabilistic?</span>
<span class="sd">    :type probabilistic: bool</span>
<span class="sd">    :param encoding: the encoding of the grammar, if it is a binary string</span>
<span class="sd">    :type encoding: str</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">encoding</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="nb">input</span>

    <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">productions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">continue_line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">linenum</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">continue_line</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">):</span>
            <span class="n">continue_line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span>
            <span class="k">continue</span>
        <span class="n">continue_line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;%&quot;</span><span class="p">:</span>
                <span class="n">directive</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">directive</span> <span class="o">==</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span>
                    <span class="n">start</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">nonterm_parser</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad argument to start directive&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad directive&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># expand out the disjunctions on the RHS</span>
                <span class="n">productions</span> <span class="o">+=</span> <span class="n">_read_production</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">nonterm_parser</span><span class="p">,</span> <span class="n">probabilistic</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to parse line </span><span class="si">{</span><span class="n">linenum</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">productions</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No productions found!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">start</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">productions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">productions</span><span class="p">)</span></div>


<span class="n">_STANDARD_NONTERM_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;( [\w/][\w/^&lt;&gt;-]* ) \s*&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">standard_nonterm_parser</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">_STANDARD_NONTERM_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected a nonterminal, found: &quot;</span> <span class="o">+</span> <span class="n">string</span><span class="p">[</span><span class="n">pos</span><span class="p">:])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Nonterminal</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>


<span class="c1">#################################################################</span>
<span class="c1"># Reading Dependency Grammars</span>
<span class="c1">#################################################################</span>

<span class="n">_READ_DG_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;^\s*                # leading whitespace</span>
<span class="sd">                              (&#39;[^&#39;]+&#39;)\s*        # single-quoted lhs</span>
<span class="sd">                              (?:[-=]+&gt;)\s*        # arrow</span>
<span class="sd">                              (?:(                 # rhs:</span>
<span class="sd">                                   &quot;[^&quot;]+&quot;         # doubled-quoted terminal</span>
<span class="sd">                                 | &#39;[^&#39;]+&#39;         # single-quoted terminal</span>
<span class="sd">                                 | \|              # disjunction</span>
<span class="sd">                                 )</span>
<span class="sd">                                 \s*)              # trailing space</span>
<span class="sd">                                 *$&quot;&quot;&quot;</span><span class="p">,</span>  <span class="c1"># zero or more copies</span>
    <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">_SPLIT_DG_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;(&#39;[^&#39;]&#39;|[-=]+&gt;|&quot;[^&quot;]+&quot;|&#39;[^&#39;]+&#39;|\|)&quot;&quot;&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_read_dependency_production</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_READ_DG_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad production string&quot;</span><span class="p">)</span>
    <span class="n">pieces</span> <span class="o">=</span> <span class="n">_SPLIT_DG_RE</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">pieces</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pieces</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">lhside</span> <span class="o">=</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">rhsides</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">pieces</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">piece</span> <span class="o">==</span> <span class="s2">&quot;|&quot;</span><span class="p">:</span>
            <span class="n">rhsides</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rhsides</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">DependencyProduction</span><span class="p">(</span><span class="n">lhside</span><span class="p">,</span> <span class="n">rhside</span><span class="p">)</span> <span class="k">for</span> <span class="n">rhside</span> <span class="ow">in</span> <span class="n">rhsides</span><span class="p">]</span>


<span class="c1">#################################################################</span>
<span class="c1"># Demonstration</span>
<span class="c1">#################################################################</span>


<span class="k">def</span> <span class="nf">cfg_demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration showing how ``CFGs`` can be created and used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">CFG</span><span class="p">,</span> <span class="n">Production</span><span class="p">,</span> <span class="n">nonterminals</span>

    <span class="c1"># Create some nonterminals</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">NP</span><span class="p">,</span> <span class="n">VP</span><span class="p">,</span> <span class="n">PP</span> <span class="o">=</span> <span class="n">nonterminals</span><span class="p">(</span><span class="s2">&quot;S, NP, VP, PP&quot;</span><span class="p">)</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Det</span> <span class="o">=</span> <span class="n">nonterminals</span><span class="p">(</span><span class="s2">&quot;N, V, P, Det&quot;</span><span class="p">)</span>
    <span class="n">VP_slash_NP</span> <span class="o">=</span> <span class="n">VP</span> <span class="o">/</span> <span class="n">NP</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Some nonterminals:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="n">NP</span><span class="p">,</span> <span class="n">VP</span><span class="p">,</span> <span class="n">PP</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Det</span><span class="p">,</span> <span class="n">VP</span> <span class="o">/</span> <span class="n">NP</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    S.symbol() =&gt;&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">symbol</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="n">NP</span><span class="p">]))</span>

    <span class="c1"># Create some Grammar Productions</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">CFG</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      S -&gt; NP VP</span>
<span class="sd">      PP -&gt; P NP</span>
<span class="sd">      NP -&gt; Det N | NP PP</span>
<span class="sd">      VP -&gt; V NP | VP PP</span>
<span class="sd">      Det -&gt; &#39;a&#39; | &#39;the&#39;</span>
<span class="sd">      N -&gt; &#39;dog&#39; | &#39;cat&#39;</span>
<span class="sd">      V -&gt; &#39;chased&#39; | &#39;sat&#39;</span>
<span class="sd">      P -&gt; &#39;on&#39; | &#39;in&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A Grammar:&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">grammar</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    grammar.start()       =&gt;&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    grammar.productions() =&gt;&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="c1"># Use string.replace(...) is to line-wrap the output.</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">25</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">pcfg_demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration showing how a ``PCFG`` can be created and used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">induce_pcfg</span><span class="p">,</span> <span class="n">treetransforms</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">treebank</span>
    <span class="kn">from</span> <span class="nn">nltk.parse</span> <span class="kn">import</span> <span class="n">pchart</span>

    <span class="n">toy_pcfg1</span> <span class="o">=</span> <span class="n">PCFG</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        S -&gt; NP VP [1.0]</span>
<span class="sd">        NP -&gt; Det N [0.5] | NP PP [0.25] | &#39;John&#39; [0.1] | &#39;I&#39; [0.15]</span>
<span class="sd">        Det -&gt; &#39;the&#39; [0.8] | &#39;my&#39; [0.2]</span>
<span class="sd">        N -&gt; &#39;man&#39; [0.5] | &#39;telescope&#39; [0.5]</span>
<span class="sd">        VP -&gt; VP PP [0.1] | V NP [0.7] | V [0.2]</span>
<span class="sd">        V -&gt; &#39;ate&#39; [0.35] | &#39;saw&#39; [0.65]</span>
<span class="sd">        PP -&gt; P NP [1.0]</span>
<span class="sd">        P -&gt; &#39;with&#39; [0.61] | &#39;under&#39; [0.39]</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="n">toy_pcfg2</span> <span class="o">=</span> <span class="n">PCFG</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        S    -&gt; NP VP         [1.0]</span>
<span class="sd">        VP   -&gt; V NP          [.59]</span>
<span class="sd">        VP   -&gt; V             [.40]</span>
<span class="sd">        VP   -&gt; VP PP         [.01]</span>
<span class="sd">        NP   -&gt; Det N         [.41]</span>
<span class="sd">        NP   -&gt; Name          [.28]</span>
<span class="sd">        NP   -&gt; NP PP         [.31]</span>
<span class="sd">        PP   -&gt; P NP          [1.0]</span>
<span class="sd">        V    -&gt; &#39;saw&#39;         [.21]</span>
<span class="sd">        V    -&gt; &#39;ate&#39;         [.51]</span>
<span class="sd">        V    -&gt; &#39;ran&#39;         [.28]</span>
<span class="sd">        N    -&gt; &#39;boy&#39;         [.11]</span>
<span class="sd">        N    -&gt; &#39;cookie&#39;      [.12]</span>
<span class="sd">        N    -&gt; &#39;table&#39;       [.13]</span>
<span class="sd">        N    -&gt; &#39;telescope&#39;   [.14]</span>
<span class="sd">        N    -&gt; &#39;hill&#39;        [.5]</span>
<span class="sd">        Name -&gt; &#39;Jack&#39;        [.52]</span>
<span class="sd">        Name -&gt; &#39;Bob&#39;         [.48]</span>
<span class="sd">        P    -&gt; &#39;with&#39;        [.61]</span>
<span class="sd">        P    -&gt; &#39;under&#39;       [.39]</span>
<span class="sd">        Det  -&gt; &#39;the&#39;         [.41]</span>
<span class="sd">        Det  -&gt; &#39;a&#39;           [.31]</span>
<span class="sd">        Det  -&gt; &#39;my&#39;          [.28]</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="n">pcfg_prods</span> <span class="o">=</span> <span class="n">toy_pcfg1</span><span class="o">.</span><span class="n">productions</span><span class="p">()</span>

    <span class="n">pcfg_prod</span> <span class="o">=</span> <span class="n">pcfg_prods</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A PCFG production:&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">pcfg_prod</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    pcfg_prod.lhs()  =&gt;&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">pcfg_prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    pcfg_prod.rhs()  =&gt;&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">pcfg_prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    pcfg_prod.prob() =&gt;&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">pcfg_prod</span><span class="o">.</span><span class="n">prob</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="n">grammar</span> <span class="o">=</span> <span class="n">toy_pcfg2</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A PCFG grammar:&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">grammar</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    grammar.start()       =&gt;&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    grammar.productions() =&gt;&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="c1"># Use .replace(...) is to line-wrap the output.</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">26</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># extract productions from three trees and induce the PCFG</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Induce PCFG grammar from treebank data:&quot;</span><span class="p">)</span>

    <span class="n">productions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">treebank</span><span class="o">.</span><span class="n">_fileids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">treebank</span><span class="o">.</span><span class="n">parsed_sents</span><span class="p">(</span><span class="n">item</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]:</span>
        <span class="c1"># perform optional tree transformations, e.g.:</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">collapse_unary</span><span class="p">(</span><span class="n">collapsePOS</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">chomsky_normal_form</span><span class="p">(</span><span class="n">horzMarkov</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">productions</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">.</span><span class="n">productions</span><span class="p">()</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">Nonterminal</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">induce_pcfg</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">productions</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parse sentence using induced grammar:&quot;</span><span class="p">)</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">pchart</span><span class="o">.</span><span class="n">InsideChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># doesn&#39;t work as tokens are different:</span>
    <span class="c1"># sent = treebank.tokenized(&#39;wsj_0001.mrg&#39;)[0]</span>

    <span class="n">sent</span> <span class="o">=</span> <span class="n">treebank</span><span class="o">.</span><span class="n">parsed_sents</span><span class="p">(</span><span class="n">item</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">leaves</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">parse</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sent</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">parse</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fcfg_demo</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">nltk.data</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;grammars/book_grammars/feat0.fcfg&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">dg_demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration showing the creation and inspection of a</span>
<span class="sd">    ``DependencyGrammar``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">DependencyGrammar</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &#39;scratch&#39; -&gt; &#39;cats&#39; | &#39;walls&#39;</span>
<span class="sd">    &#39;walls&#39; -&gt; &#39;the&#39;</span>
<span class="sd">    &#39;cats&#39; -&gt; &#39;the&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sdg_demo</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration of how to read a string representation of</span>
<span class="sd">    a CoNLL format dependency tree.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">nltk.parse</span> <span class="kn">import</span> <span class="n">DependencyGraph</span>

    <span class="n">dg</span> <span class="o">=</span> <span class="n">DependencyGraph</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    1   Ze                ze                Pron  Pron  per|3|evofmv|nom                 2   su      _  _</span>
<span class="sd">    2   had               heb               V     V     trans|ovt|1of2of3|ev             0   ROOT    _  _</span>
<span class="sd">    3   met               met               Prep  Prep  voor                             8   mod     _  _</span>
<span class="sd">    4   haar              haar              Pron  Pron  bez|3|ev|neut|attr               5   det     _  _</span>
<span class="sd">    5   moeder            moeder            N     N     soort|ev|neut                    3   obj1    _  _</span>
<span class="sd">    6   kunnen            kan               V     V     hulp|ott|1of2of3|mv              2   vc      _  _</span>
<span class="sd">    7   gaan              ga                V     V     hulp|inf                         6   vc      _  _</span>
<span class="sd">    8   winkelen          winkel            V     V     intrans|inf                      11  cnj     _  _</span>
<span class="sd">    9   ,                 ,                 Punc  Punc  komma                            8   punct   _  _</span>
<span class="sd">    10  zwemmen           zwem              V     V     intrans|inf                      11  cnj     _  _</span>
<span class="sd">    11  of                of                Conj  Conj  neven                            7   vc      _  _</span>
<span class="sd">    12  terrassen         terras            N     N     soort|mv|neut                    11  cnj     _  _</span>
<span class="sd">    13  .                 .                 Punc  Punc  punt                             12  punct   _  _</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">tree</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">pprint</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="n">cfg_demo</span><span class="p">()</span>
    <span class="n">pcfg_demo</span><span class="p">()</span>
    <span class="n">fcfg_demo</span><span class="p">()</span>
    <span class="n">dg_demo</span><span class="p">()</span>
    <span class="n">sdg_demo</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Nonterminal&quot;</span><span class="p">,</span>
    <span class="s2">&quot;nonterminals&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CFG&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Production&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PCFG&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ProbabilisticProduction&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DependencyGrammar&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DependencyProduction&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ProbabilisticDependencyGrammar&quot;</span><span class="p">,</span>
    <span class="s2">&quot;induce_pcfg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read_grammar&quot;</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>