<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.tag.tnt</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.tag.tnt</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: TnT Tagger</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Sam Huston &lt;sjh900@gmail.com&gt;</span>
<span class="c1">#</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implementation of &#39;TnT - A Statisical Part of Speech Tagger&#39;</span>
<span class="sd">by Thorsten Brants</span>

<span class="sd">https://aclanthology.org/A00-1031.pdf</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">ConditionalFreqDist</span><span class="p">,</span> <span class="n">FreqDist</span>
<span class="kn">from</span> <span class="nn">nltk.tag.api</span> <span class="kn">import</span> <span class="n">TaggerI</span>


<div class="viewcode-block" id="TnT"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.TnT">[docs]</a><span class="k">class</span> <span class="nc">TnT</span><span class="p">(</span><span class="n">TaggerI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TnT - Statistical POS tagger</span>

<span class="sd">    IMPORTANT NOTES:</span>

<span class="sd">    * DOES NOT AUTOMATICALLY DEAL WITH UNSEEN WORDS</span>

<span class="sd">      - It is possible to provide an untrained POS tagger to</span>
<span class="sd">        create tags for unknown words, see __init__ function</span>

<span class="sd">    * SHOULD BE USED WITH SENTENCE-DELIMITED INPUT</span>

<span class="sd">      - Due to the nature of this tagger, it works best when</span>
<span class="sd">        trained over sentence delimited input.</span>
<span class="sd">      - However it still produces good results if the training</span>
<span class="sd">        data and testing data are separated on all punctuation eg: [,.?!]</span>
<span class="sd">      - Input for training is expected to be a list of sentences</span>
<span class="sd">        where each sentence is a list of (word, tag) tuples</span>
<span class="sd">      - Input for tag function is a single sentence</span>
<span class="sd">        Input for tagdata function is a list of sentences</span>
<span class="sd">        Output is of a similar form</span>

<span class="sd">    * Function provided to process text that is unsegmented</span>

<span class="sd">      - Please see basic_sent_chop()</span>


<span class="sd">    TnT uses a second order Markov model to produce tags for</span>
<span class="sd">    a sequence of input, specifically:</span>

<span class="sd">      argmax [Proj(P(t_i|t_i-1,t_i-2)P(w_i|t_i))] P(t_T+1 | t_T)</span>

<span class="sd">    IE: the maximum projection of a set of probabilities</span>

<span class="sd">    The set of possible tags for a given word is derived</span>
<span class="sd">    from the training data. It is the set of all tags</span>
<span class="sd">    that exact word has been assigned.</span>

<span class="sd">    To speed up and get more precision, we can use log addition</span>
<span class="sd">    to instead multiplication, specifically:</span>

<span class="sd">      argmax [Sigma(log(P(t_i|t_i-1,t_i-2))+log(P(w_i|t_i)))] +</span>
<span class="sd">             log(P(t_T+1|t_T))</span>

<span class="sd">    The probability of a tag for a given word is the linear</span>
<span class="sd">    interpolation of 3 markov models; a zero-order, first-order,</span>
<span class="sd">    and a second order model.</span>

<span class="sd">      P(t_i| t_i-1, t_i-2) = l1*P(t_i) + l2*P(t_i| t_i-1) +</span>
<span class="sd">                             l3*P(t_i| t_i-1, t_i-2)</span>

<span class="sd">    A beam search is used to limit the memory usage of the algorithm.</span>
<span class="sd">    The degree of the beam can be changed using N in the initialization.</span>
<span class="sd">    N represents the maximum number of possible solutions to maintain</span>
<span class="sd">    while tagging.</span>

<span class="sd">    It is possible to differentiate the tags which are assigned to</span>
<span class="sd">    capitalized words. However this does not result in a significant</span>
<span class="sd">    gain in the accuracy of the results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TnT.__init__"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.TnT.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Trained</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a TnT statistical tagger. Tagger must be trained</span>
<span class="sd">        before being used to tag input.</span>

<span class="sd">        :param unk: instance of a POS tagger, conforms to TaggerI</span>
<span class="sd">        :type  unk: TaggerI</span>
<span class="sd">        :param Trained: Indication that the POS tagger is trained or not</span>
<span class="sd">        :type  Trained: bool</span>
<span class="sd">        :param N: Beam search degree (see above)</span>
<span class="sd">        :type  N: int</span>
<span class="sd">        :param C: Capitalization flag</span>
<span class="sd">        :type  C: bool</span>

<span class="sd">        Initializer, creates frequency distributions to be used</span>
<span class="sd">        for tagging</span>

<span class="sd">        _lx values represent the portion of the tri/bi/uni taggers</span>
<span class="sd">        to be used to calculate the probability</span>

<span class="sd">        N value is the number of possible solutions to maintain</span>
<span class="sd">        while tagging. A good value for this is 1000</span>

<span class="sd">        C is a boolean value which specifies to use or</span>
<span class="sd">        not use the Capitalization of the word as additional</span>
<span class="sd">        information for tagging.</span>
<span class="sd">        NOTE: using capitalization may not increase the accuracy</span>
<span class="sd">        of the tagger</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bi</span> <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span> <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span> <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eos</span> <span class="o">=</span> <span class="n">ConditionalFreqDist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l3</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_C</span> <span class="o">=</span> <span class="n">C</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">=</span> <span class="n">Trained</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span> <span class="o">=</span> <span class="n">unk</span>

        <span class="c1"># statistical tools (ignore or delete me)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="TnT.train"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.TnT.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses a set of tagged data to train the tagger.</span>
<span class="sd">        If an unknown word tagger is specified,</span>
<span class="sd">        it is trained on the same data.</span>

<span class="sd">        :param data: List of lists of (word, tag) tuples</span>
<span class="sd">        :type data: tuple(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that local C flag is initialized before use</span>
        <span class="n">C</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_T</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">history</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;BOS&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;BOS&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sent</span><span class="p">:</span>

                <span class="c1"># if capitalization is requested,</span>
                <span class="c1"># and the word begins with a capital</span>
                <span class="c1"># set local flag C to True</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span> <span class="ow">and</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="n">C</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">history</span><span class="p">[</span><span class="mi">1</span><span class="p">]][(</span><span class="n">t</span><span class="p">,</span> <span class="n">C</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">history</span><span class="p">)][(</span><span class="n">t</span><span class="p">,</span> <span class="n">C</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
                <span class="n">history</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># set local flag C to false for the next word</span>
                <span class="n">C</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_eos</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s2">&quot;EOS&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># compute lambda values from the trained frequency distributions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_lambda</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_compute_lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        creates lambda values based upon training data</span>

<span class="sd">        NOTE: no need to explicitly reference C,</span>
<span class="sd">        it is contained within the tag variable :: tag == (tag,C)</span>

<span class="sd">        for each tag trigram (t1, t2, t3)</span>
<span class="sd">        depending on the maximum value of</span>
<span class="sd">        - f(t1,t2,t3)-1 / f(t1,t2)-1</span>
<span class="sd">        - f(t2,t3)-1 / f(t2)-1</span>
<span class="sd">        - f(t3)-1 / N-1</span>

<span class="sd">        increment l3,l2, or l1 by f(t1,t2,t3)</span>

<span class="sd">        ISSUES -- Resolutions:</span>
<span class="sd">        if 2 values are equal, increment both lambda values</span>
<span class="sd">        by (f(t1,t2,t3) / 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># temporary lambda variables</span>
        <span class="n">tl1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">tl2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">tl3</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># for each t1,t2 in system</span>
        <span class="k">for</span> <span class="n">history</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="o">.</span><span class="n">conditions</span><span class="p">():</span>
            <span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">)</span> <span class="o">=</span> <span class="n">history</span>

            <span class="c1"># for each t3 given t1,t2 in system</span>
            <span class="c1"># (NOTE: tag actually represents (tag,C))</span>
            <span class="c1"># However no effect within this function</span>
            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="c1"># if there has only been 1 occurrence of this tag in the data</span>
                <span class="c1"># then ignore this trigram.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># safe_div provides a safe floating point division</span>
                <span class="c1"># it returns -1 if the denominator is 0</span>
                <span class="n">c3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_div</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_div</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">h2</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">h2</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_div</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="o">.</span><span class="n">N</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

                <span class="c1"># if c1 is the maximum value:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c2</span><span class="p">):</span>
                    <span class="n">tl1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>

                <span class="c1"># if c2 is the maximum value</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c2</span> <span class="o">&gt;</span> <span class="n">c3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c2</span> <span class="o">&gt;</span> <span class="n">c1</span><span class="p">):</span>
                    <span class="n">tl2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>

                <span class="c1"># if c3 is the maximum value</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c3</span> <span class="o">&gt;</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c3</span> <span class="o">&gt;</span> <span class="n">c1</span><span class="p">):</span>
                    <span class="n">tl3</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span>

                <span class="c1"># if c3, and c2 are equal and larger than c1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c3</span> <span class="o">==</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c3</span> <span class="o">&gt;</span> <span class="n">c1</span><span class="p">):</span>
                    <span class="n">tl2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">tl3</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="c1"># if c1, and c2 are equal and larger than c3</span>
                <span class="c1"># this might be a dumb thing to do....(not sure yet)</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">c2</span> <span class="o">==</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c3</span><span class="p">):</span>
                    <span class="n">tl1</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>
                    <span class="n">tl2</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="n">history</span><span class="p">][</span><span class="n">tag</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.0</span>

                <span class="c1"># otherwise there might be a problem</span>
                <span class="c1"># eg: all values = 0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="c1"># Lambda normalisation:</span>
        <span class="c1"># ensures that l1+l2+l3 = 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l1</span> <span class="o">=</span> <span class="n">tl1</span> <span class="o">/</span> <span class="p">(</span><span class="n">tl1</span> <span class="o">+</span> <span class="n">tl2</span> <span class="o">+</span> <span class="n">tl3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l2</span> <span class="o">=</span> <span class="n">tl2</span> <span class="o">/</span> <span class="p">(</span><span class="n">tl1</span> <span class="o">+</span> <span class="n">tl2</span> <span class="o">+</span> <span class="n">tl3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l3</span> <span class="o">=</span> <span class="n">tl3</span> <span class="o">/</span> <span class="p">(</span><span class="n">tl1</span> <span class="o">+</span> <span class="n">tl2</span> <span class="o">+</span> <span class="n">tl3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_safe_div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Safe floating point division function, does not allow division by 0</span>
<span class="sd">        returns -1 if the denominator is 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">v2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>

<div class="viewcode-block" id="TnT.tagdata"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.TnT.tagdata">[docs]</a>    <span class="k">def</span> <span class="nf">tagdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tags each sentence in a list of sentences</span>

<span class="sd">        :param data:list of list of words</span>
<span class="sd">        :type data: [[string,],]</span>
<span class="sd">        :return: list of list of (word, tag) tuples</span>

<span class="sd">        Invokes tag(sent) function for each sentence</span>
<span class="sd">        compiles the results into a list of tagged sentences</span>
<span class="sd">        each tagged sentence is a list of (word, tag) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sent</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="TnT.tag"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.TnT.tag">[docs]</a>    <span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tags a single sentence</span>

<span class="sd">        :param data: list of words</span>
<span class="sd">        :type data: [string,]</span>

<span class="sd">        :return: [(word, tag),]</span>

<span class="sd">        Calls recursive function &#39;_tagword&#39;</span>
<span class="sd">        to produce a list of tags</span>

<span class="sd">        Associates the sequence of returned tags</span>
<span class="sd">        with the correct words in the input sequence</span>

<span class="sd">        returns a list of (word, tag) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">current_state</span> <span class="o">=</span> <span class="p">[([</span><span class="s2">&quot;BOS&quot;</span><span class="p">,</span> <span class="s2">&quot;BOS&quot;</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">)]</span>

        <span class="n">sent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tagword</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">current_state</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)):</span>
            <span class="c1"># unpack and discard the C flags</span>
            <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span> <span class="o">=</span> <span class="n">tags</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sent</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span></div>

    <span class="k">def</span> <span class="nf">_tagword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">current_states</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param sent : List of words remaining in the sentence</span>
<span class="sd">        :type sent  : [word,]</span>
<span class="sd">        :param current_states : List of possible tag combinations for</span>
<span class="sd">                                the sentence so far, and the log probability</span>
<span class="sd">                                associated with each tag combination</span>
<span class="sd">        :type current_states  : [([tag, ], logprob), ]</span>

<span class="sd">        Tags the first word in the sentence and</span>
<span class="sd">        recursively tags the reminder of sentence</span>

<span class="sd">        Uses formula specified above to calculate the probability</span>
<span class="sd">        of a particular tag</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if this word marks the end of the sentence,</span>
        <span class="c1"># return the most probable tag</span>
        <span class="k">if</span> <span class="n">sent</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span> <span class="o">=</span> <span class="n">current_states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">h</span>

        <span class="c1"># otherwise there are more words to be tagged</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">sent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sent</span> <span class="o">=</span> <span class="n">sent</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">new_states</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># if the Capitalisation is requested,</span>
        <span class="c1"># initialise the flag for this word</span>
        <span class="n">C</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C</span> <span class="ow">and</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
            <span class="n">C</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># if word is known</span>
        <span class="c1"># compute the set of possible tags</span>
        <span class="c1"># and their associated log probabilities</span>
        <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">known</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="n">curr_sent_logprob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">current_states</span><span class="p">:</span>
                <span class="n">logprobs</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">tC</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
                    <span class="n">p_uni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="n">tC</span><span class="p">)</span>
                    <span class="n">p_bi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bi</span><span class="p">[</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="n">tC</span><span class="p">)</span>
                    <span class="n">p_tri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tri</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">history</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])]</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="n">tC</span><span class="p">)</span>
                    <span class="n">p_wd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wd</span><span class="p">[</span><span class="n">word</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uni</span><span class="p">[</span><span class="n">tC</span><span class="p">]</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l1</span> <span class="o">*</span> <span class="n">p_uni</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l2</span> <span class="o">*</span> <span class="n">p_bi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l3</span> <span class="o">*</span> <span class="n">p_tri</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">p_wd</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

                    <span class="c1"># compute the result of appending each tag to this history</span>
                    <span class="n">new_states</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">history</span> <span class="o">+</span> <span class="p">[</span><span class="n">tC</span><span class="p">],</span> <span class="n">curr_sent_logprob</span> <span class="o">+</span> <span class="n">p2</span><span class="p">))</span>

        <span class="c1"># otherwise a new word, set of possible tags is unknown</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unknown</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># since a set of possible tags,</span>
            <span class="c1"># and the probability of each specific tag</span>
            <span class="c1"># can not be returned from most classifiers:</span>
            <span class="c1"># specify that any unknown words are tagged with certainty</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># if no unknown word tagger has been specified</span>
            <span class="c1"># then use the tag &#39;Unk&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Unk&quot;</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

            <span class="c1"># otherwise apply the unknown word tagger</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">[(</span><span class="n">_w</span><span class="p">,</span> <span class="n">t</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unk</span><span class="o">.</span><span class="n">tag</span><span class="p">([</span><span class="n">word</span><span class="p">]))</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">history</span><span class="p">,</span> <span class="n">logprob</span><span class="p">)</span> <span class="ow">in</span> <span class="n">current_states</span><span class="p">:</span>
                <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>

            <span class="n">new_states</span> <span class="o">=</span> <span class="n">current_states</span>

        <span class="c1"># now have computed a set of possible new_states</span>

        <span class="c1"># sort states by log prob</span>
        <span class="c1"># set is now ordered greatest to least log probability</span>
        <span class="n">new_states</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># del everything after N (threshold)</span>
        <span class="c1"># this is the beam search cut</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_states</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">:</span>
            <span class="n">new_states</span> <span class="o">=</span> <span class="n">new_states</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">]</span>

        <span class="c1"># compute the tags for the rest of the sentence</span>
        <span class="c1"># return the best list of tags for the sentence</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tagword</span><span class="p">(</span><span class="n">sent</span><span class="p">,</span> <span class="n">new_states</span><span class="p">)</span></div>


<span class="c1">########################################</span>
<span class="c1"># helper function -- basic sentence tokenizer</span>
<span class="c1">########################################</span>


<div class="viewcode-block" id="basic_sent_chop"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.basic_sent_chop">[docs]</a><span class="k">def</span> <span class="nf">basic_sent_chop</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Basic method for tokenizing input into sentences</span>
<span class="sd">    for this tagger:</span>

<span class="sd">    :param data: list of tokens (words or (word, tag) tuples)</span>
<span class="sd">    :type data: str or tuple(str, str)</span>
<span class="sd">    :param raw: boolean flag marking the input data</span>
<span class="sd">                as a list of words or a list of tagged words</span>
<span class="sd">    :type raw: bool</span>
<span class="sd">    :return: list of sentences</span>
<span class="sd">             sentences are a list of tokens</span>
<span class="sd">             tokens are the same as the input</span>

<span class="sd">    Function takes a list of tokens and separates the tokens into lists</span>
<span class="sd">    where each list represents a sentence fragment</span>
<span class="sd">    This function can separate both tagged and raw sequences into</span>
<span class="sd">    basic sentences.</span>

<span class="sd">    Sentence markers are the set of [,.!?]</span>

<span class="sd">    This is a simple method which enhances the performance of the TnT</span>
<span class="sd">    tagger. Better sentence tokenization will further enhance the results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curr_sent</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sent_mark</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">raw</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">sent_mark</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">)</span>
                <span class="n">curr_sent</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">sent_mark</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">word</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span>
                <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_sent</span><span class="p">)</span>
                <span class="n">curr_sent</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curr_sent</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">word</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new_data</span></div>


<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>

    <span class="n">sents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>
    <span class="n">test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">sents</span><span class="p">())</span>

    <span class="n">tagger</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">()</span>
    <span class="n">tagger</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">sents</span><span class="p">[</span><span class="mi">200</span><span class="p">:</span><span class="mi">1000</span><span class="p">])</span>

    <span class="n">tagged_data</span> <span class="o">=</span> <span class="n">tagger</span><span class="o">.</span><span class="n">tagdata</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">120</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tagged_data</span><span class="p">)):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">tagged_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">sents</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">()</span></div>


<div class="viewcode-block" id="demo2"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.demo2">[docs]</a><span class="k">def</span> <span class="nf">demo2</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">treebank</span>

    <span class="n">d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">treebank</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">11</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="p">:])</span>
    <span class="n">s</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">11</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="p">:])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">tacc</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">100</span> <span class="p">:</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)])</span>
        <span class="n">tp_un</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">tp_kn</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Capitalization off:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy:&quot;</span><span class="p">,</span> <span class="n">tacc</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Percentage known:&quot;</span><span class="p">,</span> <span class="n">tp_kn</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Percentage unknown:&quot;</span><span class="p">,</span> <span class="n">tp_un</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy over known words:&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">tacc</span> <span class="o">/</span> <span class="n">tp_kn</span><span class="p">))</span>

        <span class="n">sacc</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">100</span> <span class="p">:</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)])</span>
        <span class="n">sp_un</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">sp_kn</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Capitalization on:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy:&quot;</span><span class="p">,</span> <span class="n">sacc</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Percentage known:&quot;</span><span class="p">,</span> <span class="n">sp_kn</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Percentage unknown:&quot;</span><span class="p">,</span> <span class="n">sp_un</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy over known words:&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">sacc</span> <span class="o">/</span> <span class="n">sp_kn</span><span class="p">))</span></div>


<div class="viewcode-block" id="demo3"><a class="viewcode-back" href="../../../api/nltk.tag.TnT.html#nltk.tag.tnt.demo3">[docs]</a><span class="k">def</span> <span class="nf">demo3</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span><span class="p">,</span> <span class="n">treebank</span>

    <span class="n">d</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">treebank</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>
    <span class="n">e</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">())</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>

    <span class="n">d10</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>
    <span class="n">e10</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span>

    <span class="n">tknacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sknacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tallacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sallacc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tknown</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sknown</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">TnT</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">dtest</span> <span class="o">=</span> <span class="n">d</span><span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">d10</span><span class="p">)</span> <span class="p">:</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d10</span><span class="p">)]</span>
        <span class="n">etest</span> <span class="o">=</span> <span class="n">e</span><span class="p">[(</span><span class="n">i</span> <span class="o">*</span> <span class="n">e10</span><span class="p">)</span> <span class="p">:</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">e10</span><span class="p">)]</span>

        <span class="n">dtrain</span> <span class="o">=</span> <span class="n">d</span><span class="p">[:</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">d10</span><span class="p">)]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d10</span><span class="p">)</span> <span class="p">:]</span>
        <span class="n">etrain</span> <span class="o">=</span> <span class="n">e</span><span class="p">[:</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">e10</span><span class="p">)]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">e10</span><span class="p">)</span> <span class="p">:]</span>

        <span class="n">t</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">dtrain</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">etrain</span><span class="p">)</span>

        <span class="n">tacc</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">dtest</span><span class="p">)</span>
        <span class="n">tp_un</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">tp_kn</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">tknown</span> <span class="o">+=</span> <span class="n">tp_kn</span>
        <span class="n">t</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">t</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">sacc</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accuracy</span><span class="p">(</span><span class="n">etest</span><span class="p">)</span>
        <span class="n">sp_un</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">sp_kn</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">unknown</span><span class="p">)</span>
        <span class="n">sknown</span> <span class="o">+=</span> <span class="n">sp_kn</span>
        <span class="n">s</span><span class="o">.</span><span class="n">unknown</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span><span class="o">.</span><span class="n">known</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">tknacc</span> <span class="o">+=</span> <span class="n">tacc</span> <span class="o">/</span> <span class="n">tp_kn</span>
        <span class="n">sknacc</span> <span class="o">+=</span> <span class="n">sacc</span> <span class="o">/</span> <span class="n">tp_kn</span>
        <span class="n">tallacc</span> <span class="o">+=</span> <span class="n">tacc</span>
        <span class="n">sallacc</span> <span class="o">+=</span> <span class="n">sacc</span>

        <span class="c1"># print(i+1, (tacc / tp_kn), i+1, (sacc / tp_kn), i+1, tacc, i+1, sacc)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;brown: acc over words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tknacc</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     : overall accuracy:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tallacc</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     : words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">tknown</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;treebank: acc over words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sknacc</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;        : overall accuracy:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sallacc</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;        : words known:&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">sknown</span><span class="p">)</span></div>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>