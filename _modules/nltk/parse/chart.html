<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.parse.chart</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.parse.chart</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: A Chart Parser</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1">#         Jean Mark Gawron &lt;gawron@mail.sdsu.edu&gt;</span>
<span class="c1">#         Peter Ljungl√∂f &lt;peter.ljunglof@heatherleaf.se&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data classes and parser implementations for &quot;chart parsers&quot;, which</span>
<span class="sd">use dynamic programming to efficiently parse a text.  A chart</span>
<span class="sd">parser derives parse trees for a text by iteratively adding &quot;edges&quot;</span>
<span class="sd">to a &quot;chart.&quot;  Each edge represents a hypothesis about the tree</span>
<span class="sd">structure for a subsequence of the text.  The chart is a</span>
<span class="sd">&quot;blackboard&quot; for composing and combining these hypotheses.</span>

<span class="sd">When a chart parser begins parsing a text, it creates a new (empty)</span>
<span class="sd">chart, spanning the text.  It then incrementally adds new edges to the</span>
<span class="sd">chart.  A set of &quot;chart rules&quot; specifies the conditions under which</span>
<span class="sd">new edges should be added to the chart.  Once the chart reaches a</span>
<span class="sd">stage where none of the chart rules adds any new edges, parsing is</span>
<span class="sd">complete.</span>

<span class="sd">Charts are encoded with the ``Chart`` class, and edges are encoded with</span>
<span class="sd">the ``TreeEdge`` and ``LeafEdge`` classes.  The chart parser module</span>
<span class="sd">defines three chart parsers:</span>

<span class="sd">  - ``ChartParser`` is a simple and flexible chart parser.  Given a</span>
<span class="sd">    set of chart rules, it will apply those rules to the chart until</span>
<span class="sd">    no more edges are added.</span>

<span class="sd">  - ``SteppingChartParser`` is a subclass of ``ChartParser`` that can</span>
<span class="sd">    be used to step through the parsing process.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>

<span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">PCFG</span><span class="p">,</span> <span class="n">is_nonterminal</span><span class="p">,</span> <span class="n">is_terminal</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">raise_unorderable_types</span>
<span class="kn">from</span> <span class="nn">nltk.parse.api</span> <span class="kn">import</span> <span class="n">ParserI</span>
<span class="kn">from</span> <span class="nn">nltk.tree</span> <span class="kn">import</span> <span class="n">Tree</span>
<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="c1">########################################################################</span>
<span class="c1">##  Edges</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="EdgeI"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI">[docs]</a><span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">EdgeI</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A hypothesis about the structure of part of a sentence.</span>
<span class="sd">    Each edge records the fact that a structure is (partially)</span>
<span class="sd">    consistent with the sentence.  An edge contains:</span>

<span class="sd">    - A span, indicating what part of the sentence is</span>
<span class="sd">      consistent with the hypothesized structure.</span>
<span class="sd">    - A left-hand side, specifying what kind of structure is</span>
<span class="sd">      hypothesized.</span>
<span class="sd">    - A right-hand side, specifying the contents of the</span>
<span class="sd">      hypothesized structure.</span>
<span class="sd">    - A dot position, indicating how much of the hypothesized</span>
<span class="sd">      structure is consistent with the sentence.</span>

<span class="sd">    Every edge is either complete or incomplete:</span>

<span class="sd">    - An edge is complete if its structure is fully consistent</span>
<span class="sd">      with the sentence.</span>
<span class="sd">    - An edge is incomplete if its structure is partially</span>
<span class="sd">      consistent with the sentence.  For every incomplete edge, the</span>
<span class="sd">      span specifies a possible prefix for the edge&#39;s structure.</span>

<span class="sd">    There are two kinds of edge:</span>

<span class="sd">    - A ``TreeEdge`` records which trees have been found to</span>
<span class="sd">      be (partially) consistent with the text.</span>
<span class="sd">    - A ``LeafEdge`` records the tokens occurring in the text.</span>

<span class="sd">    The ``EdgeI`` interface provides a common interface to both types</span>
<span class="sd">    of edge, allowing chart parsers to treat them in a uniform manner.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="EdgeI.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">EdgeI</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Edge is an abstract interface&quot;</span><span class="p">)</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Span</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="EdgeI.span"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple ``(s, e)``, where ``tokens[s:e]`` is the</span>
<span class="sd">        portion of the sentence that is consistent with this</span>
<span class="sd">        edge&#39;s structure.</span>

<span class="sd">        :rtype: tuple(int, int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeI.start"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the start index of this edge&#39;s span.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeI.end"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the end index of this edge&#39;s span.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeI.length"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the length of this edge&#39;s span.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Left Hand Side</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="EdgeI.lhs"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.lhs">[docs]</a>    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this edge&#39;s left-hand side, which specifies what kind</span>
<span class="sd">        of structure is hypothesized by this edge.</span>

<span class="sd">        :see: ``TreeEdge`` and ``LeafEdge`` for a description of</span>
<span class="sd">            the left-hand side values for each edge type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Right Hand Side</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="EdgeI.rhs"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.rhs">[docs]</a>    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this edge&#39;s right-hand side, which specifies</span>
<span class="sd">        the content of the structure hypothesized by this edge.</span>

<span class="sd">        :see: ``TreeEdge`` and ``LeafEdge`` for a description of</span>
<span class="sd">            the right-hand side values for each edge type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeI.dot"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return this edge&#39;s dot position, which indicates how much of</span>
<span class="sd">        the hypothesized structure is consistent with the</span>
<span class="sd">        sentence.  In particular, ``self.rhs[:dot]`` is consistent</span>
<span class="sd">        with ``tokens[self.start():self.end()]``.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeI.nextsym"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.nextsym">[docs]</a>    <span class="k">def</span> <span class="nf">nextsym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the element of this edge&#39;s right-hand side that</span>
<span class="sd">        immediately follows its dot.</span>

<span class="sd">        :rtype: Nonterminal or terminal or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeI.is_complete"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this edge&#39;s structure is fully consistent</span>
<span class="sd">        with the text.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="EdgeI.is_incomplete"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EdgeI.is_incomplete">[docs]</a>    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if this edge&#39;s structure is partially consistent</span>
<span class="sd">        with the text.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Comparisons &amp; hashing</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_comparison_key</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">EdgeI</span><span class="p">):</span>
            <span class="n">raise_unorderable_types</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_comparison_key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span></div>


<div class="viewcode-block" id="TreeEdge"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge">[docs]</a><span class="k">class</span> <span class="nc">TreeEdge</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An edge that records the fact that a tree is (partially)</span>
<span class="sd">    consistent with the sentence.  A tree edge consists of:</span>

<span class="sd">    - A span, indicating what part of the sentence is</span>
<span class="sd">      consistent with the hypothesized tree.</span>
<span class="sd">    - A left-hand side, specifying the hypothesized tree&#39;s node</span>
<span class="sd">      value.</span>
<span class="sd">    - A right-hand side, specifying the hypothesized tree&#39;s</span>
<span class="sd">      children.  Each element of the right-hand side is either a</span>
<span class="sd">      terminal, specifying a token with that terminal as its leaf</span>
<span class="sd">      value; or a nonterminal, specifying a subtree with that</span>
<span class="sd">      nonterminal&#39;s symbol as its node value.</span>
<span class="sd">    - A dot position, indicating which children are consistent</span>
<span class="sd">      with part of the sentence.  In particular, if ``dot`` is the</span>
<span class="sd">      dot position, ``rhs`` is the right-hand size, ``(start,end)``</span>
<span class="sd">      is the span, and ``sentence`` is the list of tokens in the</span>
<span class="sd">      sentence, then ``tokens[start:end]`` can be spanned by the</span>
<span class="sd">      children specified by ``rhs[:dot]``.</span>

<span class="sd">    For more information about edges, see the ``EdgeI`` interface.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TreeEdge.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new ``TreeEdge``.</span>

<span class="sd">        :type span: tuple(int, int)</span>
<span class="sd">        :param span: A tuple ``(s, e)``, where ``tokens[s:e]`` is the</span>
<span class="sd">            portion of the sentence that is consistent with the new</span>
<span class="sd">            edge&#39;s structure.</span>
<span class="sd">        :type lhs: Nonterminal</span>
<span class="sd">        :param lhs: The new edge&#39;s left-hand side, specifying the</span>
<span class="sd">            hypothesized tree&#39;s node value.</span>
<span class="sd">        :type rhs: list(Nonterminal and str)</span>
<span class="sd">        :param rhs: The new edge&#39;s right-hand side, specifying the</span>
<span class="sd">            hypothesized tree&#39;s children.</span>
<span class="sd">        :type dot: int</span>
<span class="sd">        :param dot: The position of the new edge&#39;s dot.  This position</span>
<span class="sd">            specifies what prefix of the production&#39;s right hand side</span>
<span class="sd">            is consistent with the text.  In particular, if</span>
<span class="sd">            ``sentence`` is the list of tokens in the sentence, then</span>
<span class="sd">            ``okens[span[0]:span[1]]`` can be spanned by the</span>
<span class="sd">            children specified by ``rhs[:dot]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_span</span> <span class="o">=</span> <span class="n">span</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">=</span> <span class="n">dot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeEdge.from_production"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.from_production">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_production</span><span class="p">(</span><span class="n">production</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TreeEdge`` formed from the given production.</span>
<span class="sd">        The new edge&#39;s left-hand side and right-hand side will</span>
<span class="sd">        be taken from ``production``; its span will be</span>
<span class="sd">        ``(index,index)``; and its dot position will be ``0``.</span>

<span class="sd">        :rtype: TreeEdge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TreeEdge</span><span class="p">(</span>
            <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">lhs</span><span class="o">=</span><span class="n">production</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">rhs</span><span class="o">=</span><span class="n">production</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TreeEdge.move_dot_forward"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.move_dot_forward">[docs]</a>    <span class="k">def</span> <span class="nf">move_dot_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new ``TreeEdge`` formed from this edge.</span>
<span class="sd">        The new edge&#39;s dot position is increased by ``1``,</span>
<span class="sd">        and its end index will be replaced by ``new_end``.</span>

<span class="sd">        :param new_end: The new end index.</span>
<span class="sd">        :type new_end: int</span>
<span class="sd">        :rtype: TreeEdge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TreeEdge</span><span class="p">(</span>
            <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_end</span><span class="p">),</span>
            <span class="n">lhs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,</span>
            <span class="n">rhs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">,</span>
            <span class="n">dot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="c1"># Accessors</span>
<div class="viewcode-block" id="TreeEdge.lhs"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.lhs">[docs]</a>    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span></div>

<div class="viewcode-block" id="TreeEdge.span"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span></div>

<div class="viewcode-block" id="TreeEdge.start"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TreeEdge.end"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TreeEdge.length"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TreeEdge.rhs"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.rhs">[docs]</a>    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span></div>

<div class="viewcode-block" id="TreeEdge.dot"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span></div>

<div class="viewcode-block" id="TreeEdge.is_complete"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeEdge.is_incomplete"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.is_incomplete">[docs]</a>    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span></div>

<div class="viewcode-block" id="TreeEdge.nextsym"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TreeEdge.nextsym">[docs]</a>    <span class="k">def</span> <span class="nf">nextsym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">]</span></div>

    <span class="c1"># String representation</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_span</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">] &quot;</span>
        <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%-2r</span><span class="s2"> -&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lhs</span><span class="p">,)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">:</span>
                <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot; *&quot;</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rhs</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dot</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot; *&quot;</span>
        <span class="k">return</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[Edge: </span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="LeafEdge"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge">[docs]</a><span class="k">class</span> <span class="nc">LeafEdge</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An edge that records the fact that a leaf value is consistent with</span>
<span class="sd">    a word in the sentence.  A leaf edge consists of:</span>

<span class="sd">    - An index, indicating the position of the word.</span>
<span class="sd">    - A leaf, specifying the word&#39;s content.</span>

<span class="sd">    A leaf edge&#39;s left-hand side is its leaf value, and its right hand</span>
<span class="sd">    side is ``()``.  Its span is ``[index, index+1]``, and its dot</span>
<span class="sd">    position is ``0``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeafEdge.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new ``LeafEdge``.</span>

<span class="sd">        :param leaf: The new edge&#39;s leaf value, specifying the word</span>
<span class="sd">            that is recorded by this edge.</span>
<span class="sd">        :param index: The new edge&#39;s index, specifying the position of</span>
<span class="sd">            the word that is recorded by this edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span> <span class="o">=</span> <span class="n">leaf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span></div>

    <span class="c1"># Accessors</span>
<div class="viewcode-block" id="LeafEdge.lhs"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.lhs">[docs]</a>    <span class="k">def</span> <span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span></div>

<div class="viewcode-block" id="LeafEdge.span"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.span">[docs]</a>    <span class="k">def</span> <span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="LeafEdge.start"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span></div>

<div class="viewcode-block" id="LeafEdge.end"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="LeafEdge.length"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="LeafEdge.rhs"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.rhs">[docs]</a>    <span class="k">def</span> <span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">()</span></div>

<div class="viewcode-block" id="LeafEdge.dot"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.dot">[docs]</a>    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="LeafEdge.is_complete"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.is_complete">[docs]</a>    <span class="k">def</span> <span class="nf">is_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="LeafEdge.is_incomplete"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.is_incomplete">[docs]</a>    <span class="k">def</span> <span class="nf">is_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="LeafEdge.nextsym"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafEdge.nextsym">[docs]</a>    <span class="k">def</span> <span class="nf">nextsym</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="c1"># String representations</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_leaf</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;[Edge: </span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<span class="c1">########################################################################</span>
<span class="c1">##  Chart</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="Chart"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart">[docs]</a><span class="k">class</span> <span class="nc">Chart</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A blackboard for hypotheses about the syntactic constituents of a</span>
<span class="sd">    sentence.  A chart contains a set of edges, and each edge encodes</span>
<span class="sd">    a single hypothesis about the structure of some portion of the</span>
<span class="sd">    sentence.</span>

<span class="sd">    The ``select`` method can be used to select a specific collection</span>
<span class="sd">    of edges.  For example ``chart.select(is_complete=True, start=0)``</span>
<span class="sd">    yields all complete edges whose start indices are 0.  To ensure</span>
<span class="sd">    the efficiency of these selection operations, ``Chart`` dynamically</span>
<span class="sd">    creates and maintains an index for each set of attributes that</span>
<span class="sd">    have been selected on.</span>

<span class="sd">    In order to reconstruct the trees that are represented by an edge,</span>
<span class="sd">    the chart associates each edge with a set of child pointer lists.</span>
<span class="sd">    A child pointer list is a list of the edges that license an</span>
<span class="sd">    edge&#39;s right-hand side.</span>

<span class="sd">    :ivar _tokens: The sentence that the chart covers.</span>
<span class="sd">    :ivar _num_leaves: The number of tokens.</span>
<span class="sd">    :ivar _edges: A list of the edges in the chart</span>
<span class="sd">    :ivar _edge_to_cpls: A dictionary mapping each edge to a set</span>
<span class="sd">        of child pointer lists that are associated with that edge.</span>
<span class="sd">    :ivar _indexes: A dictionary mapping tuples of edge attributes</span>
<span class="sd">        to indices, where each index maps the corresponding edge</span>
<span class="sd">        attribute values to lists of edges.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Chart.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new chart. The chart is initialized with the</span>
<span class="sd">        leaf edges corresponding to the terminal leaves.</span>

<span class="sd">        :type tokens: list</span>
<span class="sd">        :param tokens: The sentence that this chart will be used to parse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Record the sentence token and the sentence length.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">)</span>

        <span class="c1"># Initialise the chart.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span></div>

<div class="viewcode-block" id="Chart.initialize"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A list of edges contained in this chart.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The set of child pointer lists associated with each edge.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Indexes mapping attribute values to lists of edges</span>
        <span class="c1"># (used by select()).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span> <span class="o">=</span> <span class="p">{}</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Sentence Access</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Chart.num_leaves"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.num_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">num_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of words in this chart&#39;s sentence.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span></div>

<div class="viewcode-block" id="Chart.leaf"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.leaf">[docs]</a>    <span class="k">def</span> <span class="nf">leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the leaf value of the word at the given index.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>

<div class="viewcode-block" id="Chart.leaves"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.leaves">[docs]</a>    <span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the leaf values of each word in the</span>
<span class="sd">        chart&#39;s sentence.</span>

<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Edge access</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Chart.edges"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all edges in this chart.  New edges</span>
<span class="sd">        that are added to the chart after the call to edges()</span>
<span class="sd">        will *not* be contained in this list.</span>

<span class="sd">        :rtype: list(EdgeI)</span>
<span class="sd">        :see: ``iteredges``, ``select``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[:]</span></div>

<div class="viewcode-block" id="Chart.iteredges"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.iteredges">[docs]</a>    <span class="k">def</span> <span class="nf">iteredges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the edges in this chart.  It is</span>
<span class="sd">        not guaranteed that new edges which are added to the</span>
<span class="sd">        chart before the iterator is exhausted will also be generated.</span>

<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        :see: ``edges``, ``select``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">)</span></div>

    <span class="c1"># Iterating over the chart yields its edges.</span>
    <span class="fm">__iter__</span> <span class="o">=</span> <span class="n">iteredges</span>

<div class="viewcode-block" id="Chart.num_edges"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.num_edges">[docs]</a>    <span class="k">def</span> <span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of edges contained in this chart.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="p">)</span></div>

<div class="viewcode-block" id="Chart.select"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">restrictions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the edges in this chart.  Any</span>
<span class="sd">        new edges that are added to the chart before the iterator</span>
<span class="sd">        is exahusted will also be generated.  ``restrictions``</span>
<span class="sd">        can be used to restrict the set of edges that will be</span>
<span class="sd">        generated.</span>

<span class="sd">        :param span: Only generate edges ``e`` where ``e.span()==span``</span>
<span class="sd">        :param start: Only generate edges ``e`` where ``e.start()==start``</span>
<span class="sd">        :param end: Only generate edges ``e`` where ``e.end()==end``</span>
<span class="sd">        :param length: Only generate edges ``e`` where ``e.length()==length``</span>
<span class="sd">        :param lhs: Only generate edges ``e`` where ``e.lhs()==lhs``</span>
<span class="sd">        :param rhs: Only generate edges ``e`` where ``e.rhs()==rhs``</span>
<span class="sd">        :param nextsym: Only generate edges ``e`` where</span>
<span class="sd">            ``e.nextsym()==nextsym``</span>
<span class="sd">        :param dot: Only generate edges ``e`` where ``e.dot()==dot``</span>
<span class="sd">        :param is_complete: Only generate edges ``e`` where</span>
<span class="sd">            ``e.is_complete()==is_complete``</span>
<span class="sd">        :param is_incomplete: Only generate edges ``e`` where</span>
<span class="sd">            ``e.is_incomplete()==is_incomplete``</span>
<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If there are no restrictions, then return all edges.</span>
        <span class="k">if</span> <span class="n">restrictions</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">)</span>

        <span class="c1"># Find the index corresponding to the given restrictions.</span>
        <span class="n">restr_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">restrictions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">restr_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">restr_keys</span><span class="p">)</span>

        <span class="c1"># If it doesn&#39;t exist, then create it.</span>
        <span class="k">if</span> <span class="n">restr_keys</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_index</span><span class="p">(</span><span class="n">restr_keys</span><span class="p">)</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">restrictions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">restr_keys</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[]))</span></div>

    <span class="k">def</span> <span class="nf">_add_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">restr_keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for ``select``, which creates a new index for</span>
<span class="sd">        a given set of attributes (aka restriction keys).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure it&#39;s a valid index.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">EdgeI</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad restriction: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

        <span class="c1"># Create the index.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="p">[</span><span class="n">restr_keys</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Add all existing edges to the index.</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">key</span><span class="p">)()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_with_indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for ``insert``, which registers the new</span>
<span class="sd">        edge with all existing indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">restr_keys</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">key</span><span class="p">)()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">restr_keys</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Edge Insertion</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Chart.insert_with_backpointer"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.insert_with_backpointer">[docs]</a>    <span class="k">def</span> <span class="nf">insert_with_backpointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_edge</span><span class="p">,</span> <span class="n">previous_edge</span><span class="p">,</span> <span class="n">child_edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new edge to the chart, using a pointer to the previous edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">previous_edge</span><span class="p">)</span>
        <span class="n">new_cpls</span> <span class="o">=</span> <span class="p">[</span><span class="n">cpl</span> <span class="o">+</span> <span class="p">(</span><span class="n">child_edge</span><span class="p">,)</span> <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="n">cpls</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="o">*</span><span class="n">new_cpls</span><span class="p">)</span></div>

<div class="viewcode-block" id="Chart.insert"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="o">*</span><span class="n">child_pointer_lists</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new edge to the chart, and return True if this operation</span>
<span class="sd">        modified the chart.  In particular, return true iff the chart</span>
<span class="sd">        did not already contain ``edge``, or if it did not already associate</span>
<span class="sd">        ``child_pointer_lists`` with ``edge``.</span>

<span class="sd">        :type edge: EdgeI</span>
<span class="sd">        :param edge: The new edge</span>
<span class="sd">        :type child_pointer_lists: sequence of tuple(EdgeI)</span>
<span class="sd">        :param child_pointer_lists: A sequence of lists of the edges that</span>
<span class="sd">            were used to form this edge.  This list is used to reconstruct</span>
<span class="sd">            the trees (or partial trees) that are associated with ``edge``.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Is it a new edge?</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="p">:</span>
            <span class="c1"># Add it to the list of edges.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="c1"># Register with indexes.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_with_indexes</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="c1"># Get the set of child pointer lists for this edge.</span>
        <span class="n">cpls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">())</span>
        <span class="n">chart_was_modified</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">child_pointer_list</span> <span class="ow">in</span> <span class="n">child_pointer_lists</span><span class="p">:</span>
            <span class="n">child_pointer_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child_pointer_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child_pointer_list</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cpls</span><span class="p">:</span>
                <span class="c1"># It&#39;s a new CPL; register it, and return true.</span>
                <span class="n">cpls</span><span class="p">[</span><span class="n">child_pointer_list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">chart_was_modified</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">chart_was_modified</span></div>

    <span class="k">def</span> <span class="nf">_append_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Tree extraction &amp; child pointer lists</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Chart.parses"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.parses">[docs]</a>    <span class="k">def</span> <span class="nf">parses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of the complete tree structures that span</span>
<span class="sd">        the entire chart, and whose root node is ``root``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="n">root</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Chart.trees"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.trees">[docs]</a>    <span class="k">def</span> <span class="nf">trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">,</span> <span class="n">complete</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator of the tree structures that are associated</span>
<span class="sd">        with ``edge``.</span>

<span class="sd">        If ``edge`` is incomplete, then the unexpanded children will be</span>
<span class="sd">        encoded as childless subtrees, whose node value is the</span>
<span class="sd">        corresponding terminal or nonterminal.</span>

<span class="sd">        :rtype: list(Tree)</span>
<span class="sd">        :note: If two trees share a common subtree, then the same</span>
<span class="sd">            Tree may be used to encode that subtree in</span>
<span class="sd">            both trees.  If you need to eliminate this subtree</span>
<span class="sd">            sharing, then create a deep copy of each tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{},</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">tree_class</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper function for ``trees``.</span>

<span class="sd">        :param memo: A dictionary used to record the trees that we&#39;ve</span>
<span class="sd">            generated for each edge, so that when we see an edge more</span>
<span class="sd">            than once, we can reuse the same trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If we&#39;ve seen this edge before, then reuse our old answer.</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>

        <span class="c1"># when we&#39;re reading trees off the chart, don&#39;t use incomplete edges</span>
        <span class="k">if</span> <span class="n">complete</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Leaf edges.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">LeafEdge</span><span class="p">):</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>

        <span class="c1"># Until we&#39;re done computing the trees for edge, set</span>
        <span class="c1"># memo[edge] to be empty.  This has the effect of filtering</span>
        <span class="c1"># out any cyclic trees (i.e., trees that contain themselves as</span>
        <span class="c1"># descendants), because if we reach this edge via a cycle,</span>
        <span class="c1"># then it will appear that the edge doesn&#39;t generate any trees.</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trees</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span><span class="o">.</span><span class="n">symbol</span><span class="p">()</span>

        <span class="c1"># Each child pointer list can be used to form trees.</span>
        <span class="k">for</span> <span class="n">cpl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">edge</span><span class="p">):</span>
            <span class="c1"># Get the set of child choices for each child pointer.</span>
            <span class="c1"># child_choices[i] is the set of choices for the tree&#39;s</span>
            <span class="c1"># ith child.</span>
            <span class="n">child_choices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_trees</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">complete</span><span class="p">,</span> <span class="n">memo</span><span class="p">,</span> <span class="n">tree_class</span><span class="p">)</span> <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">cpl</span><span class="p">]</span>

            <span class="c1"># For each combination of children, add a tree.</span>
            <span class="k">for</span> <span class="n">children</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">child_choices</span><span class="p">):</span>
                <span class="n">trees</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_class</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>

        <span class="c1"># If the edge is incomplete, then extend it with &quot;partial trees&quot;:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="n">unexpanded</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree_class</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="n">edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()</span> <span class="p">:]]</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
                <span class="n">tree</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unexpanded</span><span class="p">)</span>

        <span class="c1"># Update the memoization dictionary.</span>
        <span class="n">memo</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">trees</span>

        <span class="c1"># Return the list of trees.</span>
        <span class="k">return</span> <span class="n">trees</span>

<div class="viewcode-block" id="Chart.child_pointer_lists"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.child_pointer_lists">[docs]</a>    <span class="k">def</span> <span class="nf">child_pointer_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of child pointer lists for the given edge.</span>
<span class="sd">        Each child pointer list is a list of edges that have</span>
<span class="sd">        been used to form this edge.</span>

<span class="sd">        :rtype: list(list(EdgeI))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a copy, in case they modify it.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_to_cpls</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Display</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>
<div class="viewcode-block" id="Chart.pretty_format_edge"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.pretty_format_edge">[docs]</a>    <span class="k">def</span> <span class="nf">pretty_format_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pretty-printed string representation of a given edge</span>
<span class="sd">        in this chart.</span>

<span class="sd">        :rtype: str</span>
<span class="sd">        :param width: The number of characters allotted to each</span>
<span class="sd">            index in the sentence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>

        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">start</span>

        <span class="c1"># Zero-width edges are &quot;#&quot; if complete, &quot;&gt;&quot; if incomplete</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
                <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;#&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;&gt;&quot;</span>

        <span class="c1"># Spanning complete edges are &quot;[===]&quot;; Other edges are</span>
        <span class="c1"># &quot;[---]&quot; if complete, &quot;[---&gt;&quot; if incomplete</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span><span class="p">):</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span>

        <span class="nb">str</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_leaves</span> <span class="o">-</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span> <span class="o">+</span> <span class="s2">&quot;| </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">edge</span></div>

<div class="viewcode-block" id="Chart.pretty_format_leaves"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.pretty_format_leaves">[docs]</a>    <span class="k">def</span> <span class="nf">pretty_format_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pretty-printed string representation of this</span>
<span class="sd">        chart&#39;s leaves.  This string can be used as a header</span>
<span class="sd">        for calls to ``pretty_format_edge``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;|.&quot;</span>
            <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tokens</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">[:</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="s2">&quot;|&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">return</span> <span class="n">header</span></div>

<div class="viewcode-block" id="Chart.pretty_format"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.pretty_format">[docs]</a>    <span class="k">def</span> <span class="nf">pretty_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pretty-printed string representation of this chart.</span>

<span class="sd">        :param width: The number of characters allotted to each</span>
<span class="sd">            index in the sentence.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># sort edges: primary key=length, secondary key=start index.</span>
        <span class="c1"># (and filter out the token edges)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">((</span><span class="n">e</span><span class="o">.</span><span class="n">length</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pretty_format_leaves</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">)</span>
        <span class="p">)</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Display: Dot (AT&amp;T Graphviz)</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="Chart.dot_digraph"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.Chart.dot_digraph">[docs]</a>    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Header</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;digraph nltk_chart {</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="c1"># s += &#39;  size=&quot;5,5&quot;;\n&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  rankdir=LR;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  node [height=0.1,width=0.1];</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  node [style=filled, color=&quot;lightgray&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Set up the nodes</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  node [style=filled, color=&quot;black&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="p">):</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [label=&quot;&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Add a spacer</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  x [style=invis]; x-&gt;0000.0000 [style=invis];</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># Declare ranks.</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  {rank=same;&quot;</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="p">):</span>
                    <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%04d</span><span class="s2">.</span><span class="si">%04d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># Add the leaves</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  edge [style=invis, weight=100];</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  node [shape=plaintext]</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  0000.0000&quot;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;-&gt;</span><span class="si">%s</span><span class="s2">-&gt;</span><span class="si">%04d</span><span class="s2">.0000&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;;</span><span class="se">\n\n</span><span class="s2">&quot;</span>

        <span class="c1"># Add the edges</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  edge [style=solid, weight=1];</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">()):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> -&gt; </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [style=&quot;invis&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span>
                    <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> -&gt; </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [label=&quot;</span><span class="si">%s</span><span class="s1">&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span>
                <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">edge</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;  </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> -&gt; </span><span class="si">%04d</span><span class="s1">.</span><span class="si">%04d</span><span class="s1"> [style=&quot;invis&quot;];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span>
                    <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">s</span></div></div>


<span class="c1">########################################################################</span>
<span class="c1">##  Chart Rules</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="ChartRuleI"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartRuleI">[docs]</a><span class="k">class</span> <span class="nc">ChartRuleI</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that specifies what new edges are licensed by any given set</span>
<span class="sd">    of existing edges.  Each chart rule expects a fixed number of</span>
<span class="sd">    edges, as indicated by the class variable ``NUM_EDGES``.  In</span>
<span class="sd">    particular:</span>

<span class="sd">    - A chart rule with ``NUM_EDGES=0`` specifies what new edges are</span>
<span class="sd">      licensed, regardless of existing edges.</span>
<span class="sd">    - A chart rule with ``NUM_EDGES=1`` specifies what new edges are</span>
<span class="sd">      licensed by a single existing edge.</span>
<span class="sd">    - A chart rule with ``NUM_EDGES=2`` specifies what new edges are</span>
<span class="sd">      licensed by a pair of existing edges.</span>

<span class="sd">    :type NUM_EDGES: int</span>
<span class="sd">    :cvar NUM_EDGES: The number of existing edges that this rule uses</span>
<span class="sd">        to license new edges.  Typically, this number ranges from zero</span>
<span class="sd">        to two.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ChartRuleI.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartRuleI.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that will add edges licensed by this rule</span>
<span class="sd">        and the given edges to the chart, one at a time.  Each</span>
<span class="sd">        time the generator is resumed, it will either add a new</span>
<span class="sd">        edge and yield that edge; or return.</span>

<span class="sd">        :type edges: list(EdgeI)</span>
<span class="sd">        :param edges: A set of existing edges.  The number of edges</span>
<span class="sd">            that should be passed to ``apply()`` is specified by the</span>
<span class="sd">            ``NUM_EDGES`` class variable.</span>
<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="ChartRuleI.apply_everywhere"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartRuleI.apply_everywhere">[docs]</a>    <span class="k">def</span> <span class="nf">apply_everywhere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that will add all edges licensed by</span>
<span class="sd">        this rule, given the edges that are currently in the</span>
<span class="sd">        chart, one at a time.  Each time the generator is resumed,</span>
<span class="sd">        it will either add a new edge and yield that edge; or return.</span>

<span class="sd">        :rtype: iter(EdgeI)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="AbstractChartRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.AbstractChartRule">[docs]</a><span class="k">class</span> <span class="nc">AbstractChartRule</span><span class="p">(</span><span class="n">ChartRuleI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract base class for chart rules.  ``AbstractChartRule``</span>
<span class="sd">    provides:</span>

<span class="sd">    - A default implementation for ``apply``.</span>
<span class="sd">    - A default implementation for ``apply_everywhere``,</span>
<span class="sd">      (Currently, this implementation assumes that ``NUM_EDGES &lt;= 3``.)</span>
<span class="sd">    - A default implementation for ``__str__``, which returns a</span>
<span class="sd">      name based on the rule&#39;s class name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Subclasses must define apply.</span>
<div class="viewcode-block" id="AbstractChartRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.AbstractChartRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">*</span><span class="n">edges</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="c1"># Default: loop through the given number of edges, and call</span>
    <span class="c1"># self.apply() for each set of edges.</span>
<div class="viewcode-block" id="AbstractChartRule.apply_everywhere"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.AbstractChartRule.apply_everywhere">[docs]</a>    <span class="k">def</span> <span class="nf">apply_everywhere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">e3</span> <span class="ow">in</span> <span class="n">chart</span><span class="p">:</span>
                        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">e3</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;NUM_EDGES&gt;3 is not currently supported&quot;</span><span class="p">)</span></div>

    <span class="c1"># Default: return a name based on the class name.</span>
    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Add spaces between InitialCapsWords.</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;([a-z])([A-Z])&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;\1 \2&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>


<span class="c1"># ////////////////////////////////////////////////////////////</span>
<span class="c1"># Fundamental Rule</span>
<span class="c1"># ////////////////////////////////////////////////////////////</span>


<div class="viewcode-block" id="FundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.FundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">FundamentalRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that joins two adjacent edges to form a single combined</span>
<span class="sd">    edge.  In particular, this rule specifies that any pair of edges</span>

<span class="sd">    - ``[A -&gt; alpha \* B beta][i:j]``</span>
<span class="sd">    - ``[B -&gt; gamma \*][j:k]``</span>

<span class="sd">    licenses the edge:</span>

<span class="sd">    - ``[A -&gt; alpha B * beta][i:j]``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">2</span>

<div class="viewcode-block" id="FundamentalRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.FundamentalRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="c1"># Make sure the rule is applicable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">left_edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Construct the new edge.</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>

        <span class="c1"># Insert it into the chart.</span>
        <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="SingleEdgeFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SingleEdgeFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">SingleEdgeFundamentalRule</span><span class="p">(</span><span class="n">FundamentalRule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that joins a given edge with adjacent edges in the chart,</span>
<span class="sd">    to form combined edges.  In particular, this rule specifies that</span>
<span class="sd">    either of the edges:</span>

<span class="sd">    - ``[A -&gt; alpha \* B beta][i:j]``</span>
<span class="sd">    - ``[B -&gt; gamma \*][j:k]``</span>

<span class="sd">    licenses the edge:</span>

<span class="sd">    - ``[A -&gt; alpha B * beta][i:j]``</span>

<span class="sd">    if the other edge is already in the chart.</span>

<span class="sd">    :note: This is basically ``FundamentalRule``, with one edge left</span>
<span class="sd">        unspecified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="SingleEdgeFundamentalRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SingleEdgeFundamentalRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_incomplete</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_complete</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_apply_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">left_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">end</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nextsym</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

    <span class="k">def</span> <span class="nf">_apply_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">right_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">new_edge</span></div>


<span class="c1"># ////////////////////////////////////////////////////////////</span>
<span class="c1"># Inserting Terminal Leafs</span>
<span class="c1"># ////////////////////////////////////////////////////////////</span>


<div class="viewcode-block" id="LeafInitRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafInitRule">[docs]</a><span class="k">class</span> <span class="nc">LeafInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="LeafInitRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeafInitRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">LeafEdge</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<span class="c1"># ////////////////////////////////////////////////////////////</span>
<span class="c1"># Top-Down Prediction</span>
<span class="c1"># ////////////////////////////////////////////////////////////</span>


<div class="viewcode-block" id="TopDownInitRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TopDownInitRule">[docs]</a><span class="k">class</span> <span class="nc">TopDownInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing edges corresponding to the grammar productions for</span>
<span class="sd">    the grammar&#39;s start symbol.  In particular, this rule specifies that</span>
<span class="sd">    ``[S -&gt; \* alpha][0:i]`` is licensed for each grammar production</span>
<span class="sd">    ``S -&gt; alpha``, where ``S`` is the grammar&#39;s start symbol.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="TopDownInitRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TopDownInitRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="TopDownPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TopDownPredictRule">[docs]</a><span class="k">class</span> <span class="nc">TopDownPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing edges corresponding to the grammar productions</span>
<span class="sd">    for the nonterminal following an incomplete edge&#39;s dot.  In</span>
<span class="sd">    particular, this rule specifies that</span>
<span class="sd">    ``[A -&gt; alpha \* B beta][i:j]`` licenses the edge</span>
<span class="sd">    ``[B -&gt; \* gamma][j:j]`` for each grammar production ``B -&gt; gamma``.</span>

<span class="sd">    :note: This rule corresponds to the Predictor Rule in Earley parsing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="TopDownPredictRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TopDownPredictRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="CachedTopDownPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.CachedTopDownPredictRule">[docs]</a><span class="k">class</span> <span class="nc">CachedTopDownPredictRule</span><span class="p">(</span><span class="n">TopDownPredictRule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A cached version of ``TopDownPredictRule``.  After the first time</span>
<span class="sd">    this rule is applied to an edge with a given ``end`` and ``next``,</span>
<span class="sd">    it will not generate any more edges for edges with that ``end`` and</span>
<span class="sd">    ``next``.</span>

<span class="sd">    If ``chart`` or ``grammar`` are changed, then the cache is flushed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="CachedTopDownPredictRule.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.CachedTopDownPredictRule.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">TopDownPredictRule</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done</span> <span class="o">=</span> <span class="p">{}</span></div>

<div class="viewcode-block" id="CachedTopDownPredictRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.CachedTopDownPredictRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="n">nextsym</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">(),</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">nextsym</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># If we&#39;ve already applied this rule to an edge with the same</span>
        <span class="c1"># next &amp; end, and the chart &amp; grammar have not changed, then</span>
        <span class="c1"># just return (no new edges to add).</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">nextsym</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">done</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">chart</span> <span class="ow">and</span> <span class="n">done</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">grammar</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Add all the edges indicated by the top down expand rule.</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">lhs</span><span class="o">=</span><span class="n">nextsym</span><span class="p">):</span>
            <span class="c1"># If the left corner in the predicted production is</span>
            <span class="c1"># leaf, it must match with the input.</span>
            <span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">():</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">first</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">or</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                        <span class="k">continue</span>

            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span>

        <span class="c1"># Record the fact that we&#39;ve applied this rule.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_done</span><span class="p">[</span><span class="n">nextsym</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">)</span></div></div>


<span class="c1"># ////////////////////////////////////////////////////////////</span>
<span class="c1"># Bottom-Up Prediction</span>
<span class="c1"># ////////////////////////////////////////////////////////////</span>


<div class="viewcode-block" id="BottomUpPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpPredictRule">[docs]</a><span class="k">class</span> <span class="nc">BottomUpPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing any edge corresponding to a production whose</span>
<span class="sd">    right-hand side begins with a complete edge&#39;s left-hand side.  In</span>
<span class="sd">    particular, this rule specifies that ``[A -&gt; alpha \*]`` licenses</span>
<span class="sd">    the edge ``[B -&gt; \* A beta]`` for each grammar production ``B -&gt; A beta``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="BottomUpPredictRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpPredictRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="BottomUpPredictCombineRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpPredictCombineRule">[docs]</a><span class="k">class</span> <span class="nc">BottomUpPredictCombineRule</span><span class="p">(</span><span class="n">BottomUpPredictRule</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule licensing any edge corresponding to a production whose</span>
<span class="sd">    right-hand side begins with a complete edge&#39;s left-hand side.  In</span>
<span class="sd">    particular, this rule specifies that ``[A -&gt; alpha \*]``</span>
<span class="sd">    licenses the edge ``[B -&gt; A \* beta]`` for each grammar</span>
<span class="sd">    production ``B -&gt; A beta``.</span>

<span class="sd">    :note: This is like ``BottomUpPredictRule``, but it also applies</span>
<span class="sd">        the ``FundamentalRule`` to the resulting edge.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="BottomUpPredictCombineRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpPredictCombineRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,)):</span>
                <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="EmptyPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EmptyPredictRule">[docs]</a><span class="k">class</span> <span class="nc">EmptyPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A rule that inserts all empty productions as passive edges,</span>
<span class="sd">    in every position in the chart.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="EmptyPredictRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.EmptyPredictRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">empty</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<span class="c1">########################################################################</span>
<span class="c1">##  Filtered Bottom Up</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="FilteredSingleEdgeFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.FilteredSingleEdgeFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">FilteredSingleEdgeFundamentalRule</span><span class="p">(</span><span class="n">SingleEdgeFundamentalRule</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_apply_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">left_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">end</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nextsym</span><span class="o">=</span><span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span>

    <span class="k">def</span> <span class="nf">_apply_incomplete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">right_edge</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">move_dot_forward</span><span class="p">(</span><span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert_with_backpointer</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span></div>


<div class="viewcode-block" id="FilteredBottomUpPredictCombineRule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.FilteredBottomUpPredictCombineRule">[docs]</a><span class="k">class</span> <span class="nc">FilteredBottomUpPredictCombineRule</span><span class="p">(</span><span class="n">BottomUpPredictCombineRule</span><span class="p">):</span>
<div class="viewcode-block" id="FilteredBottomUpPredictCombineRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.FilteredBottomUpPredictCombineRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="n">end</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">nexttoken</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="ow">and</span> <span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">(</span><span class="n">rhs</span><span class="o">=</span><span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()):</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">TreeEdge</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">span</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">(</span><span class="n">edge</span><span class="p">,)):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<span class="k">def</span> <span class="nf">_bottomup_filter</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dot</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">_next</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">is_terminal</span><span class="p">(</span><span class="n">_next</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">nexttoken</span> <span class="o">==</span> <span class="n">_next</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_leftcorner</span><span class="p">(</span><span class="n">_next</span><span class="p">,</span> <span class="n">nexttoken</span><span class="p">)</span>


<span class="c1">########################################################################</span>
<span class="c1">##  Generic Chart Parser</span>
<span class="c1">########################################################################</span>

<span class="n">TD_STRATEGY</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">LeafInitRule</span><span class="p">(),</span>
    <span class="n">TopDownInitRule</span><span class="p">(),</span>
    <span class="n">CachedTopDownPredictRule</span><span class="p">(),</span>
    <span class="n">SingleEdgeFundamentalRule</span><span class="p">(),</span>
<span class="p">]</span>
<span class="n">BU_STRATEGY</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">LeafInitRule</span><span class="p">(),</span>
    <span class="n">EmptyPredictRule</span><span class="p">(),</span>
    <span class="n">BottomUpPredictRule</span><span class="p">(),</span>
    <span class="n">SingleEdgeFundamentalRule</span><span class="p">(),</span>
<span class="p">]</span>
<span class="n">BU_LC_STRATEGY</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">LeafInitRule</span><span class="p">(),</span>
    <span class="n">EmptyPredictRule</span><span class="p">(),</span>
    <span class="n">BottomUpPredictCombineRule</span><span class="p">(),</span>
    <span class="n">SingleEdgeFundamentalRule</span><span class="p">(),</span>
<span class="p">]</span>

<span class="n">LC_STRATEGY</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">LeafInitRule</span><span class="p">(),</span>
    <span class="n">FilteredBottomUpPredictCombineRule</span><span class="p">(),</span>
    <span class="n">FilteredSingleEdgeFundamentalRule</span><span class="p">(),</span>
<span class="p">]</span>


<div class="viewcode-block" id="ChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartParser">[docs]</a><span class="k">class</span> <span class="nc">ChartParser</span><span class="p">(</span><span class="n">ParserI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic chart parser.  A &quot;strategy&quot;, or list of</span>
<span class="sd">    ``ChartRuleI`` instances, is used to decide what edges to add to</span>
<span class="sd">    the chart.  In particular, ``ChartParser`` uses the following</span>
<span class="sd">    algorithm to parse texts:</span>

<span class="sd">    | Until no new edges are added:</span>
<span class="sd">    |   For each *rule* in *strategy*:</span>
<span class="sd">    |     Apply *rule* to any applicable edges in the chart.</span>
<span class="sd">    | Return any complete parses in the chart</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ChartParser.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grammar</span><span class="p">,</span>
        <span class="n">strategy</span><span class="o">=</span><span class="n">BU_LC_STRATEGY</span><span class="p">,</span>
        <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">trace_chart_width</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
        <span class="n">use_agenda</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">chart_class</span><span class="o">=</span><span class="n">Chart</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new chart parser, that uses ``grammar`` to parse</span>
<span class="sd">        texts.</span>

<span class="sd">        :type grammar: CFG</span>
<span class="sd">        :param grammar: The grammar used to parse texts.</span>
<span class="sd">        :type strategy: list(ChartRuleI)</span>
<span class="sd">        :param strategy: A list of rules that should be used to decide</span>
<span class="sd">            what edges to add to the chart (top-down strategy by default).</span>
<span class="sd">        :type trace: int</span>
<span class="sd">        :param trace: The level of tracing that should be used when</span>
<span class="sd">            parsing a text.  ``0`` will generate no tracing output;</span>
<span class="sd">            and higher numbers will produce more verbose tracing</span>
<span class="sd">            output.</span>
<span class="sd">        :type trace_chart_width: int</span>
<span class="sd">        :param trace_chart_width: The default total width reserved for</span>
<span class="sd">            the chart in trace output.  The remainder of each line will</span>
<span class="sd">            be used to display edges.</span>
<span class="sd">        :type use_agenda: bool</span>
<span class="sd">        :param use_agenda: Use an optimized agenda-based algorithm,</span>
<span class="sd">            if possible.</span>
<span class="sd">        :param chart_class: The class that should be used to create</span>
<span class="sd">            the parse charts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace_chart_width</span> <span class="o">=</span> <span class="n">trace_chart_width</span>
        <span class="c1"># If the strategy only consists of axioms (NUM_EDGES==0) and</span>
        <span class="c1"># inference rules (NUM_EDGES==1), we can use an agenda-based algorithm:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span> <span class="o">=</span> <span class="n">use_agenda</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart_class</span> <span class="o">=</span> <span class="n">chart_class</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">strategy</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rule</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">rule</span><span class="o">.</span><span class="n">NUM_EDGES</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="ChartParser.grammar"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span></div>

    <span class="k">def</span> <span class="nf">_trace_new_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">edge_width</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">trace</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">print_rule_header</span> <span class="o">=</span> <span class="n">trace</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">new_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">print_rule_header</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:&quot;</span> <span class="o">%</span> <span class="n">rule</span><span class="p">)</span>
                <span class="n">print_rule_header</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">edge_width</span><span class="p">))</span>

<div class="viewcode-block" id="ChartParser.chart_parse"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartParser.chart_parse">[docs]</a>    <span class="k">def</span> <span class="nf">chart_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the final parse ``Chart`` from which all possible</span>
<span class="sd">        parse trees can be extracted.</span>

<span class="sd">        :param tokens: The sentence to be parsed</span>
<span class="sd">        :type tokens: list(str)</span>
<span class="sd">        :rtype: Chart</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">trace</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span>
        <span class="n">trace_new_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_new_edges</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart_class</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

        <span class="c1"># Width, for printing trace edges.</span>
        <span class="n">trace_edge_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_chart_width</span> <span class="o">//</span> <span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pretty_format_leaves</span><span class="p">(</span><span class="n">trace_edge_width</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_agenda</span><span class="p">:</span>
            <span class="c1"># Use an agenda-based algorithm.</span>
            <span class="k">for</span> <span class="n">axiom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axioms</span><span class="p">:</span>
                <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axiom</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">))</span>
                <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">axiom</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>

            <span class="n">inference_rules</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inference_rules</span>
            <span class="n">agenda</span> <span class="o">=</span> <span class="n">chart</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
            <span class="c1"># We reverse the initial agenda, since it is a stack</span>
            <span class="c1"># but chart.edges() functions as a queue.</span>
            <span class="n">agenda</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">agenda</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">agenda</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">inference_rules</span><span class="p">:</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">trace</span><span class="p">:</span>
                        <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>
                    <span class="n">agenda</span> <span class="o">+=</span> <span class="n">new_edges</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Do not use an agenda-based algorithm.</span>
            <span class="n">edges_added</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">edges_added</span><span class="p">:</span>
                <span class="n">edges_added</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rule</span><span class="o">.</span><span class="n">apply_everywhere</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">))</span>
                    <span class="n">edges_added</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
                    <span class="n">trace_new_edges</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">trace_edge_width</span><span class="p">)</span>

        <span class="c1"># Return the final chart.</span>
        <span class="k">return</span> <span class="n">chart</span></div>

<div class="viewcode-block" id="ChartParser.parse"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.ChartParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="TopDownChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TopDownChartParser">[docs]</a><span class="k">class</span> <span class="nc">TopDownChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` using a top-down parsing strategy.</span>
<span class="sd">    See ``ChartParser`` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="TopDownChartParser.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.TopDownChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">TD_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BottomUpChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` using a bottom-up parsing strategy.</span>
<span class="sd">    See ``ChartParser`` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BottomUpChartParser.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">PCFG</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;BottomUpChartParser only works for CFG, &quot;</span>
                <span class="s2">&quot;use BottomUpProbabilisticChartParser instead&quot;</span><span class="p">,</span>
                <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">BU_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="BottomUpLeftCornerChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpLeftCornerChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpLeftCornerChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` using a bottom-up left-corner parsing strategy.</span>
<span class="sd">    This strategy is often more efficient than standard bottom-up.</span>
<span class="sd">    See ``ChartParser`` for more information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BottomUpLeftCornerChartParser.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.BottomUpLeftCornerChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">BU_LC_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="LeftCornerChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeftCornerChartParser">[docs]</a><span class="k">class</span> <span class="nc">LeftCornerChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
<div class="viewcode-block" id="LeftCornerChartParser.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.LeftCornerChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_nonempty</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;LeftCornerParser only works for grammars &quot;</span> <span class="s2">&quot;without empty productions.&quot;</span>
            <span class="p">)</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">LC_STRATEGY</span><span class="p">,</span> <span class="o">**</span><span class="n">parser_args</span><span class="p">)</span></div></div>


<span class="c1">########################################################################</span>
<span class="c1">##  Stepping Chart Parser</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="SteppingChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser">[docs]</a><span class="k">class</span> <span class="nc">SteppingChartParser</span><span class="p">(</span><span class="n">ChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ``ChartParser`` that allows you to step through the parsing</span>
<span class="sd">    process, adding a single edge at a time.  It also allows you to</span>
<span class="sd">    change the parser&#39;s strategy or grammar midway through parsing a</span>
<span class="sd">    text.</span>

<span class="sd">    The ``initialize`` method is used to start parsing a text.  ``step``</span>
<span class="sd">    adds a single edge to the chart.  ``set_strategy`` changes the</span>
<span class="sd">    strategy used by the chart parser.  ``parses`` returns the set of</span>
<span class="sd">    parses that has been found by the chart parser.</span>

<span class="sd">    :ivar _restart: Records whether the parser&#39;s strategy, grammar,</span>
<span class="sd">        or chart has been changed.  If so, then ``step`` must restart</span>
<span class="sd">        the parsing algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SteppingChartParser.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="p">[],</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ChartParser</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">trace</span><span class="p">)</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Initialization</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.initialize"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="s2">&quot;Begin parsing the given tokens.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="n">Chart</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Stepping</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.step"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator that adds edges to the chart, one at a</span>
<span class="sd">        time.  Each time the generator is resumed, it adds a single</span>
<span class="sd">        edge and yields that edge.  If no more edges can be added,</span>
<span class="sd">        then it yields None.</span>

<span class="sd">        If the parser&#39;s strategy, grammar, or chart is changed, then</span>
<span class="sd">        the generator will continue adding edges using the new</span>
<span class="sd">        strategy, grammar, or chart.</span>

<span class="sd">        Note that this generator never terminates, since the grammar</span>
<span class="sd">        or strategy might be changed to values that would add new</span>
<span class="sd">        edges.  Instead, it yields None when no more edges can be</span>
<span class="sd">        added with the current strategy and grammar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parser must be initialized first&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">50</span> <span class="o">//</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                <span class="k">yield</span> <span class="n">e</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="kc">None</span>  <span class="c1"># No more edges.</span></div>

    <span class="k">def</span> <span class="nf">_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A generator that implements the actual parsing algorithm.</span>
<span class="sd">        ``step`` iterates through this generator, and restarts it</span>
<span class="sd">        whenever the parser&#39;s strategy, grammar, or chart is modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>
        <span class="n">edges_added</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">edges_added</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges_added</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span> <span class="o">=</span> <span class="n">rule</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">rule</span><span class="o">.</span><span class="n">apply_everywhere</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
                    <span class="n">edges_added</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">yield</span> <span class="n">e</span>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Accessors</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.strategy"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.strategy">[docs]</a>    <span class="k">def</span> <span class="nf">strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the strategy used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span></div>

<div class="viewcode-block" id="SteppingChartParser.grammar"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the grammar used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span></div>

<div class="viewcode-block" id="SteppingChartParser.chart"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.chart">[docs]</a>    <span class="k">def</span> <span class="nf">chart</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the chart that is used by this parser.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span></div>

<div class="viewcode-block" id="SteppingChartParser.current_chartrule"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.current_chartrule">[docs]</a>    <span class="k">def</span> <span class="nf">current_chartrule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the chart rule used to generate the most recent edge.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_chartrule</span></div>

<div class="viewcode-block" id="SteppingChartParser.parses"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.parses">[docs]</a>    <span class="k">def</span> <span class="nf">parses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="s2">&quot;Return the parse trees currently contained in the chart.&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">tree_class</span><span class="p">)</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Parser modification</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.set_strategy"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.set_strategy">[docs]</a>    <span class="k">def</span> <span class="nf">set_strategy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the strategy that the parser uses to decide which edges</span>
<span class="sd">        to add to the chart.</span>

<span class="sd">        :type strategy: list(ChartRuleI)</span>
<span class="sd">        :param strategy: A list of rules that should be used to decide</span>
<span class="sd">            what edges to add to the chart.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">[:]</span>  <span class="c1"># Make a copy.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="SteppingChartParser.set_grammar"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.set_grammar">[docs]</a>    <span class="k">def</span> <span class="nf">set_grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="s2">&quot;Change the grammar used by the parser.&quot;</span>
        <span class="k">if</span> <span class="n">grammar</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="SteppingChartParser.set_chart"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.set_chart">[docs]</a>    <span class="k">def</span> <span class="nf">set_chart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="s2">&quot;Load a given chart into the chart parser.&quot;</span>
        <span class="k">if</span> <span class="n">chart</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chart</span> <span class="o">=</span> <span class="n">chart</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_restart</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># ////////////////////////////////////////////////////////////</span>
    <span class="c1"># Standard parser methods</span>
    <span class="c1"># ////////////////////////////////////////////////////////////</span>

<div class="viewcode-block" id="SteppingChartParser.parse"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.SteppingChartParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">tree_class</span><span class="o">=</span><span class="n">Tree</span><span class="p">):</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Initialize ourselves.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

        <span class="c1"># Step until no more edges are generated.</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Return an iterator of complete parses.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">tree_class</span><span class="o">=</span><span class="n">tree_class</span><span class="p">)</span></div></div>


<span class="c1">########################################################################</span>
<span class="c1">##  Demo Code</span>
<span class="c1">########################################################################</span>


<div class="viewcode-block" id="demo_grammar"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.demo_grammar">[docs]</a><span class="k">def</span> <span class="nf">demo_grammar</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">CFG</span>

    <span class="k">return</span> <span class="n">CFG</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">S  -&gt; NP VP</span>
<span class="sd">PP -&gt; &quot;with&quot; NP</span>
<span class="sd">NP -&gt; NP PP</span>
<span class="sd">VP -&gt; VP PP</span>
<span class="sd">VP -&gt; Verb NP</span>
<span class="sd">VP -&gt; Verb</span>
<span class="sd">NP -&gt; Det Noun</span>
<span class="sd">NP -&gt; &quot;John&quot;</span>
<span class="sd">NP -&gt; &quot;I&quot;</span>
<span class="sd">Det -&gt; &quot;the&quot;</span>
<span class="sd">Det -&gt; &quot;my&quot;</span>
<span class="sd">Det -&gt; &quot;a&quot;</span>
<span class="sd">Noun -&gt; &quot;dog&quot;</span>
<span class="sd">Noun -&gt; &quot;cookie&quot;</span>
<span class="sd">Verb -&gt; &quot;ate&quot;</span>
<span class="sd">Verb -&gt; &quot;saw&quot;</span>
<span class="sd">Prep -&gt; &quot;with&quot;</span>
<span class="sd">Prep -&gt; &quot;under&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.parse.chart.html#nltk.parse.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">(</span>
    <span class="n">choice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">print_times</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">print_grammar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">print_trees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">trace</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">sent</span><span class="o">=</span><span class="s2">&quot;I saw John with a dog with my cookie&quot;</span><span class="p">,</span>
    <span class="n">numparses</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration of the chart parsers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">CFG</span><span class="p">,</span> <span class="n">Production</span><span class="p">,</span> <span class="n">nonterminals</span>

    <span class="c1"># The grammar for ChartParser and SteppingChartParser:</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">demo_grammar</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">print_grammar</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Grammar&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>

    <span class="c1"># Tokenize the sample sentence.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Sentence:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Ask the user which parser to test,</span>
    <span class="c1"># if the parser wasn&#39;t provided as an argument</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  1: Top-down chart parser&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  2: Bottom-up chart parser&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  3: Bottom-up left-corner chart parser&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  4: Left-corner chart parser with bottom-up filter&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  5: Stepping chart parser (alternating top-down &amp; bottom-up)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  6: All parsers&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Which parser (1-6)? &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="n">choice</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">choice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;123456&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bad parser number&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Keep track of how long each parser takes.</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">strategies</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Top-down&quot;</span><span class="p">,</span> <span class="n">TD_STRATEGY</span><span class="p">),</span>
        <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Bottom-up&quot;</span><span class="p">,</span> <span class="n">BU_STRATEGY</span><span class="p">),</span>
        <span class="s2">&quot;3&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Bottom-up left-corner&quot;</span><span class="p">,</span> <span class="n">BU_LC_STRATEGY</span><span class="p">),</span>
        <span class="s2">&quot;4&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;Filtered left-corner&quot;</span><span class="p">,</span> <span class="n">LC_STRATEGY</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="n">choices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">in</span> <span class="n">strategies</span><span class="p">:</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="p">[</span><span class="n">choice</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="o">==</span> <span class="s2">&quot;6&quot;</span><span class="p">:</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="s2">&quot;1234&quot;</span>

    <span class="c1"># Run the requested chart parser(s), except the stepping parser.</span>
    <span class="k">for</span> <span class="n">strategy</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Strategy: &quot;</span> <span class="o">+</span> <span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">ChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">chart_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">parses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">()))</span>

        <span class="n">times</span><span class="p">[</span><span class="n">strategies</span><span class="p">[</span><span class="n">strategy</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nr edges in chart:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">numparses</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span> <span class="o">==</span> <span class="n">numparses</span><span class="p">,</span> <span class="s2">&quot;Not all parses found&quot;</span>
        <span class="k">if</span> <span class="n">print_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nr trees:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Run the stepping parser, if requested.</span>
    <span class="k">if</span> <span class="n">choice</span> <span class="ow">in</span> <span class="s2">&quot;56&quot;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Strategy: Stepping (top-down vs bottom-up)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">SteppingChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">)</span>
        <span class="n">cp</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** SWITCH TO TOP DOWN&quot;</span><span class="p">)</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">set_strategy</span><span class="p">(</span><span class="n">TD_STRATEGY</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">step</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;*** SWITCH TO BOTTOM UP&quot;</span><span class="p">)</span>
            <span class="n">cp</span><span class="o">.</span><span class="n">set_strategy</span><span class="p">(</span><span class="n">BU_STRATEGY</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">step</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="n">times</span><span class="p">[</span><span class="s2">&quot;Stepping&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nr edges in chart:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">chart</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">numparses</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">()))</span> <span class="o">==</span> <span class="n">numparses</span><span class="p">,</span> <span class="s2">&quot;Not all parses found&quot;</span>
        <span class="k">if</span> <span class="n">print_trees</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nr trees:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">parses</span><span class="p">())))</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Print the times of all parsers:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">print_times</span> <span class="ow">and</span> <span class="n">times</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;* Parsing times&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">times</span><span class="p">)</span>
    <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;%&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">maxlen</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s parser: </span><span class="si">%6.3f</span><span class="s2">sec&quot;</span>
    <span class="n">times_items</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">times_items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">format</span> <span class="o">%</span> <span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>