<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.parse.pchart</title>
  

  <link rel="stylesheet" href="../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.parse.pchart</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: Probabilistic Chart Parsers</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Classes and interfaces for associating probabilities with tree</span>
<span class="sd">structures that represent the internal organization of a text.  The</span>
<span class="sd">probabilistic parser module defines ``BottomUpProbabilisticChartParser``.</span>

<span class="sd">``BottomUpProbabilisticChartParser`` is an abstract class that implements</span>
<span class="sd">a bottom-up chart parser for ``PCFG`` grammars.  It maintains a queue of edges,</span>
<span class="sd">and adds them to the chart one at a time.  The ordering of this queue</span>
<span class="sd">is based on the probabilities associated with the edges, allowing the</span>
<span class="sd">parser to expand more likely edges before less likely ones.  Each</span>
<span class="sd">subclass implements a different queue ordering, producing different</span>
<span class="sd">search strategies.  Currently the following subclasses are defined:</span>

<span class="sd">  - ``InsideChartParser`` searches edges in decreasing order of</span>
<span class="sd">    their trees&#39; inside probabilities.</span>
<span class="sd">  - ``RandomChartParser`` searches edges in random order.</span>
<span class="sd">  - ``LongestChartParser`` searches edges in decreasing order of their</span>
<span class="sd">    location&#39;s length.</span>

<span class="sd">The ``BottomUpProbabilisticChartParser`` constructor has an optional</span>
<span class="sd">argument beam_size.  If non-zero, this controls the size of the beam</span>
<span class="sd">(aka the edge queue).  This option is most useful with InsideChartParser.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">##//////////////////////////////////////////////////////</span>
<span class="c1">##  Bottom-Up PCFG Chart Parser</span>
<span class="c1">##//////////////////////////////////////////////////////</span>

<span class="c1"># [XX] This might not be implemented quite right -- it would be better</span>
<span class="c1"># to associate probabilities with child pointer lists.</span>

<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>

<span class="kn">from</span> <span class="nn">nltk.grammar</span> <span class="kn">import</span> <span class="n">PCFG</span><span class="p">,</span> <span class="n">Nonterminal</span>
<span class="kn">from</span> <span class="nn">nltk.parse.api</span> <span class="kn">import</span> <span class="n">ParserI</span>
<span class="kn">from</span> <span class="nn">nltk.parse.chart</span> <span class="kn">import</span> <span class="n">AbstractChartRule</span><span class="p">,</span> <span class="n">Chart</span><span class="p">,</span> <span class="n">LeafEdge</span><span class="p">,</span> <span class="n">TreeEdge</span>
<span class="kn">from</span> <span class="nn">nltk.tree</span> <span class="kn">import</span> <span class="n">ProbabilisticTree</span><span class="p">,</span> <span class="n">Tree</span>


<span class="c1"># Probabilistic edges</span>
<div class="viewcode-block" id="ProbabilisticLeafEdge"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticLeafEdge">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticLeafEdge</span><span class="p">(</span><span class="n">LeafEdge</span><span class="p">):</span>
<div class="viewcode-block" id="ProbabilisticLeafEdge.prob"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticLeafEdge.prob">[docs]</a>    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.0</span></div></div>


<div class="viewcode-block" id="ProbabilisticTreeEdge"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticTreeEdge">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticTreeEdge</span><span class="p">(</span><span class="n">TreeEdge</span><span class="p">):</span>
<div class="viewcode-block" id="ProbabilisticTreeEdge.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticTreeEdge.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">TreeEdge</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prob</span> <span class="o">=</span> <span class="n">prob</span>
        <span class="c1"># two edges with different probabilities are not equal.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comparison_key</span><span class="p">,</span> <span class="n">prob</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProbabilisticTreeEdge.prob"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticTreeEdge.prob">[docs]</a>    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prob</span></div>

<div class="viewcode-block" id="ProbabilisticTreeEdge.from_production"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticTreeEdge.from_production">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_production</span><span class="p">(</span><span class="n">production</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ProbabilisticTreeEdge</span><span class="p">(</span>
            <span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">production</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">production</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span> <span class="mi">0</span>
        <span class="p">)</span></div></div>


<span class="c1"># Rules using probabilistic edges</span>
<div class="viewcode-block" id="ProbabilisticBottomUpInitRule"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticBottomUpInitRule">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticBottomUpInitRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="ProbabilisticBottomUpInitRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticBottomUpInitRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">num_leaves</span><span class="p">()):</span>
            <span class="n">new_edge</span> <span class="o">=</span> <span class="n">ProbabilisticLeafEdge</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">leaf</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="ProbabilisticBottomUpPredictRule"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticBottomUpPredictRule">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticBottomUpPredictRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="ProbabilisticBottomUpPredictRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticBottomUpPredictRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span> <span class="o">==</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="n">ProbabilisticTreeEdge</span><span class="o">.</span><span class="n">from_production</span><span class="p">(</span>
                    <span class="n">prod</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="p">()):</span>
                    <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="ProbabilisticFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">ProbabilisticFundamentalRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">2</span>

<div class="viewcode-block" id="ProbabilisticFundamentalRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.ProbabilisticFundamentalRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">left_edge</span><span class="p">,</span> <span class="n">right_edge</span><span class="p">):</span>
        <span class="c1"># Make sure the rule is applicable.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">left_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()</span> <span class="o">==</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">is_complete</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Construct the new edge.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">left_edge</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span> <span class="o">*</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
        <span class="n">new_edge</span> <span class="o">=</span> <span class="n">ProbabilisticTreeEdge</span><span class="p">(</span>
            <span class="n">p</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="p">(</span><span class="n">left_edge</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">right_edge</span><span class="o">.</span><span class="n">end</span><span class="p">()),</span>
            <span class="n">lhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span>
            <span class="n">rhs</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">rhs</span><span class="p">(),</span>
            <span class="n">dot</span><span class="o">=</span><span class="n">left_edge</span><span class="o">.</span><span class="n">dot</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add it to the chart, with appropriate child pointers.</span>
        <span class="n">changed_chart</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">cpl1</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">child_pointer_lists</span><span class="p">(</span><span class="n">left_edge</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">chart</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_edge</span><span class="p">,</span> <span class="n">cpl1</span> <span class="o">+</span> <span class="p">(</span><span class="n">right_edge</span><span class="p">,)):</span>
                <span class="n">changed_chart</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># If we changed the chart, then generate the edge.</span>
        <span class="k">if</span> <span class="n">changed_chart</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">new_edge</span></div></div>


<div class="viewcode-block" id="SingleEdgeProbabilisticFundamentalRule"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.SingleEdgeProbabilisticFundamentalRule">[docs]</a><span class="k">class</span> <span class="nc">SingleEdgeProbabilisticFundamentalRule</span><span class="p">(</span><span class="n">AbstractChartRule</span><span class="p">):</span>
    <span class="n">NUM_EDGES</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">_fundamental_rule</span> <span class="o">=</span> <span class="n">ProbabilisticFundamentalRule</span><span class="p">()</span>

<div class="viewcode-block" id="SingleEdgeProbabilisticFundamentalRule.apply"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.SingleEdgeProbabilisticFundamentalRule.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge1</span><span class="p">):</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fundamental_rule</span>
        <span class="k">if</span> <span class="n">edge1</span><span class="o">.</span><span class="n">is_incomplete</span><span class="p">():</span>
            <span class="c1"># edge1 = left_edge; edge2 = right_edge</span>
            <span class="k">for</span> <span class="n">edge2</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lhs</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">nextsym</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">yield from</span> <span class="n">fr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># edge2 = left_edge; edge1 = right_edge</span>
            <span class="k">for</span> <span class="n">edge2</span> <span class="ow">in</span> <span class="n">chart</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="n">end</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">is_complete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nextsym</span><span class="o">=</span><span class="n">edge1</span><span class="o">.</span><span class="n">lhs</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">yield from</span> <span class="n">fr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge2</span><span class="p">,</span> <span class="n">edge1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Fundamental Rule&quot;</span></div>


<div class="viewcode-block" id="BottomUpProbabilisticChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.BottomUpProbabilisticChartParser">[docs]</a><span class="k">class</span> <span class="nc">BottomUpProbabilisticChartParser</span><span class="p">(</span><span class="n">ParserI</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract bottom-up parser for ``PCFG`` grammars that uses a ``Chart`` to</span>
<span class="sd">    record partial results.  ``BottomUpProbabilisticChartParser`` maintains</span>
<span class="sd">    a queue of edges that can be added to the chart.  This queue is</span>
<span class="sd">    initialized with edges for each token in the text that is being</span>
<span class="sd">    parsed.  ``BottomUpProbabilisticChartParser`` inserts these edges into</span>
<span class="sd">    the chart one at a time, starting with the most likely edges, and</span>
<span class="sd">    proceeding to less likely edges.  For each edge that is added to</span>
<span class="sd">    the chart, it may become possible to insert additional edges into</span>
<span class="sd">    the chart; these are added to the queue.  This process continues</span>
<span class="sd">    until enough complete parses have been generated, or until the</span>
<span class="sd">    queue is empty.</span>

<span class="sd">    The sorting order for the queue is not specified by</span>
<span class="sd">    ``BottomUpProbabilisticChartParser``.  Different sorting orders will</span>
<span class="sd">    result in different search strategies.  The sorting order for the</span>
<span class="sd">    queue is defined by the method ``sort_queue``; subclasses are required</span>
<span class="sd">    to provide a definition for this method.</span>

<span class="sd">    :type _grammar: PCFG</span>
<span class="sd">    :ivar _grammar: The grammar used to parse sentences.</span>
<span class="sd">    :type _trace: int</span>
<span class="sd">    :ivar _trace: The level of tracing output that should be generated</span>
<span class="sd">        when parsing a text.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BottomUpProbabilisticChartParser.__init__"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.BottomUpProbabilisticChartParser.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">beam_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new ``BottomUpProbabilisticChartParser``, that uses</span>
<span class="sd">        ``grammar`` to parse texts.</span>

<span class="sd">        :type grammar: PCFG</span>
<span class="sd">        :param grammar: The grammar used to parse texts.</span>
<span class="sd">        :type beam_size: int</span>
<span class="sd">        :param beam_size: The maximum length for the parser&#39;s edge queue.</span>
<span class="sd">        :type trace: int</span>
<span class="sd">        :param trace: The level of tracing that should be used when</span>
<span class="sd">            parsing a text.  ``0`` will generate no tracing output;</span>
<span class="sd">            and higher numbers will produce more verbose tracing</span>
<span class="sd">            output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">PCFG</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The grammar must be probabilistic PCFG&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span> <span class="o">=</span> <span class="n">beam_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span></div>

<div class="viewcode-block" id="BottomUpProbabilisticChartParser.grammar"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.BottomUpProbabilisticChartParser.grammar">[docs]</a>    <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span></div>

<div class="viewcode-block" id="BottomUpProbabilisticChartParser.trace"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.BottomUpProbabilisticChartParser.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the level of tracing output that should be generated when</span>
<span class="sd">        parsing a text.</span>

<span class="sd">        :type trace: int</span>
<span class="sd">        :param trace: The trace level.  A trace level of ``0`` will</span>
<span class="sd">            generate no tracing output; and higher trace levels will</span>
<span class="sd">            produce more verbose tracing output.</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">=</span> <span class="n">trace</span></div>

    <span class="c1"># TODO: change this to conform more with the standard ChartParser</span>
<div class="viewcode-block" id="BottomUpProbabilisticChartParser.parse"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.BottomUpProbabilisticChartParser.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">check_coverage</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
        <span class="n">chart</span> <span class="o">=</span> <span class="n">Chart</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

        <span class="c1"># Chart parser rules.</span>
        <span class="n">bu_init</span> <span class="o">=</span> <span class="n">ProbabilisticBottomUpInitRule</span><span class="p">()</span>
        <span class="n">bu</span> <span class="o">=</span> <span class="n">ProbabilisticBottomUpPredictRule</span><span class="p">()</span>
        <span class="n">fr</span> <span class="o">=</span> <span class="n">SingleEdgeProbabilisticFundamentalRule</span><span class="p">()</span>

        <span class="c1"># Our queue</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initialize the chart.</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">bu_init</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;  </span><span class="si">%-50s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">]&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">edge</span><span class="o">.</span><span class="n">prob</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Re-sort the queue.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sort_queue</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">)</span>

            <span class="c1"># Prune the queue to the correct size if a beam was defined</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">)</span>

            <span class="c1"># Get the best edge.</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;  </span><span class="si">%-50s</span><span class="s2"> [</span><span class="si">%s</span><span class="s2">]&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">edge</span><span class="o">.</span><span class="n">prob</span><span class="p">())</span>
                <span class="p">)</span>

            <span class="c1"># Apply BU &amp; FR to it.</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bu</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">chart</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

        <span class="c1"># Get a list of complete parses.</span>
        <span class="n">parses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chart</span><span class="o">.</span><span class="n">parses</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">ProbabilisticTree</span><span class="p">))</span>

        <span class="c1"># Assign probabilities to the trees.</span>
        <span class="n">prod_probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">():</span>
            <span class="n">prod_probs</span><span class="p">[</span><span class="n">prod</span><span class="o">.</span><span class="n">lhs</span><span class="p">(),</span> <span class="n">prod</span><span class="o">.</span><span class="n">rhs</span><span class="p">()]</span> <span class="o">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">parse</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setprob</span><span class="p">(</span><span class="n">parse</span><span class="p">,</span> <span class="n">prod_probs</span><span class="p">)</span>

        <span class="c1"># Sort by probability</span>
        <span class="n">parses</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tree</span><span class="p">:</span> <span class="n">tree</span><span class="o">.</span><span class="n">prob</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_setprob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">prod_probs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Get the prob of the CFG production.</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">Nonterminal</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">())</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="n">rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Nonterminal</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rhs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">prob</span> <span class="o">=</span> <span class="n">prod_probs</span><span class="p">[</span><span class="n">lhs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">)]</span>

        <span class="c1"># Get the probs of children.</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_setprob</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">prod_probs</span><span class="p">)</span>
                <span class="n">prob</span> <span class="o">*=</span> <span class="n">child</span><span class="o">.</span><span class="n">prob</span><span class="p">()</span>

        <span class="n">tree</span><span class="o">.</span><span class="n">set_prob</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>

<div class="viewcode-block" id="BottomUpProbabilisticChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.BottomUpProbabilisticChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the given queue of ``Edge`` objects, placing the edge that should</span>
<span class="sd">        be tried first at the beginning of the queue.  This method</span>
<span class="sd">        will be called after each ``Edge`` is added to the queue.</span>

<span class="sd">        :param queue: The queue of ``Edge`` objects to sort.  Each edge in</span>
<span class="sd">            this queue is an edge that could be added to the chart by</span>
<span class="sd">            the fundamental rule; but that has not yet been added.</span>
<span class="sd">        :type queue: list(Edge)</span>
<span class="sd">        :param chart: The chart being used to parse the text.  This</span>
<span class="sd">            chart can be used to provide extra information for sorting</span>
<span class="sd">            the queue.</span>
<span class="sd">        :type chart: Chart</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Discard items in the queue if the queue is longer than the beam.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span><span class="p">:</span>
            <span class="n">split</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beam_size</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">queue</span><span class="p">[:</span><span class="n">split</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">%-50s</span><span class="s2"> [DISCARDED]&quot;</span> <span class="o">%</span> <span class="n">chart</span><span class="o">.</span><span class="n">pretty_format_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">queue</span><span class="p">[:</span><span class="n">split</span><span class="p">]</span></div>


<div class="viewcode-block" id="InsideChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.InsideChartParser">[docs]</a><span class="k">class</span> <span class="nc">InsideChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries edges in descending</span>
<span class="sd">    order of the inside probabilities of their trees.  The &quot;inside</span>
<span class="sd">    probability&quot; of a tree is simply the</span>
<span class="sd">    probability of the entire tree, ignoring its context.  In</span>
<span class="sd">    particular, the inside probability of a tree generated by</span>
<span class="sd">    production *p* with children *c[1], c[2], ..., c[n]* is</span>
<span class="sd">    *P(p)P(c[1])P(c[2])...P(c[n])*; and the inside</span>
<span class="sd">    probability of a token is 1 if it is present in the text, and 0 if</span>
<span class="sd">    it is absent.</span>

<span class="sd">    This sorting order results in a type of lowest-cost-first search</span>
<span class="sd">    strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Inherit constructor.</span>
<div class="viewcode-block" id="InsideChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.InsideChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the given queue of edges, in descending order of the</span>
<span class="sd">        inside probabilities of the edges&#39; trees.</span>

<span class="sd">        :param queue: The queue of ``Edge`` objects to sort.  Each edge in</span>
<span class="sd">            this queue is an edge that could be added to the chart by</span>
<span class="sd">            the fundamental rule; but that has not yet been added.</span>
<span class="sd">        :type queue: list(Edge)</span>
<span class="sd">        :param chart: The chart being used to parse the text.  This</span>
<span class="sd">            chart can be used to provide extra information for sorting</span>
<span class="sd">            the queue.</span>
<span class="sd">        :type chart: Chart</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">prob</span><span class="p">())</span></div></div>


<span class="c1"># Eventually, this will become some sort of inside-outside parser:</span>
<span class="c1"># class InsideOutsideParser(BottomUpProbabilisticChartParser):</span>
<span class="c1">#     def __init__(self, grammar, trace=0):</span>
<span class="c1">#         # Inherit docs.</span>
<span class="c1">#         BottomUpProbabilisticChartParser.__init__(self, grammar, trace)</span>
<span class="c1">#</span>
<span class="c1">#         # Find the best path from S to each nonterminal</span>
<span class="c1">#         bestp = {}</span>
<span class="c1">#         for production in grammar.productions(): bestp[production.lhs()]=0</span>
<span class="c1">#         bestp[grammar.start()] = 1.0</span>
<span class="c1">#</span>
<span class="c1">#         for i in range(len(grammar.productions())):</span>
<span class="c1">#             for production in grammar.productions():</span>
<span class="c1">#                 lhs = production.lhs()</span>
<span class="c1">#                 for elt in production.rhs():</span>
<span class="c1">#                     bestp[elt] = max(bestp[lhs]*production.prob(),</span>
<span class="c1">#                                      bestp.get(elt,0))</span>
<span class="c1">#</span>
<span class="c1">#         self._bestp = bestp</span>
<span class="c1">#         for (k,v) in self._bestp.items(): print(k,v)</span>
<span class="c1">#</span>
<span class="c1">#     def _sortkey(self, edge):</span>
<span class="c1">#         return edge.structure()[PROB] * self._bestp[edge.lhs()]</span>
<span class="c1">#</span>
<span class="c1">#     def sort_queue(self, queue, chart):</span>
<span class="c1">#         queue.sort(key=self._sortkey)</span>


<div class="viewcode-block" id="RandomChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.RandomChartParser">[docs]</a><span class="k">class</span> <span class="nc">RandomChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries edges in random order.</span>
<span class="sd">    This sorting order results in a random search strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Inherit constructor</span>
<div class="viewcode-block" id="RandomChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.RandomChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">queue</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">queue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="UnsortedChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.UnsortedChartParser">[docs]</a><span class="k">class</span> <span class="nc">UnsortedChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries edges in whatever order.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Inherit constructor</span>
<div class="viewcode-block" id="UnsortedChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.UnsortedChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="k">return</span></div></div>


<div class="viewcode-block" id="LongestChartParser"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.LongestChartParser">[docs]</a><span class="k">class</span> <span class="nc">LongestChartParser</span><span class="p">(</span><span class="n">BottomUpProbabilisticChartParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A bottom-up parser for ``PCFG`` grammars that tries longer edges before</span>
<span class="sd">    shorter ones.  This sorting order results in a type of best-first</span>
<span class="sd">    search strategy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Inherit constructor</span>
<div class="viewcode-block" id="LongestChartParser.sort_queue"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.LongestChartParser.sort_queue">[docs]</a>    <span class="k">def</span> <span class="nf">sort_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">chart</span><span class="p">):</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">edge</span><span class="p">:</span> <span class="n">edge</span><span class="o">.</span><span class="n">length</span><span class="p">())</span></div></div>


<span class="c1">##//////////////////////////////////////////////////////</span>
<span class="c1">##  Test Code</span>
<span class="c1">##//////////////////////////////////////////////////////</span>


<div class="viewcode-block" id="demo"><a class="viewcode-back" href="../../../api/nltk.parse.pchart.html#nltk.parse.demo">[docs]</a><span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">choice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">draw_parses</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">print_parses</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A demonstration of the probabilistic parsers.  The user is</span>
<span class="sd">    prompted to select which demo to run, and how many parses should</span>
<span class="sd">    be found; and then each parser is run on the same demo, and a</span>
<span class="sd">    summary of the results are displayed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">tokenize</span>
    <span class="kn">from</span> <span class="nn">nltk.parse</span> <span class="kn">import</span> <span class="n">pchart</span>

    <span class="c1"># Define two demos.  Each demo has a sentence and a grammar.</span>
    <span class="n">toy_pcfg1</span> <span class="o">=</span> <span class="n">PCFG</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    S -&gt; NP VP [1.0]</span>
<span class="sd">    NP -&gt; Det N [0.5] | NP PP [0.25] | &#39;John&#39; [0.1] | &#39;I&#39; [0.15]</span>
<span class="sd">    Det -&gt; &#39;the&#39; [0.8] | &#39;my&#39; [0.2]</span>
<span class="sd">    N -&gt; &#39;man&#39; [0.5] | &#39;telescope&#39; [0.5]</span>
<span class="sd">    VP -&gt; VP PP [0.1] | V NP [0.7] | V [0.2]</span>
<span class="sd">    V -&gt; &#39;ate&#39; [0.35] | &#39;saw&#39; [0.65]</span>
<span class="sd">    PP -&gt; P NP [1.0]</span>
<span class="sd">    P -&gt; &#39;with&#39; [0.61] | &#39;under&#39; [0.39]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="n">toy_pcfg2</span> <span class="o">=</span> <span class="n">PCFG</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    S    -&gt; NP VP         [1.0]</span>
<span class="sd">    VP   -&gt; V NP          [.59]</span>
<span class="sd">    VP   -&gt; V             [.40]</span>
<span class="sd">    VP   -&gt; VP PP         [.01]</span>
<span class="sd">    NP   -&gt; Det N         [.41]</span>
<span class="sd">    NP   -&gt; Name          [.28]</span>
<span class="sd">    NP   -&gt; NP PP         [.31]</span>
<span class="sd">    PP   -&gt; P NP          [1.0]</span>
<span class="sd">    V    -&gt; &#39;saw&#39;         [.21]</span>
<span class="sd">    V    -&gt; &#39;ate&#39;         [.51]</span>
<span class="sd">    V    -&gt; &#39;ran&#39;         [.28]</span>
<span class="sd">    N    -&gt; &#39;boy&#39;         [.11]</span>
<span class="sd">    N    -&gt; &#39;cookie&#39;      [.12]</span>
<span class="sd">    N    -&gt; &#39;table&#39;       [.13]</span>
<span class="sd">    N    -&gt; &#39;telescope&#39;   [.14]</span>
<span class="sd">    N    -&gt; &#39;hill&#39;        [.5]</span>
<span class="sd">    Name -&gt; &#39;Jack&#39;        [.52]</span>
<span class="sd">    Name -&gt; &#39;Bob&#39;         [.48]</span>
<span class="sd">    P    -&gt; &#39;with&#39;        [.61]</span>
<span class="sd">    P    -&gt; &#39;under&#39;       [.39]</span>
<span class="sd">    Det  -&gt; &#39;the&#39;         [.41]</span>
<span class="sd">    Det  -&gt; &#39;a&#39;           [.31]</span>
<span class="sd">    Det  -&gt; &#39;my&#39;          [.28]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="n">demos</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;I saw John with my telescope&quot;</span><span class="p">,</span> <span class="n">toy_pcfg1</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;the boy saw Jack with Bob under the table with a telescope&quot;</span><span class="p">,</span> <span class="n">toy_pcfg2</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">choice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Ask the user which demo they want to use.</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">demos</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">demos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;     </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">demos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Which demo (</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">)? &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">demos</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="n">choice</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sent</span><span class="p">,</span> <span class="n">grammar</span> <span class="o">=</span> <span class="n">demos</span><span class="p">[</span><span class="n">choice</span><span class="p">]</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bad sentence number&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Tokenize the sentence.</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="n">sent</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="c1"># Define a list of parsers.  We&#39;ll use all parsers.</span>
    <span class="n">parsers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">InsideChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">RandomChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">UnsortedChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">LongestChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">),</span>
        <span class="n">pchart</span><span class="o">.</span><span class="n">InsideChartParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">beam_size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>  <span class="c1"># was BeamParser</span>
    <span class="p">]</span>

    <span class="c1"># Run the parsers on the tokenized sentence.</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">average_p</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_parses</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_parses</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">parser</span> <span class="ow">in</span> <span class="n">parsers</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">s: </span><span class="si">{</span><span class="n">sent</span><span class="si">}</span><span class="se">\n</span><span class="s2">parser: </span><span class="si">{</span><span class="n">parser</span><span class="si">}</span><span class="se">\n</span><span class="s2">grammar: </span><span class="si">{</span><span class="n">grammar</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">parses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">))</span>
        <span class="n">times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">prob</span><span class="p">(),</span> <span class="n">parses</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span> <span class="k">if</span> <span class="n">parses</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">average_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">num_parses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span>
            <span class="n">all_parses</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">freeze</span><span class="p">()]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Print some summary statistics</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;       Parser      Beam | Time (secs)   # Parses   Average P(parse)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------------------------+------------------------------------------&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parsers</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">%18s</span><span class="s2"> </span><span class="si">%4d</span><span class="s2"> |</span><span class="si">%11.4f%11d%19.14f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="n">parsers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">parsers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">beam_size</span><span class="p">,</span>
                <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">num_parses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">average_p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">parses</span> <span class="o">=</span> <span class="n">all_parses</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">parses</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">prob</span><span class="p">(),</span> <span class="n">parses</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;------------------------+------------------------------------------&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%18s</span><span class="s2">      |</span><span class="si">%11s%11d%19.14f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;(All Parses)&quot;</span><span class="p">,</span> <span class="s2">&quot;n/a&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">parses</span><span class="p">),</span> <span class="n">p</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">draw_parses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Ask the user if we should draw the parses.</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Draw parses (y/n)? &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="n">draw_parses</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">draw_parses</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">nltk.draw.tree</span> <span class="kn">import</span> <span class="n">draw_trees</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  please wait...&quot;</span><span class="p">)</span>
        <span class="n">draw_trees</span><span class="p">(</span><span class="o">*</span><span class="n">parses</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_parses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Ask the user if we should print the parses.</span>
        <span class="nb">print</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Print parses (y/n)? &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="n">print_parses</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">print_parses</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">parse</span> <span class="ow">in</span> <span class="n">parses</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">parse</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>