<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.corpus.reader.xmldocs</title>
  

  <link rel="stylesheet" href="../../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.corpus.reader.xmldocs</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: XML Corpus Reader</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Corpus reader for corpora whose documents are xml files.</span>

<span class="sd">(note -- not named &#39;xml&#39; to avoid conflicting w/ standard xml package)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">from</span> <span class="nn">xml.etree</span> <span class="kn">import</span> <span class="n">ElementTree</span>

<span class="kn">from</span> <span class="nn">nltk.corpus.reader.api</span> <span class="kn">import</span> <span class="n">CorpusReader</span>
<span class="kn">from</span> <span class="nn">nltk.corpus.reader.util</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">nltk.data</span> <span class="kn">import</span> <span class="n">SeekableUnicodeStreamReader</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">ElementWrapper</span>
<span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">WordPunctTokenizer</span>


<div class="viewcode-block" id="XMLCorpusReader"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusReader">[docs]</a><span class="k">class</span> <span class="nc">XMLCorpusReader</span><span class="p">(</span><span class="n">CorpusReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Corpus reader for corpora whose documents are xml files.</span>

<span class="sd">    Note that the ``XMLCorpusReader`` constructor does not take an</span>
<span class="sd">    ``encoding`` argument, because the unicode encoding is specified by</span>
<span class="sd">    the XML files themselves.  See the XML specs for more info.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="XMLCorpusReader.__init__"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusReader.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">,</span> <span class="n">wrap_etree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_etree</span> <span class="o">=</span> <span class="n">wrap_etree</span>
        <span class="n">CorpusReader</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">)</span></div>

<div class="viewcode-block" id="XMLCorpusReader.xml"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusReader.xml">[docs]</a>    <span class="k">def</span> <span class="nf">xml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Make sure we have exactly one file -- no concatenating XML.</span>
        <span class="k">if</span> <span class="n">fileid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fileids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">fileid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fileids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileid</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a single file identifier string&quot;</span><span class="p">)</span>
        <span class="c1"># Read the XML in using ElementTree.</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">elt</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
        <span class="c1"># If requested, wrap it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_etree</span><span class="p">:</span>
            <span class="n">elt</span> <span class="o">=</span> <span class="n">ElementWrapper</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
        <span class="c1"># Return the ElementTree element.</span>
        <span class="k">return</span> <span class="n">elt</span></div>

<div class="viewcode-block" id="XMLCorpusReader.words"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusReader.words">[docs]</a>    <span class="k">def</span> <span class="nf">words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all of the words and punctuation symbols in the specified file</span>
<span class="sd">        that were in text nodes -- ie, tags are ignored. Like the xml() method,</span>
<span class="sd">        fileid can only specify one file.</span>

<span class="sd">        :return: the given file&#39;s text nodes as a list of words and punctuation symbols</span>
<span class="sd">        :rtype: list(str)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">elt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xml</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
        <span class="n">encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
        <span class="n">word_tokenizer</span> <span class="o">=</span> <span class="n">WordPunctTokenizer</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">getiterator</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="n">elt</span><span class="o">.</span><span class="n">iter</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">text</span>
            <span class="k">if</span> <span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="n">toks</span> <span class="o">=</span> <span class="n">word_tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">toks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div></div>


<div class="viewcode-block" id="XMLCorpusView"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusView">[docs]</a><span class="k">class</span> <span class="nc">XMLCorpusView</span><span class="p">(</span><span class="n">StreamBackedCorpusView</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A corpus view that selects out specified elements from an XML</span>
<span class="sd">    file, and provides a flat list-like interface for accessing them.</span>
<span class="sd">    (Note: ``XMLCorpusView`` is not used by ``XMLCorpusReader`` itself,</span>
<span class="sd">    but may be used by subclasses of ``XMLCorpusReader``.)</span>

<span class="sd">    Every XML corpus view has a &quot;tag specification&quot;, indicating what</span>
<span class="sd">    XML elements should be included in the view; and each (non-nested)</span>
<span class="sd">    element that matches this specification corresponds to one item in</span>
<span class="sd">    the view.  Tag specifications are regular expressions over tag</span>
<span class="sd">    paths, where a tag path is a list of element tag names, separated</span>
<span class="sd">    by &#39;/&#39;, indicating the ancestry of the element.  Some examples:</span>

<span class="sd">      - ``&#39;foo&#39;``: A top-level element whose tag is ``foo``.</span>
<span class="sd">      - ``&#39;foo/bar&#39;``: An element whose tag is ``bar`` and whose parent</span>
<span class="sd">        is a top-level element whose tag is ``foo``.</span>
<span class="sd">      - ``&#39;.*/foo&#39;``: An element whose tag is ``foo``, appearing anywhere</span>
<span class="sd">        in the xml tree.</span>
<span class="sd">      - ``&#39;.*/(foo|bar)&#39;``: An wlement whose tag is ``foo`` or ``bar``,</span>
<span class="sd">        appearing anywhere in the xml tree.</span>

<span class="sd">    The view items are generated from the selected XML elements via</span>
<span class="sd">    the method ``handle_elt()``.  By default, this method returns the</span>
<span class="sd">    element as-is (i.e., as an ElementTree object); but it can be</span>
<span class="sd">    overridden, either via subclassing or via the ``elt_handler``</span>
<span class="sd">    constructor parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#: If true, then display debugging output to stdout when reading</span>
    <span class="c1">#: blocks.</span>
    <span class="n">_DEBUG</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#: The number of characters read at a time by this corpus reader.</span>
    <span class="n">_BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">1024</span>

<div class="viewcode-block" id="XMLCorpusView.__init__"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusView.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="p">,</span> <span class="n">tagspec</span><span class="p">,</span> <span class="n">elt_handler</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new corpus view based on a specified XML file.</span>

<span class="sd">        Note that the ``XMLCorpusView`` constructor does not take an</span>
<span class="sd">        ``encoding`` argument, because the unicode encoding is</span>
<span class="sd">        specified by the XML files themselves.</span>

<span class="sd">        :type tagspec: str</span>
<span class="sd">        :param tagspec: A tag specification, indicating what XML</span>
<span class="sd">            elements should be included in the view.  Each non-nested</span>
<span class="sd">            element that matches this specification corresponds to one</span>
<span class="sd">            item in the view.</span>

<span class="sd">        :param elt_handler: A function used to transform each element</span>
<span class="sd">            to a value for the view.  If no handler is specified, then</span>
<span class="sd">            ``self.handle_elt()`` is called, which returns the element</span>
<span class="sd">            as an ElementTree object.  The signature of elt_handler is::</span>

<span class="sd">                elt_handler(elt, tagspec) -&gt; value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">elt_handler</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle_elt</span> <span class="o">=</span> <span class="n">elt_handler</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tagspec</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">tagspec</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;\Z&quot;</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;The tag specification for this corpus view.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tag_context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">()}</span>
        <span class="sd">&quot;&quot;&quot;A dictionary mapping from file positions (as returned by</span>
<span class="sd">           ``stream.seek()`` to XML contexts.  An XML context is a</span>
<span class="sd">           tuple of XML tag names, indicating which tags have not yet</span>
<span class="sd">           been closed.&quot;&quot;&quot;</span>

        <span class="n">encoding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detect_encoding</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
        <span class="n">StreamBackedCorpusView</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_detect_encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileid</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileid</span><span class="p">,</span> <span class="n">PathPointer</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">infile</span> <span class="o">=</span> <span class="n">fileid</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">infile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileid</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_BE</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;utf-16-be&quot;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF16_LE</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;utf-16-le&quot;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_BE</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;utf-32-be&quot;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF32_LE</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;utf-32-le&quot;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">codecs</span><span class="o">.</span><span class="n">BOM_UTF8</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;utf-8&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">rb</span><span class="s1">&#39;\s*&lt;\?xml\b.*\bencoding=&quot;([^&quot;]+)&quot;&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">rb</span><span class="s2">&quot;\s*&lt;\?xml\b.*\bencoding=&#39;([^&#39;]+)&#39;&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="c1"># No encoding found -- what should the default be?</span>
        <span class="k">return</span> <span class="s2">&quot;utf-8&quot;</span>

<div class="viewcode-block" id="XMLCorpusView.handle_elt"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusView.handle_elt">[docs]</a>    <span class="k">def</span> <span class="nf">handle_elt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elt</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert an element into an appropriate value for inclusion in</span>
<span class="sd">        the view.  Unless overridden by a subclass or by the</span>
<span class="sd">        ``elt_handler`` constructor argument, this method simply</span>
<span class="sd">        returns ``elt``.</span>

<span class="sd">        :return: The view value corresponding to ``elt``.</span>

<span class="sd">        :type elt: ElementTree</span>
<span class="sd">        :param elt: The element that should be converted.</span>

<span class="sd">        :type context: str</span>
<span class="sd">        :param context: A string composed of element tags separated by</span>
<span class="sd">            forward slashes, indicating the XML context of the given</span>
<span class="sd">            element.  For example, the string ``&#39;foo/bar/baz&#39;``</span>
<span class="sd">            indicates that the element is a ``baz`` element whose</span>
<span class="sd">            parent is a ``bar`` element and whose grandparent is a</span>
<span class="sd">            top-level ``foo`` element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">elt</span></div>

    <span class="c1">#: A regular expression that matches XML fragments that do not</span>
    <span class="c1">#: contain any un-closed tags.</span>
    <span class="n">_VALID_XML_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        [^&lt;]*</span>
<span class="sd">        (</span>
<span class="sd">          ((&lt;!--.*?--&gt;)                         |  # comment</span>
<span class="sd">           (&lt;![CDATA[.*?]])                     |  # raw character data</span>
<span class="sd">           (&lt;!DOCTYPE\s+[^\[]*(\[[^\]]*])?\s*&gt;) |  # doctype decl</span>
<span class="sd">           (&lt;[^!&gt;][^&gt;]*&gt;))                         # tag or PI</span>
<span class="sd">          [^&lt;]*)*</span>
<span class="sd">        \Z&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1">#: A regular expression used to extract the tag name from a start tag,</span>
    <span class="c1">#: end tag, or empty-elt tag string.</span>
    <span class="n">_XML_TAG_NAME</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&lt;\s*(?:/\s*)?([^\s&gt;]+)&quot;</span><span class="p">)</span>

    <span class="c1">#: A regular expression used to find all start-tags, end-tags, and</span>
    <span class="c1">#: empty-elt tags in an XML file.  This regexp is more lenient than</span>
    <span class="c1">#: the XML spec -- e.g., it allows spaces in some places where the</span>
    <span class="c1">#: spec does not.</span>
    <span class="n">_XML_PIECE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        # Include these so we can skip them:</span>
<span class="sd">        (?P&lt;COMMENT&gt;        &lt;!--.*?--&gt;                          )|</span>
<span class="sd">        (?P&lt;CDATA&gt;          &lt;![CDATA[.*?]]&gt;                     )|</span>
<span class="sd">        (?P&lt;PI&gt;             &lt;\?.*?\?&gt;                           )|</span>
<span class="sd">        (?P&lt;DOCTYPE&gt;        &lt;!DOCTYPE\s+[^\[^&gt;]*(\[[^\]]*])?\s*&gt;)|</span>
<span class="sd">        # These are the ones we actually care about:</span>
<span class="sd">        (?P&lt;EMPTY_ELT_TAG&gt;  &lt;\s*[^&gt;/\?!\s][^&gt;]*/\s*&gt;            )|</span>
<span class="sd">        (?P&lt;START_TAG&gt;      &lt;\s*[^&gt;/\?!\s][^&gt;]*&gt;                )|</span>
<span class="sd">        (?P&lt;END_TAG&gt;        &lt;\s*/[^&gt;/\?!\s][^&gt;]*&gt;               )&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">VERBOSE</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_xml_fragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read a string from the given stream that does not contain any</span>
<span class="sd">        un-closed tags.  In particular, this function first reads a</span>
<span class="sd">        block from the stream of size ``self._BLOCK_SIZE``.  It then</span>
<span class="sd">        checks if that block contains an un-closed tag.  If it does,</span>
<span class="sd">        then this function either backtracks to the last &#39;&lt;&#39;, or reads</span>
<span class="sd">        another block.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fragment</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">SeekableUnicodeStreamReader</span><span class="p">):</span>
            <span class="n">startpos</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Read a block and add it to the fragment.</span>
            <span class="n">xml_block</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_BLOCK_SIZE</span><span class="p">)</span>
            <span class="n">fragment</span> <span class="o">+=</span> <span class="n">xml_block</span>

            <span class="c1"># Do we have a well-formed xml fragment?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VALID_XML_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fragment</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fragment</span>

            <span class="c1"># Do we have a fragment that will never be well-formed?</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;[&lt;&gt;]&quot;</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span> <span class="o">-</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;[&lt;&gt;]&quot;</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unexpected &quot;&gt;&quot; near char </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">pos</span><span class="p">)</span>

            <span class="c1"># End of file?</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">xml_block</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected end of file: tag not closed&quot;</span><span class="p">)</span>

            <span class="c1"># If not, then we must be in the middle of a &lt;..tag..&gt;.</span>
            <span class="c1"># If appropriate, backtrack to the most recent &#39;&lt;&#39;</span>
            <span class="c1"># character.</span>
            <span class="n">last_open_bracket</span> <span class="o">=</span> <span class="n">fragment</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">last_open_bracket</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_VALID_XML_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">fragment</span><span class="p">[:</span><span class="n">last_open_bracket</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">SeekableUnicodeStreamReader</span><span class="p">):</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">startpos</span><span class="p">)</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">char_seek_forward</span><span class="p">(</span><span class="n">last_open_bracket</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span> <span class="o">-</span> <span class="n">last_open_bracket</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">fragment</span><span class="p">[:</span><span class="n">last_open_bracket</span><span class="p">]</span>

            <span class="c1"># Otherwise, read another block. (i.e., return to the</span>
            <span class="c1"># top of the loop.)</span>

<div class="viewcode-block" id="XMLCorpusView.read_block"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.xmldocs.html#nltk.corpus.reader.XMLCorpusView.read_block">[docs]</a>    <span class="k">def</span> <span class="nf">read_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">tagspec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elt_handler</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read from ``stream`` until we find at least one element that</span>
<span class="sd">        matches ``tagspec``, and return the result of applying</span>
<span class="sd">        ``elt_handler`` to each element found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tagspec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tagspec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tagspec</span>
        <span class="k">if</span> <span class="n">elt_handler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elt_handler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_elt</span>

        <span class="c1"># Use a stack of strings to keep track of our context:</span>
        <span class="n">context</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tag_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()))</span>
        <span class="k">assert</span> <span class="n">context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># check this -- could it ever happen?</span>

        <span class="n">elts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">elt_start</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># where does the elt start</span>
        <span class="n">elt_depth</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># what context depth</span>
        <span class="n">elt_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">while</span> <span class="n">elts</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">elt_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">SeekableUnicodeStreamReader</span><span class="p">):</span>
                <span class="n">startpos</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="n">xml_fragment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_xml_fragment</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>

            <span class="c1"># End of file.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">xml_fragment</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elt_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected end of file&quot;</span><span class="p">)</span>

            <span class="c1"># Process each &lt;tag&gt; in the xml fragment.</span>
            <span class="k">for</span> <span class="n">piece</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_XML_PIECE</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">xml_fragment</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEBUG</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:&gt;25}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">)[</span><span class="o">-</span><span class="mi">20</span><span class="p">:],</span> <span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">()))</span>

                <span class="k">if</span> <span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;START_TAG&quot;</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_XML_TAG_NAME</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">())</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># Keep context up-to-date.</span>
                    <span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="c1"># Is this one of the elts we&#39;re looking for?</span>
                    <span class="k">if</span> <span class="n">elt_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tagspec</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">)):</span>
                            <span class="n">elt_start</span> <span class="o">=</span> <span class="n">piece</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                            <span class="n">elt_depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;END_TAG&quot;</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_XML_TAG_NAME</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">())</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># sanity checks:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unmatched tag &lt;/</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">context</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unmatched tag &lt;</span><span class="si">{</span><span class="n">context</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&gt;...&lt;/</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&gt;&quot;</span><span class="p">)</span>
                    <span class="c1"># Is this the end of an element?</span>
                    <span class="k">if</span> <span class="n">elt_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">elt_depth</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
                        <span class="n">elt_text</span> <span class="o">+=</span> <span class="n">xml_fragment</span><span class="p">[</span><span class="n">elt_start</span> <span class="p">:</span> <span class="n">piece</span><span class="o">.</span><span class="n">end</span><span class="p">()]</span>
                        <span class="n">elts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">elt_text</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">)))</span>
                        <span class="n">elt_start</span> <span class="o">=</span> <span class="n">elt_depth</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">elt_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                    <span class="c1"># Keep context up-to-date</span>
                    <span class="n">context</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="k">elif</span> <span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;EMPTY_ELT_TAG&quot;</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_XML_TAG_NAME</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">())</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">elt_start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tagspec</span><span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">):</span>
                            <span class="n">elts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">piece</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">elt_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If we haven&#39;t found any elements yet, then keep</span>
                <span class="c1"># looping until we do.</span>
                <span class="k">if</span> <span class="n">elts</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="n">elt_text</span> <span class="o">+=</span> <span class="n">xml_fragment</span><span class="p">[</span><span class="n">elt_start</span><span class="p">:]</span>
                    <span class="n">elt_start</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># If we&#39;ve found at least one element, then try</span>
                <span class="c1"># backtracking to the start of the element that we&#39;re</span>
                <span class="c1"># inside of.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># take back the last start-tag, and return what</span>
                    <span class="c1"># we&#39;ve gotten so far (elts is non-empty).</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_DEBUG</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">36</span> <span class="o">+</span> <span class="s2">&quot;(backtrack)&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">SeekableUnicodeStreamReader</span><span class="p">):</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">startpos</span><span class="p">)</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">char_seek_forward</span><span class="p">(</span><span class="n">elt_start</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xml_fragment</span><span class="p">)</span> <span class="o">-</span> <span class="n">elt_start</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="p">[:</span> <span class="n">elt_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">elt_start</span> <span class="o">=</span> <span class="n">elt_depth</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">elt_text</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Update the _tag_context dict.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_context</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag_context</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tag_context</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="n">elt_handler</span><span class="p">(</span>
                <span class="n">ElementTree</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">elt</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">,</span> <span class="s2">&quot;xmlcharrefreplace&quot;</span><span class="p">)),</span>
                <span class="n">context</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="ow">in</span> <span class="n">elts</span>
        <span class="p">]</span></div></div>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>