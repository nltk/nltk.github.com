<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>NLTK :: nltk.corpus.reader.wordnet</title>
  

  <link rel="stylesheet" href="../../../../_static/css/nltk_theme.css"/>
  <link rel="stylesheet" href="../../../../_static/css/custom.css"/>

  <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../../_static/documentation_options.js"></script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
  

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script> 
</head>

<body>
  <div id="nltk-theme-container">
    <header>
      <div id="logo-container">
          
          <h1>
            <a href="../../../../index.html">NLTK</a>
          </h1>
          
      </div>
      <div id="project-container">
        
        <h1>Documentation</h1>
        
      </div>

      <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

      <script type="text/javascript">
        $("#menu-toggle").click(function() {
          $("#menu-toggle").toggleClass("toggled");
          $("#side-menu-container").slideToggle(300);
        });
      </script>
    </header>

    <div id="content-container">

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">
          
  
    
  
  
    <p class="caption" role="heading"><span class="caption-text">NLTK Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/nltk.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../howto.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../py-modindex.html">Module Index</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/issues">Open Issues</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk">NLTK on GitHub</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../data.html">Installing NLTK Data</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../news.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribute.html">Contributing to NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../team.html">NLTK Team</a></li>
</ul>

  

        </div>

        
      </div>

      <div id="main-content-container">
        <div id="main-content" role="main">
          
  <h1>Source code for nltk.corpus.reader.wordnet</h1><div class="highlight"><pre>
<span></span><span class="c1"># Natural Language Toolkit: WordNet</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2001-2023 NLTK Project</span>
<span class="c1"># Author: Steven Bethard &lt;Steven.Bethard@colorado.edu&gt;</span>
<span class="c1">#         Steven Bird &lt;stevenbird1@gmail.com&gt;</span>
<span class="c1">#         Edward Loper &lt;edloper@gmail.com&gt;</span>
<span class="c1">#         Nitin Madnani &lt;nmadnani@ets.org&gt;</span>
<span class="c1">#         Nasruddin Aâ€™aidil Shari</span>
<span class="c1">#         Sim Wei Ying Geraldine</span>
<span class="c1">#         Soe Lynn</span>
<span class="c1">#         Francis Bond &lt;bond@ieee.org&gt;</span>
<span class="c1">#         Eric Kafe &lt;kafe.eric@gmail.com&gt;</span>

<span class="c1"># URL: &lt;https://www.nltk.org/&gt;</span>
<span class="c1"># For license information, see LICENSE.TXT</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An NLTK interface for WordNet</span>

<span class="sd">WordNet is a lexical database of English.</span>
<span class="sd">Using synsets, helps find conceptual relationships between words</span>
<span class="sd">such as hypernyms, hyponyms, synonyms, antonyms etc.</span>

<span class="sd">For details about WordNet see:</span>
<span class="sd">https://wordnet.princeton.edu/</span>

<span class="sd">This module also allows you to find lemmas in languages</span>
<span class="sd">other than English from the Open Multilingual Wordnet</span>
<span class="sd">https://omwn.org/</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="kn">from</span> <span class="nn">nltk.corpus.reader</span> <span class="kn">import</span> <span class="n">CorpusReader</span>
<span class="kn">from</span> <span class="nn">nltk.internals</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">nltk.probability</span> <span class="kn">import</span> <span class="n">FreqDist</span>
<span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">binary_search_file</span> <span class="k">as</span> <span class="n">_binary_search_file</span>

<span class="c1">######################################################################</span>
<span class="c1"># Table of Contents</span>
<span class="c1">######################################################################</span>
<span class="c1"># - Constants</span>
<span class="c1"># - Data Classes</span>
<span class="c1">#   - WordNetError</span>
<span class="c1">#   - Lemma</span>
<span class="c1">#   - Synset</span>
<span class="c1"># - WordNet Corpus Reader</span>
<span class="c1"># - WordNet Information Content Corpus Reader</span>
<span class="c1"># - Similarity Metrics</span>
<span class="c1"># - Demo</span>

<span class="c1">######################################################################</span>
<span class="c1"># Constants</span>
<span class="c1">######################################################################</span>

<span class="c1">#: Positive infinity (for similarity functions)</span>
<span class="n">_INF</span> <span class="o">=</span> <span class="mf">1e300</span>

<span class="c1"># { Part-of-speech constants</span>
<span class="n">ADJ</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">,</span> <span class="n">ADV</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span>
<span class="c1"># }</span>

<span class="n">POS_LIST</span> <span class="o">=</span> <span class="p">[</span><span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span><span class="p">,</span> <span class="n">ADJ</span><span class="p">,</span> <span class="n">ADV</span><span class="p">]</span>

<span class="c1"># A table of strings that are used to express verb frames.</span>
<span class="n">VERB_FRAME_STRINGS</span> <span class="o">=</span> <span class="p">(</span>
    <span class="kc">None</span><span class="p">,</span>
    <span class="s2">&quot;Something </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;It is </span><span class="si">%s</span><span class="s2">ing&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Something is </span><span class="si">%s</span><span class="s2">ing PP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Something </span><span class="si">%s</span><span class="s2"> something Adjective/Noun&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Something </span><span class="si">%s</span><span class="s2"> Adjective/Noun&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> Adjective&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Something </span><span class="si">%s</span><span class="s2"> somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Something </span><span class="si">%s</span><span class="s2"> something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Something </span><span class="si">%s</span><span class="s2"> to somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> on something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> something to somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> something from somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody with something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody of something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> something on somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody PP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> something PP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> PP&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody&#39;s (body part) </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody to INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> that CLAUSE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> to somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> to INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> whether INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> somebody into V-ing something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> something with something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> INFINITIVE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> VERB-ing&quot;</span><span class="p">,</span>
    <span class="s2">&quot;It </span><span class="si">%s</span><span class="s2"> that CLAUSE&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Something </span><span class="si">%s</span><span class="s2"> INFINITIVE&quot;</span><span class="p">,</span>
    <span class="c1"># OEWN additions:</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> at something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> for something&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> on somebody&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Somebody </span><span class="si">%s</span><span class="s2"> out of somebody&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">SENSENUM_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\.[\d]+\.&quot;</span><span class="p">)</span>


<span class="c1">######################################################################</span>
<span class="c1"># Data Classes</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="WordNetError"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetError">[docs]</a><span class="k">class</span> <span class="nc">WordNetError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An exception class for wordnet-related errors.&quot;&quot;&quot;</span></div>


<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">_WordNetObject</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A common base class for lemmas and synsets.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;@&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">instance_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;@i&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_instance_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;@i&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hyponyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">instance_hyponyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;~i&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">member_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;#m&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">substance_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;#s&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">part_holonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;#p&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">member_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;%m&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">substance_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">part_meronyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;%p&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">topic_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;;c&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_topic_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;-c&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">region_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;;r&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_region_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;-r&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">usage_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;;u&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">in_usage_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;-u&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">entailments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">causes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">also_sees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verb_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;$&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">similar_tos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span>


<div class="viewcode-block" id="Lemma"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma">[docs]</a><span class="k">class</span> <span class="nc">Lemma</span><span class="p">(</span><span class="n">_WordNetObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The lexical entry for a single morphological form of a</span>
<span class="sd">    sense-disambiguated word.</span>

<span class="sd">    Create a Lemma from a &quot;&lt;word&gt;.&lt;pos&gt;.&lt;number&gt;.&lt;lemma&gt;&quot; string where:</span>
<span class="sd">    &lt;word&gt; is the morphological stem identifying the synset</span>
<span class="sd">    &lt;pos&gt; is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB</span>
<span class="sd">    &lt;number&gt; is the sense number, counting from 0.</span>
<span class="sd">    &lt;lemma&gt; is the morphological form of interest</span>

<span class="sd">    Note that &lt;word&gt; and &lt;lemma&gt; can be different, e.g. the Synset</span>
<span class="sd">    &#39;salt.n.03&#39; has the Lemmas &#39;salt.n.03.salt&#39;, &#39;salt.n.03.saltiness&#39; and</span>
<span class="sd">    &#39;salt.n.03.salinity&#39;.</span>

<span class="sd">    Lemma attributes, accessible via methods with the same name:</span>

<span class="sd">    - name: The canonical name of this lemma.</span>
<span class="sd">    - synset: The synset that this lemma belongs to.</span>
<span class="sd">    - syntactic_marker: For adjectives, the WordNet string identifying the</span>
<span class="sd">      syntactic position relative modified noun. See:</span>
<span class="sd">      https://wordnet.princeton.edu/documentation/wninput5wn</span>
<span class="sd">      For all other parts of speech, this attribute is None.</span>
<span class="sd">    - count: The frequency of this lemma in wordnet.</span>

<span class="sd">    Lemma methods:</span>

<span class="sd">    Lemmas have the following methods for retrieving related Lemmas. They</span>
<span class="sd">    correspond to the names for the pointer symbols defined here:</span>
<span class="sd">    https://wordnet.princeton.edu/documentation/wninput5wn</span>
<span class="sd">    These methods all return lists of Lemmas:</span>

<span class="sd">    - antonyms</span>
<span class="sd">    - hypernyms, instance_hypernyms</span>
<span class="sd">    - hyponyms, instance_hyponyms</span>
<span class="sd">    - member_holonyms, substance_holonyms, part_holonyms</span>
<span class="sd">    - member_meronyms, substance_meronyms, part_meronyms</span>
<span class="sd">    - topic_domains, region_domains, usage_domains</span>
<span class="sd">    - attributes</span>
<span class="sd">    - derivationally_related_forms</span>
<span class="sd">    - entailments</span>
<span class="sd">    - causes</span>
<span class="sd">    - also_sees</span>
<span class="sd">    - verb_groups</span>
<span class="sd">    - similar_tos</span>
<span class="sd">    - pertainyms</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_wordnet_corpus_reader&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_syntactic_marker&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_synset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_frame_strings&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_frame_ids&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lexname_index&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lex_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lang&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_key&quot;</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="Lemma.__init__"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">wordnet_corpus_reader</span><span class="p">,</span>
        <span class="n">synset</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">lexname_index</span><span class="p">,</span>
        <span class="n">lex_id</span><span class="p">,</span>
        <span class="n">syntactic_marker</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span> <span class="o">=</span> <span class="n">wordnet_corpus_reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_syntactic_marker</span> <span class="o">=</span> <span class="n">syntactic_marker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span> <span class="o">=</span> <span class="n">synset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexname_index</span> <span class="o">=</span> <span class="n">lexname_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lex_id</span> <span class="o">=</span> <span class="n">lex_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang</span> <span class="o">=</span> <span class="s2">&quot;eng&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># gets set later.</span></div>

<div class="viewcode-block" id="Lemma.name"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.name">[docs]</a>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span></div>

<div class="viewcode-block" id="Lemma.syntactic_marker"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.syntactic_marker">[docs]</a>    <span class="k">def</span> <span class="nf">syntactic_marker</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_syntactic_marker</span></div>

<div class="viewcode-block" id="Lemma.synset"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.synset">[docs]</a>    <span class="k">def</span> <span class="nf">synset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span></div>

<div class="viewcode-block" id="Lemma.frame_strings"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.frame_strings">[docs]</a>    <span class="k">def</span> <span class="nf">frame_strings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_strings</span></div>

<div class="viewcode-block" id="Lemma.frame_ids"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.frame_ids">[docs]</a>    <span class="k">def</span> <span class="nf">frame_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span></div>

<div class="viewcode-block" id="Lemma.lang"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.lang">[docs]</a>    <span class="k">def</span> <span class="nf">lang</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang</span></div>

<div class="viewcode-block" id="Lemma.key"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.key">[docs]</a>    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(&#39;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="n">tup</span>

    <span class="k">def</span> <span class="nf">_related</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">):</span>
        <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span><span class="o">.</span><span class="n">_lemma_pointers</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">get_synset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="n">lemma_index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">lemma_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset</span><span class="o">.</span><span class="n">_lemma_pointers</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">relation_symbol</span>
            <span class="p">]</span>
        <span class="p">]</span>

<div class="viewcode-block" id="Lemma.count"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the frequency count for this Lemma&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">lemma_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lemma.antonyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.antonyms">[docs]</a>    <span class="k">def</span> <span class="nf">antonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;!&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lemma.derivationally_related_forms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.derivationally_related_forms">[docs]</a>    <span class="k">def</span> <span class="nf">derivationally_related_forms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lemma.pertainyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Lemma.pertainyms">[docs]</a>    <span class="k">def</span> <span class="nf">pertainyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_related</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Synset"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset">[docs]</a><span class="k">class</span> <span class="nc">Synset</span><span class="p">(</span><span class="n">_WordNetObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a Synset from a &quot;&lt;lemma&gt;.&lt;pos&gt;.&lt;number&gt;&quot; string where:</span>
<span class="sd">    &lt;lemma&gt; is the word&#39;s morphological stem</span>
<span class="sd">    &lt;pos&gt; is one of the module attributes ADJ, ADJ_SAT, ADV, NOUN or VERB</span>
<span class="sd">    &lt;number&gt; is the sense number, counting from 0.</span>

<span class="sd">    Synset attributes, accessible via methods with the same name:</span>

<span class="sd">    - name: The canonical name of this synset, formed using the first lemma</span>
<span class="sd">      of this synset. Note that this may be different from the name</span>
<span class="sd">      passed to the constructor if that string used a different lemma to</span>
<span class="sd">      identify the synset.</span>
<span class="sd">    - pos: The synset&#39;s part of speech, matching one of the module level</span>
<span class="sd">      attributes ADJ, ADJ_SAT, ADV, NOUN or VERB.</span>
<span class="sd">    - lemmas: A list of the Lemma objects for this synset.</span>
<span class="sd">    - definition: The definition for this synset.</span>
<span class="sd">    - examples: A list of example strings for this synset.</span>
<span class="sd">    - offset: The offset in the WordNet dict file of this synset.</span>
<span class="sd">    - lexname: The name of the lexicographer file containing this synset.</span>

<span class="sd">    Synset methods:</span>

<span class="sd">    Synsets have the following methods for retrieving related Synsets.</span>
<span class="sd">    They correspond to the names for the pointer symbols defined here:</span>
<span class="sd">    https://wordnet.princeton.edu/documentation/wninput5wn</span>
<span class="sd">    These methods all return lists of Synsets.</span>

<span class="sd">    - hypernyms, instance_hypernyms</span>
<span class="sd">    - hyponyms, instance_hyponyms</span>
<span class="sd">    - member_holonyms, substance_holonyms, part_holonyms</span>
<span class="sd">    - member_meronyms, substance_meronyms, part_meronyms</span>
<span class="sd">    - attributes</span>
<span class="sd">    - entailments</span>
<span class="sd">    - causes</span>
<span class="sd">    - also_sees</span>
<span class="sd">    - verb_groups</span>
<span class="sd">    - similar_tos</span>

<span class="sd">    Additionally, Synsets support the following methods specific to the</span>
<span class="sd">    hypernym relation:</span>

<span class="sd">    - root_hypernyms</span>
<span class="sd">    - common_hypernyms</span>
<span class="sd">    - lowest_common_hypernyms</span>

<span class="sd">    Note that Synsets do not support the following relations because</span>
<span class="sd">    these are defined by WordNet as lexical relations:</span>

<span class="sd">    - antonyms</span>
<span class="sd">    - derivationally_related_forms</span>
<span class="sd">    - pertainyms</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;_pos&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_frame_ids&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lemmas&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lemma_names&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_definition&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_examples&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lexname&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_pointers&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lemma_pointers&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_max_depth&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_min_depth&quot;</span><span class="p">,</span>
    <span class="p">]</span>

<div class="viewcode-block" id="Synset.__init__"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordnet_corpus_reader</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span> <span class="o">=</span> <span class="n">wordnet_corpus_reader</span>
        <span class="c1"># All of these attributes get initialized by</span>
        <span class="c1"># WordNetCorpusReader._synset_from_pos_and_line()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemmas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_definition</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_examples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexname</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># lexicographer name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pointers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.pos"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.pos">[docs]</a>    <span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span></div>

<div class="viewcode-block" id="Synset.offset"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.offset">[docs]</a>    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span></div>

<div class="viewcode-block" id="Synset.name"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.name">[docs]</a>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span></div>

<div class="viewcode-block" id="Synset.frame_ids"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.frame_ids">[docs]</a>    <span class="k">def</span> <span class="nf">frame_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_ids</span></div>

    <span class="k">def</span> <span class="nf">_doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc_type</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method for Synset.definition and Synset.examples&quot;&quot;&quot;</span>
        <span class="n">corpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">corpus</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corpus</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">of</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">ss2of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">lg_attrs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">doc_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">of</span> <span class="ow">in</span> <span class="n">corpus</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">corpus</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">of</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Synset.definition"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.definition">[docs]</a>    <span class="k">def</span> <span class="nf">definition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return definition in specified language&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc</span><span class="p">(</span><span class="s2">&quot;def&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_definition</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.examples"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.examples">[docs]</a>    <span class="k">def</span> <span class="nf">examples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return examples in specified language&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doc</span><span class="p">(</span><span class="s2">&quot;exe&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_examples</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.lexname"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.lexname">[docs]</a>    <span class="k">def</span> <span class="nf">lexname</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lexname</span></div>

    <span class="k">def</span> <span class="nf">_needs_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">NOUN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;1.6&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Synset.lemma_names"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.lemma_names">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the lemma_names associated with the synset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span>
            <span class="n">reader</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">ss2of</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reader</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">reader</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Synset.lemmas"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all the lemma objects associated with the synset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemmas</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">lemmark</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lemmy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lemma_names</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lem</span> <span class="ow">in</span> <span class="n">lemmy</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">Lemma</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="p">,</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">lem</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_lexnames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lexname</span><span class="p">()),</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="kc">None</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">_lang</span> <span class="o">=</span> <span class="n">lang</span>
                <span class="n">lemmark</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lemmark</span></div>

<div class="viewcode-block" id="Synset.root_hypernyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.root_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">root_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the topmost hypernyms of this synset in WordNet.&quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
            <span class="n">next_synset</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">next_synset</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_synset</span><span class="p">)</span>
                <span class="n">next_hypernyms</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">next_synset</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="n">next_synset</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">next_hypernyms</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_synset</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">todo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">next_hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="c1"># Simpler implementation which makes incorrect assumption that</span>
    <span class="c1"># hypernym hierarchy is acyclic:</span>
    <span class="c1">#</span>
    <span class="c1">#        if not self.hypernyms():</span>
    <span class="c1">#            return [self]</span>
    <span class="c1">#        else:</span>
    <span class="c1">#            return list(set(root for h in self.hypernyms()</span>
    <span class="c1">#                            for root in h.root_hypernyms()))</span>
<div class="viewcode-block" id="Synset.max_depth"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.max_depth">[docs]</a>    <span class="k">def</span> <span class="nf">max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The length of the longest hypernym path from this</span>
<span class="sd">            synset to the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;_max_depth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hypernyms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span></div>

<div class="viewcode-block" id="Synset.min_depth"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.min_depth">[docs]</a>    <span class="k">def</span> <span class="nf">min_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: The length of the shortest hypernym path from this</span>
<span class="sd">            synset to the root.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;_min_depth&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hypernyms</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_depth</span></div>

<div class="viewcode-block" id="Synset.closure"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.closure">[docs]</a>    <span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the transitive closure of source under the rel</span>
<span class="sd">        relationship, breadth-first, discarding cycles:</span>

<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; computer = wn.synset(&#39;computer.n.01&#39;)</span>
<span class="sd">        &gt;&gt;&gt; topic = lambda s:s.topic_domains()</span>
<span class="sd">        &gt;&gt;&gt; print(list(computer.closure(topic)))</span>
<span class="sd">        [Synset(&#39;computer_science.n.01&#39;)]</span>

<span class="sd">        UserWarning: Discarded redundant search for Synset(&#39;computer.n.01&#39;) at depth 2</span>


<span class="sd">        Include redundant paths (but only once), avoiding duplicate searches</span>
<span class="sd">        (from &#39;animal.n.01&#39; to &#39;entity.n.01&#39;):</span>

<span class="sd">        &gt;&gt;&gt; dog = wn.synset(&#39;dog.n.01&#39;)</span>
<span class="sd">        &gt;&gt;&gt; hyp = lambda s:s.hypernyms()</span>
<span class="sd">        &gt;&gt;&gt; print(list(dog.closure(hyp)))</span>
<span class="sd">        [Synset(&#39;canine.n.02&#39;), Synset(&#39;domestic_animal.n.01&#39;), Synset(&#39;carnivore.n.01&#39;),\</span>
<span class="sd"> Synset(&#39;animal.n.01&#39;), Synset(&#39;placental.n.01&#39;), Synset(&#39;organism.n.01&#39;),\</span>
<span class="sd"> Synset(&#39;mammal.n.01&#39;), Synset(&#39;living_thing.n.01&#39;), Synset(&#39;vertebrate.n.01&#39;),\</span>
<span class="sd"> Synset(&#39;whole.n.02&#39;), Synset(&#39;chordate.n.01&#39;), Synset(&#39;object.n.01&#39;),\</span>
<span class="sd"> Synset(&#39;physical_entity.n.01&#39;), Synset(&#39;entity.n.01&#39;)]</span>

<span class="sd">        UserWarning: Discarded redundant search for Synset(&#39;animal.n.01&#39;) at depth 7</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">acyclic_breadth_first</span>

        <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">acyclic_breadth_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">synset</span> <span class="o">!=</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">synset</span></div>

    <span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">acyclic_depth_first</span> <span class="k">as</span> <span class="n">acyclic_tree</span>
    <span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">unweighted_minimum_spanning_tree</span> <span class="k">as</span> <span class="n">mst</span>

    <span class="c1"># Also add this shortcut?</span>
    <span class="c1">#    from nltk.util import unweighted_minimum_spanning_digraph as umsd</span>

<div class="viewcode-block" id="Synset.tree"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.tree">[docs]</a>    <span class="k">def</span> <span class="nf">tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">cut_mark</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the full relation tree, including self,</span>
<span class="sd">        discarding cycles:</span>

<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; from pprint import pprint</span>
<span class="sd">        &gt;&gt;&gt; computer = wn.synset(&#39;computer.n.01&#39;)</span>
<span class="sd">        &gt;&gt;&gt; topic = lambda s:s.topic_domains()</span>
<span class="sd">        &gt;&gt;&gt; pprint(computer.tree(topic))</span>
<span class="sd">        [Synset(&#39;computer.n.01&#39;), [Synset(&#39;computer_science.n.01&#39;)]]</span>

<span class="sd">        UserWarning: Discarded redundant search for Synset(&#39;computer.n.01&#39;) at depth -3</span>


<span class="sd">        But keep duplicate branches (from &#39;animal.n.01&#39; to &#39;entity.n.01&#39;):</span>

<span class="sd">        &gt;&gt;&gt; dog = wn.synset(&#39;dog.n.01&#39;)</span>
<span class="sd">        &gt;&gt;&gt; hyp = lambda s:s.hypernyms()</span>
<span class="sd">        &gt;&gt;&gt; pprint(dog.tree(hyp))</span>
<span class="sd">        [Synset(&#39;dog.n.01&#39;),</span>
<span class="sd">         [Synset(&#39;canine.n.02&#39;),</span>
<span class="sd">          [Synset(&#39;carnivore.n.01&#39;),</span>
<span class="sd">           [Synset(&#39;placental.n.01&#39;),</span>
<span class="sd">            [Synset(&#39;mammal.n.01&#39;),</span>
<span class="sd">             [Synset(&#39;vertebrate.n.01&#39;),</span>
<span class="sd">              [Synset(&#39;chordate.n.01&#39;),</span>
<span class="sd">               [Synset(&#39;animal.n.01&#39;),</span>
<span class="sd">                [Synset(&#39;organism.n.01&#39;),</span>
<span class="sd">                 [Synset(&#39;living_thing.n.01&#39;),</span>
<span class="sd">                  [Synset(&#39;whole.n.02&#39;),</span>
<span class="sd">                   [Synset(&#39;object.n.01&#39;),</span>
<span class="sd">                    [Synset(&#39;physical_entity.n.01&#39;),</span>
<span class="sd">                     [Synset(&#39;entity.n.01&#39;)]]]]]]]]]]]]],</span>
<span class="sd">         [Synset(&#39;domestic_animal.n.01&#39;),</span>
<span class="sd">          [Synset(&#39;animal.n.01&#39;),</span>
<span class="sd">           [Synset(&#39;organism.n.01&#39;),</span>
<span class="sd">            [Synset(&#39;living_thing.n.01&#39;),</span>
<span class="sd">             [Synset(&#39;whole.n.02&#39;),</span>
<span class="sd">              [Synset(&#39;object.n.01&#39;),</span>
<span class="sd">               [Synset(&#39;physical_entity.n.01&#39;), [Synset(&#39;entity.n.01&#39;)]]]]]]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">acyclic_branches_depth_first</span>

        <span class="k">return</span> <span class="n">acyclic_branches_depth_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">cut_mark</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.hypernym_paths"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.hypernym_paths">[docs]</a>    <span class="k">def</span> <span class="nf">hypernym_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the path(s) from this synset to the root, where each path is a</span>
<span class="sd">        list of the synset nodes traversed on the way to the root.</span>

<span class="sd">        :return: A list of lists, where each list gives the node sequence</span>
<span class="sd">           connecting the initial ``Synset`` node and a root node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">hypernyms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypernyms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="n">hypernyms</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ancestor_list</span> <span class="ow">in</span> <span class="n">hypernym</span><span class="o">.</span><span class="n">hypernym_paths</span><span class="p">():</span>
                <span class="n">ancestor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ancestor_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span></div>

<div class="viewcode-block" id="Synset.common_hypernyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.common_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">common_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all synsets that are hypernyms of this synset and the</span>
<span class="sd">        other synset.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: other input synset.</span>
<span class="sd">        :return: The synsets that are hypernyms of both synsets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">self_synset</span>
                <span class="k">for</span> <span class="n">self_synsets</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">self_synset</span> <span class="ow">in</span> <span class="n">self_synsets</span>
            <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">_all_hypernyms</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">other_synset</span>
                <span class="k">for</span> <span class="n">other_synsets</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">other_synset</span> <span class="ow">in</span> <span class="n">other_synsets</span>
            <span class="p">}</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_all_hypernyms</span><span class="p">))</span></div>

<div class="viewcode-block" id="Synset.lowest_common_hypernyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.lowest_common_hypernyms">[docs]</a>    <span class="k">def</span> <span class="nf">lowest_common_hypernyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_min_depth</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of lowest synset(s) that both synsets have as a hypernym.</span>
<span class="sd">        When `use_min_depth == False` this means that the synset which appears</span>
<span class="sd">        as a hypernym of both `self` and `other` with the lowest maximum depth</span>
<span class="sd">        is returned or if there are multiple such synsets at the same depth</span>
<span class="sd">        they are all returned</span>

<span class="sd">        However, if `use_min_depth == True` then the synset(s) which has/have</span>
<span class="sd">        the lowest minimum depth and appear(s) in both paths is/are returned.</span>

<span class="sd">        By setting the use_min_depth flag to True, the behavior of NLTK2 can be</span>
<span class="sd">        preserved. This was changed in NLTK3 to give more accurate results in a</span>
<span class="sd">        small set of cases, generally with synsets concerning people. (eg:</span>
<span class="sd">        &#39;chef.n.01&#39;, &#39;fireman.n.01&#39;, etc.)</span>

<span class="sd">        This method is an implementation of Ted Pedersen&#39;s &quot;Lowest Common</span>
<span class="sd">        Subsumer&quot; method from the Perl Wordnet module. It can return either</span>
<span class="sd">        &quot;self&quot; or &quot;other&quot; if they are a hypernym of the other.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: other input synset</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (False by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to True to enable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will need to be added</span>
<span class="sd">            for nouns as well.</span>
<span class="sd">        :type use_min_depth: bool</span>
<span class="sd">        :param use_min_depth: This setting mimics older (v2) behavior of NLTK</span>
<span class="sd">            wordnet If True, will use the min_depth function to calculate the</span>
<span class="sd">            lowest common hypernyms. This is known to give strange results for</span>
<span class="sd">            some synset pairs (eg: &#39;chef.n.01&#39;, &#39;fireman.n.01&#39;) but is retained</span>
<span class="sd">            for backwards compatibility</span>
<span class="sd">        :return: The synsets that are the lowest common hypernyms of both</span>
<span class="sd">            synsets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">synsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_hypernyms</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;*ROOT*&quot;</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">hypernyms</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">instance_hypernyms</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[]</span>
            <span class="n">synsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fake_synset</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_min_depth</span><span class="p">:</span>
                <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">)</span>
                <span class="n">unsorted_lch</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">min_depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_depth</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">max_depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">)</span>
                <span class="n">unsorted_lch</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synsets</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="o">==</span> <span class="n">max_depth</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unsorted_lch</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Synset.hypernym_distances"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.hypernym_distances">[docs]</a>    <span class="k">def</span> <span class="nf">hypernym_distances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the path(s) from this synset to the root, counting the distance</span>
<span class="sd">        of each node from the initial node on the way. A set of</span>
<span class="sd">        (synset, distance) tuples is returned.</span>

<span class="sd">        :type distance: int</span>
<span class="sd">        :param distance: the distance (number of edges) from this hypernym to</span>
<span class="sd">            the original hypernym ``Synset`` on which this method was called.</span>
<span class="sd">        :return: A set of ``(Synset, int)`` tuples where each ``Synset`` is</span>
<span class="sd">           a hypernym of the first ``Synset``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">{(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">)}</span>
        <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance_hypernyms</span><span class="p">():</span>
            <span class="n">distances</span> <span class="o">|=</span> <span class="n">hypernym</span><span class="o">.</span><span class="n">hypernym_distances</span><span class="p">(</span><span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;*ROOT*&quot;</span>
            <span class="n">fake_synset_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">fake_synset</span><span class="p">,</span> <span class="n">fake_synset_distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">distances</span></div>

    <span class="k">def</span> <span class="nf">_shortest_hypernym_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s2">&quot;*ROOT*&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">path</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>

            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">hyp</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">_hypernyms</span><span class="p">())</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">hyp</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">hyp</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">_instance_hypernyms</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">fake_synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">fake_synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;*ROOT*&quot;</span>
            <span class="n">path</span><span class="p">[</span><span class="n">fake_synset</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">path</span>

<div class="viewcode-block" id="Synset.shortest_path_distance"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.shortest_path_distance">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the distance of the shortest path linking the two synsets (if</span>
<span class="sd">        one exists). For each synset, all the ancestor nodes and their</span>
<span class="sd">        distances are recorded and compared. The ancestor node common to both</span>
<span class="sd">        synsets that can be reached with the minimum number of traversals is</span>
<span class="sd">        used. If no ancestor nodes are common, None is returned. If a node is</span>
<span class="sd">        compared with itself 0 is returned.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: The Synset to which the shortest path will be found.</span>
<span class="sd">        :return: The number of edges in the shortest path connecting the two</span>
<span class="sd">            nodes, or None if no path exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">dist_dict1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shortest_hypernym_paths</span><span class="p">(</span><span class="n">simulate_root</span><span class="p">)</span>
        <span class="n">dist_dict2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_shortest_hypernym_paths</span><span class="p">(</span><span class="n">simulate_root</span><span class="p">)</span>

        <span class="c1"># For each ancestor synset common to both subject synsets, find the</span>
        <span class="c1"># connecting path length. Return the shortest of these.</span>

        <span class="n">inf</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">path_distance</span> <span class="o">=</span> <span class="n">inf</span>
        <span class="k">for</span> <span class="n">synset</span><span class="p">,</span> <span class="n">d1</span> <span class="ow">in</span> <span class="n">dist_dict1</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">dist_dict2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">synset</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>
            <span class="n">path_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_distance</span><span class="p">,</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">path_distance</span><span class="p">)</span> <span class="k">else</span> <span class="n">path_distance</span></div>

    <span class="c1"># interface to similarity methods</span>
<div class="viewcode-block" id="Synset.path_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.path_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Path Distance Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        shortest path that connects the senses in the is-a (hypernym/hypnoym)</span>
<span class="sd">        taxonomy. The score is in the range 0 to 1, except in those cases where</span>
<span class="sd">        a path cannot be found (will only be true for verbs as there are many</span>
<span class="sd">        distinct verb taxonomies), in which case None is returned. A score of</span>
<span class="sd">        1 represents identity i.e. comparing a sense with itself will return 1.</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well.</span>
<span class="sd">        :return: A score denoting the similarity of the two ``Synset`` objects,</span>
<span class="sd">            normally between 0 and 1. None is returned if no connecting path</span>
<span class="sd">            could be found. 1 is returned if a ``Synset`` is compared with</span>
<span class="sd">            itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.lch_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.lch_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Leacock Chodorow Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        shortest path that connects the senses (as above) and the maximum depth</span>
<span class="sd">        of the taxonomy in which the senses occur. The relationship is given as</span>
<span class="sd">        -log(p/2d) where p is the shortest path length and d is the taxonomy</span>
<span class="sd">        depth.</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well.</span>
<span class="sd">        :return: A score denoting the similarity of the two ``Synset`` objects,</span>
<span class="sd">            normally greater than 0. None is returned if no connecting path</span>
<span class="sd">            could be found. If a ``Synset`` is compared with itself, the</span>
<span class="sd">            maximum score is returned, which varies depending on the taxonomy</span>
<span class="sd">            depth.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_pos</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span>
                <span class="s2">&quot;Computing the lch similarity requires &quot;</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> to have the same part of speech.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">need_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_compute_max_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="n">need_root</span><span class="p">)</span>

        <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">distance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">distance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">depth</span><span class="p">))</span></div>

<div class="viewcode-block" id="Synset.wup_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.wup_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wu-Palmer Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        depth of the two senses in the taxonomy and that of their Least Common</span>
<span class="sd">        Subsumer (most specific ancestor node). Previously, the scores computed</span>
<span class="sd">        by this implementation did _not_ always agree with those given by</span>
<span class="sd">        Pedersen&#39;s Perl implementation of WordNet Similarity. However, with</span>
<span class="sd">        the addition of the simulate_root flag (see below), the score for</span>
<span class="sd">        verbs now almost always agree but not always for nouns.</span>

<span class="sd">        The LCS does not necessarily feature in the shortest path connecting</span>
<span class="sd">        the two senses, as it is by definition the common ancestor deepest in</span>
<span class="sd">        the taxonomy, not closest to the two senses. Typically, however, it</span>
<span class="sd">        will so feature. Where multiple candidates for the LCS exist, that</span>
<span class="sd">        whose shortest path to the root node is the longest will be selected.</span>
<span class="sd">        Where the LCS has multiple paths to the root, the longer path is used</span>
<span class="sd">        for the purposes of the calculation.</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type simulate_root: bool</span>
<span class="sd">        :param simulate_root: The various verb taxonomies do not</span>
<span class="sd">            share a single root which disallows this metric from working for</span>
<span class="sd">            synsets that are not connected. This flag (True by default)</span>
<span class="sd">            creates a fake root that connects all the taxonomies. Set it</span>
<span class="sd">            to false to disable this behavior. For the noun taxonomy,</span>
<span class="sd">            there is usually a default root except for WordNet version 1.6.</span>
<span class="sd">            If you are using wordnet 1.6, a fake root will be added for nouns</span>
<span class="sd">            as well.</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects, normally greater than zero. If no connecting path between</span>
<span class="sd">            the two senses can be found, None is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">need_root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">_needs_root</span><span class="p">()</span>

        <span class="c1"># Note that to preserve behavior from NLTK2 we set use_min_depth=True</span>
        <span class="c1"># It is possible that more accurate results could be obtained by</span>
        <span class="c1"># removing this setting and it should be tested later on</span>
        <span class="n">subsumers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowest_common_hypernyms</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span><span class="p">,</span> <span class="n">use_min_depth</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># If no LCS was found return None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsumers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">subsumer</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">subsumers</span> <span class="k">else</span> <span class="n">subsumers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Get the longest path from the LCS to the root,</span>
        <span class="c1"># including a correction:</span>
        <span class="c1"># - add one because the calculations include both the start and end</span>
        <span class="c1">#   nodes</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="n">subsumer</span><span class="o">.</span><span class="n">max_depth</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Note: No need for an additional add-one correction for non-nouns</span>
        <span class="c1"># to account for an imaginary root node because that is now</span>
        <span class="c1"># automatically handled by simulate_root</span>
        <span class="c1"># if subsumer._pos != NOUN:</span>
        <span class="c1">#     depth += 1</span>

        <span class="c1"># Get the shortest path from the LCS to each of the synsets it is</span>
        <span class="c1"># subsuming.  Add this to the LCS path length to get the path</span>
        <span class="c1"># length from each synset to the root.</span>
        <span class="n">len1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">subsumer</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span>
        <span class="p">)</span>
        <span class="n">len2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">shortest_path_distance</span><span class="p">(</span>
            <span class="n">subsumer</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span> <span class="ow">and</span> <span class="n">need_root</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">len1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">len2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">len1</span> <span class="o">+=</span> <span class="n">depth</span>
        <span class="n">len2</span> <span class="o">+=</span> <span class="n">depth</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">depth</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">len1</span> <span class="o">+</span> <span class="n">len2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Synset.res_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.res_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resnik Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node).</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type ic: dict</span>
<span class="sd">        :param ic: an information content object (as returned by</span>
<span class="sd">            ``nltk.corpus.wordnet_ic.ic()``).</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects. Synsets whose LCS is the root node of the taxonomy will</span>
<span class="sd">            have a score of 0 (e.g. N[&#39;dog&#39;][0] and N[&#39;table&#39;][0]).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lcs_ic</span></div>

<div class="viewcode-block" id="Synset.jcn_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.jcn_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jiang-Conrath Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node) and that of the two input Synsets. The relationship is</span>
<span class="sd">        given by the equation 1 / (IC(s1) + IC(s2) - 2 * IC(lcs)).</span>

<span class="sd">        :type  other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type  ic: dict</span>
<span class="sd">        :param ic: an information content object (as returned by</span>
<span class="sd">            ``nltk.corpus.wordnet_ic.ic()``).</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_INF</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>

        <span class="c1"># If either of the input synsets are the root synset, or have a</span>
        <span class="c1"># frequency of 0 (sparse data problem), return 0.</span>
        <span class="k">if</span> <span class="n">ic1</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ic2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">ic_difference</span> <span class="o">=</span> <span class="n">ic1</span> <span class="o">+</span> <span class="n">ic2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">lcs_ic</span>

        <span class="k">if</span> <span class="n">ic_difference</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_INF</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">ic_difference</span></div>

<div class="viewcode-block" id="Synset.lin_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.Synset.lin_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lin Similarity:</span>
<span class="sd">        Return a score denoting how similar two word senses are, based on the</span>
<span class="sd">        Information Content (IC) of the Least Common Subsumer (most specific</span>
<span class="sd">        ancestor node) and that of the two input Synsets. The relationship is</span>
<span class="sd">        given by the equation 2 * IC(lcs) / (IC(s1) + IC(s2)).</span>

<span class="sd">        :type other: Synset</span>
<span class="sd">        :param other: The ``Synset`` that this ``Synset`` is being compared to.</span>
<span class="sd">        :type ic: dict</span>
<span class="sd">        :param ic: an information content object (as returned by</span>
<span class="sd">            ``nltk.corpus.wordnet_ic.ic()``).</span>
<span class="sd">        :return: A float score denoting the similarity of the two ``Synset``</span>
<span class="sd">            objects, in the range 0 to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">lcs_ic</span> <span class="o">=</span> <span class="n">_lcs_ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">lcs_ic</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ic1</span> <span class="o">+</span> <span class="n">ic2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_iter_hypernym_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: An iterator over ``Synset`` objects that are either proper</span>
<span class="sd">        hypernyms or instance of hypernyms of the synset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">todo</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">synset</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">todo</span>
            <span class="n">todo</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">hypernym</span>
                <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="n">todo</span>
                <span class="k">for</span> <span class="n">hypernym</span> <span class="ow">in</span> <span class="p">(</span><span class="n">synset</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">()</span> <span class="o">+</span> <span class="n">synset</span><span class="o">.</span><span class="n">instance_hypernyms</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">hypernym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span>
            <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>

    <span class="k">def</span> <span class="nf">_related</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relation_symbol</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wordnet_corpus_reader</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span>
        <span class="k">if</span> <span class="n">relation_symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">pointer_tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">relation_symbol</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_synset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">pointer_tuples</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">r</span></div>


<span class="c1">######################################################################</span>
<span class="c1"># WordNet Corpus Reader</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="WordNetCorpusReader"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader">[docs]</a><span class="k">class</span> <span class="nc">WordNetCorpusReader</span><span class="p">(</span><span class="n">CorpusReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A corpus reader used to access wordnet or its variants.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_ENCODING</span> <span class="o">=</span> <span class="s2">&quot;utf8&quot;</span>

    <span class="c1"># { Part-of-speech constants</span>
    <span class="n">ADJ</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">,</span> <span class="n">ADV</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">,</span> <span class="n">VERB</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span>
    <span class="c1"># }</span>

    <span class="c1"># { Filename constants</span>
    <span class="n">_FILEMAP</span> <span class="o">=</span> <span class="p">{</span><span class="n">ADJ</span><span class="p">:</span> <span class="s2">&quot;adj&quot;</span><span class="p">,</span> <span class="n">ADV</span><span class="p">:</span> <span class="s2">&quot;adv&quot;</span><span class="p">,</span> <span class="n">NOUN</span><span class="p">:</span> <span class="s2">&quot;noun&quot;</span><span class="p">,</span> <span class="n">VERB</span><span class="p">:</span> <span class="s2">&quot;verb&quot;</span><span class="p">}</span>
    <span class="c1"># }</span>

    <span class="c1"># { Part of speech constants</span>
    <span class="n">_pos_numbers</span> <span class="o">=</span> <span class="p">{</span><span class="n">NOUN</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">VERB</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ADJ</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ADV</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">ADJ_SAT</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
    <span class="n">_pos_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tup</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">_pos_numbers</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="c1"># }</span>

    <span class="c1">#: A list of file identifiers for all the fileids used by this</span>
    <span class="c1">#: corpus reader.</span>
    <span class="n">_FILES</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;cntlist.rev&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lexnames&quot;</span><span class="p">,</span>
        <span class="s2">&quot;index.sense&quot;</span><span class="p">,</span>
        <span class="s2">&quot;index.adj&quot;</span><span class="p">,</span>
        <span class="s2">&quot;index.adv&quot;</span><span class="p">,</span>
        <span class="s2">&quot;index.noun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;index.verb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;data.adj&quot;</span><span class="p">,</span>
        <span class="s2">&quot;data.adv&quot;</span><span class="p">,</span>
        <span class="s2">&quot;data.noun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;data.verb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;adj.exc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;adv.exc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;noun.exc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;verb.exc&quot;</span><span class="p">,</span>
    <span class="p">)</span>

<div class="viewcode-block" id="WordNetCorpusReader.__init__"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">omw_reader</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new wordnet corpus reader, with the given root</span>
<span class="sd">        directory.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILES</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ENCODING</span><span class="p">)</span>

        <span class="c1"># A index that provides the file offset</span>
        <span class="c1"># Map from lemma -&gt; pos -&gt; synset_index -&gt; offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># A cache so we don&#39;t have to reconstruct synsets</span>
        <span class="c1"># Map from pos -&gt; offset -&gt; synset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># A lookup for the maximum depth of each part of speech.  Useful for</span>
        <span class="c1"># the lch similarity metric.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># Corpus reader containing omw data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span> <span class="o">=</span> <span class="n">omw_reader</span>

        <span class="c1"># Corpus reader containing extended_omw data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exomw_reader</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">[</span><span class="s2">&quot;eng&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The multilingual functions are not available with this Wordnet version&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">omw_langs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># A cache to store the wordnet data of multiple languages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Load the lexnames</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;lexnames&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">lexname</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">assert</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lexname</span><span class="p">)</span>

        <span class="c1"># Load the indices for lemmas and synset offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_lemma_pos_offset_map</span><span class="p">()</span>

        <span class="c1"># load the exception file data into memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_exception_map</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nomap</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splits</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># map from WordNet 3.0 for OMW data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map30</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_wn30</span><span class="p">()</span>

        <span class="c1"># Language data attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lg_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;lemma&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;def&quot;</span><span class="p">,</span> <span class="s2">&quot;exe&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.index_sense"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.index_sense">[docs]</a>    <span class="k">def</span> <span class="nf">index_sense</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read sense key to synset id mapping from index.sense file in corpus directory&quot;&quot;&quot;</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="s2">&quot;index.sense&quot;</span>
        <span class="k">if</span> <span class="n">version</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">CorpusReader</span><span class="p">,</span> <span class="n">LazyCorpusLoader</span>

            <span class="n">ixreader</span> <span class="o">=</span> <span class="n">LazyCorpusLoader</span><span class="p">(</span><span class="n">version</span><span class="p">,</span> <span class="n">CorpusReader</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;.*/&quot;</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ixreader</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">with</span> <span class="n">ixreader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">sensekey_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">sensekey</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_names</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sensekey</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">sensekey_map</span><span class="p">[</span><span class="n">sensekey</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">sensekey_map</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.map_to_many"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.map_to_many">[docs]</a>    <span class="k">def</span> <span class="nf">map_to_many</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sensekey_map1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_sense</span><span class="p">(</span><span class="s2">&quot;wordnet&quot;</span><span class="p">)</span>
        <span class="n">sensekey_map2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_sense</span><span class="p">()</span>
        <span class="n">synset_to_many</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">synsetid</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">sensekey_map1</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">synset_to_many</span><span class="p">[</span><span class="n">synsetid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sensekey</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">sensekey_map1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">sensekey_map2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">sensekey_map1</span><span class="p">[</span><span class="n">sensekey</span><span class="p">]</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">sensekey_map2</span><span class="p">[</span><span class="n">sensekey</span><span class="p">]</span>
            <span class="n">synset_to_many</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">synset_to_many</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.map_to_one"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.map_to_one">[docs]</a>    <span class="k">def</span> <span class="nf">map_to_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">synset_to_many</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_to_many</span><span class="p">()</span>
        <span class="n">synset_to_one</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">synset_to_many</span><span class="p">:</span>
            <span class="n">candidates_bag</span> <span class="o">=</span> <span class="n">synset_to_many</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">candidates_bag</span><span class="p">:</span>
                <span class="n">candidates_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">candidates_bag</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">candidates_bag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates_set</span><span class="p">:</span>
                        <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">candidates_bag</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">candidate</span><span class="p">),</span> <span class="n">candidate</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">splits</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">counts</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">synset_to_one</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span>
                <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
                    <span class="c1"># Add a mapping from &quot;a&quot; to target for applications like omw,</span>
                    <span class="c1"># where only Lithuanian and Slovak use the &quot;s&quot; ss_type.</span>
                    <span class="n">synset_to_one</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nomap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">synset_to_one</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.map_wn30"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.map_wn30">[docs]</a>    <span class="k">def</span> <span class="nf">map_wn30</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mapping from Wordnet 3.0 to currently loaded Wordnet version&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_version</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;3.0&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_to_one</span><span class="p">()</span></div>

    <span class="c1"># Open Multilingual WordNet functions, contributed by</span>
    <span class="c1"># Nasruddin Aâ€™aidil Shari, Sim Wei Ying Geraldine, and Soe Lynn</span>

<div class="viewcode-block" id="WordNetCorpusReader.of2ss"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.of2ss">[docs]</a>    <span class="k">def</span> <span class="nf">of2ss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">of</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;take an id and return the synsets&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="n">of</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">of</span><span class="p">[:</span><span class="mi">8</span><span class="p">]))</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.ss2of"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.ss2of">[docs]</a>    <span class="k">def</span> <span class="nf">ss2of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return the ID of the synset&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ss</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ss</span><span class="o">.</span><span class="n">offset</span><span class="p">()</span><span class="si">:</span><span class="s2">08d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">ss</span><span class="o">.</span><span class="n">pos</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span></div>

    <span class="k">def</span> <span class="nf">_load_lang_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;load the wordnet data of the requested language from the file to</span>
<span class="sd">        the cache, _lang_data&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">omw_langs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_omw</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">&quot;Language is not supported.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exomw_reader</span> <span class="ow">and</span> <span class="n">lang</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">omw_langs</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exomw_reader</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span>

        <span class="n">prov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">[</span><span class="n">lang</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prov</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cldr&quot;</span><span class="p">,</span> <span class="s2">&quot;wikt&quot;</span><span class="p">]:</span>
            <span class="n">prov2</span> <span class="o">=</span> <span class="n">prov</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prov2</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span>

        <span class="k">with</span> <span class="n">reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prov</span><span class="si">}</span><span class="s2">/wn-</span><span class="si">{</span><span class="n">prov2</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">lang</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">.tab&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">custom_lemmas</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">lang</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disable_custom_lemmas</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>

<div class="viewcode-block" id="WordNetCorpusReader.add_provs"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.add_provs">[docs]</a>    <span class="k">def</span> <span class="nf">add_provs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add languages from Multilingual Wordnet to the provenance dictionary&quot;&quot;&quot;</span>
        <span class="n">fileids</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">fileids</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fileid</span> <span class="ow">in</span> <span class="n">fileids</span><span class="p">:</span>
            <span class="n">prov</span><span class="p">,</span> <span class="n">langfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
            <span class="n">file_name</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">langfile</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">file_extension</span> <span class="o">==</span> <span class="s2">&quot;.tab&quot;</span><span class="p">:</span>
                <span class="n">lang</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span> <span class="ow">or</span> <span class="n">prov</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cldr&quot;</span><span class="p">,</span> <span class="s2">&quot;wikt&quot;</span><span class="p">]:</span>
                    <span class="c1"># We already have another resource for this lang,</span>
                    <span class="c1"># so we need to further specify the lang id:</span>
                    <span class="n">lang</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lang</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">prov</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">[</span><span class="n">lang</span><span class="p">]</span> <span class="o">=</span> <span class="n">prov</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.add_omw"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.add_omw">[docs]</a>    <span class="k">def</span> <span class="nf">add_omw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_provs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omw_langs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.add_exomw"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.add_exomw">[docs]</a>    <span class="k">def</span> <span class="nf">add_exomw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add languages from Extended OMW</span>

<span class="sd">        &gt;&gt;&gt; import nltk</span>
<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; wn.add_exomw()</span>
<span class="sd">        &gt;&gt;&gt; print(wn.synset(&#39;intrinsically.r.01&#39;).lemmas(lang=&quot;eng_wikt&quot;))</span>
<span class="sd">        [Lemma(&#39;intrinsically.r.01.per_se&#39;), Lemma(&#39;intrinsically.r.01.as_such&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">extended_omw</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_omw</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exomw_reader</span> <span class="o">=</span> <span class="n">extended_omw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_provs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_exomw_reader</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.langs"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.langs">[docs]</a>    <span class="k">def</span> <span class="nf">langs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a list of languages supported by Multilingual Wordnet&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">_load_lemma_pos_offset_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>

            <span class="c1"># parse each line of the file (ignoring comment lines)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;index.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

                    <span class="k">def</span> <span class="nf">_next_token</span><span class="p">():</span>
                        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>

                    <span class="k">try</span><span class="p">:</span>

                        <span class="c1"># get the lemma and part-of-speech</span>
                        <span class="n">lemma</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                        <span class="n">pos</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>

                        <span class="c1"># get the number of synsets for this lemma</span>
                        <span class="n">n_synsets</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                        <span class="k">assert</span> <span class="n">n_synsets</span> <span class="o">&gt;</span> <span class="mi">0</span>

                        <span class="c1"># get and ignore the pointer symbols for all synsets of</span>
                        <span class="c1"># this lemma</span>
                        <span class="n">n_pointers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                        <span class="p">[</span><span class="n">_next_token</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pointers</span><span class="p">)]</span>

                        <span class="c1"># same as number of synsets</span>
                        <span class="n">n_senses</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                        <span class="k">assert</span> <span class="n">n_synsets</span> <span class="o">==</span> <span class="n">n_senses</span>

                        <span class="c1"># get and ignore number of senses ranked according to</span>
                        <span class="c1"># frequency</span>
                        <span class="n">_next_token</span><span class="p">()</span>

                        <span class="c1"># get synset offsets</span>
                        <span class="n">synset_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_synsets</span><span class="p">)]</span>

                    <span class="c1"># raise more informative error with file name and line number</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;index.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">e</span>
                        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">&quot;file </span><span class="si">%s</span><span class="s2">, line </span><span class="si">%i</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

                    <span class="c1"># map lemmas and parts of speech to synsets</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset_offsets</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset_offsets</span>

    <span class="k">def</span> <span class="nf">_load_exception_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># load the exception file data into memory</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.exc&quot;</span> <span class="o">%</span> <span class="n">suffix</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">:</span>
                    <span class="n">terms</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">ADJ</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_max_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the max depth for the given part of speech.  This is</span>
<span class="sd">        used by the lch similarity metric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_synsets</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">ii</span><span class="o">.</span><span class="n">max_depth</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simulate_root</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_depth</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">depth</span>

<div class="viewcode-block" id="WordNetCorpusReader.get_version"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.get_version">[docs]</a>    <span class="k">def</span> <span class="nf">get_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file</span><span class="p">(</span><span class="n">ADJ</span><span class="p">)</span>
        <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Word[nN]et (\d+|\d+\.\d+) Copyright&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">version</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">version</span></div>

    <span class="c1">#############################################################</span>
    <span class="c1"># Loading Lemmas</span>
    <span class="c1">#############################################################</span>

<div class="viewcode-block" id="WordNetCorpusReader.lemma"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.lemma">[docs]</a>    <span class="k">def</span> <span class="nf">lemma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return lemma object that matches the name&quot;&quot;&quot;</span>
        <span class="c1"># cannot simply split on first &#39;.&#39;,</span>
        <span class="c1"># e.g.: &#39;.45_caliber.a.01..45_caliber&#39;</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="n">SENSENUM_RE</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="n">synset_name</span><span class="p">,</span> <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span> <span class="n">separator</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="p">[</span><span class="n">separator</span><span class="p">:]</span>

        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset</span><span class="p">(</span><span class="n">synset_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">(</span><span class="n">lang</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">lemma_name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lemma</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No lemma </span><span class="si">{</span><span class="n">lemma_name</span><span class="si">!r}</span><span class="s2"> in </span><span class="si">{</span><span class="n">synset_name</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.lemma_from_key"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.lemma_from_key">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_from_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># Keys are case sensitive and always lower-case</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">lemma_name</span><span class="p">,</span> <span class="n">lex_sense</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">)</span>
        <span class="n">pos_number</span><span class="p">,</span> <span class="n">lexname_index</span><span class="p">,</span> <span class="n">lex_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lex_sense</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pos_names</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">pos_number</span><span class="p">)]</span>

        <span class="c1"># open the key -&gt; synset file if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;index.sense&quot;</span><span class="p">)</span>

        <span class="c1"># Find the synset for the lemma.</span>
        <span class="n">synset_line</span> <span class="o">=</span> <span class="n">_binary_search_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_synset_file</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">synset_line</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">&quot;No synset found for key </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">synset_line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        <span class="c1"># return the corresponding lemma</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_key</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lemma</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="s2">&quot;No lemma found for for key </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span></div>

    <span class="c1">#############################################################</span>
    <span class="c1"># Loading Synsets</span>
    <span class="c1">#############################################################</span>
<div class="viewcode-block" id="WordNetCorpusReader.synset"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.synset">[docs]</a>    <span class="k">def</span> <span class="nf">synset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># split name into lemma, part of speech and synset number</span>
        <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">synset_index_str</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">synset_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">synset_index_str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># get the offset for this synset</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">][</span><span class="n">synset_index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No lemma </span><span class="si">{</span><span class="n">lemma</span><span class="si">!r}</span><span class="s2"> with part of speech </span><span class="si">{</span><span class="n">pos</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">n_senses</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">][</span><span class="n">pos</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Lemma </span><span class="si">{</span><span class="n">lemma</span><span class="si">!r}</span><span class="s2"> with part of speech </span><span class="si">{</span><span class="n">pos</span><span class="si">!r}</span><span class="s2"> only &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;has </span><span class="si">{</span><span class="n">n_senses</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;sense&#39;</span> <span class="k">if</span> <span class="n">n_senses</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;senses&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="c1"># load synset information from the appropriate file</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

        <span class="c1"># some basic sanity checks on loaded attributes</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span> <span class="ow">and</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Adjective satellite requested but only plain &quot;</span>
                <span class="s2">&quot;adjective found for lemma </span><span class="si">%r</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">message</span> <span class="o">%</span> <span class="n">lemma</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">pos</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span> <span class="ow">and</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>

        <span class="c1"># Return the synset object.</span>
        <span class="k">return</span> <span class="n">synset</span></div>

    <span class="k">def</span> <span class="nf">_data_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an open file pointer for the data file for the given</span>
<span class="sd">        part of speech.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fileid</span> <span class="o">=</span> <span class="s2">&quot;data.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

<div class="viewcode-block" id="WordNetCorpusReader.synset_from_pos_and_offset"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.synset_from_pos_and_offset">[docs]</a>    <span class="k">def</span> <span class="nf">synset_from_pos_and_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        - pos: The synset&#39;s part of speech, matching one of the module level</span>
<span class="sd">          attributes ADJ, ADJ_SAT, ADV, NOUN or VERB (&#39;a&#39;, &#39;s&#39;, &#39;r&#39;, &#39;n&#39;, or &#39;v&#39;).</span>
<span class="sd">        - offset: The byte offset of this synset in the WordNet dict file</span>
<span class="sd">          for this pos.</span>

<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; print(wn.synset_from_pos_and_offset(&#39;n&#39;, 1740))</span>
<span class="sd">        Synset(&#39;entity.n.01&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check to see if the synset is in the cache</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span>

        <span class="n">data_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_file</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">data_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">data_file_line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="c1"># If valid, the offset equals the 8-digit 0-padded integer found at the start of the line:</span>
        <span class="n">line_offset</span> <span class="o">=</span> <span class="n">data_file_line</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">line_offset</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">line_offset</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;0&#39;</span><span class="o">*</span><span class="p">(</span><span class="mi">8</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">offset</span><span class="p">)))</span><span class="si">}{</span><span class="nb">str</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">):</span>
            <span class="n">synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_line</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">data_file_line</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">synset</span><span class="o">.</span><span class="n">_offset</span> <span class="o">==</span> <span class="n">offset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">synset</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No WordNet synset found for pos=</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> at offset=</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">data_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">synset</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s2">&quot;Use public method synset_from_pos_and_offset() instead&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_synset_from_pos_and_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hack to help people like the readers of</span>
<span class="sd">        https://stackoverflow.com/a/27145655/1709587</span>
<span class="sd">        who were using this function before it was officially a public method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_synset_from_pos_and_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">data_file_line</span><span class="p">):</span>
        <span class="c1"># Construct a new (empty) synset.</span>
        <span class="n">synset</span> <span class="o">=</span> <span class="n">Synset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># parse the entry for this synset</span>
        <span class="k">try</span><span class="p">:</span>

            <span class="c1"># parse out the definitions and examples from the gloss</span>
            <span class="n">columns_str</span><span class="p">,</span> <span class="n">gloss</span> <span class="o">=</span> <span class="n">data_file_line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)</span>
            <span class="n">definition</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[</span><span class="se">\&quot;</span><span class="s2">].*?[</span><span class="se">\&quot;</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">gloss</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">examples</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&quot;([^&quot;]*)&quot;&#39;</span><span class="p">,</span> <span class="n">gloss</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">example</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
                <span class="n">synset</span><span class="o">.</span><span class="n">_examples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>

            <span class="n">synset</span><span class="o">.</span><span class="n">_definition</span> <span class="o">=</span> <span class="n">definition</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;; &quot;</span><span class="p">)</span>

            <span class="c1"># split the other info into fields</span>
            <span class="n">_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">columns_str</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

            <span class="k">def</span> <span class="nf">_next_token</span><span class="p">():</span>
                <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">_iter</span><span class="p">)</span>

            <span class="c1"># get the offset</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>

            <span class="c1"># determine the lexicographer file name</span>
            <span class="n">lexname_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">_lexname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lexnames</span><span class="p">[</span><span class="n">lexname_index</span><span class="p">]</span>

            <span class="c1"># get the part of speech</span>
            <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>

            <span class="c1"># create Lemma objects for each lemma</span>
            <span class="n">n_lemmas</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_lemmas</span><span class="p">):</span>
                <span class="c1"># get the lemma name</span>
                <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="c1"># get the lex_id (used for sense_keys)</span>
                <span class="n">lex_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
                <span class="c1"># If the lemma has a syntactic marker, extract it.</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.*?)(\(.*\))?$&quot;</span><span class="p">,</span> <span class="n">lemma_name</span><span class="p">)</span>
                <span class="n">lemma_name</span><span class="p">,</span> <span class="n">syn_mark</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
                <span class="c1"># create the lemma object</span>
                <span class="n">lemma</span> <span class="o">=</span> <span class="n">Lemma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset</span><span class="p">,</span> <span class="n">lemma_name</span><span class="p">,</span> <span class="n">lexname_index</span><span class="p">,</span> <span class="n">lex_id</span><span class="p">,</span> <span class="n">syn_mark</span><span class="p">)</span>
                <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma</span><span class="p">)</span>
                <span class="n">synset</span><span class="o">.</span><span class="n">_lemma_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

            <span class="c1"># collect the pointer tuples</span>
            <span class="n">n_pointers</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pointers</span><span class="p">):</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="n">lemma_ids_str</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">lemma_ids_str</span> <span class="o">==</span> <span class="s2">&quot;0000&quot;</span><span class="p">:</span>
                    <span class="n">synset</span><span class="o">.</span><span class="n">_pointers</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">source_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lemma_ids_str</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">target_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lemma_ids_str</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">16</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">source_lemma_name</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="n">source_index</span><span class="p">]</span><span class="o">.</span><span class="n">_name</span>
                    <span class="n">lemma_pointers</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemma_pointers</span>
                    <span class="n">tups</span> <span class="o">=</span> <span class="n">lemma_pointers</span><span class="p">[</span><span class="n">source_lemma_name</span><span class="p">,</span> <span class="n">symbol</span><span class="p">]</span>
                    <span class="n">tups</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">target_index</span><span class="p">))</span>

            <span class="c1"># read the verb frames</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">frame_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frame_count</span><span class="p">):</span>
                    <span class="c1"># read the plus sign</span>
                    <span class="n">plus</span> <span class="o">=</span> <span class="n">_next_token</span><span class="p">()</span>
                    <span class="k">assert</span> <span class="n">plus</span> <span class="o">==</span> <span class="s2">&quot;+&quot;</span>
                    <span class="c1"># read the frame and lemma number</span>
                    <span class="n">frame_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">())</span>
                    <span class="n">frame_string_fmt</span> <span class="o">=</span> <span class="n">VERB_FRAME_STRINGS</span><span class="p">[</span><span class="n">frame_number</span><span class="p">]</span>
                    <span class="n">lemma_number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_next_token</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span>
                    <span class="c1"># lemma number of 00 means all words in the synset</span>
                    <span class="k">if</span> <span class="n">lemma_number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">synset</span><span class="o">.</span><span class="n">_frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">:</span>
                            <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                            <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_string_fmt</span> <span class="o">%</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
                    <span class="c1"># only a specific word in the synset</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lemma</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="n">lemma_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_number</span><span class="p">)</span>
                        <span class="n">lemma</span><span class="o">.</span><span class="n">_frame_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame_string_fmt</span> <span class="o">%</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

        <span class="c1"># raise a more informative error with line text</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;line </span><span class="si">{</span><span class="n">data_file_line</span><span class="si">!r}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

        <span class="c1"># set sense keys for Lemma objects - note that this has to be</span>
        <span class="c1"># done afterwards so that the relations are available</span>
        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                <span class="n">head_lemma</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">similar_tos</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">head_name</span> <span class="o">=</span> <span class="n">head_lemma</span><span class="o">.</span><span class="n">_name</span>
                <span class="n">head_id</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%02d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">head_lemma</span><span class="o">.</span><span class="n">_lex_id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">head_name</span> <span class="o">=</span> <span class="n">head_id</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">lemma</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                <span class="n">WordNetCorpusReader</span><span class="o">.</span><span class="n">_pos_numbers</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">],</span>
                <span class="n">lemma</span><span class="o">.</span><span class="n">_lexname_index</span><span class="p">,</span>
                <span class="n">lemma</span><span class="o">.</span><span class="n">_lex_id</span><span class="p">,</span>
                <span class="n">head_name</span><span class="p">,</span>
                <span class="n">head_id</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">lemma</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%%%d</span><span class="s2">:</span><span class="si">%02d</span><span class="s2">:</span><span class="si">%02d</span><span class="s2">:</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">tup</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># the canonical name is based on the first lemma</span>
        <span class="n">lemma_name</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_lemmas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma_name</span><span class="p">][</span><span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">]</span>
        <span class="n">sense_index</span> <span class="o">=</span> <span class="n">offsets</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">synset</span><span class="o">.</span><span class="n">_offset</span><span class="p">)</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="n">lemma_name</span><span class="p">,</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span><span class="p">,</span> <span class="n">sense_index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">synset</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">.</span><span class="si">%02i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">tup</span>

        <span class="k">return</span> <span class="n">synset</span>

<div class="viewcode-block" id="WordNetCorpusReader.synset_from_sense_key"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.synset_from_sense_key">[docs]</a>    <span class="k">def</span> <span class="nf">synset_from_sense_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sense_key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves synset based on a given sense_key. Sense keys can be</span>
<span class="sd">        obtained from lemma.key()</span>

<span class="sd">        From https://wordnet.princeton.edu/documentation/senseidx5wn:</span>
<span class="sd">        A sense_key is represented as::</span>

<span class="sd">            lemma % lex_sense (e.g. &#39;dog%1:18:01::&#39;)</span>

<span class="sd">        where lex_sense is encoded as::</span>

<span class="sd">            ss_type:lex_filenum:lex_id:head_word:head_id</span>

<span class="sd">        :lemma:       ASCII text of word/collocation, in lower case</span>
<span class="sd">        :ss_type:     synset type for the sense (1 digit int)</span>
<span class="sd">                      The synset type is encoded as follows::</span>

<span class="sd">                          1    NOUN</span>
<span class="sd">                          2    VERB</span>
<span class="sd">                          3    ADJECTIVE</span>
<span class="sd">                          4    ADVERB</span>
<span class="sd">                          5    ADJECTIVE SATELLITE</span>
<span class="sd">        :lex_filenum: name of lexicographer file containing the synset for the sense (2 digit int)</span>
<span class="sd">        :lex_id:      when paired with lemma, uniquely identifies a sense in the lexicographer file (2 digit int)</span>
<span class="sd">        :head_word:   lemma of the first word in satellite&#39;s head synset</span>
<span class="sd">                      Only used if sense is in an adjective satellite synset</span>
<span class="sd">        :head_id:     uniquely identifies sense in a lexicographer file when paired with head_word</span>
<span class="sd">                      Only used if head_word is present (2 digit int)</span>

<span class="sd">        &gt;&gt;&gt; import nltk</span>
<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; print(wn.synset_from_sense_key(&quot;drive%1:04:03::&quot;))</span>
<span class="sd">        Synset(&#39;drive.n.06&#39;)</span>

<span class="sd">        &gt;&gt;&gt; print(wn.synset_from_sense_key(&quot;driving%1:04:03::&quot;))</span>
<span class="sd">        Synset(&#39;drive.n.06&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lemma_from_key</span><span class="p">(</span><span class="n">sense_key</span><span class="p">)</span><span class="o">.</span><span class="n">synset</span><span class="p">()</span></div>

    <span class="c1">#############################################################</span>
    <span class="c1"># Retrieve synsets and lemmas.</span>
    <span class="c1">#############################################################</span>

<div class="viewcode-block" id="WordNetCorpusReader.synsets"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.synsets">[docs]</a>    <span class="k">def</span> <span class="nf">synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load all synsets with a given lemma and part of speech tag.</span>
<span class="sd">        If no pos is specified, all synsets for all parts of speech</span>
<span class="sd">        will be loaded.</span>
<span class="sd">        If lang is specified, all the synsets associated with the lemma name</span>
<span class="sd">        of that language will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lemma</span> <span class="o">=</span> <span class="n">lemma</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="n">get_synset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synset_from_pos_and_offset</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">POS_LIST</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">get_synset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span>
                <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">index</span><span class="p">[</span><span class="n">form</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">[])</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">synset_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">lemma</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">synset_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">of2ss</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">synset_list</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.lemmas"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all Lemma objects with a name matching the specified lemma</span>
<span class="sd">        name and part of speech tag. Matches any part of speech tag if none is</span>
<span class="sd">        specified.&quot;&quot;&quot;</span>

        <span class="n">lemma</span> <span class="o">=</span> <span class="n">lemma</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">lemma_obj</span>
                <span class="k">for</span> <span class="n">synset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">lemma_obj</span> <span class="ow">in</span> <span class="n">synset</span><span class="o">.</span><span class="n">lemmas</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">lemma_obj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">lemma</span>
            <span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">lemmas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">syn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syn</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">pos</span><span class="p">()</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">lemma_obj</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">lemmas</span><span class="p">(</span><span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lemma_obj</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">lemma</span><span class="p">:</span>
                        <span class="n">lemmas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lemma_obj</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lemmas</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.all_lemma_names"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.all_lemma_names">[docs]</a>    <span class="k">def</span> <span class="nf">all_lemma_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all lemma names for all synsets for the given</span>
<span class="sd">        part of speech tag and language or languages. If pos is</span>
<span class="sd">        not specified, all synsets for all parts of speech will</span>
<span class="sd">        be used.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">lemma</span>
                    <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">lemma</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
            <span class="n">lemma</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">lemma</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>

            <span class="n">lemma</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lemma</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">lemma</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.all_omw_synsets"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.all_omw_synsets">[docs]</a>    <span class="k">def</span> <span class="nf">all_omw_synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_lang_data</span><span class="p">(</span><span class="n">lang</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span> <span class="ow">or</span> <span class="n">of</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">of2ss</span><span class="p">(</span><span class="n">of</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ss</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ss</span></div>

    <span class="c1">#            else:</span>
    <span class="c1"># A few OMW offsets don&#39;t exist in Wordnet 3.0.</span>
    <span class="c1">#                warnings.warn(f&quot;Language {lang}: no synset found for {of}&quot;)</span>

<div class="viewcode-block" id="WordNetCorpusReader.all_synsets"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.all_synsets">[docs]</a>    <span class="k">def</span> <span class="nf">all_synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over all synsets with a given part of speech tag.</span>
<span class="sd">        If no pos is specified, all synsets for all parts of speech</span>
<span class="sd">        will be loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_eng_synsets</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_omw_synsets</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.all_eng_synsets"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.all_eng_synsets">[docs]</a>    <span class="k">def</span> <span class="nf">all_eng_synsets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos_tags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos_tags</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_offset_cache</span>
        <span class="n">from_pos_and_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synset_from_pos_and_line</span>

        <span class="c1"># generate all synsets for each part of speech</span>
        <span class="k">for</span> <span class="n">pos_tag</span> <span class="ow">in</span> <span class="n">pos_tags</span><span class="p">:</span>
            <span class="c1"># Open the file for reading.  Note that we can not re-use</span>
            <span class="c1"># the file pointers from self._data_file_map here, because</span>
            <span class="c1"># we&#39;re defining an iterator, and those file pointers might</span>
            <span class="c1"># be moved while we&#39;re not looking.</span>
            <span class="k">if</span> <span class="n">pos_tag</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                <span class="n">pos_file</span> <span class="o">=</span> <span class="n">ADJ</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos_file</span> <span class="o">=</span> <span class="n">pos_tag</span>
            <span class="n">fileid</span> <span class="o">=</span> <span class="s2">&quot;data.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_FILEMAP</span><span class="p">[</span><span class="n">pos_file</span><span class="p">]</span>
            <span class="n">data_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileid</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># generate synsets for each line in the POS file</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">while</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">]:</span>
                            <span class="c1"># See if the synset is cached</span>
                            <span class="n">synset</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Otherwise, parse the line</span>
                            <span class="n">synset</span> <span class="o">=</span> <span class="n">from_pos_and_line</span><span class="p">(</span><span class="n">pos_tag</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                            <span class="n">cache</span><span class="p">[</span><span class="n">pos_tag</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">synset</span>

                        <span class="c1"># adjective satellites are in the same file as</span>
                        <span class="c1"># adjectives so only yield the synset if it&#39;s actually</span>
                        <span class="c1"># a satellite</span>
                        <span class="k">if</span> <span class="n">pos_tag</span> <span class="o">==</span> <span class="n">ADJ_SAT</span> <span class="ow">and</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">synset</span>
                        <span class="c1"># for all other POS tags, yield all synsets (this means</span>
                        <span class="c1"># that adjectives also include adjective satellites)</span>
                        <span class="k">elif</span> <span class="n">pos_tag</span> <span class="o">!=</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">synset</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">data_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

            <span class="c1"># close the extra file handle we opened</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">data_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.words"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.words">[docs]</a>    <span class="k">def</span> <span class="nf">words</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return lemmas of the given language as list of words&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_lemma_names</span><span class="p">(</span><span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.synonyms"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.synonyms">[docs]</a>    <span class="k">def</span> <span class="nf">synonyms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return nested list with the synonyms of the different senses of word in the given language&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">lemma_names</span><span class="p">(</span><span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">))</span> <span class="o">-</span> <span class="p">{</span><span class="n">word</span><span class="p">}))</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span>
        <span class="p">]</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.doc"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.doc">[docs]</a>    <span class="k">def</span> <span class="nf">doc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="s2">&quot;README&quot;</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the contents of readme, license or citation file</span>
<span class="sd">        use lang=lang to get the file for an individual language&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lang</span> <span class="o">==</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omw_reader</span>
            <span class="k">if</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">langs</span><span class="p">():</span>
                <span class="n">file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">[</span><span class="n">lang</span><span class="p">],</span><span class="n">file</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lang</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Cannot determine </span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">lang</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Language </span><span class="si">{</span><span class="n">lang</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.license"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.license">[docs]</a>    <span class="k">def</span> <span class="nf">license</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the contents of LICENSE (for omw)</span>
<span class="sd">        use lang=lang to get the license for an individual language&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;LICENSE&quot;</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.readme"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.readme">[docs]</a>    <span class="k">def</span> <span class="nf">readme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the contents of README (for omw)</span>
<span class="sd">        use lang=lang to get the readme for an individual language&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;README&quot;</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.citation"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.citation">[docs]</a>    <span class="k">def</span> <span class="nf">citation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="s2">&quot;eng&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the contents of citation.bib file (for omw)</span>
<span class="sd">        use lang=lang to get the citation for an individual language&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;citation.bib&quot;</span><span class="p">,</span> <span class="n">lang</span><span class="o">=</span><span class="n">lang</span><span class="p">)</span></div>

    <span class="c1">#############################################################</span>
    <span class="c1"># Misc</span>
    <span class="c1">#############################################################</span>
<div class="viewcode-block" id="WordNetCorpusReader.lemma_count"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.lemma_count">[docs]</a>    <span class="k">def</span> <span class="nf">lemma_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lemma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the frequency count for this Lemma&quot;&quot;&quot;</span>
        <span class="c1"># Currently, count is only work for English</span>
        <span class="k">if</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_lang</span> <span class="o">!=</span> <span class="s2">&quot;eng&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="c1"># open the count file if we haven&#39;t already</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;cntlist.rev&quot;</span><span class="p">)</span>
        <span class="c1"># find the key in the counts file and return the count</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">_binary_search_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_count_file</span><span class="p">,</span> <span class="n">lemma</span><span class="o">.</span><span class="n">_key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.path_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.path_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>

    <span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.lch_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.lch_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lch_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>

    <span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.wup_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.wup_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="p">)</span></div>

    <span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.res_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.res_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">res_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>

    <span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.jcn_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.jcn_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>

    <span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="WordNetCorpusReader.lin_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.lin_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lin_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>

    <span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="c1">#############################################################</span>
    <span class="c1"># Morphy</span>
    <span class="c1">#############################################################</span>
    <span class="c1"># Morphy, adapted from Oliver Steele&#39;s pywordnet</span>
<div class="viewcode-block" id="WordNetCorpusReader.morphy"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.morphy">[docs]</a>    <span class="k">def</span> <span class="nf">morphy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a possible base form for the given form, with the given</span>
<span class="sd">        part of speech, by checking WordNet&#39;s list of exceptional</span>
<span class="sd">        forms, and by recursively stripping affixes for this part of</span>
<span class="sd">        speech until a form in WordNet is found.</span>

<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy(&#39;dogs&#39;))</span>
<span class="sd">        dog</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy(&#39;churches&#39;))</span>
<span class="sd">        church</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy(&#39;aardwolves&#39;))</span>
<span class="sd">        aardwolf</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy(&#39;abaci&#39;))</span>
<span class="sd">        abacus</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;hardrock&#39;, wn.ADV)</span>
<span class="sd">        &gt;&gt;&gt; print(wn.morphy(&#39;book&#39;, wn.NOUN))</span>
<span class="sd">        book</span>
<span class="sd">        &gt;&gt;&gt; wn.morphy(&#39;book&#39;, wn.ADJ)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">morphy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span>
            <span class="n">analyses</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">POS_LIST</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">morphy</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">analyses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphy</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="p">)</span>

        <span class="c1"># get the first one we find</span>
        <span class="n">first</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">analyses</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">first</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">NOUN</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ses&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ves&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;xes&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;zes&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ches&quot;</span><span class="p">,</span> <span class="s2">&quot;ch&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;shes&quot;</span><span class="p">,</span> <span class="s2">&quot;sh&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;men&quot;</span><span class="p">,</span> <span class="s2">&quot;man&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ies&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">),</span>
        <span class="p">],</span>
        <span class="n">VERB</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ies&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;es&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;es&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ed&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ed&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ing&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;ing&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
        <span class="p">],</span>
        <span class="n">ADJ</span><span class="p">:</span> <span class="p">[(</span><span class="s2">&quot;er&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;est&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;er&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;est&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">)],</span>
        <span class="n">ADV</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>

    <span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span><span class="p">[</span><span class="n">ADJ_SAT</span><span class="p">]</span> <span class="o">=</span> <span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span><span class="p">[</span><span class="n">ADJ</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_morphy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">form</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">check_exceptions</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># from jordanbg:</span>
        <span class="c1"># Given an original string x</span>
        <span class="c1"># 1. Apply rules once to the input to get y1, y2, y3, etc.</span>
        <span class="c1"># 2. Return all that are in the database</span>
        <span class="c1"># 3. If there are no matches, keep applying rules until you either</span>
        <span class="c1">#    find a match or you can&#39;t go any further</span>

        <span class="n">exceptions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exception_map</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">substitutions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MORPHOLOGICAL_SUBSTITUTIONS</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">apply_rules</span><span class="p">(</span><span class="n">forms</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">form</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)]</span> <span class="o">+</span> <span class="n">new</span>
                <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span>
                <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">substitutions</span>
                <span class="k">if</span> <span class="n">form</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">def</span> <span class="nf">filter_forms</span><span class="p">(</span><span class="n">forms</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">forms</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">form</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lemma_pos_offset_map</span><span class="p">[</span><span class="n">form</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">form</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
                            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">form</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># 0. Check the exception lists</span>
        <span class="k">if</span> <span class="n">check_exceptions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">form</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">filter_forms</span><span class="p">([</span><span class="n">form</span><span class="p">]</span> <span class="o">+</span> <span class="n">exceptions</span><span class="p">[</span><span class="n">form</span><span class="p">])</span>

        <span class="c1"># 1. Apply rules once to the input to get y1, y2, y3, etc.</span>
        <span class="n">forms</span> <span class="o">=</span> <span class="n">apply_rules</span><span class="p">([</span><span class="n">form</span><span class="p">])</span>

        <span class="c1"># 2. Return all that are in the database (and check the original too)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">filter_forms</span><span class="p">([</span><span class="n">form</span><span class="p">]</span> <span class="o">+</span> <span class="n">forms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results</span>

        <span class="c1"># 3. If there are no matches, keep applying rules until we find a match</span>
        <span class="k">while</span> <span class="n">forms</span><span class="p">:</span>
            <span class="n">forms</span> <span class="o">=</span> <span class="n">apply_rules</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">filter_forms</span><span class="p">(</span><span class="n">forms</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">results</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">results</span>

        <span class="c1"># Return an empty list if we can&#39;t find anything</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1">#############################################################</span>
    <span class="c1"># Create information content from corpus</span>
    <span class="c1">#############################################################</span>
<div class="viewcode-block" id="WordNetCorpusReader.ic"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.ic">[docs]</a>    <span class="k">def</span> <span class="nf">ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">weight_senses_equally</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an information content lookup dictionary from a corpus.</span>

<span class="sd">        :type corpus: CorpusReader</span>
<span class="sd">        :param corpus: The corpus from which we create an information</span>
<span class="sd">            content dictionary.</span>
<span class="sd">        :type weight_senses_equally: bool</span>
<span class="sd">        :param weight_senses_equally: If this is True, gives all</span>
<span class="sd">            possible senses equal weight rather than dividing by the</span>
<span class="sd">            number of possible senses.  (If a word has 3 synses, each</span>
<span class="sd">            sense gets 0.3333 per appearance when this is False, 1.0 when</span>
<span class="sd">            it is true.)</span>
<span class="sd">        :param smoothing: How much do we smooth synset counts (default is 1.0)</span>
<span class="sd">        :type smoothing: float</span>
<span class="sd">        :return: An information content dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">FreqDist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">corpus</span><span class="o">.</span><span class="n">words</span><span class="p">():</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">ww</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">ic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">POS_LIST</span><span class="p">:</span>
            <span class="n">ic</span><span class="p">[</span><span class="n">pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># Initialize the counts with the smoothing value</span>
        <span class="k">if</span> <span class="n">smoothing</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">POS_LIST</span><span class="p">:</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pp</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothing</span>
            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_synsets</span><span class="p">():</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">_pos</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">ss</span><span class="o">.</span><span class="n">_offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothing</span>

        <span class="k">for</span> <span class="n">ww</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">possible_synsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synsets</span><span class="p">(</span><span class="n">ww</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_synsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Distribute weight among possible synsets</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">ww</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">weight_senses_equally</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">possible_synsets</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">possible_synsets</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">_pos</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
                <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">ss</span><span class="o">.</span><span class="n">_iter_hypernym_lists</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">hh</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>
                        <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">hh</span><span class="o">.</span><span class="n">_offset</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
                <span class="c1"># Add the weight to the root</span>
                <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">weight</span>
        <span class="k">return</span> <span class="n">ic</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.custom_lemmas"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.custom_lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">custom_lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tab_file</span><span class="p">,</span> <span class="n">lang</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads a custom tab file containing mappings of lemmas in the given</span>
<span class="sd">        language to Princeton WordNet 3.0 synset offsets, allowing NLTK&#39;s</span>
<span class="sd">        WordNet functions to then be used with that language.</span>

<span class="sd">        See the &quot;Tab files&quot; section at https://omwn.org/omw1.html for</span>
<span class="sd">        documentation on the Multilingual WordNet tab file format.</span>

<span class="sd">        :param tab_file: Tab file as a file or file-like object</span>
<span class="sd">        :type: lang str</span>
<span class="sd">        :param: lang ISO 639-3 code of the language of the tab file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lg</span> <span class="o">=</span> <span class="n">lang</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lg</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lang should be a (3 character) ISO 639-3 code&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span>
            <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span>
            <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span>
            <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">tab_file</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="c1"># Support byte-stream files (e.g. as returned by Python 2&#39;s</span>
                <span class="c1"># open() function) as well as text-stream ones</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                <span class="n">triple</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triple</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">offset_pos</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">triple</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">triple</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map30</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">offset_pos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">map30</span><span class="p">:</span>
                        <span class="c1"># Map offset_pos to current Wordnet version:</span>
                        <span class="n">offset_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map30</span><span class="p">[</span><span class="n">offset_pos</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Some OMW offsets were never in Wordnet:</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">offset_pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nomap</span>
                            <span class="ow">and</span> <span class="n">offset_pos</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nomap</span>
                        <span class="p">):</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lang</span><span class="si">}</span><span class="s2">: invalid offset </span><span class="si">{</span><span class="n">offset_pos</span><span class="si">}</span><span class="s2"> in &#39;</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                            <span class="p">)</span>
                        <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">offset_pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
                    <span class="n">wnss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">of2ss</span><span class="p">(</span><span class="n">offset_pos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">wnss</span> <span class="ow">and</span> <span class="n">wnss</span><span class="o">.</span><span class="n">pos</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>  <span class="c1"># Wordnet pos is &quot;s&quot;</span>
                        <span class="c1"># Label OMW adjective satellites back to their Wordnet pos (&quot;s&quot;)</span>
                        <span class="n">offset_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ss2of</span><span class="p">(</span><span class="n">wnss</span><span class="p">)</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="n">pair</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">lg</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s2">&quot;lemma&quot;</span><span class="p">:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offset_pos</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lg_attrs</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">lg_attrs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">attr</span><span class="p">)][</span>
                            <span class="n">offset_pos</span>
                        <span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span></div>

<div class="viewcode-block" id="WordNetCorpusReader.disable_custom_lemmas"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.disable_custom_lemmas">[docs]</a>    <span class="k">def</span> <span class="nf">disable_custom_lemmas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lang</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;prevent synsets from being mistakenly added&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lg_attrs</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lang_data</span><span class="p">[</span><span class="n">lang</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">default_factory</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="c1">######################################################################</span>
    <span class="c1"># Visualize WordNet relation graphs using Graphviz</span>
    <span class="c1">######################################################################</span>

<div class="viewcode-block" id="WordNetCorpusReader.digraph"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetCorpusReader.digraph">[docs]</a>    <span class="k">def</span> <span class="nf">digraph</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">,</span>
        <span class="n">rel</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">hypernyms</span><span class="p">(),</span>
        <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxdepth</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">shapes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce a graphical representation from &#39;inputs&#39; (a list of</span>
<span class="sd">        start nodes, which can be a mix of Synsets, Lemmas and/or words),</span>
<span class="sd">        and a synset relation, for drawing with the &#39;dot&#39; graph visualisation</span>
<span class="sd">        program from the Graphviz package.</span>

<span class="sd">        Return a string in the DOT graph file language, which can then be</span>
<span class="sd">        converted to an image by nltk.parse.dependencygraph.dot2img(dot_string).</span>

<span class="sd">        Optional Parameters:</span>
<span class="sd">        :rel: Wordnet synset relation</span>
<span class="sd">        :pos: for words, restricts Part of Speech to &#39;n&#39;, &#39;v&#39;, &#39;a&#39; or &#39;r&#39;</span>
<span class="sd">        :maxdepth: limit the longest path</span>
<span class="sd">        :shapes: dictionary of strings that trigger a specified shape</span>
<span class="sd">        :attr: dictionary with global graph attributes</span>
<span class="sd">        :verbose: warn about cycles</span>

<span class="sd">        &gt;&gt;&gt; from nltk.corpus import wordnet as wn</span>
<span class="sd">        &gt;&gt;&gt; print(wn.digraph([wn.synset(&#39;dog.n.01&#39;)]))</span>
<span class="sd">        digraph G {</span>
<span class="sd">        &quot;Synset(&#39;animal.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;organism.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;canine.n.02&#39;)&quot; -&gt; &quot;Synset(&#39;carnivore.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;carnivore.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;placental.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;chordate.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;animal.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;dog.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;canine.n.02&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;dog.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;domestic_animal.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;domestic_animal.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;animal.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;living_thing.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;whole.n.02&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;mammal.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;vertebrate.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;object.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;physical_entity.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;organism.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;living_thing.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;physical_entity.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;entity.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;placental.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;mammal.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;vertebrate.n.01&#39;)&quot; -&gt; &quot;Synset(&#39;chordate.n.01&#39;)&quot;;</span>
<span class="sd">        &quot;Synset(&#39;whole.n.02&#39;)&quot; -&gt; &quot;Synset(&#39;object.n.01&#39;)&quot;;</span>
<span class="sd">        }</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">nltk.util</span> <span class="kn">import</span> <span class="n">edge_closure</span><span class="p">,</span> <span class="n">edges2dot</span>

        <span class="n">synsets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">add_lemma</span><span class="p">(</span><span class="n">lem</span><span class="p">):</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">lem</span><span class="o">.</span><span class="n">synset</span><span class="p">()</span>
            <span class="n">synsets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">lem</span><span class="p">,</span> <span class="n">ss</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="n">Synset</span><span class="p">:</span>
                <span class="n">synsets</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="n">Lemma</span><span class="p">:</span>
                <span class="n">add_lemma</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lemmas</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
                    <span class="n">add_lemma</span><span class="p">(</span><span class="n">lemma</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">synsets</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">edge_closure</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">rel</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">,</span> <span class="n">verbose</span><span class="p">))</span>
        <span class="n">dot_string</span> <span class="o">=</span> <span class="n">edges2dot</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="p">)),</span> <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dot_string</span></div></div>


<span class="c1">######################################################################</span>
<span class="c1"># WordNet Information Content Corpus Reader</span>
<span class="c1">######################################################################</span>


<div class="viewcode-block" id="WordNetICCorpusReader"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetICCorpusReader">[docs]</a><span class="k">class</span> <span class="nc">WordNetICCorpusReader</span><span class="p">(</span><span class="n">CorpusReader</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A corpus reader for the WordNet information content corpus.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="WordNetICCorpusReader.__init__"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetICCorpusReader.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">):</span>
        <span class="n">CorpusReader</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fileids</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span></div>

    <span class="c1"># this load function would be more efficient if the data was pickled</span>
    <span class="c1"># Note that we can&#39;t use NLTK&#39;s frequency distributions because</span>
    <span class="c1"># synsets are overlapping (each instance of a synset also counts</span>
    <span class="c1"># as an instance of its hypernyms)</span>
<div class="viewcode-block" id="WordNetICCorpusReader.ic"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.WordNetICCorpusReader.ic">[docs]</a>    <span class="k">def</span> <span class="nf">ic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">icfile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load an information content file from the wordnet_ic corpus</span>
<span class="sd">        and return a dictionary.  This dictionary has just two keys,</span>
<span class="sd">        NOUN and VERB, whose values are dictionaries that map from</span>
<span class="sd">        synsets to information content values.</span>

<span class="sd">        :type icfile: str</span>
<span class="sd">        :param icfile: The name of the wordnet_ic file (e.g. &quot;ic-brown.dat&quot;)</span>
<span class="sd">        :return: An information content dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ic</span><span class="p">[</span><span class="n">NOUN</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ic</span><span class="p">[</span><span class="n">VERB</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">icfile</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># skip the header</span>
                    <span class="k">continue</span>
                <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">_get_pos</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">fields</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;ROOT&quot;</span><span class="p">:</span>
                    <span class="c1"># Store root count.</span>
                    <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">ic</span></div></div>


<span class="c1">######################################################################</span>
<span class="c1"># Similarity metrics</span>
<span class="c1">######################################################################</span>

<span class="c1"># TODO: Add in the option to manually add a new root node; this will be</span>
<span class="c1"># useful for verb similarity as there exist multiple verb taxonomies.</span>

<span class="c1"># More information about the metrics is available at</span>
<span class="c1"># http://marimba.d.umn.edu/similarity/measures.html</span>


<div class="viewcode-block" id="path_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.path_similarity">[docs]</a><span class="k">def</span> <span class="nf">path_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">path_similarity</span><span class="p">(</span>
        <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="lch_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.lch_similarity">[docs]</a><span class="k">def</span> <span class="nf">lch_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lch_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span><span class="p">)</span></div>


<div class="viewcode-block" id="wup_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.wup_similarity">[docs]</a><span class="k">def</span> <span class="nf">wup_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">wup_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">simulate_root</span><span class="o">=</span><span class="n">simulate_root</span><span class="p">)</span></div>


<div class="viewcode-block" id="res_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.res_similarity">[docs]</a><span class="k">def</span> <span class="nf">res_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">res_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="jcn_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.jcn_similarity">[docs]</a><span class="k">def</span> <span class="nf">jcn_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="lin_similarity"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.lin_similarity">[docs]</a><span class="k">def</span> <span class="nf">lin_similarity</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">synset1</span><span class="o">.</span><span class="n">lin_similarity</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">path_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lch_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">wup_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">res_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">jcn_similarity</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Synset</span><span class="o">.</span><span class="n">lin_similarity</span><span class="o">.</span><span class="vm">__doc__</span>


<span class="k">def</span> <span class="nf">_lcs_ic</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the information content of the least common subsumer that has</span>
<span class="sd">    the highest information content value.  If two nodes have no</span>
<span class="sd">    explicit common subsumer, assume that they share an artificial</span>
<span class="sd">    root node that is the hypernym of all explicit roots.</span>

<span class="sd">    :type synset1: Synset</span>
<span class="sd">    :param synset1: First input synset.</span>
<span class="sd">    :type synset2: Synset</span>
<span class="sd">    :param synset2: Second input synset.  Must be the same part of</span>
<span class="sd">    speech as the first synset.</span>
<span class="sd">    :type  ic: dict</span>
<span class="sd">    :param ic: an information content object (as returned by ``load_ic()``).</span>
<span class="sd">    :return: The information content of the two synsets and their most</span>
<span class="sd">    informative subsumer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">synset1</span><span class="o">.</span><span class="n">_pos</span> <span class="o">!=</span> <span class="n">synset2</span><span class="o">.</span><span class="n">_pos</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span>
            <span class="s2">&quot;Computing the least common subsumer requires &quot;</span>
            <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> to have the same part of speech.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">synset2</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">ic1</span> <span class="o">=</span> <span class="n">information_content</span><span class="p">(</span><span class="n">synset1</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
    <span class="n">ic2</span> <span class="o">=</span> <span class="n">information_content</span><span class="p">(</span><span class="n">synset2</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span>
    <span class="n">subsumers</span> <span class="o">=</span> <span class="n">synset1</span><span class="o">.</span><span class="n">common_hypernyms</span><span class="p">(</span><span class="n">synset2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subsumers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subsumer_ic</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsumer_ic</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">information_content</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ic</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsumers</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt; LCS Subsumer by content:&quot;</span><span class="p">,</span> <span class="n">subsumer_ic</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ic1</span><span class="p">,</span> <span class="n">ic2</span><span class="p">,</span> <span class="n">subsumer_ic</span>


<span class="c1"># Utility functions</span>


<div class="viewcode-block" id="information_content"><a class="viewcode-back" href="../../../../api/nltk.corpus.reader.wordnet.html#nltk.corpus.reader.information_content">[docs]</a><span class="k">def</span> <span class="nf">information_content</span><span class="p">(</span><span class="n">synset</span><span class="p">,</span> <span class="n">ic</span><span class="p">):</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">synset</span><span class="o">.</span><span class="n">_pos</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="n">ADJ_SAT</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">ADJ</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">icpos</span> <span class="o">=</span> <span class="n">ic</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Information content file has no entries for part-of-speech: </span><span class="si">%s</span><span class="s2">&quot;</span>
        <span class="k">raise</span> <span class="n">WordNetError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">pos</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="n">counts</span> <span class="o">=</span> <span class="n">icpos</span><span class="p">[</span><span class="n">synset</span><span class="o">.</span><span class="n">_offset</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_INF</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts</span> <span class="o">/</span> <span class="n">icpos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<span class="c1"># get the part of speech (NOUN or VERB) from the information content record</span>
<span class="c1"># (each identifier has a &#39;n&#39; or &#39;v&#39; suffix)</span>


<span class="k">def</span> <span class="nf">_get_pos</span><span class="p">(</span><span class="n">field</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;n&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NOUN</span>
    <span class="k">elif</span> <span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">VERB</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Unidentified part of speech in WordNet Information Content file &quot;</span>
            <span class="s2">&quot;for field </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">field</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
</pre></div>

        </div>
      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            
                <li class="footer-element">
                    <a href="https://github.com/nltk/nltk/tree/3.8.1">3.8.1</a>
                </li>
            

            
                <li class="footer-element">
                    Jan 02, 2023
                </li>
            
        </ul>

        
            <div id="copyright">
                &copy; 2023, NLTK Project
            </div>
        

        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/tomaarsen/nltk_theme">NLTK Theme</a>
        </div>
    </div>
</footer> 

</div>

</body>
</html>