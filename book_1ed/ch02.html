<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}

table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document">


<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<div class="compound">
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
</div>
<!-- TODO: add Mark Twain -->
<!-- TODO: discussion of resource rich/poor languages in section on corpora in other languages
number of languages in the world, Ethnologue, etc -->
<!-- TODO: explain double vs single vs triple quotes for strings -->
<!-- TODO: extracting dates from a tokenized text -->
<!-- TODO: finding a sequence of words matching some pattern (including doubled words, e.g. "the thing is is that") -->
<!-- TODO: The Lexicon:
* words are more than just the output of tokenization
* explore what it means for a document to contain a word
* ways this can fail: mis-spelling; different endings; synonyms; homonyms
* type vs token distinction; connection of types to lemmas (cf issue 201)
* concept of "word", many-to-many mapping between forms and meanings
* why the lexicon is an open set, lexical productivity and challenge for NLP
* morphology -->
<!-- Exploratory data analysis, a technique for learning about a specific
linguistic pattern, consists of four steps: search, categorization,
counting, and hypothesis refinement. -->
<!-- TODO: expand the summary -->
<!-- TODO: explain reload() in connection with redefining the lexical_diversity function
(suggested in issue 170) -->
<!-- TODO: style - - reduce number of sents starting with "We can"? -->
<div class="section" id="accessing-text-corpora-and-lexical-resources">
<span id="chap-corpora"></span><h1>2&nbsp;&nbsp;&nbsp;Accessing Text Corpora and Lexical Resources</h1>
<p>Practical work in Natural Language Processing typically uses
large bodies of linguistic data, or <a name="corpora_index_term" /><span class="termdef">corpora</span>.
The goal of this chapter is to answer the following questions:</p>
<ol class="arabic simple">
<li>What are some useful text corpora and lexical resources, and how can we access them with Python?</li>
<li>Which Python constructs are most helpful for this work?</li>
<li>How do we avoid repeating ourselves when writing Python code?</li>
</ol>
<p>This chapter continues to present programming concepts by example, in the
context of a linguistic processing task.  We will wait until later before
exploring each Python construct systematically.  Don't worry if you see
an example that contains something unfamiliar; simply try it out and see
what it does, and &#8212; if you're game &#8212; modify it by substituting
some part of the code with a different text or word.  This way you will
associate a task with a programming idiom, and learn the hows and whys later.</p>
<div class="section" id="accessing-text-corpora">
<span id="sec-extracting-text-from-corpora"></span><h2>2.1&nbsp;&nbsp;&nbsp;Accessing Text Corpora</h2>
<p>As just mentioned, a text corpus is a large body of text. Many
corpora are designed to contain a careful balance of material
in one or more genres.  We examined some small text collections in
<a class="reference external" href="ch01.html#chap-introduction">1</a>, such as the speeches known as the US Presidential
Inaugural Addresses.  This particular corpus actually contains dozens
of individual texts &#8212; one per address &#8212; but for convenience
we glued them end-to-end and treated them as a single text.
<a class="reference external" href="ch01.html#chap-introduction">1</a> also used various pre-defined texts that
we accessed by typing <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> book <span class="pysrc-keyword">import</span> *</span></tt>.  However, since we want
to be able to work with other texts, this section examines a
variety of text corpora. We'll see how
to select individual texts, and how to work with them.</p>
<div class="section" id="gutenberg-corpus">
<h3>Gutenberg Corpus</h3>
<p>NLTK includes a small selection of texts from the Project Gutenberg
electronic text archive, which contains
some 25,000 free electronic books, hosted at <tt class="doctest"><span class="pre">http://www.gutenberg.org/</span></tt>.  We begin
by getting the Python interpreter to load the NLTK package,
then ask to see <tt class="doctest"><span class="pre">nltk.corpus.gutenberg.fileids()</span></tt>, the file identifiers in
this corpus:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">import</span> nltk
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.corpus.gutenberg.fileids()
<span class="pysrc-output">['austen-emma.txt', 'austen-persuasion.txt', 'austen-sense.txt', 'bible-kjv.txt',</span>
<span class="pysrc-output">'blake-poems.txt', 'bryant-stories.txt', 'burgess-busterbrown.txt',</span>
<span class="pysrc-output">'carroll-alice.txt', 'chesterton-ball.txt', 'chesterton-brown.txt',</span>
<span class="pysrc-output">'chesterton-thursday.txt', 'edgeworth-parents.txt', 'melville-moby_dick.txt',</span>
<span class="pysrc-output">'milton-paradise.txt', 'shakespeare-caesar.txt', 'shakespeare-hamlet.txt',</span>
<span class="pysrc-output">'shakespeare-macbeth.txt', 'whitman-leaves.txt']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's pick out the first of these texts &#8212; <em>Emma</em> by Jane Austen &#8212; and
give it a short name, <tt class="doctest"><span class="pre">emma</span></tt>, then find out how many words it contains:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>emma = nltk.corpus.gutenberg.words(<span class="pysrc-string">'austen-emma.txt'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(emma)
<span class="pysrc-output">192427</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p>In <a class="reference external" href="ch01.html#sec-computing-with-language-texts-and-words">1.1</a>, we showed how you
could carry out concordancing of a text such as <tt class="doctest"><span class="pre">text1</span></tt> with the
command <tt class="doctest"><span class="pre">text1.concordance()</span></tt>. However, this assumes that you are
using one of the nine texts obtained as a result of doing <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span>
nltk.book <span class="pysrc-keyword">import</span> *</span></tt>. Now that you have started examining data from
<tt class="doctest"><span class="pre">nltk.corpus</span></tt>, as in the previous example, you have to employ the
following pair of statements to perform concordancing and other
tasks from <a class="reference external" href="ch01.html#sec-computing-with-language-texts-and-words">1.1</a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>emma = nltk.Text(nltk.corpus.gutenberg.words(<span class="pysrc-string">'austen-emma.txt'</span>))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>emma.concordance(<span class="pysrc-string">&quot;surprize&quot;</span>)</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<p>When we defined <tt class="doctest"><span class="pre">emma</span></tt>, we invoked the <tt class="doctest"><span class="pre">words()</span></tt> function of the <tt class="doctest"><span class="pre">gutenberg</span></tt>
object in NLTK's <tt class="doctest"><span class="pre">corpus</span></tt> package.
But since it is cumbersome to type such long names all the time, Python provides
another version of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt> statement, as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> gutenberg
<span class="pysrc-prompt">&gt;&gt;&gt; </span>gutenberg.fileids()
<span class="pysrc-output">['austen-emma.txt', 'austen-persuasion.txt', 'austen-sense.txt', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>emma = gutenberg.words(<span class="pysrc-string">'austen-emma.txt'</span>)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's write a short program to display other information about each
text, by looping over all the values of <tt class="doctest"><span class="pre">fileid</span></tt> corresponding to
the <tt class="doctest"><span class="pre">gutenberg</span></tt> file identifiers listed earlier and then computing
statistics for each text.  For a compact output display, we will make
sure that the numbers are all integers, using <tt class="doctest"><span class="pre">int()</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> fileid <span class="pysrc-keyword">in</span> gutenberg.fileids():
<span class="pysrc-more">... </span>    num_chars = len(gutenberg.raw(fileid)) <a name="raw-access" /><a href="#ref-raw-access"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    num_words = len(gutenberg.words(fileid))
<span class="pysrc-more">... </span>    num_sents = len(gutenberg.sents(fileid))
<span class="pysrc-more">... </span>    num_vocab = len(set([w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> gutenberg.words(fileid)]))
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> int(num_chars/num_words), int(num_words/num_sents), int(num_words/num_vocab), fileid
<span class="pysrc-more">...</span>
<span class="pysrc-output">4 21 26 austen-emma.txt</span>
<span class="pysrc-output">4 23 16 austen-persuasion.txt</span>
<span class="pysrc-output">4 24 22 austen-sense.txt</span>
<span class="pysrc-output">4 33 79 bible-kjv.txt</span>
<span class="pysrc-output">4 18 5 blake-poems.txt</span>
<span class="pysrc-output">4 17 14 bryant-stories.txt</span>
<span class="pysrc-output">4 17 12 burgess-busterbrown.txt</span>
<span class="pysrc-output">4 16 12 carroll-alice.txt</span>
<span class="pysrc-output">4 17 11 chesterton-ball.txt</span>
<span class="pysrc-output">4 19 11 chesterton-brown.txt</span>
<span class="pysrc-output">4 16 10 chesterton-thursday.txt</span>
<span class="pysrc-output">4 18 24 edgeworth-parents.txt</span>
<span class="pysrc-output">4 24 15 melville-moby_dick.txt</span>
<span class="pysrc-output">4 52 10 milton-paradise.txt</span>
<span class="pysrc-output">4 12 8 shakespeare-caesar.txt</span>
<span class="pysrc-output">4 13 7 shakespeare-hamlet.txt</span>
<span class="pysrc-output">4 13 6 shakespeare-macbeth.txt</span>
<span class="pysrc-output">4 35 12 whitman-leaves.txt</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This program displays three statistics for each text:
average word length, average sentence length, and the number of times each vocabulary
item appears in the text on average (our lexical diversity score).
Observe that average word length appears to be a general property of English, since
it has a recurrent value of <tt class="doctest"><span class="pre">4</span></tt>.  (In fact, the average word length is really
<tt class="doctest"><span class="pre">3</span></tt> not <tt class="doctest"><span class="pre">4</span></tt>, since the <tt class="doctest"><span class="pre">num_chars</span></tt> variable counts space characters.)
By contrast average sentence length and lexical diversity
appear to be characteristics of particular authors.</p>
<p>The previous example also showed how we can access the &quot;raw&quot; text of the book <a class="reference internal" href="#raw-access"><span id="ref-raw-access"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
not split up into tokens.  The <tt class="doctest"><span class="pre">raw()</span></tt> function gives us the contents of the file
without any linguistic processing.  So, for example, <tt class="doctest"><span class="pre">len(gutenberg.raw(<span class="pysrc-string">'blake-poems.txt'</span>)</span></tt>
tells us how many <em>letters</em> occur in the text, including the spaces between words.
The <tt class="doctest"><span class="pre">sents()</span></tt> function divides the text up into its sentences, where each sentence is
a list of words:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>macbeth_sentences = gutenberg.sents(<span class="pysrc-string">'shakespeare-macbeth.txt'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>macbeth_sentences
<span class="pysrc-output">[['[', 'The', 'Tragedie', 'of', 'Macbeth', 'by', 'William', 'Shakespeare',</span>
<span class="pysrc-output">'1603', ']'], ['Actus', 'Primus', '.'], ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>macbeth_sentences[1037]
<span class="pysrc-output">['Double', ',', 'double', ',', 'toile', 'and', 'trouble', ';',</span>
<span class="pysrc-output">'Fire', 'burne', ',', 'and', 'Cauldron', 'bubble']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>longest_len = max([len(s) <span class="pysrc-keyword">for</span> s <span class="pysrc-keyword">in</span> macbeth_sentences])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[s <span class="pysrc-keyword">for</span> s <span class="pysrc-keyword">in</span> macbeth_sentences <span class="pysrc-keyword">if</span> len(s) == longest_len]
<span class="pysrc-output">[['Doubtfull', 'it', 'stood', ',', 'As', 'two', 'spent', 'Swimmers', ',', 'that',</span>
<span class="pysrc-output">'doe', 'cling', 'together', ',', 'And', 'choake', 'their', 'Art', ':', 'The',</span>
<span class="pysrc-output">'mercilesse', 'Macdonwald', ...], ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Most NLTK corpus readers include a variety of access methods
apart from <tt class="doctest"><span class="pre">words()</span></tt>, <tt class="doctest"><span class="pre">raw()</span></tt>, and <tt class="doctest"><span class="pre">sents()</span></tt>.  Richer
linguistic content is available from some corpora, such as part-of-speech
tags, dialogue tags, syntactic trees, and so forth; we will see these
in later chapters.</p>
</div>
</div>
<div class="section" id="web-and-chat-text">
<h3>Web and Chat Text</h3>
<p>Although Project Gutenberg contains thousands of books, it represents established
literature.  It is important to consider less formal language as well.  NLTK's
small collection of web text includes content from a Firefox discussion forum,
conversations overheard in New York, the movie script of <em>Pirates of the Carribean</em>,
personal advertisements, and wine reviews:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> webtext
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> fileid <span class="pysrc-keyword">in</span> webtext.fileids():
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> fileid, webtext.raw(fileid)[:65], <span class="pysrc-string">'...'</span>
<span class="pysrc-more">...</span>
<span class="pysrc-output">firefox.txt Cookie Manager: &quot;Don't allow sites that set removed cookies to se...</span>
<span class="pysrc-output">grail.txt SCENE 1: [wind] [clop clop clop] KING ARTHUR: Whoa there!  [clop...</span>
<span class="pysrc-output">overheard.txt White guy: So, do you have any plans for this evening? Asian girl...</span>
<span class="pysrc-output">pirates.txt PIRATES OF THE CARRIBEAN: DEAD MAN'S CHEST, by Ted Elliott &amp; Terr...</span>
<span class="pysrc-output">singles.txt 25 SEXY MALE, seeks attrac older single lady, for discreet encoun...</span>
<span class="pysrc-output">wine.txt Lovely delicate, fragrant Rhone wine. Polished leather and strawb...</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>There is also a corpus of instant messaging chat sessions, originally collected
by the Naval Postgraduate School for research on automatic detection of Internet predators.
The corpus contains over 10,000 posts, anonymized by replacing usernames with generic
names of the form &quot;UserNNN&quot;, and manually edited to remove any other identifying information.
The corpus is organized into 15 files, where each file contains several hundred posts
collected on a given date, for an age-specific chatroom (teens, 20s, 30s, 40s, plus a
generic adults chatroom).  The filename contains the date, chatroom,
and number of posts; e.g., <tt class="doctest"><span class="pre">10-19-20s_706posts.xml</span></tt> contains 706 posts gathered from
the 20s chat room on 10/19/2006.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> nps_chat
<span class="pysrc-prompt">&gt;&gt;&gt; </span>chatroom = nps_chat.posts(<span class="pysrc-string">'10-19-20s_706posts.xml'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>chatroom[123]
<span class="pysrc-output">['i', 'do', &quot;n't&quot;, 'want', 'hot', 'pics', 'of', 'a', 'female', ',',</span>
<span class="pysrc-output">'I', 'can', 'look', 'in', 'a', 'mirror', '.']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="brown-corpus">
<h3>Brown Corpus</h3>
<p>The Brown Corpus was the first million-word electronic
corpus of English, created in 1961 at Brown University.
This corpus contains text from 500 sources, and the sources
have been categorized by genre, such as <em>news</em>, <em>editorial</em>, and so on.
<a class="reference internal" href="#tab-brown-sources">2.1</a> gives an example of each genre
(for a complete list, see <tt class="doctest"><span class="pre">http://icame.uib.no/brown/bcm-los.html</span></tt>).</p>
<span class="target" id="tab-brown-sources"></span><table border="1" class="docutils" id="tab-brown-sources">
<colgroup>
<col width="3%" />
<col width="8%" />
<col width="15%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">ID</th>
<th class="head">File</th>
<th class="head">Genre</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>A16</td>
<td><tt class="doctest"><span class="pre">ca16</span></tt></td>
<td>news</td>
<td>Chicago Tribune: <em>Society Reportage</em></td>
</tr>
<tr><td>B02</td>
<td><tt class="doctest"><span class="pre">cb02</span></tt></td>
<td>editorial</td>
<td>Christian Science Monitor: <em>Editorials</em></td>
</tr>
<tr><td>C17</td>
<td><tt class="doctest"><span class="pre">cc17</span></tt></td>
<td>reviews</td>
<td>Time Magazine: <em>Reviews</em></td>
</tr>
<tr><td>D12</td>
<td><tt class="doctest"><span class="pre">cd12</span></tt></td>
<td>religion</td>
<td>Underwood: <em>Probing the Ethics of Realtors</em></td>
</tr>
<tr><td>E36</td>
<td><tt class="doctest"><span class="pre">ce36</span></tt></td>
<td>hobbies</td>
<td>Norling: <em>Renting a Car in Europe</em></td>
</tr>
<tr><td>F25</td>
<td><tt class="doctest"><span class="pre">cf25</span></tt></td>
<td>lore</td>
<td>Boroff: <em>Jewish Teenage Culture</em></td>
</tr>
<tr><td>G22</td>
<td><tt class="doctest"><span class="pre">cg22</span></tt></td>
<td>belles_lettres</td>
<td>Reiner: <em>Coping with Runaway Technology</em></td>
</tr>
<tr><td>H15</td>
<td><tt class="doctest"><span class="pre">ch15</span></tt></td>
<td>government</td>
<td>US Office of Civil and Defence Mobilization: <em>The Family Fallout Shelter</em></td>
</tr>
<tr><td>J17</td>
<td><tt class="doctest"><span class="pre">cj19</span></tt></td>
<td>learned</td>
<td>Mosteller: <em>Probability with Statistical Applications</em></td>
</tr>
<tr><td>K04</td>
<td><tt class="doctest"><span class="pre">ck04</span></tt></td>
<td>fiction</td>
<td>W.E.B. Du Bois: <em>Worlds of Color</em></td>
</tr>
<tr><td>L13</td>
<td><tt class="doctest"><span class="pre">cl13</span></tt></td>
<td>mystery</td>
<td>Hitchens: <em>Footsteps in the Night</em></td>
</tr>
<tr><td>M01</td>
<td><tt class="doctest"><span class="pre">cm01</span></tt></td>
<td>science_fiction</td>
<td>Heinlein: <em>Stranger in a Strange Land</em></td>
</tr>
<tr><td>N14</td>
<td><tt class="doctest"><span class="pre">cn15</span></tt></td>
<td>adventure</td>
<td>Field: <em>Rattlesnake Ridge</em></td>
</tr>
<tr><td>P12</td>
<td><tt class="doctest"><span class="pre">cp12</span></tt></td>
<td>romance</td>
<td>Callaghan: <em>A Passion in Rome</em></td>
</tr>
<tr><td>R06</td>
<td><tt class="doctest"><span class="pre">cr06</span></tt></td>
<td>humor</td>
<td>Thurber: <em>The Future, If Any, of Comedy</em></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 2.1</span>: <p>Example Document for Each Section of the Brown Corpus</p>
</p>
</table>
<p>We can access the corpus as a list of words, or a list of sentences (where each sentence
is itself just a list of words).  We can optionally specify particular categories or files to read:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> brown
<span class="pysrc-prompt">&gt;&gt;&gt; </span>brown.categories()
<span class="pysrc-output">['adventure', 'belles_lettres', 'editorial', 'fiction', 'government', 'hobbies',</span>
<span class="pysrc-output">'humor', 'learned', 'lore', 'mystery', 'news', 'religion', 'reviews', 'romance',</span>
<span class="pysrc-output">'science_fiction']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>brown.words(categories=<span class="pysrc-string">'news'</span>)
<span class="pysrc-output">['The', 'Fulton', 'County', 'Grand', 'Jury', 'said', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>brown.words(fileids=[<span class="pysrc-string">'cg22'</span>])
<span class="pysrc-output">['Does', 'our', 'society', 'have', 'a', 'runaway', ',', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>brown.sents(categories=[<span class="pysrc-string">'news'</span>, <span class="pysrc-string">'editorial'</span>, <span class="pysrc-string">'reviews'</span>])
<span class="pysrc-output">[['The', 'Fulton', 'County'...], ['The', 'jury', 'further'...], ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The Brown Corpus is a convenient resource for studying systematic differences between
genres, a kind of linguistic inquiry known as <a name="stylistics_index_term" /><span class="termdef">stylistics</span>.
Let's compare genres in their usage of modal verbs.  The first step
is to produce the counts for a particular genre.  Remember to
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span> nltk</span></tt> before doing the following:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> brown
<span class="pysrc-prompt">&gt;&gt;&gt; </span>news_text = brown.words(categories=<span class="pysrc-string">'news'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist = nltk.FreqDist([w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> news_text])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>modals = [<span class="pysrc-string">'can'</span>, <span class="pysrc-string">'could'</span>, <span class="pysrc-string">'may'</span>, <span class="pysrc-string">'might'</span>, <span class="pysrc-string">'must'</span>, <span class="pysrc-string">'will'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> m <span class="pysrc-keyword">in</span> modals:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> m + <span class="pysrc-string">':'</span>, fdist[m],
<span class="pysrc-more">...</span>
<span class="pysrc-output">can: 94 could: 87 may: 93 might: 38 must: 53 will: 389</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Choose a different section of the Brown Corpus, and adapt the previous
example to count a selection of <span class="example">wh</span> words, such as <span class="example">what</span>,
<span class="example">when</span>, <span class="example">where</span>, <span class="example">who</span>, and <span class="example">why</span>.</p>
</div>
<p>Next, we need to obtain counts for each genre of interest.  We'll use
NLTK's support for conditional frequency distributions. These are
presented systematically in <a class="reference internal" href="#sec-conditional-frequency-distributions">2.2</a>,
where we also unpick the following code line by line. For the moment,
you can ignore the details and just concentrate on the output.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(
<span class="pysrc-more">... </span>          (genre, word)
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> genre <span class="pysrc-keyword">in</span> brown.categories()
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> brown.words(categories=genre))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>genres = [<span class="pysrc-string">'news'</span>, <span class="pysrc-string">'religion'</span>, <span class="pysrc-string">'hobbies'</span>, <span class="pysrc-string">'science_fiction'</span>, <span class="pysrc-string">'romance'</span>, <span class="pysrc-string">'humor'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>modals = [<span class="pysrc-string">'can'</span>, <span class="pysrc-string">'could'</span>, <span class="pysrc-string">'may'</span>, <span class="pysrc-string">'might'</span>, <span class="pysrc-string">'must'</span>, <span class="pysrc-string">'will'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd.tabulate(conditions=genres, samples=modals)
<span class="pysrc-output">                 can could  may might must will</span>
<span class="pysrc-output">           news   93   86   66   38   50  389</span>
<span class="pysrc-output">       religion   82   59   78   12   54   71</span>
<span class="pysrc-output">        hobbies  268   58  131   22   83  264</span>
<span class="pysrc-output">science_fiction   16   49    4   12    8   16</span>
<span class="pysrc-output">        romance   74  193   11   51   45   43</span>
<span class="pysrc-output">          humor   16   30    8    8    9   13</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Observe that the most frequent modal in the news genre is <span class="example">will</span>,
while the most frequent modal in the romance genre is <span class="example">could</span>.
Would you have predicted this?  The idea that word counts
might distinguish genres will be taken up again in <a class="reference external" href="ch06.html#chap-data-intensive">chap-data-intensive</a>.</p>
<!-- XXX xref isn't being handled? -->
</div>
<div class="section" id="reuters-corpus">
<h3>Reuters Corpus</h3>
<p>The Reuters Corpus contains 10,788 news documents totaling 1.3 million words.
The documents have been classified into 90 topics, and grouped
into two sets, called &quot;training&quot; and &quot;test&quot;; thus, the text with
fileid <tt class="doctest"><span class="pre"><span class="pysrc-string">'test/14826'</span></span></tt> is a document drawn from the test set. This split is for
training and testing algorithms that automatically detect the topic of a document,
as we will see in <a class="reference external" href="ch06.html#chap-data-intensive">chap-data-intensive</a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> reuters
<span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.fileids()
<span class="pysrc-output">['test/14826', 'test/14828', 'test/14829', 'test/14832', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.categories()
<span class="pysrc-output">['acq', 'alum', 'barley', 'bop', 'carcass', 'castor-oil', 'cocoa',</span>
<span class="pysrc-output">'coconut', 'coconut-oil', 'coffee', 'copper', 'copra-cake', 'corn',</span>
<span class="pysrc-output">'cotton', 'cotton-oil', 'cpi', 'cpu', 'crude', 'dfl', 'dlr', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Unlike the Brown Corpus, categories in the Reuters corpus overlap with
each other, simply because a news story often covers multiple topics.
We can ask for the topics covered by one or more documents, or for the
documents included in one or more categories. For convenience, the
corpus methods accept a single fileid or a list of fileids.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.categories(<span class="pysrc-string">'training/9865'</span>)
<span class="pysrc-output">['barley', 'corn', 'grain', 'wheat']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.categories([<span class="pysrc-string">'training/9865'</span>, <span class="pysrc-string">'training/9880'</span>])
<span class="pysrc-output">['barley', 'corn', 'grain', 'money-fx', 'wheat']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.fileids(<span class="pysrc-string">'barley'</span>)
<span class="pysrc-output">['test/15618', 'test/15649', 'test/15676', 'test/15728', 'test/15871', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.fileids([<span class="pysrc-string">'barley'</span>, <span class="pysrc-string">'corn'</span>])
<span class="pysrc-output">['test/14832', 'test/14858', 'test/15033', 'test/15043', 'test/15106',</span>
<span class="pysrc-output">'test/15287', 'test/15341', 'test/15618', 'test/15618', 'test/15648', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Similarly, we can specify the words or sentences we want in terms of
files or categories. The first handful of words in each of these texts are the
titles, which by convention are stored as upper case.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.words(<span class="pysrc-string">'training/9865'</span>)[:14]
<span class="pysrc-output">['FRENCH', 'FREE', 'MARKET', 'CEREAL', 'EXPORT', 'BIDS',</span>
<span class="pysrc-output">'DETAILED', 'French', 'operators', 'have', 'requested', 'licences', 'to', 'export']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.words([<span class="pysrc-string">'training/9865'</span>, <span class="pysrc-string">'training/9880'</span>])
<span class="pysrc-output">['FRENCH', 'FREE', 'MARKET', 'CEREAL', 'EXPORT', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.words(categories=<span class="pysrc-string">'barley'</span>)
<span class="pysrc-output">['FRENCH', 'FREE', 'MARKET', 'CEREAL', 'EXPORT', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>reuters.words(categories=[<span class="pysrc-string">'barley'</span>, <span class="pysrc-string">'corn'</span>])
<span class="pysrc-output">['THAI', 'TRADE', 'DEFICIT', 'WIDENS', 'IN', 'FIRST', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="inaugural-address-corpus">
<h3>Inaugural Address Corpus</h3>
<!-- XXX fig-inaugural_ isn't being handled correctly in the output -->
<p>In <a class="reference external" href="ch01.html#sec-computing-with-language-texts-and-words">1.1</a>, we looked at
the Inaugural Address Corpus,
but treated it as a single text.  The graph in <a class="reference external" href="ch01.html#fig-inaugural">fig-inaugural</a>
used &quot;word offset&quot; as one of the axes; this is the numerical index of the
word in the corpus, counting from the first word of the first address.
However, the corpus is actually a collection of 55 texts, one for each presidential address.
An interesting property of this collection is its time dimension:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> inaugural
<span class="pysrc-prompt">&gt;&gt;&gt; </span>inaugural.fileids()
<span class="pysrc-output">['1789-Washington.txt', '1793-Washington.txt', '1797-Adams.txt', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[fileid[:4] <span class="pysrc-keyword">for</span> fileid <span class="pysrc-keyword">in</span> inaugural.fileids()]
<span class="pysrc-output">['1789', '1793', '1797', '1801', '1805', '1809', '1813', '1817', '1821', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice that the year of each text appears in its filename.  To get the year
out of the filename, we extracted the first four characters, using <tt class="doctest"><span class="pre">fileid[:4]</span></tt>.</p>
<p>Let's look at how the words <span class="example">America</span> and <span class="example">citizen</span> are used over time.
The following code
converts the words in the Inaugural corpus
to lowercase using <tt class="doctest"><span class="pre">w.lower()</span></tt> <a class="reference internal" href="#lowercase-startswith"><span id="ref-lowercase-startswith"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
then checks if they start with either of the &quot;targets&quot;
<tt class="doctest"><span class="pre">america</span></tt> or <tt class="doctest"><span class="pre">citizen</span></tt> using <tt class="doctest"><span class="pre">startswith()</span></tt> <a class="reference internal" href="#lowercase-startswith"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>.
Thus it will count words like <span class="example">American's</span> and <span class="example">Citizens</span>.
We'll learn about conditional frequency distributions in
<a class="reference internal" href="#sec-conditional-frequency-distributions">2.2</a>; for now just consider
the output, shown in <a class="reference internal" href="#fig-inaugural2">2.1</a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(
<span class="pysrc-more">... </span>          (target, fileid[:4])
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> fileid <span class="pysrc-keyword">in</span> inaugural.fileids()
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> inaugural.words(fileid)
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> target <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'america'</span>, <span class="pysrc-string">'citizen'</span>]
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">if</span> w.lower().startswith(target)) <a name="lowercase-startswith" /><a href="#ref-lowercase-startswith"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd.plot()</pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-inaugural2"></span><div class="figure" id="fig-inaugural2">
<img alt="../images/inaugural2.png" src="../images/inaugural2.png" style="width: 646.74px; height: 292.32px;" />
<p class="caption"><span class="caption-label">Figure 2.1</span>: Plot of a Conditional Frequency Distribution: all words in the Inaugural Address
Corpus that begin with <tt class="doctest"><span class="pre">america</span></tt> or <tt class="doctest"><span class="pre">citizen</span></tt> are counted; separate counts
are kept for each address; these are plotted so that trends in usage over time can
be observed; counts are not normalized for document length.</p>
</div>
</div>
<div class="section" id="annotated-text-corpora">
<h3>Annotated Text Corpora</h3>
<p>Many text corpora contain linguistic annotations, representing POS tags,
named entities, syntactic structures, semantic roles, and so forth.  NLTK provides
convenient ways to access several of these corpora, and has data packages containing corpora
and corpus samples, freely downloadable for use in teaching and research.
<a class="reference internal" href="#tab-corpora">2.2</a> lists some of the corpora.  For information about
downloading them, see <tt class="doctest"><span class="pre">http://www.nltk.org/data</span></tt>.
For more examples of how to access NLTK corpora,
please consult the Corpus HOWTO at <tt class="doctest"><span class="pre">http://www.nltk.org/howto</span></tt>.</p>
<span class="target" id="tab-corpora"></span><table border="1" class="docutils" id="tab-corpora">
<colgroup>
<col width="31%" />
<col width="18%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Corpus</th>
<th class="head">Compiler</th>
<th class="head">Contents</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Brown Corpus</td>
<td>Francis, Kucera</td>
<td>15 genres, 1.15M words, tagged, categorized</td>
</tr>
<tr><td>CESS Treebanks</td>
<td>CLiC-UB</td>
<td>1M words, tagged and parsed (Catalan, Spanish)</td>
</tr>
<tr><td>Chat-80 Data Files</td>
<td>Pereira &amp; Warren</td>
<td>World Geographic Database</td>
</tr>
<tr><td>CMU Pronouncing Dictionary</td>
<td>CMU</td>
<td>127k entries</td>
</tr>
<tr><td>CoNLL 2000 Chunking Data</td>
<td>CoNLL</td>
<td>270k words, tagged and chunked</td>
</tr>
<tr><td>CoNLL 2002 Named Entity</td>
<td>CoNLL</td>
<td>700k words, pos- and named-entity-tagged (Dutch, Spanish)</td>
</tr>
<tr><td>CoNLL 2007 Dependency Treebanks (sel)</td>
<td>CoNLL</td>
<td>150k words, dependency parsed (Basque, Catalan)</td>
</tr>
<tr><td>Dependency Treebank</td>
<td>Narad</td>
<td>Dependency parsed version of Penn Treebank sample</td>
</tr>
<tr><td>Floresta Treebank</td>
<td>Diana Santos et al</td>
<td>9k sentences, tagged and parsed (Portuguese)</td>
</tr>
<tr><td>Gazetteer Lists</td>
<td>Various</td>
<td>Lists of cities and countries</td>
</tr>
<tr><td>Genesis Corpus</td>
<td>Misc web sources</td>
<td>6 texts, 200k words, 6 languages</td>
</tr>
<tr><td>Gutenberg (selections)</td>
<td>Hart, Newby, et al</td>
<td>18 texts, 2M words</td>
</tr>
<tr><td>Inaugural Address Corpus</td>
<td>CSpan</td>
<td>US Presidential Inaugural Addresses (1789-present)</td>
</tr>
<tr><td>Indian POS-Tagged Corpus</td>
<td>Kumaran et al</td>
<td>60k words, tagged (Bangla, Hindi, Marathi, Telugu)</td>
</tr>
<tr><td>MacMorpho Corpus</td>
<td>NILC, USP, Brazil</td>
<td>1M words, tagged (Brazilian Portuguese)</td>
</tr>
<tr><td>Movie Reviews</td>
<td>Pang, Lee</td>
<td>2k movie reviews with sentiment polarity classification</td>
</tr>
<tr><td>Names Corpus</td>
<td>Kantrowitz, Ross</td>
<td>8k male and female names</td>
</tr>
<tr><td>NIST 1999 Info Extr (selections)</td>
<td>Garofolo</td>
<td>63k words, newswire and named-entity SGML markup</td>
</tr>
<tr><td>NPS Chat Corpus</td>
<td>Forsyth, Martell</td>
<td>10k IM chat posts, POS-tagged and dialogue-act tagged</td>
</tr>
<tr><td>PP Attachment Corpus</td>
<td>Ratnaparkhi</td>
<td>28k prepositional phrases, tagged as noun or verb modifiers</td>
</tr>
<tr><td>Proposition Bank</td>
<td>Palmer</td>
<td>113k propositions, 3300 verb frames</td>
</tr>
<tr><td>Question Classification</td>
<td>Li, Roth</td>
<td>6k questions, categorized</td>
</tr>
<tr><td>Reuters Corpus</td>
<td>Reuters</td>
<td>1.3M words, 10k news documents, categorized</td>
</tr>
<tr><td>Roget's Thesaurus</td>
<td>Project Gutenberg</td>
<td>200k words, formatted text</td>
</tr>
<tr><td>RTE Textual Entailment</td>
<td>Dagan et al</td>
<td>8k sentence pairs, categorized</td>
</tr>
<tr><td>SEMCOR</td>
<td>Rus, Mihalcea</td>
<td>880k words, part-of-speech and sense tagged</td>
</tr>
<tr><td>Senseval 2 Corpus</td>
<td>Pedersen</td>
<td>600k words, part-of-speech and sense tagged</td>
</tr>
<tr><td>Shakespeare texts (selections)</td>
<td>Bosak</td>
<td>8 books in XML format</td>
</tr>
<tr><td>State of the Union Corpus</td>
<td>CSPAN</td>
<td>485k words, formatted text</td>
</tr>
<tr><td>Stopwords Corpus</td>
<td>Porter et al</td>
<td>2,400 stopwords for 11 languages</td>
</tr>
<tr><td>Swadesh Corpus</td>
<td>Wiktionary</td>
<td>comparative wordlists in 24 languages</td>
</tr>
<tr><td>Switchboard Corpus (selections)</td>
<td>LDC</td>
<td>36 phonecalls, transcribed, parsed</td>
</tr>
<tr><td>Univ Decl of Human Rights</td>
<td>United Nations</td>
<td>480k words, 300+ languages</td>
</tr>
<tr><td>Penn Treebank (selections)</td>
<td>LDC</td>
<td>40k words, tagged and parsed</td>
</tr>
<tr><td>TIMIT Corpus (selections)</td>
<td>NIST/LDC</td>
<td>audio files and transcripts for 16 speakers</td>
</tr>
<tr><td>VerbNet 2.1</td>
<td>Palmer et al</td>
<td>5k verbs, hierarchically organized, linked to WordNet</td>
</tr>
<tr><td>Wordlist Corpus</td>
<td>OpenOffice.org et al</td>
<td>960k words and 20k affixes for 8 languages</td>
</tr>
<tr><td>WordNet 3.0 (English)</td>
<td>Miller, Fellbaum</td>
<td>145k synonym sets</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 2.2</span>: <p>Some of the Corpora and Corpus Samples Distributed with NLTK: For information about downloading
and using them, please consult the NLTK website.</p>
</p>
</table>
</div>
<div class="section" id="corpora-in-other-languages">
<h3>Corpora in Other Languages</h3>
<p>NLTK comes with corpora for many languages, though in some cases
you will need to learn how to manipulate character encodings in Python
before using these corpora (see <a class="reference external" href="ch03.html#sec-unicode">3.3</a>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.corpus.cess_esp.words()
<span class="pysrc-output">['El', 'grupo', 'estatal', 'Electricit\xe9_de_France', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.corpus.floresta.words()
<span class="pysrc-output">['Um', 'revivalismo', 'refrescante', 'O', '7_e_Meio', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.corpus.indian.words(<span class="pysrc-string">'hindi.pos'</span>)
<span class="pysrc-output">['\xe0\xa4\xaa\xe0\xa5\x82\xe0\xa4\xb0\xe0\xa5\x8d\xe0\xa4\xa3',</span>
<span class="pysrc-output">'\xe0\xa4\xaa\xe0\xa5\x8d\xe0\xa4\xb0\xe0\xa4\xa4\xe0\xa4\xbf\xe0\xa4\xac\xe0\xa4</span>
<span class="pysrc-output">\x82\xe0\xa4\xa7', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.corpus.udhr.fileids()
<span class="pysrc-output">['Abkhaz-Cyrillic+Abkh', 'Abkhaz-UTF8', 'Achehnese-Latin1', 'Achuar-Shiwiar-Latin1',</span>
<span class="pysrc-output">'Adja-UTF8', 'Afaan_Oromo_Oromiffa-Latin1', 'Afrikaans-Latin1', 'Aguaruna-Latin1',</span>
<span class="pysrc-output">'Akuapem_Twi-UTF8', 'Albanian_Shqip-Latin1', 'Amahuaca', 'Amahuaca-Latin1', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.corpus.udhr.words(<span class="pysrc-string">'Javanese-Latin1'</span>)[11:]
<span class="pysrc-output">[u'Saben', u'umat', u'manungsa', u'lair', u'kanthi', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The last of these corpora, <tt class="doctest"><span class="pre">udhr</span></tt>, contains the Universal Declaration of Human Rights
in over 300 languages.  The fileids for this corpus include
information about the character encoding used in the file,
such as <tt class="doctest"><span class="pre">UTF8</span></tt> or <tt class="doctest"><span class="pre">Latin1</span></tt>.
Let's use a conditional frequency distribution to examine the differences in word lengths
for a selection of languages included in the <tt class="doctest"><span class="pre">udhr</span></tt> corpus.
The output is shown in <a class="reference internal" href="#fig-word-len-dist">2.2</a> (run the program yourself to see a color plot).
Note that <tt class="doctest"><span class="pre">True</span></tt> and <tt class="doctest"><span class="pre">False</span></tt> are Python's built-in boolean values.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> udhr
<span class="pysrc-prompt">&gt;&gt;&gt; </span>languages = [<span class="pysrc-string">'Chickasaw'</span>, <span class="pysrc-string">'English'</span>, <span class="pysrc-string">'German_Deutsch'</span>,
<span class="pysrc-more">... </span>    <span class="pysrc-string">'Greenlandic_Inuktikut'</span>, <span class="pysrc-string">'Hungarian_Magyar'</span>, <span class="pysrc-string">'Ibibio_Efik'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(
<span class="pysrc-more">... </span>          (lang, len(word))
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> lang <span class="pysrc-keyword">in</span> languages
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> udhr.words(lang + <span class="pysrc-string">'-Latin1'</span>))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd.plot(cumulative=True)</pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-word-len-dist"></span><div class="figure" id="fig-word-len-dist">
<img alt="../images/word-len-dist.png" src="../images/word-len-dist.png" style="width: 613.0px; height: 463.0px;" />
<p class="caption"><span class="caption-label">Figure 2.2</span>: Cumulative Word Length Distributions:
Six translations of the Universal Declaration of Human Rights are processed;
this graph shows that words having 5 or fewer letters account for about
80% of Ibibio text, 60% of German text, and 25% of Inuktitut text.</p>
</div>
<!-- XXX In the following, nltk.FreqDist got wrapped weirdly (as FreqD-ist) -->
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Pick a language of interest in <tt class="doctest"><span class="pre">udhr.fileids()</span></tt>, and define a variable
<tt class="doctest"><span class="pre">raw_text = udhr.raw(</span></tt><em>Language-Latin1</em><tt class="doctest"><span class="pre">)</span></tt>.  Now plot a frequency
distribution of the letters of the text using <tt class="doctest"><span class="pre">nltk.FreqDist(raw_text).plot()</span></tt>.</p>
</div>
<p>Unfortunately, for many languages, substantial corpora are not yet available.  Often there is
insufficient government or industrial support for developing language resources, and individual
efforts are piecemeal and hard to discover or re-use.  Some languages have no
established writing system, or are endangered.  (See <a class="reference internal" href="#sec-further-reading-corpora">2.7</a>
for suggestions on how to locate language resources.)</p>
</div>
<div class="section" id="text-corpus-structure">
<h3>Text Corpus Structure</h3>
<p>We have seen a variety of corpus structures so far; these are
summarized in <a class="reference internal" href="#fig-text-corpus-structure">2.3</a>.
The simplest kind lacks any structure: it is just a collection of texts.
Often, texts are grouped into categories that might correspond to genre, source, author, language, etc.
Sometimes these categories overlap, notably in the case of topical categories as a text can be
relevant to more than one topic.  Occasionally, text collections have temporal structure,
news collections being the most common example.</p>
<span class="target" id="fig-text-corpus-structure"></span><div class="figure" id="fig-text-corpus-structure">
<img alt="../images/text-corpus-structure.png" src="../images/text-corpus-structure.png" style="width: 607.2px; height: 129.6px;" />
<p class="caption"><span class="caption-label">Figure 2.3</span>: Common Structures for Text Corpora: The simplest kind of corpus is a collection
of isolated texts with no particular organization; some corpora are structured
into categories like genre (Brown Corpus); some categorizations overlap, such as
topic categories (Reuters Corpus); other corpora represent language use over time
(Inaugural Address Corpus).</p>
</div>
<span class="target" id="tab-corpus"></span><table border="1" class="docutils" id="tab-corpus">
<colgroup>
<col width="35%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Example</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">fileids()</span></tt></td>
<td>the files of the corpus</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fileids([categories])</span></tt></td>
<td>the files of the corpus corresponding to these categories</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">categories()</span></tt></td>
<td>the categories of the corpus</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">categories([fileids])</span></tt></td>
<td>the categories of the corpus corresponding to these files</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">raw()</span></tt></td>
<td>the raw content of the corpus</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">raw(fileids=[f1,f2,f3])</span></tt></td>
<td>the raw content of the specified files</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">raw(categories=[c1,c2])</span></tt></td>
<td>the raw content of the specified categories</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">words()</span></tt></td>
<td>the words of the whole corpus</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">words(fileids=[f1,f2,f3])</span></tt></td>
<td>the words of the specified fileids</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">words(categories=[c1,c2])</span></tt></td>
<td>the words of the specified categories</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">sents()</span></tt></td>
<td>the sentences of the whole corpus</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">sents(fileids=[f1,f2,f3])</span></tt></td>
<td>the sentences of the specified fileids</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">sents(categories=[c1,c2])</span></tt></td>
<td>the sentences of the specified categories</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">abspath(fileid)</span></tt></td>
<td>the location of the given file on disk</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">encoding(fileid)</span></tt></td>
<td>the encoding of the file (if known)</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">open(fileid)</span></tt></td>
<td>open a stream for reading the given corpus file</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">root()</span></tt></td>
<td>the path to the root of locally installed corpus</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">readme()</span></tt></td>
<td>the contents of the README file of the corpus</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 2.3</span>: <p>Basic Corpus Functionality defined in NLTK: more documentation can be found using
<tt class="doctest"><span class="pre">help(nltk.corpus.reader)</span></tt> and by reading the online Corpus HOWTO at <tt class="doctest"><span class="pre">http://www.nltk.org/howto</span></tt>.</p>
</p>
</table>
<p>NLTK's corpus readers support efficient access to a variety of corpora, and can
be used to work with new corpora.  <a class="reference internal" href="#tab-corpus">2.3</a> lists functionality
provided by the corpus readers.  We illustrate the difference between some
of the corpus access methods below:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>raw = gutenberg.raw(<span class="pysrc-string">&quot;burgess-busterbrown.txt&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>raw[1:20]
<span class="pysrc-output">'The Adventures of B'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>words = gutenberg.words(<span class="pysrc-string">&quot;burgess-busterbrown.txt&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words[1:20]
<span class="pysrc-output">['The', 'Adventures', 'of', 'Buster', 'Bear', 'by', 'Thornton', 'W', '.',</span>
<span class="pysrc-output">'Burgess', '1920', ']', 'I', 'BUSTER', 'BEAR', 'GOES', 'FISHING', 'Buster',</span>
<span class="pysrc-output">'Bear']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sents = gutenberg.sents(<span class="pysrc-string">&quot;burgess-busterbrown.txt&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sents[1:20]
<span class="pysrc-output">[['I'], ['BUSTER', 'BEAR', 'GOES', 'FISHING'], ['Buster', 'Bear', 'yawned', 'as',</span>
<span class="pysrc-output">'he', 'lay', 'on', 'his', 'comfortable', 'bed', 'of', 'leaves', 'and', 'watched',</span>
<span class="pysrc-output">'the', 'first', 'early', 'morning', 'sunbeams', 'creeping', 'through', ...], ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="loading-your-own-corpus">
<h3>Loading your own Corpus</h3>
<p>If you have a your own collection of text files that you would like to access using
the above methods, you can easily load them with the help of NLTK's
<tt class="doctest"><span class="pre">PlaintextCorpusReader</span></tt>. Check the location of your files on your file system; in
the following example, we have taken this to be the directory
<tt class="doctest"><span class="pre">/usr/share/dict</span></tt>. Whatever the location, set this to be the value of
<tt class="doctest"><span class="pre">corpus_root</span></tt> <a class="reference internal" href="#corpus-root-dict"><span id="ref-corpus-root-dict"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
The second parameter of the <tt class="doctest"><span class="pre">PlaintextCorpusReader</span></tt> initializer <a class="reference internal" href="#corpus-reader"><span id="ref-corpus-reader"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>
can be a list of fileids, like <tt class="doctest"><span class="pre">[<span class="pysrc-string">'a.txt'</span>, <span class="pysrc-string">'test/b.txt'</span>]</span></tt>,
or a pattern that matches all fileids, like <tt class="doctest"><span class="pre"><span class="pysrc-string">'[abc]/.*\.txt'</span></span></tt>
(see <a class="reference external" href="ch03.html#sec-regular-expressions-word-patterns">3.4</a> for information
about regular expressions).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> PlaintextCorpusReader
<span class="pysrc-prompt">&gt;&gt;&gt; </span>corpus_root = <span class="pysrc-string">'/usr/share/dict'</span> <a name="corpus-root-dict" /><a href="#ref-corpus-root-dict"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wordlists = PlaintextCorpusReader(corpus_root, <span class="pysrc-string">'.*'</span>) <a name="corpus-reader" /><a href="#ref-corpus-reader"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wordlists.fileids()
<span class="pysrc-output">['README', 'connectives', 'propernames', 'web2', 'web2a', 'words']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wordlists.words(<span class="pysrc-string">'connectives'</span>)
<span class="pysrc-output">['the', 'of', 'and', 'to', 'a', 'in', 'that', 'is', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>As another example, suppose you have your own local copy of Penn Treebank (release 3),
in <tt class="doctest"><span class="pre">C:\corpora</span></tt>.  We can use the <tt class="doctest"><span class="pre">BracketParseCorpusReader</span></tt> to access this
corpus.  We specify the <tt class="doctest"><span class="pre">corpus_root</span></tt> to be the location of the parsed Wall Street
Journal component of the corpus <a class="reference internal" href="#corpus-root-treebank"><span id="ref-corpus-root-treebank"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, and give a <tt class="doctest"><span class="pre">file_pattern</span></tt>
that matches the files contained within its subfolders <a class="reference internal" href="#file-pattern"><span id="ref-file-pattern"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a> (using forward slashes).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> BracketParseCorpusReader
<span class="pysrc-prompt">&gt;&gt;&gt; </span>corpus_root = r<span class="pysrc-string">&quot;C:\corpora\penntreebank\parsed\mrg\wsj&quot;</span> <a name="corpus-root-treebank" /><a href="#ref-corpus-root-treebank"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>file_pattern = r<span class="pysrc-string">&quot;.*/wsj_.*\.mrg&quot;</span> <a name="file-pattern" /><a href="#ref-file-pattern"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>ptb = BracketParseCorpusReader(corpus_root, file_pattern)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>ptb.fileids()
<span class="pysrc-output">['00/wsj_0001.mrg', '00/wsj_0002.mrg', '00/wsj_0003.mrg', '00/wsj_0004.mrg', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(ptb.sents())
<span class="pysrc-output">49208</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>ptb.sents(fileids=<span class="pysrc-string">'20/wsj_2013.mrg'</span>)[19]
<span class="pysrc-output">['The', '55-year-old', 'Mr.', 'Noriega', 'is', &quot;n't&quot;, 'as', 'smooth', 'as', 'the',</span>
<span class="pysrc-output">'shah', 'of', 'Iran', ',', 'as', 'well-born', 'as', 'Nicaragua', &quot;'s&quot;, 'Anastasio',</span>
<span class="pysrc-output">'Somoza', ',', 'as', 'imperial', 'as', 'Ferdinand', 'Marcos', 'of', 'the', 'Philippines',</span>
<span class="pysrc-output">'or', 'as', 'bloody', 'as', 'Haiti', &quot;'s&quot;, 'Baby', Doc', 'Duvalier', '.']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="conditional-frequency-distributions">
<span id="sec-conditional-frequency-distributions"></span><h2>2.2&nbsp;&nbsp;&nbsp;Conditional Frequency Distributions</h2>
<p>We introduced frequency distributions in <a class="reference external" href="ch01.html#sec-computing-with-language-simple-statistics">1.3</a>.
We saw that given some list <tt class="doctest"><span class="pre">mylist</span></tt> of words or other items,
<tt class="doctest"><span class="pre">FreqDist(mylist)</span></tt> would compute the number of occurrences of each
item in the list.  Here we will generalize this idea.</p>
<p>When the texts of a corpus are divided into several
categories, by genre, topic, author, etc, we can maintain separate
frequency distributions for each category.  This will allow us to
study systematic differences between the categories.  In the previous
section we achieved this using NLTK's <tt class="doctest"><span class="pre">ConditionalFreqDist</span></tt> data
type.  A <a name="conditional_frequency_distribution_index_term" /><span class="termdef">conditional frequency distribution</span> is a collection of
frequency distributions, each one for a different &quot;condition&quot;.  The
condition will often be the category of the text.  <a class="reference internal" href="#fig-tally2">2.4</a>
depicts a fragment of a conditional frequency distribution having just
two conditions, one for news text and one for romance text.</p>
<span class="target" id="fig-tally2"></span><div class="figure" id="fig-tally2">
<img alt="../images/tally2.png" src="../images/tally2.png" style="width: 412.3px; height: 130.2px;" />
<p class="caption"><span class="caption-label">Figure 2.4</span>: Counting Words Appearing in a Text Collection (a conditional frequency distribution)</p>
</div>
<div class="section" id="conditions-and-events">
<h3>Conditions and Events</h3>
<p>A frequency distribution counts observable events,
such as the appearance of words in a text.  A conditional
frequency distribution needs to pair each event with a condition.
So instead of processing a sequence of words <a class="reference internal" href="#seq-words"><span id="ref-seq-words"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
we have to process a sequence of pairs <a class="reference internal" href="#seq-pairs"><span id="ref-seq-pairs"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = [<span class="pysrc-string">'The'</span>, <span class="pysrc-string">'Fulton'</span>, <span class="pysrc-string">'County'</span>, <span class="pysrc-string">'Grand'</span>, <span class="pysrc-string">'Jury'</span>, <span class="pysrc-string">'said'</span>, ...] <a name="seq-words" /><a href="#ref-seq-words"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pairs = [(<span class="pysrc-string">'news'</span>, <span class="pysrc-string">'The'</span>), (<span class="pysrc-string">'news'</span>, <span class="pysrc-string">'Fulton'</span>), (<span class="pysrc-string">'news'</span>, <span class="pysrc-string">'County'</span>), ...] <a name="seq-pairs" /><a href="#ref-seq-pairs"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Each pair has the form <tt class="doctest"><span class="pre">(condition, event)</span></tt>.  If we were processing the
entire Brown Corpus by genre there would be 15 conditions (one per genre),
and 1,161,192 events (one per word).</p>
</div>
<div class="section" id="counting-words-by-genre">
<h3>Counting Words by Genre</h3>
<p>In <a class="reference internal" href="#sec-extracting-text-from-corpora">2.1</a> we saw a conditional
frequency distribution where the condition was the section of the
Brown Corpus, and for each condition we counted words. Whereas
<tt class="doctest"><span class="pre">FreqDist()</span></tt> takes a simple list as input, <tt class="doctest"><span class="pre">ConditionalFreqDist()</span></tt>
takes a list of pairs.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> brown
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(
<span class="pysrc-more">... </span>          (genre, word)
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> genre <span class="pysrc-keyword">in</span> brown.categories()
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> brown.words(categories=genre))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's break this down, and look at just two genres, news and romance.
For each genre <a class="reference internal" href="#each-genre"><span id="ref-each-genre"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>, we loop over every word in the genre <a class="reference internal" href="#each-word"><span id="ref-each-word"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>,
producing pairs consisting of the genre and the word <a class="reference internal" href="#genre-word-pairs"><span id="ref-genre-word-pairs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>genre_word = [(genre, word) <a name="genre-word-pairs" /><a href="#ref-genre-word-pairs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>              <span class="pysrc-keyword">for</span> genre <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'news'</span>, <span class="pysrc-string">'romance'</span>] <a name="each-genre" /><a href="#ref-each-genre"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">... </span>              <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> brown.words(categories=genre)] <a name="each-word" /><a href="#ref-each-word"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(genre_word)
<span class="pysrc-output">170576</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>So, as we can see below,
pairs at the beginning of the list <tt class="doctest"><span class="pre">genre_word</span></tt> will be of the form
(<tt class="doctest"><span class="pre"><span class="pysrc-string">'news'</span></span></tt>, <em>word</em>) <a class="reference internal" href="#start-genre"><span id="ref-start-genre"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, while those at the end will be of the form
(<tt class="doctest"><span class="pre"><span class="pysrc-string">'romance'</span></span></tt>, <em>word</em>) <a class="reference internal" href="#end-genre"><span id="ref-end-genre"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>genre_word[:4]
<span class="pysrc-output">[('news', 'The'), ('news', 'Fulton'), ('news', 'County'), ('news', 'Grand')] # [_start-genre]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>genre_word[-4:]
<span class="pysrc-output">[('romance', 'afraid'), ('romance', 'not'), ('romance', &quot;''&quot;), ('romance', '.')] # [_end-genre]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can now use this list of pairs to create a <tt class="doctest"><span class="pre">ConditionalFreqDist</span></tt>, and
save it in a variable <tt class="doctest"><span class="pre">cfd</span></tt>.  As usual, we can type the name of the
variable to inspect it <a class="reference internal" href="#inspect-cfd"><span id="ref-inspect-cfd"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, and verify it has two conditions <a class="reference internal" href="#conditions-cfd"><span id="ref-conditions-cfd"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(genre_word)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd <a name="inspect-cfd" /><a href="#ref-inspect-cfd"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">&lt;ConditionalFreqDist with 2 conditions&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd.conditions()
<span class="pysrc-output">['news', 'romance'] # [_conditions-cfd]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's access the two conditions, and satisfy ourselves that each is just
a frequency distribution:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd[<span class="pysrc-string">'news'</span>]
<span class="pysrc-output">&lt;FreqDist with 100554 outcomes&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd[<span class="pysrc-string">'romance'</span>]
<span class="pysrc-output">&lt;FreqDist with 70022 outcomes&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>list(cfd[<span class="pysrc-string">'romance'</span>])
<span class="pysrc-output">[',', '.', 'the', 'and', 'to', 'a', 'of', '``', &quot;''&quot;, 'was', 'I', 'in', 'he', 'had',</span>
<span class="pysrc-output">'?', 'her', 'that', 'it', 'his', 'she', 'with', 'you', 'for', 'at', 'He', 'on', 'him',</span>
<span class="pysrc-output">'said', '!', '--', 'be', 'as', ';', 'have', 'but', 'not', 'would', 'She', 'The', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd[<span class="pysrc-string">'romance'</span>][<span class="pysrc-string">'could'</span>]
<span class="pysrc-output">193</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="plotting-and-tabulating-distributions">
<h3>Plotting and Tabulating Distributions</h3>
<p>Apart from combining two or more frequency distributions, and being easy to initialize,
a <tt class="doctest"><span class="pre">ConditionalFreqDist</span></tt> provides some useful methods for tabulation and plotting.</p>
<p>The plot in <a class="reference internal" href="#fig-inaugural2">2.1</a> was based on a conditional frequency distribution
reproduced in the code below.
The condition is either of the words <span class="example">america</span> or <span class="example">citizen</span> <a class="reference internal" href="#america-citizen"><span id="ref-america-citizen"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
and the counts being plotted are the number of times the word occured in a particular speech.
It expoits the fact that the filename for each speech, e.g., <tt class="doctest"><span class="pre">1865-Lincoln.txt</span></tt>
contains the year as the first four characters <a class="reference internal" href="#first-four-chars"><span id="ref-first-four-chars"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
This code generates the pair <tt class="doctest"><span class="pre">(<span class="pysrc-string">'america'</span>, <span class="pysrc-string">'1865'</span>)</span></tt> for
every instance of a word whose lowercased form starts with <span class="example">america</span>
&#8212; such as <span class="example">Americans</span> &#8212; in the file <tt class="doctest"><span class="pre">1865-Lincoln.txt</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> inaugural
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(
<span class="pysrc-more">... </span>          (target, fileid[:4]) <a name="first-four-chars" /><a href="#ref-first-four-chars"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> fileid <span class="pysrc-keyword">in</span> inaugural.fileids()
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> inaugural.words(fileid)
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> target <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'america'</span>, <span class="pysrc-string">'citizen'</span>] <a name="america-citizen" /><a href="#ref-america-citizen"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">if</span> w.lower().startswith(target))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The plot in <a class="reference internal" href="#fig-word-len-dist">2.2</a> was also based on a conditional frequency distribution,
reproduced below.  This time, the condition is the name of the language
and the counts being plotted are derived from word lengths <a class="reference internal" href="#lang-len-word"><span id="ref-lang-len-word"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
It exploits the fact that the filename for each language is the language name followed
by <tt class="doctest"><span class="pre"><span class="pysrc-string">'-Latin1'</span></span></tt> (the character encoding).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> udhr
<span class="pysrc-prompt">&gt;&gt;&gt; </span>languages = [<span class="pysrc-string">'Chickasaw'</span>, <span class="pysrc-string">'English'</span>, <span class="pysrc-string">'German_Deutsch'</span>,
<span class="pysrc-more">... </span>    <span class="pysrc-string">'Greenlandic_Inuktikut'</span>, <span class="pysrc-string">'Hungarian_Magyar'</span>, <span class="pysrc-string">'Ibibio_Efik'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(
<span class="pysrc-more">... </span>          (lang, len(word)) <a name="lang-len-word" /><a href="#ref-lang-len-word"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> lang <span class="pysrc-keyword">in</span> languages
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> udhr.words(lang + <span class="pysrc-string">'-Latin1'</span>))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In the <tt class="doctest"><span class="pre">plot()</span></tt> and <tt class="doctest"><span class="pre">tabulate()</span></tt> methods, we can
optionally specify which conditions to display with a <tt class="doctest"><span class="pre">conditions=</span></tt> parameter.
When we omit it, we get all the conditions.  Similarly, we can limit the
samples to display with a <tt class="doctest"><span class="pre">samples=</span></tt> parameter.  This makes it possible to
load a large quantity of data into a conditional frequency distribution, and then
to explore it by plotting or tabulating selected conditions and samples.  It also
gives us full control over the order of conditions and samples in any displays.
For example, we can tabulate the cumulative frequency data just for two
languages, and for words less than 10 characters long, as shown below.
We interpret a the last cell on the top row to mean that 1,638 words of the
English text have 9 or fewer letters.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd.tabulate(conditions=[<span class="pysrc-string">'English'</span>, <span class="pysrc-string">'German_Deutsch'</span>],
<span class="pysrc-more">... </span>             samples=range(10), cumulative=True)
<span class="pysrc-output">                  0    1    2    3    4    5    6    7    8    9</span>
<span class="pysrc-output">       English    0  185  525  883  997 1166 1283 1440 1558 1638</span>
<span class="pysrc-output">German_Deutsch    0  171  263  614  717  894 1013 1110 1213 1275</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Working with the news and romance genres from the Brown Corpus,
find out which days of the week are most newsworthy, and which are most romantic.
Define a variable called <tt class="doctest"><span class="pre">days</span></tt> containing a list of days of the week, i.e.
<tt class="doctest"><span class="pre">[<span class="pysrc-string">'Monday'</span>, ...]</span></tt>.  Now tabulate the counts for these words using
<tt class="doctest"><span class="pre">cfd.tabulate(samples=days)</span></tt>.  Now try the same thing using <tt class="doctest"><span class="pre">plot</span></tt> in place of <tt class="doctest"><span class="pre">tabulate</span></tt>.
You may control the output order of days with the help of an extra parameter:
<tt class="doctest"><span class="pre">conditions=[<span class="pysrc-string">'Monday'</span>, ...]</span></tt>.</p>
</div>
<p>You may have noticed that the multi-line expressions we have been
using with conditional frequency distributions look like list
comprehensions, but without the brackets.  In general,
when we use a list comprehension as a parameter to a function,
like <tt class="doctest"><span class="pre">set([w.lower <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> t])</span></tt>, we are permitted to omit
the square brackets and just write: <tt class="doctest"><span class="pre">set(w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> t)</span></tt>.
(See the discussion of &quot;generator expressions&quot; in <a class="reference external" href="ch04.html#sec-sequences">4.2</a>
for more about this.)</p>
</div>
<div class="section" id="generating-random-text-with-bigrams">
<h3>Generating Random Text with Bigrams</h3>
<p>We can use a conditional frequency distribution to create a table of
bigrams (word pairs). (We introducted bigrams in
<a class="reference external" href="ch01.html#sec-computing-with-language-simple-statistics">1.3</a>.)
The <tt class="doctest"><span class="pre">bigrams()</span></tt> function takes a list of
words and builds a list of consecutive word pairs:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'In'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'beginning'</span>, <span class="pysrc-string">'God'</span>, <span class="pysrc-string">'created'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'heaven'</span>,
<span class="pysrc-more">... </span>  <span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'earth'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.bigrams(sent)
<span class="pysrc-output">[('In', 'the'), ('the', 'beginning'), ('beginning', 'God'), ('God', 'created'),</span>
<span class="pysrc-output">('created', 'the'), ('the', 'heaven'), ('heaven', 'and'), ('and', 'the'),</span>
<span class="pysrc-output">('the', 'earth'), ('earth', '.')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In <a class="reference internal" href="#code-random-text">2.5</a>, we treat each word as a condition, and for each one
we effectively create a frequency distribution over the following
words.  The function <tt class="doctest"><span class="pre">generate_model()</span></tt> contains a simple loop to
generate text. When we call the function, we choose a word (such as
<tt class="doctest"><span class="pre"><span class="pysrc-string">'living'</span></span></tt>) as our initial context, then once inside the loop, we
print the current value of the variable <tt class="doctest"><span class="pre">word</span></tt>, and reset <tt class="doctest"><span class="pre">word</span></tt>
to be the most likely token in that context (using <tt class="doctest"><span class="pre">max()</span></tt>); next
time through the loop, we use that word as our new context.  As you
can see by inspecting the output, this simple approach to text
generation tends to get stuck in loops; another method would be to
randomly choose the next word from among the available words.</p>
<span class="target" id="code-random-text"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">generate_model</span>(cfdist, word, num=15):
    <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(num):
        <span class="pysrc-keyword">print</span> word,
        word = cfdist[word].max()

text = nltk.corpus.genesis.words(<span class="pysrc-string">'english-kjv.txt'</span>)
bigrams = nltk.bigrams(text)
cfd = nltk.ConditionalFreqDist(bigrams) <a name="bigram-condition" /><a href="#ref-bigram-condition"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a></pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span> cfd[<span class="pysrc-string">'living'</span>]
<span class="pysrc-output">&lt;FreqDist: 'creature': 7, 'thing': 4, 'substance': 2, ',': 1, '.': 1, 'soul': 1&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>generate_model(cfd, <span class="pysrc-string">'living'</span>)
<span class="pysrc-output">living creature that he said , and the land of the land of the land</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_random_text.py" type="text/x-python"><span class="caption-label">Example 2.5 (code_random_text.py)</span></a>: <span class="caption-label">Figure 2.5</span>: Generating Random Text: this program obtains all bigrams
from the text of the book of Genesis, then constructs a
conditional frequency distribution to record which
words are most likely to follow a given word; e.g., after
the word <span class="example">living</span>, the most likely word is
<span class="example">creature</span>; the <tt class="doctest"><span class="pre">generate_model()</span></tt> function uses this
data, and a seed word, to generate random text.</td></tr></p>
</table></div>
<p>Conditional frequency distributions are a useful data structure for many NLP tasks.
Their commonly-used methods are summarized in <a class="reference internal" href="#tab-conditionalfreqdist">2.4</a>.</p>
<span class="target" id="tab-conditionalfreqdist"></span><table border="1" class="docutils" id="tab-conditionalfreqdist">
<colgroup>
<col width="36%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Example</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">cfdist = ConditionalFreqDist(pairs)</span></tt></td>
<td>create a conditional frequency distribution from a list of pairs</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist.conditions()</span></tt></td>
<td>alphabetically sorted list of conditions</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist[condition]</span></tt></td>
<td>the frequency distribution for this condition</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist[condition][sample]</span></tt></td>
<td>frequency for the given sample for this condition</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist.tabulate()</span></tt></td>
<td>tabulate the conditional frequency distribution</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist.tabulate(samples, conditions)</span></tt></td>
<td>tabulation limited to the specified samples and conditions</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist.plot()</span></tt></td>
<td>graphical plot of the conditional frequency distribution</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist.plot(samples, conditions)</span></tt></td>
<td>graphical plot limited to the specified samples and conditions</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">cfdist1 &lt; cfdist2</span></tt></td>
<td>test if samples in <tt class="doctest"><span class="pre">cfdist1</span></tt> occur less frequently than in <tt class="doctest"><span class="pre">cfdist2</span></tt></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 2.4</span>: <p>NLTK's Conditional Frequency Distributions: commonly-used methods and idioms for defining,
accessing, and visualizing a conditional frequency distribution.
of counters.</p>
</p>
</table>
</div>
</div>
<div class="section" id="more-python-reusing-code">
<span id="sec-reusing-code"></span><h2>2.3&nbsp;&nbsp;&nbsp;More Python: Reusing Code</h2>
<p>By this time you've probably typed and retyped a lot of code in the Python
interactive interpreter.  If you mess up when retyping a complex example you have
to enter it again.  Using the arrow keys to access and modify previous commands is helpful but only goes so
far.  In this section we see two important ways to reuse code: text editors and Python functions.</p>
<div class="section" id="creating-programs-with-a-text-editor">
<h3>Creating Programs with a Text Editor</h3>
<p>The Python interactive interpreter performs your instructions as soon as you type
them.  Often, it is better to compose a multi-line program using a text editor,
then ask Python to run the whole program at once.  Using IDLE, you can do
this by going to the <tt class="doctest"><span class="pre">File</span></tt> menu and opening a new window.  Try this now, and
enter the following one-line program:</p>
<pre class="literal-block">
print 'Monty Python'
</pre>
<p>Save this program in a file called <tt class="doctest"><span class="pre">monty.py</span></tt>, then
go to the <tt class="doctest"><span class="pre">Run</span></tt> menu, and select the command <tt class="doctest"><span class="pre">Run Module</span></tt>.
(We'll learn what modules are shortly.)
The result in the main IDLE window should look like this:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>================================ RESTART ================================
<span class="pysrc-prompt">&gt;&gt;&gt;</span>
<span class="pysrc-output">Monty Python</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>You can also type <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> monty <span class="pysrc-keyword">import</span> *</span></tt> and it will do the same thing.</p>
<p>From now on, you have a choice of using the interactive interpreter or a
text editor to create your programs.  It is often convenient to test your ideas
using the interpreter, revising a line of code until it does what you expect.
Once you're ready, you can paste the code
(minus any <tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> or <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> prompts) into the text editor,
continue to expand it, and finally save the program
in a file so that you don't have to type it in again later.
Give the file a short but descriptive name, using all lowercase letters and separating
words with underscore, and using the <tt class="doctest"><span class="pre">.py</span></tt> filename extension, e.g., <tt class="doctest"><span class="pre">monty_python.py</span></tt>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Important:</strong>
Our inline code examples include the <tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> prompts
as if we are interacting directly with the interpreter.  As they get more complicated,
you should instead type them into the editor, without the prompts, and run them
from the editor as shown above.  When we provide longer programs in this book,
we will leave out the prompts to remind you to type them into a file rather
than using the interpreter.  You can see this already in <a class="reference internal" href="#code-random-text">2.5</a> above.
Note that it still includes a couple of lines with the Python prompt;
this is the interactive part of the task where you inspect some data and invoke a function.
Remember that all code samples like <a class="reference internal" href="#code-random-text">2.5</a> are downloadable
from <tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>.</p>
</div>
</div>
<div class="section" id="functions">
<h3>Functions</h3>
<p>Suppose that you work on analyzing text that involves different forms
of the same word, and that part of your program needs to work out
the plural form of a given singular noun.  Suppose it needs to do this
work in two places, once when it is processing some texts, and again
when it is processing user input.</p>
<p>Rather than repeating the same code several times over, it is more
efficient and reliable to localize this work inside a <a name="function_index_term" /><span class="termdef">function</span>.
A function is just a named block of code that performs some well-defined
task, as we saw in <a class="reference external" href="ch01.html#sec-computing-with-language-texts-and-words">1.1</a>.
A function is usually defined to take some inputs, using special variables known as <a name="parameters_index_term" /><span class="termdef">parameters</span>,
and it may produce a result, also known as a <a name="return_value_index_term" /><span class="termdef">return value</span>.
We define a function using the keyword <tt class="doctest"><span class="pre">def</span></tt> followed by the
function name and any input parameters, followed by the body of the
function.  Here's the function we saw in <a class="reference external" href="ch01.html#sec-computing-with-language-texts-and-words">1.1</a>
(including the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt> statement that makes division behave as expected):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> __future__ <span class="pysrc-keyword">import</span> division
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">lexical_diversity</span>(text):
<span class="pysrc-more">... </span>    return len(text) / len(set(text))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We use the keyword <tt class="doctest"><span class="pre">return</span></tt> to indicate the value that is
produced as output by the function.  In the above example,
all the work of the function is done in the <tt class="doctest"><span class="pre">return</span></tt> statement.
Here's an equivalent definition which does the same work
using multiple lines of code.  We'll change the parameter name
from <tt class="doctest"><span class="pre">text</span></tt> to <tt class="doctest"><span class="pre">my_text_data</span></tt> to remind you that this is an arbitrary choice:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">lexical_diversity</span>(my_text_data):
<span class="pysrc-more">... </span>    word_count = len(my_text_data)
<span class="pysrc-more">... </span>    vocab_size = len(set(my_text_data))
<span class="pysrc-more">... </span>    diversity_score = word_count / vocab_size
<span class="pysrc-more">... </span>    return diversity_score</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice that we've created some new variables inside the body of the function.
These are <a name="local_variables_index_term" /><span class="termdef">local variables</span> and are not accessible outside the function.
So now we have defined a function with the name <tt class="doctest"><span class="pre">lexical_diversity</span></tt>. But just
defining it won't produce any output!
Functions do nothing until they are &quot;called&quot; (or &quot;invoked&quot;):</p>
<!-- doctest-ignore
>>> lexical_diversity(text3)
16.050197203298673 -->
<p>Let's return to our earlier scenario, and actually define a simple
function to work out English plurals.  The function <tt class="doctest"><span class="pre">plural()</span></tt> in <a class="reference internal" href="#code-plural">2.6</a>
takes a singular noun and generates a plural form, though it is not always
correct.  (We'll discuss functions at greater length in <a class="reference external" href="ch04.html#sec-functions">4.4</a>.)</p>
<span class="target" id="code-plural"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">plural</span>(word):
    <span class="pysrc-keyword">if</span> word.endswith(<span class="pysrc-string">'y'</span>):
        return word[:-1] + <span class="pysrc-string">'ies'</span>
    <span class="pysrc-keyword">elif</span> word[-1] <span class="pysrc-keyword">in</span> <span class="pysrc-string">'sx'</span> <span class="pysrc-keyword">or</span> word[-2:] <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'sh'</span>, <span class="pysrc-string">'ch'</span>]:
        return word + <span class="pysrc-string">'es'</span>
    <span class="pysrc-keyword">elif</span> word.endswith(<span class="pysrc-string">'an'</span>):
        return word[:-2] + <span class="pysrc-string">'en'</span>
    <span class="pysrc-keyword">else</span>:
        return word + <span class="pysrc-string">'s'</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'fairy'</span>)
<span class="pysrc-output">'fairies'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'woman'</span>)
<span class="pysrc-output">'women'</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_plural.py" type="text/x-python"><span class="caption-label">Example 2.6 (code_plural.py)</span></a>: <span class="caption-label">Figure 2.6</span>: A Python Function: this function tries to work out the
plural form of any English noun; the keyword <tt class="doctest"><span class="pre">def</span></tt> (define)
is followed by the function name, then a parameter inside
parentheses, and a colon; the body of the function is the
indented block of code; it tries to recognize patterns
within the word and process the word accordingly; e.g., if the
word ends with <span class="example">y</span>, delete the <span class="example">y</span> and add <span class="example">ies</span>.</td></tr></p>
</table></div>
<p>The <tt class="doctest"><span class="pre">endswith()</span></tt> function is always associated with a string object
(e.g., <tt class="doctest"><span class="pre">word</span></tt> in <a class="reference internal" href="#code-plural">2.6</a>).  To call such functions, we give
the name of the object, a period, and then the name of the function.
These functions are usually known as <a name="methods_index_term" /><span class="termdef">methods</span>.</p>
</div>
<div class="section" id="modules">
<h3>Modules</h3>
<p>Over time you will find that you create a variety of useful little text processing functions,
and you end up copying them from old programs to new ones.  Which file contains the
latest version of the function you want to use?
It makes life a lot easier if you can collect your work into a single place, and
access previously defined functions without making copies.</p>
<p>To do this, save your function(s) in a file called (say) <tt class="doctest"><span class="pre">textproc.py</span></tt>.
Now, you can access your work simply by importing it from the file:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> textproc <span class="pysrc-keyword">import</span> plural
<span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'wish'</span>)
<span class="pysrc-output">wishes</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>plural(<span class="pysrc-string">'fan'</span>)
<span class="pysrc-output">fen</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Our plural function obviously has an error, since the plural of
<span class="example">fan</span> is <span class="example">fans</span>.
Instead of typing in a new version of the function, we can
simply edit the existing one.  Thus, at every
stage, there is only one version of our plural function, and no confusion about
which one is being used.</p>
<p>A collection of variable and function definitions in a file is called a Python
<a name="module_index_term" /><span class="termdef">module</span>.  A collection of related modules is called a <a name="package_index_term" /><span class="termdef">package</span>.
NLTK's code for processing the Brown Corpus is an example of a module,
and its collection of code for processing all the different corpora is
an example of a package.  NLTK itself is a set of packages, sometimes
called a <a name="library_index_term" /><span class="termdef">library</span>.</p>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">If you are creating a file to contain some of your Python
code, do <em>not</em> name your file <tt class="doctest"><span class="pre">nltk.py</span></tt>: it may get imported in
place of the &quot;real&quot; NLTK package.  When it imports modules, Python
first looks in the current directory (folder).</p>
</div>
</div>
</div>
<div class="section" id="lexical-resources">
<span id="sec-lexical-resources"></span><h2>2.4&nbsp;&nbsp;&nbsp;Lexical Resources</h2>
<p>A lexicon, or lexical resource, is a collection of words and/or phrases along
with associated information such as part of speech and sense definitions.
Lexical resources are secondary to texts, and are usually created and enriched with the help
of texts.  For example, if we have defined a text <tt class="doctest"><span class="pre">my_text</span></tt>, then
<tt class="doctest"><span class="pre">vocab = sorted(set(my_text))</span></tt> builds the vocabulary of <tt class="doctest"><span class="pre">my_text</span></tt>,
while <tt class="doctest"><span class="pre">word_freq = FreqDist(my_text)</span></tt> counts the frequency of each word in the text.  Both
of <tt class="doctest"><span class="pre">vocab</span></tt> and <tt class="doctest"><span class="pre">word_freq</span></tt> are simple lexical resources.  Similarly, a concordance
like the one we saw in <a class="reference external" href="ch01.html#sec-computing-with-language-texts-and-words">1.1</a>
gives us information about word usage that might help in the preparation of
a dictionary.  Standard terminology for lexicons is illustrated in <a class="reference internal" href="#fig-lexicon">2.7</a>.
A <a name="lexical_entry_index_term" /><span class="termdef">lexical entry</span> consists of a <a name="headword_index_term" /><span class="termdef">headword</span> (also known as a <a name="lemma_index_term" /><span class="termdef">lemma</span>)
along with additional information such as the part of speech and the sense
definition.  Two distinct words having the same spelling are called <a name="homonyms_index_term" /><span class="termdef">homonyms</span>.</p>
<span class="target" id="fig-lexicon"></span><div class="figure" id="fig-lexicon">
<img alt="../images/lexicon.png" src="../images/lexicon.png" style="width: 504.0px; height: 223.2px;" />
<p class="caption"><span class="caption-label">Figure 2.7</span>: Lexicon Terminology: lexical entries for two lemmas
having the same spelling (homonyms), providing part of speech
and gloss information.</p>
</div>
<p>The simplest kind of lexicon is nothing more than a sorted list of words.
Sophisticated lexicons include complex structure within and across
the individual entries.  In this section we'll look at some lexical resources
included with NLTK.</p>
<div class="section" id="wordlist-corpora">
<h3>Wordlist Corpora</h3>
<!-- XXX There's a useful opportunity here to link back to the discussion of what words
characterize a text found in ch01. -->
<p>NLTK includes some corpora that are nothing more than wordlists.
The Words Corpus is the <tt class="doctest"><span class="pre">/usr/share/dict/words</span></tt> file from Unix, used by
some spell checkers.  We can use it to find unusual or mis-spelt
words in a text corpus, as shown in <a class="reference internal" href="#code-unusual">2.8</a>.</p>
<span class="target" id="code-unusual"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">unusual_words</span>(text):
    text_vocab = set(w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text <span class="pysrc-keyword">if</span> w.isalpha())
    english_vocab = set(w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> nltk.corpus.words.words())
    unusual = text_vocab.difference(english_vocab)
    return sorted(unusual)</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>unusual_words(nltk.corpus.gutenberg.words(<span class="pysrc-string">'austen-sense.txt'</span>))
<span class="pysrc-output">['abbeyland', 'abhorrence', 'abominably', 'abridgement', 'accordant', 'accustomary',</span>
<span class="pysrc-output">'adieus', 'affability', 'affectedly', 'aggrandizement', 'alighted', 'allenham',</span>
<span class="pysrc-output">'amiably', 'annamaria', 'annuities', 'apologising', 'arbour', 'archness', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>unusual_words(nltk.corpus.nps_chat.words())
<span class="pysrc-output">['aaaaaaaaaaaaaaaaa', 'aaahhhh', 'abou', 'abourted', 'abs', 'ack', 'acros',</span>
<span class="pysrc-output">'actualy', 'adduser', 'addy', 'adoted', 'adreniline', 'ae', 'afe', 'affari', 'afk',</span>
<span class="pysrc-output">'agaibn', 'agurlwithbigguns', 'ahah', 'ahahah', 'ahahh', 'ahahha', 'ahem', 'ahh', ...]</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_unusual.py" type="text/x-python"><span class="caption-label">Example 2.8 (code_unusual.py)</span></a>: <span class="caption-label">Figure 2.8</span>: Filtering a Text: this program computes the vocabulary of a text,
then removes all items that occur in an existing wordlist,
leaving just the uncommon or mis-spelt words.</td></tr></p>
</table></div>
<p>There is also a corpus of <a name="stopwords_index_term" /><span class="termdef">stopwords</span>, that is, high-frequency
words like <span class="example">the</span>, <span class="example">to</span> and <span class="example">also</span> that we sometimes
want to filter out of a document before further processing. Stopwords
usually have little lexical content, and their presence in a text fails
to distinguish it from other texts.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> stopwords
<span class="pysrc-prompt">&gt;&gt;&gt; </span>stopwords.words(<span class="pysrc-string">'english'</span>)
<span class="pysrc-output">['a', &quot;a's&quot;, 'able', 'about', 'above', 'according', 'accordingly', 'across',</span>
<span class="pysrc-output">'actually', 'after', 'afterwards', 'again', 'against', &quot;ain't&quot;, 'all', 'allow',</span>
<span class="pysrc-output">'allows', 'almost', 'alone', 'along', 'already', 'also', 'although', 'always', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's define a function to compute what fraction of words in a text are <em>not</em> in the
stopwords list:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">content_fraction</span>(text):
<span class="pysrc-more">... </span>    stopwords = nltk.corpus.stopwords.words(<span class="pysrc-string">'english'</span>)
<span class="pysrc-more">... </span>    content = [w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text <span class="pysrc-keyword">if</span> w.lower() <span class="pysrc-keyword">not</span> <span class="pysrc-keyword">in</span> stopwords]
<span class="pysrc-more">... </span>    return len(content) / len(text)
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>content_fraction(nltk.corpus.reuters.words())
<span class="pysrc-output">0.65997695393285261</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Thus, with the help of stopwords we filter out a third of the words of the text.
Notice that we've combined two different kinds of corpus here, using a lexical
resource to filter the content of a text corpus.</p>
<span class="target" id="fig-target"></span><div class="figure" id="fig-target">
<img alt="../images/target.png" src="../images/target.png" style="width: 652.5px; height: 133.8px;" />
<p class="caption"><span class="caption-label">Figure 2.9</span>: A Word Puzzle: a grid of randomly chosen letters with rules for
creating words out of the letters; this puzzle is known as &quot;Target.&quot;</p>
</div>
<p>A wordlist is useful for solving word puzzles, such as the one in <a class="reference internal" href="#fig-target">2.9</a>.
Our program iterates through every word and, for each one, checks whether it meets
the conditions.  It is easy to check obligatory letter <a class="reference internal" href="#obligatory-letter"><span id="ref-obligatory-letter"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>
and length constraints <a class="reference internal" href="#length-constraint"><span id="ref-length-constraint"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> (and we'll
only look for words with six or more letters here).
It is trickier to check that candidate solutions only use combinations of the
supplied letters, especially since some of the supplied letters
appear twice (here, the letter <span class="example">v</span>).
The <tt class="doctest"><span class="pre">FreqDist</span></tt> comparison method <a class="reference internal" href="#freqdist-compare"><span id="ref-freqdist-compare"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a> permits us to check that
the frequency of each <em>letter</em> in the candidate word is less than or equal
to the frequency of the corresponding letter in the puzzle.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>puzzle_letters = nltk.FreqDist(<span class="pysrc-string">'egivrvonl'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>obligatory = <span class="pysrc-string">'r'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wordlist = nltk.corpus.words.words()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> wordlist <span class="pysrc-keyword">if</span> len(w) &gt;= 6 <a name="length-constraint" /><a href="#ref-length-constraint"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>                     <span class="pysrc-keyword">and</span> obligatory <span class="pysrc-keyword">in</span> w <a name="obligatory-letter" /><a href="#ref-obligatory-letter"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">... </span>                     <span class="pysrc-keyword">and</span> nltk.FreqDist(w) &lt;= puzzle_letters] <a name="freqdist-compare" /><a href="#ref-freqdist-compare"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">['glover', 'gorlin', 'govern', 'grovel', 'ignore', 'involver', 'lienor',</span>
<span class="pysrc-output">'linger', 'longer', 'lovering', 'noiler', 'overling', 'region', 'renvoi',</span>
<span class="pysrc-output">'revolving', 'ringle', 'roving', 'violer', 'virole']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>One more wordlist corpus is the Names corpus, containing 8,000 first names categorized by gender.
The male and female names are stored in separate files.  Let's find names which appear
in both files, i.e. names that are ambiguous for gender:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>names = nltk.corpus.names
<span class="pysrc-prompt">&gt;&gt;&gt; </span>names.fileids()
<span class="pysrc-output">['female.txt', 'male.txt']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>male_names = names.words(<span class="pysrc-string">'male.txt'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>female_names = names.words(<span class="pysrc-string">'female.txt'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> male_names <span class="pysrc-keyword">if</span> w <span class="pysrc-keyword">in</span> female_names]
<span class="pysrc-output">['Abbey', 'Abbie', 'Abby', 'Addie', 'Adrian', 'Adrien', 'Ajay', 'Alex', 'Alexis',</span>
<span class="pysrc-output">'Alfie', 'Ali', 'Alix', 'Allie', 'Allyn', 'Andie', 'Andrea', 'Andy', 'Angel',</span>
<span class="pysrc-output">'Angie', 'Ariel', 'Ashley', 'Aubrey', 'Augustine', 'Austin', 'Averil', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>It is well known that names ending in the letter <span class="example">a</span> are almost always female.
We can see this and some other patterns in the graph in <a class="reference internal" href="#fig-cfd-gender">2.10</a>,
produced by the following code.  Remember that <tt class="doctest"><span class="pre">name[-1]</span></tt> is the last letter
of <tt class="doctest"><span class="pre">name</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(
<span class="pysrc-more">... </span>          (fileid, name[-1])
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> fileid <span class="pysrc-keyword">in</span> names.fileids()
<span class="pysrc-more">... </span>          <span class="pysrc-keyword">for</span> name <span class="pysrc-keyword">in</span> names.words(fileid))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd.plot()</pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-cfd-gender"></span><div class="figure" id="fig-cfd-gender">
<img alt="../images/cfd-gender.png" src="../images/cfd-gender.png" style="width: 613.0px; height: 463.0px;" />
<p class="caption"><span class="caption-label">Figure 2.10</span>: Conditional Frequency Distribution: this plot shows the number of female and male names
ending with each letter of the alphabet; most names ending with <span class="example">a</span>, <span class="example">e</span> or <span class="example">i</span>
are female; names ending in <span class="example">h</span> and <span class="example">l</span> are equally likely to be male or female;
names ending in <span class="example">k</span>, <span class="example">o</span>, <span class="example">r</span>, <span class="example">s</span>, and <span class="example">t</span> are likely to be male.</p>
</div>
</div>
<div class="section" id="a-pronouncing-dictionary">
<h3>A Pronouncing Dictionary</h3>
<p>A slightly richer kind of lexical resource is a table (or spreadsheet), containing a word
plus some properties in each row.  NLTK includes the CMU Pronouncing
Dictionary for US English, which was designed for
use by speech synthesizers.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>entries = nltk.corpus.cmudict.entries()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(entries)
<span class="pysrc-output">127012</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> entry <span class="pysrc-keyword">in</span> entries[39943:39951]:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> entry
<span class="pysrc-more">...</span>
<span class="pysrc-output">('fir', ['F', 'ER1'])</span>
<span class="pysrc-output">('fire', ['F', 'AY1', 'ER0'])</span>
<span class="pysrc-output">('fire', ['F', 'AY1', 'R'])</span>
<span class="pysrc-output">('firearm', ['F', 'AY1', 'ER0', 'AA2', 'R', 'M'])</span>
<span class="pysrc-output">('firearm', ['F', 'AY1', 'R', 'AA2', 'R', 'M'])</span>
<span class="pysrc-output">('firearms', ['F', 'AY1', 'ER0', 'AA2', 'R', 'M', 'Z'])</span>
<span class="pysrc-output">('firearms', ['F', 'AY1', 'R', 'AA2', 'R', 'M', 'Z'])</span>
<span class="pysrc-output">('fireball', ['F', 'AY1', 'ER0', 'B', 'AO2', 'L'])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>For each word, this lexicon provides a list of phonetic
codes &#8212; distinct labels for each contrastive sound &#8212;
known as <span class="example">phones</span>.  Observe that <span class="example">fire</span> has two pronunciations
(in US English):
the one-syllable <tt class="doctest"><span class="pre">F AY1 R</span></tt>, and the two-syllable <tt class="doctest"><span class="pre">F AY1 ER0</span></tt>.
The symbols in the CMU Pronouncing Dictionary are from the <em>Arpabet</em>,
described in more detail at <tt class="doctest"><span class="pre">http://en.wikipedia.org/wiki/Arpabet</span></tt></p>
<!-- XXX Hmm - - would it be better to first explain tuple assignment outside the
context of a for loop?  (not sure how to fix this; can't use the word "tuple" yet) -->
<p>Each entry consists of two parts, and we can
process these individually using a more complex version of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statement.
Instead of writing <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> entry <span class="pysrc-keyword">in</span> entries:</span></tt>, we replace
<tt class="doctest"><span class="pre">entry</span></tt> with <em>two</em> variable names, <tt class="doctest"><span class="pre">word, pron</span></tt> <a class="reference internal" href="#word-pron"><span id="ref-word-pron"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.
Now, each time through the loop, <tt class="doctest"><span class="pre">word</span></tt> is assigned the first part of the
entry, and <tt class="doctest"><span class="pre">pron</span></tt> is assigned the second part of the entry:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word, pron <span class="pysrc-keyword">in</span> entries: <a name="word-pron" /><a href="#ref-word-pron"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> len(pron) == 3: <a name="len-pron-three" /><a href="#ref-len-pron-three"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">... </span>        ph1, ph2, ph3 = pron <a name="tuple-assignment" /><a href="#ref-tuple-assignment"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">if</span> ph1 == <span class="pysrc-string">'P'</span> <span class="pysrc-keyword">and</span> ph3 == <span class="pysrc-string">'T'</span>:
<span class="pysrc-more">... </span>            <span class="pysrc-keyword">print</span> word, ph2,
<span class="pysrc-more">...</span>
<span class="pysrc-output">pait EY1 pat AE1 pate EY1 patt AE1 peart ER1 peat IY1 peet IY1 peete IY1 pert ER1</span>
<span class="pysrc-output">pet EH1 pete IY1 pett EH1 piet IY1 piette IY1 pit IH1 pitt IH1 pot AA1 pote OW1</span>
<span class="pysrc-output">pott AA1 pout AW1 puett UW1 purt ER1 put UH1 putt AH1</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The above program scans the lexicon looking for entries whose pronunciation consists of
three phones <a class="reference internal" href="#len-pron-three"><span id="ref-len-pron-three"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.  If the condition is true, it assigns the contents
of <tt class="doctest"><span class="pre">pron</span></tt> to three new variables <tt class="doctest"><span class="pre">ph1</span></tt>, <tt class="doctest"><span class="pre">ph2</span></tt> and <tt class="doctest"><span class="pre">ph3</span></tt>.  Notice the unusual
form of the statement which does that work <a class="reference internal" href="#tuple-assignment"><span id="ref-tuple-assignment"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<p>Here's another example of the same <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statement, this time used inside a list
comprehension.  This program finds all words whose pronunciation ends with a syllable
sounding like <span class="example">nicks</span>.  You could use this method to find rhyming words.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>syllable = [<span class="pysrc-string">'N'</span>, <span class="pysrc-string">'IH0'</span>, <span class="pysrc-string">'K'</span>, <span class="pysrc-string">'S'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[word <span class="pysrc-keyword">for</span> word, pron <span class="pysrc-keyword">in</span> entries <span class="pysrc-keyword">if</span> pron[-4:] == syllable]
<span class="pysrc-output">[&quot;atlantic's&quot;, 'audiotronics', 'avionics', 'beatniks', 'calisthenics', 'centronics',</span>
<span class="pysrc-output">'chetniks', &quot;clinic's&quot;, 'clinics', 'conics', 'cynics', 'diasonics', &quot;dominic's&quot;,</span>
<span class="pysrc-output">'ebonics', 'electronics', &quot;electronics'&quot;, 'endotronics', &quot;endotronics'&quot;, 'enix', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice that the one pronunciation is spelt in several ways: <span class="example">nics</span>, <span class="example">niks</span>, <span class="example">nix</span>,
even <span class="example">ntic's</span> with a silent <span class="example">t</span>, for the word <span class="example">atlantic's</span>.  Let's look for some other
mismatches between pronunciation and writing.  Can you summarize the purpose of
the following examples and explain how they work?</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w, pron <span class="pysrc-keyword">in</span> entries <span class="pysrc-keyword">if</span> pron[-1] == <span class="pysrc-string">'M'</span> <span class="pysrc-keyword">and</span> w[-1] == <span class="pysrc-string">'n'</span>]
<span class="pysrc-output">['autumn', 'column', 'condemn', 'damn', 'goddamn', 'hymn', 'solemn']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(set(w[:2] <span class="pysrc-keyword">for</span> w, pron <span class="pysrc-keyword">in</span> entries <span class="pysrc-keyword">if</span> pron[0] == <span class="pysrc-string">'N'</span> <span class="pysrc-keyword">and</span> w[0] != <span class="pysrc-string">'n'</span>))
<span class="pysrc-output">['gn', 'kn', 'mn', 'pn']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The phones contain digits to represent
primary stress (<tt class="doctest"><span class="pre">1</span></tt>), secondary stress (<tt class="doctest"><span class="pre">2</span></tt>) and no stress (<tt class="doctest"><span class="pre">0</span></tt>).
As our final example, we define a function to extract the stress digits
and then scan our lexicon to find words having a particular stress pattern.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">stress</span>(pron):
<span class="pysrc-more">... </span>    return [char <span class="pysrc-keyword">for</span> phone <span class="pysrc-keyword">in</span> pron <span class="pysrc-keyword">for</span> char <span class="pysrc-keyword">in</span> phone <span class="pysrc-keyword">if</span> char.isdigit()]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w, pron <span class="pysrc-keyword">in</span> entries <span class="pysrc-keyword">if</span> stress(pron) == [<span class="pysrc-string">'0'</span>, <span class="pysrc-string">'1'</span>, <span class="pysrc-string">'0'</span>, <span class="pysrc-string">'2'</span>, <span class="pysrc-string">'0'</span>]]
<span class="pysrc-output">['abbreviated', 'abbreviating', 'accelerated', 'accelerating', 'accelerator',</span>
<span class="pysrc-output">'accentuated', 'accentuating', 'accommodated', 'accommodating', 'accommodative',</span>
<span class="pysrc-output">'accumulated', 'accumulating', 'accumulative', 'accumulator', 'accumulators', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w, pron <span class="pysrc-keyword">in</span> entries <span class="pysrc-keyword">if</span> stress(pron) == [<span class="pysrc-string">'0'</span>, <span class="pysrc-string">'2'</span>, <span class="pysrc-string">'0'</span>, <span class="pysrc-string">'1'</span>, <span class="pysrc-string">'0'</span>]]
<span class="pysrc-output">['abbreviation', 'abbreviations', 'abomination', 'abortifacient', 'abortifacients',</span>
<span class="pysrc-output">'academicians', 'accommodation', 'accommodations', 'accreditation', 'accreditations',</span>
<span class="pysrc-output">'accumulation', 'accumulations', 'acetylcholine', 'acetylcholine', 'adjudication', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">A subtlety of the above program is that our
user-defined function <tt class="doctest"><span class="pre">stress()</span></tt> is invoked inside the condition of
a list comprehension.  There is also a doubly-nested <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> loop.
There's a lot going on here and you might want
to return to this once you've had more experience using list comprehensions.</p>
</div>
<p>We can use a conditional frequency distribution to help us find minimally-contrasting
sets of words.  Here we find all the <span class="example">p</span>-words consisting of three sounds <a class="reference internal" href="#p3-words"><span id="ref-p3-words"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
and group them according to their first and last sounds <a class="reference internal" href="#group-first-last"><span id="ref-group-first-last"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>p3 = [(pron[0]+<span class="pysrc-string">'-'</span>+pron[2], word) <a name="group-first-last" /><a href="#ref-group-first-last"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>      <span class="pysrc-keyword">for</span> (word, pron) <span class="pysrc-keyword">in</span> entries
<span class="pysrc-more">... </span>      <span class="pysrc-keyword">if</span> pron[0] == <span class="pysrc-string">'P'</span> <span class="pysrc-keyword">and</span> len(pron) == 3] <a name="p3-words" /><a href="#ref-p3-words"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cfd = nltk.ConditionalFreqDist(p3)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> template <span class="pysrc-keyword">in</span> cfd.conditions():
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> len(cfd[template]) &gt; 10:
<span class="pysrc-more">... </span>        words = cfd[template].keys()
<span class="pysrc-more">... </span>        wordlist = <span class="pysrc-string">' '</span>.join(words)
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span> template, wordlist[:70] + <span class="pysrc-string">&quot;...&quot;</span>
<span class="pysrc-more">...</span>
<span class="pysrc-output">P-CH perch puche poche peach petsche poach pietsch putsch pautsch piche pet...</span>
<span class="pysrc-output">P-K pik peek pic pique paque polk perc poke perk pac pock poch purk pak pa...</span>
<span class="pysrc-output">P-L pil poehl pille pehl pol pall pohl pahl paul perl pale paille perle po...</span>
<span class="pysrc-output">P-N paine payne pon pain pin pawn pinn pun pine paign pen pyne pane penn p...</span>
<span class="pysrc-output">P-P pap paap pipp paup pape pup pep poop pop pipe paape popp pip peep pope...</span>
<span class="pysrc-output">P-R paar poor par poore pear pare pour peer pore parr por pair porr pier...</span>
<span class="pysrc-output">P-S pearse piece posts pasts peace perce pos pers pace puss pesce pass pur...</span>
<span class="pysrc-output">P-T pot puett pit pete putt pat purt pet peart pott pett pait pert pote pa...</span>
<span class="pysrc-output">P-Z pays p.s pao's pais paws p.'s pas pez paz pei's pose poise peas paiz p...</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Rather than iterating over the whole dictionary, we can also access it
by looking up particular words.  We will use Python's dictionary data
structure, which we will study systematically in <a class="reference external" href="ch05.html#sec-dictionaries">5.3</a>.
We look up a dictionary by specifying its name, followed by a <a name="key_index_term" /><span class="termdef">key</span>
(such as the word <tt class="doctest"><span class="pre"><span class="pysrc-string">'fire'</span></span></tt>) inside square brackets <a class="reference internal" href="#dict-key"><span id="ref-dict-key"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prondict = nltk.corpus.cmudict.dict()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prondict[<span class="pysrc-string">'fire'</span>] <a name="dict-key" /><a href="#ref-dict-key"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">[['F', 'AY1', 'ER0'], ['F', 'AY1', 'R']]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>prondict[<span class="pysrc-string">'blog'</span>] <a name="dict-key-error" /><a href="#ref-dict-key-error"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-except">Traceback (most recent call last):</span>
<span class="pysrc-except">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="pysrc-except">KeyError: 'blog'</span>
<span class="pysrc-except"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>prondict[<span class="pysrc-string">'blog'</span>] = [[<span class="pysrc-string">'B'</span>, <span class="pysrc-string">'L'</span>, <span class="pysrc-string">'AA1'</span>, <span class="pysrc-string">'G'</span>]] <a name="dict-assign" /><a href="#ref-dict-assign"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prondict[<span class="pysrc-string">'blog'</span>]
<span class="pysrc-output">[['B', 'L', 'AA1', 'G']]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>If we try to look up a non-existent key <a class="reference internal" href="#dict-key-error"><span id="ref-dict-key-error"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>, we get a <tt class="doctest"><span class="pre">KeyError</span></tt>.
This is similar to what happens when we index a list with an
integer that is to large, producing an <tt class="doctest"><span class="pre">IndexError</span></tt>.
The word <span class="example">blog</span> is missing from the pronouncing dictionary,
so we tweak our version by assigning a value for this key <a class="reference internal" href="#dict-assign"><span id="ref-dict-assign"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>
(this has no effect on the NLTK corpus; next time we access it,
<span class="example">blog</span> will still be absent).</p>
<p>We can use any lexical resource to process a text, e.g., to filter out words having
some lexical property (like nouns), or mapping every word of the text.
For example, the following text-to-speech function looks up each word
of the text in the pronunciation dictionary.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = [<span class="pysrc-string">'natural'</span>, <span class="pysrc-string">'language'</span>, <span class="pysrc-string">'processing'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[ph <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text <span class="pysrc-keyword">for</span> ph <span class="pysrc-keyword">in</span> prondict[w][0]]
<span class="pysrc-output">['N', 'AE1', 'CH', 'ER0', 'AH0', 'L', 'L', 'AE1', 'NG', 'G', 'W', 'AH0', 'JH',</span>
<span class="pysrc-output">'P', 'R', 'AA1', 'S', 'EH0', 'S', 'IH0', 'NG']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- [Summary of tabular lexicons; forward reference to discussion about processing CSV files] -->
</div>
<div class="section" id="comparative-wordlists">
<h3>Comparative Wordlists</h3>
<p>Another example of a tabular lexicon is the <a name="comparative_wordlist_index_term" /><span class="termdef">comparative wordlist</span>.
NLTK includes so-called <a name="swadesh_wordlists_index_term" /><span class="termdef">Swadesh wordlists</span>, lists of about 200 common words
in several languages.  The languages are identified using an ISO 639 two-letter code.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> swadesh
<span class="pysrc-prompt">&gt;&gt;&gt; </span>swadesh.fileids()
<span class="pysrc-output">['be', 'bg', 'bs', 'ca', 'cs', 'cu', 'de', 'en', 'es', 'fr', 'hr', 'it', 'la', 'mk',</span>
<span class="pysrc-output">'nl', 'pl', 'pt', 'ro', 'ru', 'sk', 'sl', 'sr', 'sw', 'uk']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>swadesh.words(<span class="pysrc-string">'en'</span>)
<span class="pysrc-output">['I', 'you (singular), thou', 'he', 'we', 'you (plural)', 'they', 'this', 'that',</span>
<span class="pysrc-output">'here', 'there', 'who', 'what', 'where', 'when', 'how', 'not', 'all', 'many', 'some',</span>
<span class="pysrc-output">'few', 'other', 'one', 'two', 'three', 'four', 'five', 'big', 'long', 'wide', ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can access cognate words from multiple languages using the <tt class="doctest"><span class="pre">entries()</span></tt> method,
specifying a list of languages.  With one further step we can convert this into
a simple dictionary (we'll learn about <tt class="doctest"><span class="pre">dict()</span></tt> in <a class="reference external" href="ch05.html#sec-dictionaries">5.3</a>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fr2en = swadesh.entries([<span class="pysrc-string">'fr'</span>, <span class="pysrc-string">'en'</span>])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fr2en
<span class="pysrc-output">[('je', 'I'), ('tu, vous', 'you (singular), thou'), ('il', 'he'), ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>translate = dict(fr2en)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>translate[<span class="pysrc-string">'chien'</span>]
<span class="pysrc-output">'dog'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>translate[<span class="pysrc-string">'jeter'</span>]
<span class="pysrc-output">'throw'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can make our simple translator more useful by adding other source languages.
Let's get the German-English and Spanish-English pairs, convert each to a
dictionary using <tt class="doctest"><span class="pre">dict()</span></tt>, then <em>update</em> our original <tt class="doctest"><span class="pre">translate</span></tt> dictionary
with these additional mappings:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>de2en = swadesh.entries([<span class="pysrc-string">'de'</span>, <span class="pysrc-string">'en'</span>])    <span class="pysrc-comment"># German-English</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>es2en = swadesh.entries([<span class="pysrc-string">'es'</span>, <span class="pysrc-string">'en'</span>])    <span class="pysrc-comment"># Spanish-English</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>translate.update(dict(de2en))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>translate.update(dict(es2en))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>translate[<span class="pysrc-string">'Hund'</span>]
<span class="pysrc-output">'dog'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>translate[<span class="pysrc-string">'perro'</span>]
<span class="pysrc-output">'dog'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can compare words in various Germanic and Romance languages:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>languages = [<span class="pysrc-string">'en'</span>, <span class="pysrc-string">'de'</span>, <span class="pysrc-string">'nl'</span>, <span class="pysrc-string">'es'</span>, <span class="pysrc-string">'fr'</span>, <span class="pysrc-string">'pt'</span>, <span class="pysrc-string">'la'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> [139, 140, 141, 142]:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> swadesh.entries(languages)[i]
<span class="pysrc-more">...</span>
<span class="pysrc-output">('say', 'sagen', 'zeggen', 'decir', 'dire', 'dizer', 'dicere')</span>
<span class="pysrc-output">('sing', 'singen', 'zingen', 'cantar', 'chanter', 'cantar', 'canere')</span>
<span class="pysrc-output">('play', 'spielen', 'spelen', 'jugar', 'jouer', 'jogar, brincar', 'ludere')</span>
<span class="pysrc-output">('float', 'schweben', 'zweven', 'flotar', 'flotter', 'flutuar, boiar', 'fluctuare')</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="shoebox-and-toolbox-lexicons">
<h3>Shoebox and Toolbox Lexicons</h3>
<p>Perhaps the single most popular tool used by linguists for managing data
is <em>Toolbox</em>, previously known as <em>Shoebox</em> since it replaces
the field linguist's traditional shoebox full of file cards.
Toolbox is freely downloadable from <tt class="doctest"><span class="pre">http://www.sil.org/computing/toolbox/</span></tt>.</p>
<p>A Toolbox file consists of a collection of entries,
where each entry is made up of one or more fields.
Most fields are optional or repeatable, which means that this kind of
lexical resource cannot be treated as a table or spreadsheet.</p>
<p>Here is a dictionary for the Rotokas language.  We see just the first entry,
for the word <span class="example">kaa</span> meaning &quot;to gag&quot;:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> toolbox
<span class="pysrc-prompt">&gt;&gt;&gt; </span>toolbox.entries(<span class="pysrc-string">'rotokas.dic'</span>)
<span class="pysrc-output">[('kaa', [('ps', 'V'), ('pt', 'A'), ('ge', 'gag'), ('tkp', 'nek i pas'),</span>
<span class="pysrc-output">('dcsv', 'true'), ('vx', '1'), ('sc', '???'), ('dt', '29/Oct/2005'),</span>
<span class="pysrc-output">('ex', 'Apoka ira kaaroi aioa-ia reoreopaoro.'),</span>
<span class="pysrc-output">('xp', 'Kaikai i pas long nek bilong Apoka bikos em i kaikai na toktok.'),</span>
<span class="pysrc-output">('xe', 'Apoka is gagging from food while talking.')]), ...]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Entries consist of a series of attribute-value pairs, like <tt class="doctest"><span class="pre">(<span class="pysrc-string">'ps'</span>, <span class="pysrc-string">'V'</span>)</span></tt>
to indicate that the part-of-speech is <tt class="doctest"><span class="pre"><span class="pysrc-string">'V'</span></span></tt> (verb), and <tt class="doctest"><span class="pre">(<span class="pysrc-string">'ge'</span>, <span class="pysrc-string">'gag'</span>)</span></tt>
to indicate that the gloss-into-English is <tt class="doctest"><span class="pre"><span class="pysrc-string">'gag'</span></span></tt>.
The last three pairs contain
an example sentence in Rotokas and its translations into Tok Pisin and English.</p>
<p>The loose structure of Toolbox files makes it hard for us to do much more with them
at this stage.  XML provides a powerful way to process this kind of corpus and
we will return to this topic in <a class="reference external" href="ch11.html#chap-data">11</a>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The Rotokas language is spoken on the island of Bougainville, Papua New Guinea.
This lexicon was contributed to NLTK by Stuart Robinson.
Rotokas is notable for having an inventory of just 12 phonemes (contrastive sounds),
<tt class="doctest"><span class="pre">http://en.wikipedia.org/wiki/Rotokas_language</span></tt></p>
</div>
</div>
</div>
<div class="section" id="wordnet">
<span id="sec-wordnet"></span><h2>2.5&nbsp;&nbsp;&nbsp;WordNet</h2>
<!-- XXX Can we do a better job of explaining what's going on in WordNet? Trying to
process the combination of WN's unfamiliar organization and datastructures, plus
the notation, plus the NLTK interface, imposes a very heavy cognitive load.
E.g. this whole WN  notion is pretty bizarre in some ways: "entity ``car.n.01`` is called a `synset`:dt:," -->
<p><a name="wordnet_index_term" /><span class="term">WordNet</span> is a semantically-oriented dictionary of English,
similar to a traditional thesaurus but with a richer structure.
NLTK includes the English WordNet, with 155,287 words
and 117,659 synonym sets.  We'll begin by
looking at synonyms and how they are accessed in WordNet.</p>
<div class="section" id="senses-and-synonyms">
<h3>Senses and Synonyms</h3>
<!-- senses in order of decreasing frequency? -->
<!-- how to access frequency? -->
<p>Consider the sentence in <a class="reference internal" href="#ex-car1">(1a)</a>.
If we replace the word <span class="example">motorcar</span> in <a class="reference internal" href="#ex-car1">(1a)</a> by <span class="example">automobile</span>,
to get <a class="reference internal" href="#ex-car2">(1b)</a>, the meaning of the sentence stays pretty much the same:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><span class="target" id="ex-car1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Benz is credited with the invention of the motorcar.</td></tr></table></p>
<span class="target" id="ex-car2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Benz is credited with the invention of the automobile.</td></tr></table></p>
</td></tr></table></p>
<p>Since everything else in the sentence has remained unchanged, we can
conclude that the words <span class="example">motorcar</span> and <span class="example">automobile</span> have the
same meaning, i.e. they are <a name="synonyms_index_term" /><span class="termdef">synonyms</span>.  We can explore these
words with the help of WordNet:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> wordnet <span class="pysrc-keyword">as</span> wn
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synsets(<span class="pysrc-string">'motorcar'</span>)
<span class="pysrc-output">[Synset('car.n.01')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Thus, <span class="example">motorcar</span> has just one possible meaning and it is identified as <tt class="doctest"><span class="pre">car.n.01</span></tt>,
the first noun sense of <span class="example">car</span>.  The entity <tt class="doctest"><span class="pre">car.n.01</span></tt> is called a <a name="synset_index_term" /><span class="termdef">synset</span>,
or &quot;synonym set&quot;, a collection of synonymous words (or &quot;lemmas&quot;):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'car.n.01'</span>).lemma_names
<span class="pysrc-output">['car', 'auto', 'automobile', 'machine', 'motorcar']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Each word of a synset can have several meanings, e.g., <span class="example">car</span> can also signify
a train carriage, a gondola, or an elevator car.  However, we are only interested
in the single meaning that is common to all words of the above synset.  Synsets
also come with a prose definition and some example sentences:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'car.n.01'</span>).definition
<span class="pysrc-output">'a motor vehicle with four wheels; usually propelled by an internal combustion engine'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'car.n.01'</span>).examples
<span class="pysrc-output">['he needs a car to get to work']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Although definitions help humans to understand the intended meaning of a synset,
the <span class="emphasis">words</span> of the synset are often more useful for our programs.
To eliminate ambiguity, we will identify these words as
<tt class="doctest"><span class="pre">car.n.01.automobile</span></tt>, <tt class="doctest"><span class="pre">car.n.01.motorcar</span></tt>, and so on.
This pairing of a synset with a word is called a lemma.
We can get all the lemmas for a given synset <a class="reference internal" href="#get-lemmas"><span id="ref-get-lemmas"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
look up a particular lemma <a class="reference internal" href="#lookup-lemma"><span id="ref-lookup-lemma"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>,
get the synset corresponding to a lemma <a class="reference internal" href="#get-synset"><span id="ref-get-synset"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>,
and get the &quot;name&quot; of a lemma <a class="reference internal" href="#get-name"><span id="ref-get-name"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'car.n.01'</span>).lemmas <a name="get-lemmas" /><a href="#ref-get-lemmas"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">[Lemma('car.n.01.car'), Lemma('car.n.01.auto'), Lemma('car.n.01.automobile'),</span>
<span class="pysrc-output">Lemma('car.n.01.machine'), Lemma('car.n.01.motorcar')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemma(<span class="pysrc-string">'car.n.01.automobile'</span>) <a name="lookup-lemma" /><a href="#ref-lookup-lemma"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">Lemma('car.n.01.automobile')</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemma(<span class="pysrc-string">'car.n.01.automobile'</span>).synset <a name="get-synset" /><a href="#ref-get-synset"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">Synset('car.n.01')</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemma(<span class="pysrc-string">'car.n.01.automobile'</span>).name <a name="get-name" /><a href="#ref-get-name"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a>
<span class="pysrc-output">'automobile'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Unlike the words <span class="example">automobile</span> and <span class="example">motorcar</span>, which are unambiguous
and have one synset, the word <span class="example">car</span> is ambiguous, having five synsets:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synsets(<span class="pysrc-string">'car'</span>)
<span class="pysrc-output">[Synset('car.n.01'), Synset('car.n.02'), Synset('car.n.03'), Synset('car.n.04'),</span>
<span class="pysrc-output">Synset('cable_car.n.01')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> synset <span class="pysrc-keyword">in</span> wn.synsets(<span class="pysrc-string">'car'</span>):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> synset.lemma_names
<span class="pysrc-more">...</span>
<span class="pysrc-output">['car', 'auto', 'automobile', 'machine', 'motorcar']</span>
<span class="pysrc-output">['car', 'railcar', 'railway_car', 'railroad_car']</span>
<span class="pysrc-output">['car', 'gondola']</span>
<span class="pysrc-output">['car', 'elevator_car']</span>
<span class="pysrc-output">['cable_car', 'car']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>For convenience, we can access all the lemmas involving the word <span class="example">car</span>
as follows.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemmas(<span class="pysrc-string">'car'</span>)
<span class="pysrc-output">[Lemma('car.n.01.car'), Lemma('car.n.02.car'), Lemma('car.n.03.car'),</span>
<span class="pysrc-output">Lemma('car.n.04.car'), Lemma('cable_car.n.01.car')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Write down all the senses of the word <span class="example">dish</span> that you can think of.  Now, explore this
word with the help of WordNet, using the same operations we used above.</p>
</div>
</div>
<div class="section" id="the-wordnet-hierarchy">
<h3>The WordNet Hierarchy</h3>
<p>WordNet synsets correspond to abstract concepts, and they don't always
have corresponding words in English.  These concepts are linked together in a hierarchy.
Some concepts are very general, such as <em>Entity</em>, <em>State</em>, <em>Event</em> &#8212; these are called
<a name="unique_beginners_index_term" /><span class="termdef">unique beginners</span> or root synsets.  Others, such as <em>gas guzzler</em> and
<em>hatchback</em>, are much more specific. A small portion of a concept
hierarchy is illustrated in <a class="reference internal" href="#fig-wn-hierarchy">2.11</a>.</p>
<span class="target" id="fig-wn-hierarchy"></span><div class="figure" id="fig-wn-hierarchy">
<img alt="../images/wordnet-hierarchy.png" src="../images/wordnet-hierarchy.png" style="width: 451.25px; height: 245.0px;" />
<p class="caption"><span class="caption-label">Figure 2.11</span>: Fragment of WordNet Concept Hierarchy: nodes correspond to synsets;
edges indicate the hypernym/hyponym relation, i.e. the relation between
superordinate and subordinate concepts.</p>
</div>
<p>WordNet makes it easy to navigate between concepts.
For example, given a concept like <em>motorcar</em>,
we can look at the concepts that are more specific;
the (immediate) <a name="hyponyms_index_term" /><span class="termdef">hyponyms</span>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>motorcar = wn.synset(<span class="pysrc-string">'car.n.01'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>types_of_motorcar = motorcar.hyponyms()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>types_of_motorcar[26]
<span class="pysrc-output">Synset('ambulance.n.01')</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([lemma.name <span class="pysrc-keyword">for</span> synset <span class="pysrc-keyword">in</span> types_of_motorcar <span class="pysrc-keyword">for</span> lemma <span class="pysrc-keyword">in</span> synset.lemmas])
<span class="pysrc-output">['Model_T', 'S.U.V.', 'SUV', 'Stanley_Steamer', 'ambulance', 'beach_waggon',</span>
<span class="pysrc-output">'beach_wagon', 'bus', 'cab', 'compact', 'compact_car', 'convertible',</span>
<span class="pysrc-output">'coupe', 'cruiser', 'electric', 'electric_automobile', 'electric_car',</span>
<span class="pysrc-output">'estate_car', 'gas_guzzler', 'hack', 'hardtop', 'hatchback', 'heap',</span>
<span class="pysrc-output">'horseless_carriage', 'hot-rod', 'hot_rod', 'jalopy', 'jeep', 'landrover',</span>
<span class="pysrc-output">'limo', 'limousine', 'loaner', 'minicar', 'minivan', 'pace_car', 'patrol_car',</span>
<span class="pysrc-output">'phaeton', 'police_car', 'police_cruiser', 'prowl_car', 'race_car', 'racer',</span>
<span class="pysrc-output">'racing_car', 'roadster', 'runabout', 'saloon', 'secondhand_car', 'sedan',</span>
<span class="pysrc-output">'sport_car', 'sport_utility', 'sport_utility_vehicle', 'sports_car', 'squad_car',</span>
<span class="pysrc-output">'station_waggon', 'station_wagon', 'stock_car', 'subcompact', 'subcompact_car',</span>
<span class="pysrc-output">'taxi', 'taxicab', 'tourer', 'touring_car', 'two-seater', 'used-car', 'waggon',</span>
<span class="pysrc-output">'wagon']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also navigate up the hierarchy by visiting hypernyms.  Some words
have multiple paths, because they can be classified in more than one way.
There are two paths between <tt class="doctest"><span class="pre">car.n.01</span></tt> and <tt class="doctest"><span class="pre">entity.n.01</span></tt> because
<tt class="doctest"><span class="pre">wheeled_vehicle.n.01</span></tt> can be classified as both a vehicle and a container.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>motorcar.hypernyms()
<span class="pysrc-output">[Synset('motor_vehicle.n.01')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>paths = motorcar.hypernym_paths()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(paths)
<span class="pysrc-output">2</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[synset.name <span class="pysrc-keyword">for</span> synset <span class="pysrc-keyword">in</span> paths[0]]
<span class="pysrc-output">['entity.n.01', 'physical_entity.n.01', 'object.n.01', 'whole.n.02', 'artifact.n.01',</span>
<span class="pysrc-output">'instrumentality.n.03', 'container.n.01', 'wheeled_vehicle.n.01',</span>
<span class="pysrc-output">'self-propelled_vehicle.n.01', 'motor_vehicle.n.01', 'car.n.01']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[synset.name <span class="pysrc-keyword">for</span> synset <span class="pysrc-keyword">in</span> paths[1]]
<span class="pysrc-output">['entity.n.01', 'physical_entity.n.01', 'object.n.01', 'whole.n.02', 'artifact.n.01',</span>
<span class="pysrc-output">'instrumentality.n.03', 'conveyance.n.03', 'vehicle.n.01', 'wheeled_vehicle.n.01',</span>
<span class="pysrc-output">'self-propelled_vehicle.n.01', 'motor_vehicle.n.01', 'car.n.01']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can get the most general hypernyms (or root hypernyms) of
a synset as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>motorcar.root_hypernyms()
<span class="pysrc-output">[Synset('entity.n.01')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try out NLTK's convenient graphical WordNet browser: <tt class="doctest"><span class="pre">nltk.app.wordnet()</span></tt>.
Explore the WordNet hierarchy by following the hypernym and hyponym links.</p>
</div>
</div>
<div class="section" id="more-lexical-relations">
<h3>More Lexical Relations</h3>
<p>Hypernyms and hyponyms are called <a name="lexical_relations_index_term" /><span class="termdef">lexical relations</span> because they relate one
synset to another.  These two relations navigate up and down the &quot;is-a&quot; hierarchy.
Another important way to navigate the WordNet network is from items to their
components (<a name="meronyms_index_term" /><span class="termdef">meronyms</span>) or to the things they are contained in (<a name="holonyms_index_term" /><span class="termdef">holonyms</span>).
For example, the parts of a <span class="example">tree</span> are its <span class="example">trunk</span>, <span class="example">crown</span>, and so on;
the <tt class="doctest"><span class="pre">part_meronyms()</span></tt>.
The <em>substance</em> a tree is made of includes <span class="example">heartwood</span> and <span class="example">sapwood</span>;
the <tt class="doctest"><span class="pre">substance_meronyms()</span></tt>.
A collection of trees forms a <span class="example">forest</span>; the <tt class="doctest"><span class="pre">member_holonyms()</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'tree.n.01'</span>).part_meronyms()
<span class="pysrc-output">[Synset('burl.n.02'), Synset('crown.n.07'), Synset('stump.n.01'),</span>
<span class="pysrc-output">Synset('trunk.n.01'), Synset('limb.n.02')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'tree.n.01'</span>).substance_meronyms()
<span class="pysrc-output">[Synset('heartwood.n.01'), Synset('sapwood.n.01')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'tree.n.01'</span>).member_holonyms()
<span class="pysrc-output">[Synset('forest.n.01')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>To see just how intricate things can get, consider the word <span class="example">mint</span>, which
has several closely-related senses.  We can see that <tt class="doctest"><span class="pre">mint.n.04</span></tt> is part of
<tt class="doctest"><span class="pre">mint.n.02</span></tt> and the substance from which <tt class="doctest"><span class="pre">mint.n.05</span></tt> is made.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> synset <span class="pysrc-keyword">in</span> wn.synsets(<span class="pysrc-string">'mint'</span>, wn.NOUN):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> synset.name + <span class="pysrc-string">':'</span>, synset.definition
<span class="pysrc-more">...</span>
<span class="pysrc-output">batch.n.02: (often followed by `of') a large number or amount or extent</span>
<span class="pysrc-output">mint.n.02: any north temperate plant of the genus Mentha with aromatic leaves and</span>
<span class="pysrc-output">           small mauve flowers</span>
<span class="pysrc-output">mint.n.03: any member of the mint family of plants</span>
<span class="pysrc-output">mint.n.04: the leaves of a mint plant used fresh or candied</span>
<span class="pysrc-output">mint.n.05: a candy that is flavored with a mint oil</span>
<span class="pysrc-output">mint.n.06: a plant where money is coined by authority of the government</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'mint.n.04'</span>).part_holonyms()
<span class="pysrc-output">[Synset('mint.n.02')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'mint.n.04'</span>).substance_holonyms()
<span class="pysrc-output">[Synset('mint.n.05')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>There are also relationships between verbs.  For example, the act of <span class="example">walking</span> involves the act of <span class="example">stepping</span>,
so walking <a name="entails_index_term" /><span class="termdef">entails</span> stepping.  Some verbs have multiple entailments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'walk.v.01'</span>).entailments()
<span class="pysrc-output">[Synset('step.v.01')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'eat.v.01'</span>).entailments()
<span class="pysrc-output">[Synset('swallow.v.01'), Synset('chew.v.01')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'tease.v.03'</span>).entailments()
<span class="pysrc-output">[Synset('arouse.v.07'), Synset('disappoint.v.01')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Some lexical relationships hold between lemmas, e.g., <a name="antonymy_index_term" /><span class="termdef">antonymy</span>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemma(<span class="pysrc-string">'supply.n.02.supply'</span>).antonyms()
<span class="pysrc-output">[Lemma('demand.n.02.demand')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemma(<span class="pysrc-string">'rush.v.01.rush'</span>).antonyms()
<span class="pysrc-output">[Lemma('linger.v.04.linger')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemma(<span class="pysrc-string">'horizontal.a.01.horizontal'</span>).antonyms()
<span class="pysrc-output">[Lemma('vertical.a.01.vertical'), Lemma('inclined.a.02.inclined')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.lemma(<span class="pysrc-string">'staccato.r.01.staccato'</span>).antonyms()
<span class="pysrc-output">[Lemma('legato.r.01.legato')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>You can see the lexical relations, and the other methods defined
on a synset, using <tt class="doctest"><span class="pre">dir()</span></tt>, for example: <tt class="doctest"><span class="pre">dir(wn.synset(<span class="pysrc-string">'harmony.n.02'</span>))</span></tt>.</p>
</div>
<div class="section" id="semantic-similarity">
<h3>Semantic Similarity</h3>
<!-- TODO: discuss WSD, mention Semcor, give pine cone example -->
<p>We have seen that synsets are linked by a complex network of
lexical relations.  Given a particular synset, we can traverse
the WordNet network to find synsets with related meanings.
Knowing which words are semantically related
is useful for indexing a collection of texts, so
that a search for a general term like <span class="example">vehicle</span> will match documents
containing specific terms like <span class="example">limousine</span>.</p>
<p>Recall that each synset has one or more hypernym paths that link it
to a root hypernym such as <tt class="doctest"><span class="pre">entity.n.01</span></tt>.
Two synsets linked to the same root may have several hypernyms in common
(cf <a class="reference internal" href="#fig-wn-hierarchy">2.11</a>).
If two synsets share a very specific hypernym &#8212; one that is low
down in the hypernym hierarchy &#8212; they must be closely related.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>right = wn.synset(<span class="pysrc-string">'right_whale.n.01'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>orca = wn.synset(<span class="pysrc-string">'orca.n.01'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>minke = wn.synset(<span class="pysrc-string">'minke_whale.n.01'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tortoise = wn.synset(<span class="pysrc-string">'tortoise.n.01'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>novel = wn.synset(<span class="pysrc-string">'novel.n.01'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>right.lowest_common_hypernyms(minke)
<span class="pysrc-output">[Synset('baleen_whale.n.01')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>right.lowest_common_hypernyms(orca)
<span class="pysrc-output">[Synset('whale.n.02')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>right.lowest_common_hypernyms(tortoise)
<span class="pysrc-output">[Synset('vertebrate.n.01')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>right.lowest_common_hypernyms(novel)
<span class="pysrc-output">[Synset('entity.n.01')]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Of course we know that <span class="example">whale</span> is very specific (and <span class="example">baleen whale</span> even more so),
while <span class="example">vertebrate</span> is more general and <span class="example">entity</span> is completely general.
We can quantify this concept of generality by looking up the depth of each synset:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'baleen_whale.n.01'</span>).min_depth()
<span class="pysrc-output">14</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'whale.n.02'</span>).min_depth()
<span class="pysrc-output">13</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'vertebrate.n.01'</span>).min_depth()
<span class="pysrc-output">8</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wn.synset(<span class="pysrc-string">'entity.n.01'</span>).min_depth()
<span class="pysrc-output">0</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Similarity measures have been defined over the collection of WordNet synsets
which incorporate the above insight.  For example,
<tt class="doctest"><span class="pre">path_similarity</span></tt> assigns a score in the range <tt class="doctest"><span class="pre">0</span></tt>&#8211;<tt class="doctest"><span class="pre">1</span></tt> based on the shortest path that connects the concepts in the hypernym
hierarchy (<tt class="doctest"><span class="pre">-1</span></tt> is returned in those cases where a path cannot be
found).  Comparing a synset with itself will return <tt class="doctest"><span class="pre">1</span></tt>.
Consider the following similarity scores, relating <span class="example">right whale</span>
to <span class="example">minke whale</span>, <span class="example">orca</span>, <span class="example">tortoise</span>, and <span class="example">novel</span>.
Although the numbers won't mean much, they decrease as
we move away from the semantic space of sea creatures to inanimate objects.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>right.path_similarity(minke)
<span class="pysrc-output">0.25</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>right.path_similarity(orca)
<span class="pysrc-output">0.16666666666666666</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>right.path_similarity(tortoise)
<span class="pysrc-output">0.076923076923076927</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>right.path_similarity(novel)
<span class="pysrc-output">0.043478260869565216</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Several other similarity measures are available; you can type <tt class="doctest"><span class="pre">help(wn)</span></tt>
for more information.  NLTK also includes VerbNet, a hierarhical verb lexicon linked to WordNet.
It can be accessed with <tt class="doctest"><span class="pre">nltk.corpus.verbnet</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="summary">
<h2>2.6&nbsp;&nbsp;&nbsp;Summary</h2>
<ul class="simple">
<li>A text corpus is a large, structured collection of texts.  NLTK comes with many corpora,
e.g., the Brown Corpus, <tt class="doctest"><span class="pre">nltk.corpus.brown</span></tt>.</li>
<li>Some text corpora are categorized, e.g., by genre or topic; sometimes the
categories of a corpus overlap each other.</li>
<li>A conditional frequency distribution is a collection of frequency distributions,
each one for a different condition.  They can be used for counting word frequencies,
given a context or a genre.</li>
<li>Python programs more than a few lines long should be entered using a text editor,
saved to a file with a <tt class="doctest"><span class="pre">.py</span></tt> extension, and accessed using an <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt> statement.</li>
<li>Python functions permit you to associate a name with a particular block of code,
and re-use that code as often as necessary.</li>
<li>Some functions, known as &quot;methods&quot;, are associated with an object and we give the object
name followed by a period followed by the function, like this: <tt class="doctest"><span class="pre">x.funct(y)</span></tt>,
e.g., <tt class="doctest"><span class="pre">word.isalpha()</span></tt>.</li>
<li>To find out about some variable <tt class="doctest"><span class="pre">v</span></tt>,
type <tt class="doctest"><span class="pre">help(v)</span></tt> in the Python interactive interpreter to read the help entry for this kind of object.</li>
<li>WordNet is a semantically-oriented dictionary of English, consisting of synonym sets &#8212; or synsets &#8212;
and organized into a network.</li>
<li>Some functions are not available by default, but must be accessed using
Python's <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt> statement.</li>
</ul>
</div>
<div class="section" id="further-reading">
<span id="sec-further-reading-corpora"></span><h2>2.7&nbsp;&nbsp;&nbsp;Further Reading</h2>
<p>Extra materials for this chapter are posted at <tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>, including links to freely
available resources on the web.  The corpus methods are summarized in the
Corpus HOWTO, at <tt class="doctest"><span class="pre">http://www.nltk.org/howto</span></tt>, and documented extensively in the online API documentation.</p>
<p>Significant sources of published corpora are the <span class="example">Linguistic Data Consortium</span> (LDC) and
the <span class="example">European Language Resources Agency</span> (ELRA).  Hundreds of annotated text and speech
corpora are available in dozens of languages.  Non-commercial licences permit the data to
be used in teaching and research.  For some corpora, commercial licenses are also available
(but for a higher fee).</p>
<p>These and many other language resources have been documented using OLAC Metadata, and can
be searched via the OLAC homepage at <tt class="doctest"><span class="pre">http://www.language-archives.org/</span></tt>.  <span class="emphasis">Corpora List</span> is a mailing list
for discussions about corpora, and you can find resources by searching the list archives
or posting to the list.
The most complete inventory of the world's languages is <em>Ethnologue</em>, <tt class="doctest"><span class="pre">http://www.ethnologue.com/</span></tt>.
Of 7,000 languages, only a few dozen have substantial digital resources suitable for
use in NLP.</p>
<p>This chapter has touched on the field of <a name="corpus_linguistics_index_term" /><span class="termdef">Corpus Linguistics</span>.  Other useful books in this
area include <a class="reference external" href="bibliography.html#biber1998" id="id1">(Biber, Conrad, &amp; Reppen, 1998)</a>, <a class="reference external" href="bibliography.html#mcenery2006" id="id2">(McEnery, 2006)</a>, <a class="reference external" href="bibliography.html#meyer2002" id="id3">(Meyer, 2002)</a>, <a class="reference external" href="bibliography.html#sampson2005" id="id4">(Sampson &amp; McCarthy, 2005)</a>, <a class="reference external" href="bibliography.html#scott2006" id="id5">(Scott &amp; Tribble, 2006)</a>.
Further readings in quantitative data analysis in linguistics are:
<a class="reference external" href="bibliography.html#baayen2008" id="id6">(Baayen, 2008)</a>, <a class="reference external" href="bibliography.html#gries2009" id="id7">(Gries, 2009)</a>, <a class="reference external" href="bibliography.html#woods1986" id="id8">(Woods, Fletcher, &amp; Hughes, 1986)</a>.</p>
<p>The original description of WordNet is <a class="reference external" href="bibliography.html#fellbaum1998" id="id9">(Fellbaum, 1998)</a>.
Although WordNet was originally developed for research
in psycholinguistics, it is now widely used in NLP and Information Retrieval.
WordNets are being developed for many other languages, as documented
at <tt class="doctest"><span class="pre">http://www.globalwordnet.org/</span></tt>.
For a study of WordNet similarity measures, see <a class="reference external" href="bibliography.html#budanitsky2006ewb" id="id10">(Budanitsky &amp; Hirst, 2006)</a>.</p>
<p>Other topics touched on in this chapter were phonetics and lexical semantics,
and we refer readers to chapters 7 and 20 of <a class="reference external" href="bibliography.html#jurafskymartin2008" id="id11">(Jurafsky &amp; Martin, 2008)</a>.</p>
</div>
<div class="section" id="exercises">
<h2>2.8&nbsp;&nbsp;&nbsp;Exercises</h2>
<ol class="arabic simple">
<li>&#9788; Create a variable <tt class="doctest"><span class="pre">phrase</span></tt> containing a list of words.
Experiment with the operations described in this chapter, including addition,
multiplication, indexing, slicing, and sorting.</li>
<li>&#9788; Use the corpus module to explore <tt class="doctest"><span class="pre">austen-persuasion.txt</span></tt>.
How many word tokens does this book have?  How many word types?</li>
<li>&#9788; Use the Brown corpus reader <tt class="doctest"><span class="pre">nltk.corpus.brown.words()</span></tt> or the Web text corpus
reader <tt class="doctest"><span class="pre">nltk.corpus.webtext.words()</span></tt> to access some sample text in two different genres.</li>
<li>&#9788; Read in the texts of the <em>State of the Union</em> addresses, using the
<tt class="doctest"><span class="pre">state_union</span></tt> corpus reader.  Count occurrences of <tt class="doctest"><span class="pre">men</span></tt>, <tt class="doctest"><span class="pre">women</span></tt>,
and <tt class="doctest"><span class="pre">people</span></tt> in each document.  What has happened to the usage of these
words over time?</li>
<li>&#9788; Investigate the holonym-meronym relations for some nouns.
Remember that there are three kinds of holonym-meronym relation,
so you need to use:
<tt class="doctest"><span class="pre">member_meronyms()</span></tt>, <tt class="doctest"><span class="pre">part_meronyms()</span></tt>, <tt class="doctest"><span class="pre">substance_meronyms()</span></tt>,
<tt class="doctest"><span class="pre">member_holonyms()</span></tt>, <tt class="doctest"><span class="pre">part_holonyms()</span></tt>, and <tt class="doctest"><span class="pre">substance_holonyms()</span></tt>.</li>
<li>&#9788; In the discussion of comparative wordlists, we created an object
called <tt class="doctest"><span class="pre">translate</span></tt> which you could look up using words in both German and Italian
in order to get corresponding words in English.
What problem might arise with this approach?
Can you suggest a way to avoid this problem?</li>
<li>&#9788; According to Strunk and White's <em>Elements of Style</em>,
the word <span class="example">however</span>, used at the start of a sentence,
means &quot;in whatever way&quot; or &quot;to whatever extent&quot;, and not
&quot;nevertheless&quot;.  They give this example of correct usage:
<span class="example">However you advise him, he will probably do as he thinks best.</span>
(<tt class="doctest"><span class="pre">http://www.bartleby.com/141/strunk3.html</span></tt>)
Use the concordance tool to study actual usage of this word
in the various texts we have been considering.
See also the <em>LanguageLog</em> posting &quot;Fossilized prejudices about 'however'&quot;
at <tt class="doctest"><span class="pre">http://itre.cis.upenn.edu/~myl/languagelog/archives/001913.html</span></tt></li>
<li>&#9681; Define a conditional frequency distribution over the Names corpus
that allows you to see which <em>initial</em> letters are more frequent for males
vs. females (cf. <a class="reference internal" href="#fig-cfd-gender">2.10</a>).</li>
<li>&#9681; Pick a pair of texts and study the differences between them,
in terms of vocabulary, vocabulary richness, genre, etc.  Can you
find pairs of words which have quite different meanings across the
two texts, such as <span class="example">monstrous</span> in <em>Moby Dick</em> and in <em>Sense and Sensibility</em>?</li>
<li>&#9681; Read the BBC News article: <em>UK's Vicky Pollards 'left behind'</em> <tt class="doctest"><span class="pre">http://news.bbc.co.uk/1/hi/education/6173441.stm</span></tt>.
The article gives the following statistic about teen language:
&quot;the top 20 words used, including yeah, no, but and like, account for around a third of all words.&quot;
How many word types account for a third
of all word tokens, for a variety of text sources?  What do you conclude about this statistic?
Read more about this on <em>LanguageLog</em>, at <tt class="doctest"><span class="pre">http://itre.cis.upenn.edu/~myl/languagelog/archives/003993.html</span></tt>.</li>
<li>&#9681; Investigate the table of modal distributions and look for other patterns.
Try to explain them in terms of your own impressionistic understanding
of the different genres.  Can you find other closed classes of words that
exhibit significant differences across different genres?</li>
<li>&#9681; The CMU Pronouncing Dictionary contains multiple pronunciations
for certain words.  How many distinct words does it contain?  What fraction
of words in this dictionary have more than one possible pronunciation?</li>
<li>&#9681; What percentage of noun synsets have no hyponyms?
You can get all noun synsets using <tt class="doctest"><span class="pre">wn.all_synsets(<span class="pysrc-string">'n'</span>)</span></tt>.</li>
<li>&#9681; Define a function <tt class="doctest"><span class="pre">supergloss(s)</span></tt> that takes a synset <tt class="doctest"><span class="pre">s</span></tt> as its argument
and returns a string consisting of the concatenation of the definition of <tt class="doctest"><span class="pre">s</span></tt>, and
the definitions of all the hypernyms and hyponyms of <tt class="doctest"><span class="pre">s</span></tt>.</li>
<li>&#9681; Write a program to find all words that occur at least three times in the Brown Corpus.</li>
<li>&#9681; Write a program to generate a table of lexical diversity scores (i.e. token/type ratios), as we saw in
<a class="reference external" href="ch01.html#tab-brown-types">1.1</a>.  Include the full set of Brown Corpus genres (<tt class="doctest"><span class="pre">nltk.corpus.brown.categories()</span></tt>).
Which genre has the lowest diversity (greatest number of tokens per type)?
Is this what you would have expected?</li>
<li>&#9681; Write a function that finds the 50 most frequently occurring words
of a text that are not stopwords.</li>
<li>&#9681; Write a program to print the 50 most frequent bigrams
(pairs of adjacent words) of a text, omitting bigrams that contain stopwords.</li>
<li>&#9681; Write a program to create a table of word frequencies by genre,
like the one given in _sec-extracting-text-from-corpora for modals.
Choose your own words and try to find words whose presence
(or absence) is typical of a genre.  Discuss your findings.</li>
<li>&#9681; Write a function <tt class="doctest"><span class="pre">word_freq()</span></tt> that takes a word and the name of a section
of the Brown Corpus as arguments, and computes the frequency of the word
in that section of the corpus.</li>
<li>&#9681; Write a program to guess the number of syllables contained in a text,
making use of the CMU Pronouncing Dictionary.</li>
<li>&#9681; Define a function <tt class="doctest"><span class="pre">hedge(text)</span></tt> which processes a
text and produces a new version with the word
<tt class="doctest"><span class="pre"><span class="pysrc-string">'like'</span></span></tt> between every third word.</li>
<li>&#9733; <strong>Zipf's Law</strong>:
Let <em>f(w)</em> be the frequency of a word <em>w</em> in free text. Suppose that
all the words of a text are ranked according to their frequency,
with the most frequent word first. Zipf's law states that the
frequency of a word type is inversely proportional to its rank
(i.e. <em>f</em> &#215; <em>r = k</em>, for some constant <em>k</em>). For example, the 50th most
common word type should occur three times as frequently as the
150th most common word type.<ol class="loweralpha">
<li>Write a function to process a large text and plot word
frequency against word rank using <tt class="doctest"><span class="pre">pylab.plot</span></tt>. Do
you confirm Zipf's law? (Hint: it helps to use a logarithmic scale).
What is going on at the extreme ends of the plotted line?</li>
<li>Generate random text, e.g., using <tt class="doctest"><span class="pre">random.choice(<span class="pysrc-string">&quot;abcdefg &quot;</span>)</span></tt>,
taking care to include the space character.  You will need to
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span> random</span></tt> first.  Use the string
concatenation operator to accumulate characters into a (very)
long string.  Then tokenize this string, and generate the Zipf
plot as before, and compare the two plots.  What do you make of
Zipf's Law in the light of this?</li>
</ol>
</li>
<li>&#9733; Modify the text generation program in <a class="reference internal" href="#code-random-text">2.5</a> further, to
do the following tasks:<ol class="loweralpha">
<li>Store the <em>n</em> most likely words in a list <tt class="doctest"><span class="pre">words</span></tt> then randomly
choose a word from the list using <tt class="doctest"><span class="pre">random.choice()</span></tt>.  (You will need
to <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span> random</span></tt> first.)</li>
<li>Select a particular genre, such as a section of the Brown Corpus,
or a genesis translation, one of the Gutenberg texts, or one of the Web texts.  Train
the model on this corpus and get it to generate random text.  You
may have to experiment with different start words. How intelligible
is the text?  Discuss the strengths and weaknesses of this method of
generating random text.</li>
<li>Now train your system using two distinct genres and experiment
with generating text in the hybrid genre.  Discuss your observations.</li>
</ol>
</li>
<li>&#9733; Define a function <tt class="doctest"><span class="pre">find_language()</span></tt> that takes a string
as its argument, and returns a list of languages that have that
string as a word.  Use the <tt class="doctest"><span class="pre">udhr</span></tt> corpus and limit your searches
to files in the Latin-1 encoding.</li>
<li>&#9733; What is the branching factor of the noun hypernym hierarchy?
I.e. for every noun synset that has hyponyms &#8212; or children in the
hypernym hierarchy &#8212; how many do they have on average?
You can get all noun synsets using <tt class="doctest"><span class="pre">wn.all_synsets(<span class="pysrc-string">'n'</span>)</span></tt>.</li>
<li>&#9733; The polysemy of a word is the number of senses it has.
Using WordNet, we can determine that the noun <em>dog</em> has 7 senses
with: <tt class="doctest"><span class="pre">len(wn.synsets(<span class="pysrc-string">'dog'</span>, <span class="pysrc-string">'n'</span>))</span></tt>.
Compute the average polysemy of nouns, verbs, adjectives and
adverbs according to WordNet.</li>
<li>&#9733; Use one of the predefined similarity measures to score
the similarity of each of the following pairs of words.
Rank the pairs in order of decreasing similarity.
How close is your ranking to the order given here,
an order that was established experimentally
by <a class="reference external" href="bibliography.html#millercharles1998" id="id12">(Miller &amp; Charles, 1998)</a>:
car-automobile, gem-jewel, journey-voyage, boy-lad,
coast-shore, asylum-madhouse, magician-wizard, midday-noon,
furnace-stove, food-fruit, bird-cock, bird-crane, tool-implement,
brother-monk, lad-brother, crane-implement, journey-car,
monk-oracle, cemetery-woodland, food-rooster, coast-hill,
forest-graveyard, shore-woodland, monk-slave, coast-forest,
lad-wizard, chord-smile, glass-magician, rooster-voyage, noon-string.</li>
</ol>
<!-- Footer to be used in all chapters -->
<div class="admonition-about-this-document admonition">
<p class="first admonition-title">About this document...</p>
<p>This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://www.csse.unimelb.edu.au/~sb/">Steven Bird</a>, <a class="reference external" href="http://www.ltg.ed.ac.uk/~ewan/">Ewan Klein</a> and <a class="reference external" href="http://www.cis.upenn.edu/~edloper/">Edward Loper</a>,
Copyright &#169; 2009 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>],
Version 2.0.1rc1, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Mon 15 Oct 2012 16:46:09 EST</p>
</div>
</div>
</div>
</div>
</body>
</html>
