<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}

table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document">


<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<div class="compound">
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
</div>
<!-- standard global imports

>>> import nltk, re, pprint -->
<!-- TODO: transformation based learning? -->
<!-- TODO: indexing and space-time trade-offs (more efficient concordancing, fuzzy spelling) -->
<!-- TODO: persistent storage (shelve) -->
<!-- TODO: indexing and searching a corpus, cf VITTA talk, or Ingrid's lexicon spreadsheet inversion -->
<!-- TODO: SIPs exercise -->
<!-- TODO: explain the relationship between list comprehension argument and generator expression argument; say that we oversimplified in chapter 6 -->
<!-- TODO: cover generator expressions, as promised in words chapter. -->
<!-- TODO: architectures: pipeline/cascade vs blackboard -->
<!-- TODO: lexical chaining for text segmentation, or WSD -->
<!-- TODO: multicomponent systems and APIs: spelling correction, web search -->
<!-- TODO: explain why a program should not usually import all of NLTK. -->
<div class="section" id="writing-structured-programs-extras">
<span id="chap-applied-programming"></span><h1>4&nbsp;&nbsp;&nbsp;Writing Structured Programs (Extras)</h1>
<p>This chapter introduces concepts in algorithms, data structures,
program design, and applied Python programming. It also contains
review of the basic mathematical notions of set, relation, and
function, and illustrates them in terms of Python data structures.
It contains many working program fragments that you should try yourself.</p>
<div class="section" id="the-practice-of-software-development">
<h2>4.1&nbsp;&nbsp;&nbsp;The Practice of Software Development</h2>
<p><tt class="doctest"><span class="pre">http://www.jwz.org/doc/worse-<span class="pysrc-keyword">is</span>-better.html</span></tt></p>
<p><tt class="doctest"><span class="pre">http://c2.com/cgi/wiki?DontRepeatYourself</span></tt></p>
<p><tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span> this</span></tt></p>
<ul class="simple">
<li>Pages on Python pitfalls.</li>
</ul>
</div>
<div class="section" id="abstract-data-types">
<h2>4.2&nbsp;&nbsp;&nbsp;Abstract Data Types</h2>
<div class="section" id="stacks-and-queues">
<h3>Stacks and Queues</h3>
<p>Lists are a versatile data type.  We can use lists to
implement so-called <a name="abstract_data_types_index_term" /><span class="termdef">abstract data types</span> such as stacks and queues.
A <a name="stack_index_term" /><span class="termdef">stack</span> is a container that has a last-in-first-out (or LIFO) policy
for adding and removing items (see <a class="reference internal" href="#fig-stack-queue">4.1</a>).</p>
<span class="target" id="fig-stack-queue"></span><div class="figure" id="fig-stack-queue">
<img alt="../images/stack-queue.png" src="../images/stack-queue.png" style="width: 611.5px; height: 261.5px;" />
<p class="caption"><span class="caption-label">Figure 4.1</span>: Stacks and Queues</p>
</div>
<p>Stacks are used to keep track of the current context in
computer processing of natural languages (and programming languages too).
We will seldom have to deal with stacks explicitly, as the implementation
of NLTK parsers, treebank corpus readers, (and even Python functions),
all use stacks behind the scenes.
However, it is important to understand what stacks are and how they work.</p>
<span class="target" id="code-check-parens"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">check_parens</span>(tokens):
    stack = []
    <span class="pysrc-keyword">for</span> token <span class="pysrc-keyword">in</span> tokens:
        <span class="pysrc-keyword">if</span> token == <span class="pysrc-string">'('</span>:     <span class="pysrc-comment"># push</span>
            stack.append(token)
        <span class="pysrc-keyword">elif</span> token == <span class="pysrc-string">')'</span>:   <span class="pysrc-comment"># pop</span>
            stack.pop()
    return stack</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>phrase = <span class="pysrc-string">&quot;( the cat ) ( sat ( on ( the mat )&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span> check_parens(phrase.split())
<span class="pysrc-output">['(', '(']</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_check_parens.py" type="text/x-python"><span class="caption-label">Example 4.2 (code_check_parens.py)</span></a>: <span class="caption-label">Figure 4.2</span>: Check whether parentheses are balanced</td></tr></p>
</table></div>
<!-- Adam: what this code does is funny: in some cases of unbalanced parens it
returns a non-empty stack, as in the example in the book, in other
cases - - it just fails (e.g., for ")("). -->
<p>In Python, we can treat a list as a stack by limiting ourselves to the three
operations defined on stacks: <tt class="doctest"><span class="pre">append(item)</span></tt> (to push <tt class="doctest"><span class="pre">item</span></tt> onto the stack),
<tt class="doctest"><span class="pre"><span class="pysrc-builtin">pop</span>()</span></tt> to pop the item off the top of the stack, and <tt class="doctest"><span class="pre">[-1]</span></tt> to access the
item on the top of the stack.  The program in <a class="reference internal" href="#code-check-parens">4.2</a> processes a sentence with
phrase markers, and checks that the parentheses are balanced.
The loop pushes material onto the stack when it gets an open parenthesis,
and pops the stack when it gets a close parenthesis.
We see that two are left on the stack at the end;
i.e. the parentheses are not balanced.</p>
<!-- Adam: And certainly the bit of code in text involving "phrase.count" does
not do the same - - it returns True for ")(". -->
<p>Although the program in <a class="reference internal" href="#code-check-parens">4.2</a> is a useful illustration of stacks,
it is overkill because we could have done a direct count:
<tt class="doctest"><span class="pre">phrase.count(<span class="pysrc-string">'('</span>) == phrase.count(<span class="pysrc-string">')'</span>)</span></tt>.  However, we
can use stacks for more sophisticated processing of strings
containing nested structure, as shown in <a class="reference internal" href="#code-convert-parens">4.3</a>.
Here we build a (potentially deeply-nested) list of lists.
Whenever a token other than a parenthesis is encountered,
we add it to a list at the appropriate level of nesting.
The stack keeps track of this level of nesting, exploiting
the fact that the item at the top of the stack is actually shared with a
more deeply nested item.  (Hint: add diagnostic print statements to
the function to help you see what it is doing.)</p>
<span class="target" id="code-convert-parens"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">convert_parens</span>(tokens):
    stack = [[]]
    <span class="pysrc-keyword">for</span> token <span class="pysrc-keyword">in</span> tokens:
        <span class="pysrc-keyword">if</span> token == <span class="pysrc-string">'('</span>:     <span class="pysrc-comment"># push</span>
            sublist = []
            stack[-1].append(sublist)
            stack.append(sublist)
        <span class="pysrc-keyword">elif</span> token == <span class="pysrc-string">')'</span>:   <span class="pysrc-comment"># pop</span>
            stack.pop()
        <span class="pysrc-keyword">else</span>:                <span class="pysrc-comment"># update top of stack</span>
            stack[-1].append(token)
    return stack[0]</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>phrase = <span class="pysrc-string">&quot;( the cat ) ( sat ( on ( the mat ) ) )&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span> convert_parens(phrase.split())
<span class="pysrc-output">[['the', 'cat'], ['sat', ['on', ['the', 'branch']]]]</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_convert_parens.py" type="text/x-python"><span class="caption-label">Example 4.3 (code_convert_parens.py)</span></a>: <span class="caption-label">Figure 4.3</span>: Convert a nested phrase into a nested list using a stack</td></tr></p>
</table></div>
<p>Lists can be used to represent another important data structure.
A <a name="queue_index_term" /><span class="termdef">queue</span> is a container that has a first-in-first-out (or FIFO) policy
for adding and removing items (see <a class="reference internal" href="#fig-stack-queue">4.1</a>).
We could use a queue of length <span class="math">n</span> to create all the n-grams of a text.
As with stacks, we will seldom have to deal with queues explicitly,
as the implementation of NLTK n-gram taggers (<a class="reference external" href="ch05.html#sec-n-gram-tagging">5.5</a>)
and chart parsers use queues behind the scenes.
Here's how queues can be implemented using lists.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>queue = [<span class="pysrc-string">'the'</span>, <span class="pysrc-string">'cat'</span>, <span class="pysrc-string">'sat'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>queue.append(<span class="pysrc-string">'on'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>queue.append(<span class="pysrc-string">'the'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>queue.append(<span class="pysrc-string">'branch'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>queue.pop(0)
<span class="pysrc-output">'the'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>queue.pop(0)
<span class="pysrc-output">'cat'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>queue
<span class="pysrc-output">['sat', 'on', 'the', 'branch']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The list-based implementation of queues is inefficient for large queues.
In such cases, it is better to use Python's built-in support for
&quot;double-ended queues&quot;, <tt class="doctest"><span class="pre">collections.deque</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="chinese-and-xml">
<h2>4.3&nbsp;&nbsp;&nbsp;Chinese and XML</h2>
<p>Codecs for processing Chinese text have been incorporated into Python
(since version 2.4).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>path = nltk.data.find(<span class="pysrc-string">'samples/sinorama-gb.xml'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>f = codecs.open(path, encoding=<span class="pysrc-string">'gb2312'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lines = f.readlines()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> l <span class="pysrc-keyword">in</span> lines:
<span class="pysrc-more">... </span>    l = l[:-1]
<span class="pysrc-more">... </span>    utf_enc = l.encode(<span class="pysrc-string">'utf8'</span>)
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> repr(utf_enc)
<span class="pysrc-output">'&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot; ?&gt;'</span>
<span class="pysrc-output">''</span>
<span class="pysrc-output">'&lt;sent&gt;'</span>
<span class="pysrc-output">'\xe7\x94\x9a\xe8\x87\xb3\xe7\x8c\xab\xe4\xbb\xa5\xe4\xba\xba\xe8\xb4\xb5'</span>
<span class="pysrc-output">''</span>
<span class="pysrc-output">'In some cases, cats were valued above humans.'</span>
<span class="pysrc-output">'&lt;/sent&gt;'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>With appropriate support on your terminal, the escaped text string
inside the <tt class="doctest"><span class="pre">&lt;SENT&gt;</span></tt> element above
will be rendered as the following string of ideographs:
&#29978;&#33267;&#29483;&#20197;&#20154;&#36149;.</p>
<p>We can also read in the contents of an XML file using the <tt class="doctest"><span class="pre">etree</span></tt>
package (at least, if the file is encoded as UTF-8 &#8212; as of
writing, there seems to be a problem reading GB2312-encoded files in
<tt class="doctest"><span class="pre">etree</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>path = nltk.data.find(<span class="pysrc-string">'samples/sinorama-utf8.xml'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.etree <span class="pysrc-keyword">import</span> ElementTree <span class="pysrc-keyword">as</span> ET
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tree = ET.parse(path)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = tree.findtext(<span class="pysrc-string">'sent'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>uni_text = text.encode(<span class="pysrc-string">'utf8'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span> repr(uni_text.splitlines()[1])
<span class="pysrc-output">'\xe7\x94\x9a\xe8\x87\xb3\xe7\x8c\xab\xe4\xbb\xa5\xe4\xba\xba\xe8\xb4\xb5'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="more-on-defensive-programming">
<h2>4.4&nbsp;&nbsp;&nbsp;More on Defensive Programming</h2>
<div class="section" id="the-return-statement">
<h3>The Return Statement</h3>
<p>Another aspect of defensive programming concerns the return statement of a function.
In order to be confident that all execution paths through a function lead to a
return statement, it is best to have a single return statement at the end of
the function definition.
This approach has a further benefit: it makes it more likely that the
function will only return a single type.
Thus, the following version of our <tt class="doctest"><span class="pre">tag()</span></tt> function is safer.
First we assign a default value <a class="reference internal" href="#default-value"><span id="ref-default-value"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, then in certain
cases <a class="reference internal" href="#certain-cases"><span id="ref-certain-cases"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a> we replace it with a different value <a class="reference internal" href="#different-value"><span id="ref-different-value"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.
All paths through the function body end at the single return statement <a class="reference internal" href="#single-return"><span id="ref-single-return"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">tag</span>(word):
<span class="pysrc-more">... </span>    result = <span class="pysrc-string">'noun'</span> <a name="default-value" /><a href="#ref-default-value"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> word <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'a'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'all'</span>]: <a name="certain-cases" /><a href="#ref-certain-cases"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">... </span>        result = <span class="pysrc-string">'det'</span> <a name="different-value" /><a href="#ref-different-value"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-more">... </span>    return result <a name="single-return" /><a href="#ref-single-return"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A return statement can be used to pass multiple values back to the calling
program, by packing them into a tuple.
Here we define a function that returns a tuple
consisting of the average word length of a sentence, and the inventory
of letters used in the sentence.  It would have been clearer to write
two separate functions.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">proc_words</span>(words):
<span class="pysrc-more">... </span>    avg_wordlen = sum(len(word) <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> words)/len(words)
<span class="pysrc-more">... </span>    chars_used = <span class="pysrc-string">''</span>.join(sorted(set(<span class="pysrc-string">''</span>.join(words))))
<span class="pysrc-more">... </span>    return avg_wordlen, chars_used
<span class="pysrc-prompt">&gt;&gt;&gt; </span>proc_words([<span class="pysrc-string">'Not'</span>, <span class="pysrc-string">'a'</span>, <span class="pysrc-string">'good'</span>, <span class="pysrc-string">'way'</span>, <span class="pysrc-string">'to'</span>, <span class="pysrc-string">'write'</span>, <span class="pysrc-string">'functions'</span>])
<span class="pysrc-output">(3, 'Nacdefginorstuwy')</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>[write version with two separate functions]</p>
</div>
</div>
<div class="section" id="algorithm-design">
<h2>4.5&nbsp;&nbsp;&nbsp;Algorithm Design</h2>
<p>An <em>algorithm</em> is a &quot;recipe&quot; for solving a problem.  For example,
to multiply 16 by 12 we might use any of the following methods:</p>
<ol class="arabic simple">
<li>Add 16 to itself 12 times over</li>
<li>Perform &quot;long multiplication&quot;, starting with the least-significant
digits of both numbers</li>
<li>Look up a multiplication table</li>
<li>Repeatedly halve the first number and double the second,
16*12 = 8*24 = 4*48 = 2*96 = 192</li>
<li>Do 10*12 to get 120, then add 6*12</li>
<li>Rewrite 16*12 as (x+2)(x-2), remember that 14*14=196, and add (+2)(-2) = -4</li>
</ol>
<p>Each of these methods is a different algorithm, and requires different
amounts of computation time and different amounts of intermediate
information to store.  A similar situation holds for many other
superficially simple tasks, such as sorting a list of words.</p>
<div class="section" id="sorting-algorithms">
<h3>Sorting Algorithms</h3>
<p>Now, as we saw above, Python provides a built-in function <tt class="doctest"><span class="pre">sort()</span></tt> that
performs this task efficiently.  However, NLTK also provides
several algorithms for sorting lists, to illustrate the variety of
possible methods.  To illustrate the difference in efficiency, we
will create a list of 1000 numbers, randomize the list, then sort it,
counting the number of list manipulations required.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> random <span class="pysrc-keyword">import</span> shuffle
<span class="pysrc-prompt">&gt;&gt;&gt; </span>a = range(1000)                     <span class="pysrc-comment"># [0,1,2,...999]</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>shuffle(a)                          <span class="pysrc-comment"># randomize</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now we can try a simple sort method called <em>bubble sort</em>, that
scans through the list many times, exchanging adjacent items if
they are out of order.  It sorts the list <tt class="doctest"><span class="pre">a</span></tt> in-place, and returns
the number of times it modified the list:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.misc <span class="pysrc-keyword">import</span> sort
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sort.bubble(a)
<span class="pysrc-output">250918</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can try the same task using various sorting algorithms.  Evidently
<em>merge sort</em> is much better than bubble sort, and <em>quicksort</em> is better still.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>shuffle(a); sort.merge(a)
<span class="pysrc-output">6175</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>shuffle(a); sort.quick(a)
<span class="pysrc-output">2378</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Readers are encouraged to look at <tt class="doctest"><span class="pre">nltk.misc.sort</span></tt> to see how
these different methods work.  The collection of NLTK modules
exemplify a variety of algorithm design techniques, including
brute-force, divide-and-conquer, dynamic programming, and greedy search.
Readers who would like a systematic introduction to algorithm design
should consult the resources mentioned at the end of this tutorial.</p>
</div>
<div class="section" id="decorate-sort-undecorate">
<h3>Decorate-Sort-Undecorate</h3>
<p>In <a class="reference external" href="ch04.html#chap-structured-programming">4</a> we saw how to sort a list of items
according to some property of the list.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = <span class="pysrc-string">'I turned off the spectroroute'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words.sort(cmp)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words
<span class="pysrc-output">['I', 'off', 'spectroroute', 'the', 'turned']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>words.sort(<span class="pysrc-keyword">lambda</span> x, y: cmp(len(y), len(x)))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words
<span class="pysrc-output">['spectroroute', 'turned', 'off', 'the', 'I']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This is inefficient when the list of items gets long, as
we compute <tt class="doctest"><span class="pre">len()</span></tt> twice for every comparison (about 2nlog(n) times).
The following is more efficient:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[pair[1] <span class="pysrc-keyword">for</span> pair <span class="pysrc-keyword">in</span> sorted((len(w), w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> words)[::-1]]
<span class="pysrc-output">['spectroroute', 'turned', 'the', 'off', 'I']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This technique is called <a name="decorate_sort_undecorate_index_term" /><span class="termdef">decorate-sort-undecorate</span>.
We can compare its performance by timing how long it takes to
execute it a million times.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> timeit <span class="pysrc-keyword">import</span> Timer
<span class="pysrc-prompt">&gt;&gt;&gt; </span>Timer(<span class="pysrc-string">&quot;sorted(words, lambda x, y: cmp(len(y), len(x)))&quot;</span>,
<span class="pysrc-more">... </span>      <span class="pysrc-string">&quot;words='I turned off the spectroroute'.split()&quot;</span>).timeit()
<span class="pysrc-output">8.3548779487609863</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>Timer(<span class="pysrc-string">&quot;[pair[1] for pair in sorted((len(w), w) for w in words)]&quot;</span>,
<span class="pysrc-more">... </span>     <span class="pysrc-string">&quot;words='I turned off the spectroroute'.split()&quot;</span>).timeit()
<span class="pysrc-output">9.9698889255523682</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>MORE: consider what happens as the lists get longer...</p>
<!-- finding maximum value of list: sort() vs max() -->
<p>Another example: sorting dates of the form &quot;1 Jan 1970&quot;</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>month_index = {
<span class="pysrc-more">... </span>    <span class="pysrc-string">&quot;Jan&quot;</span> : 1, <span class="pysrc-string">&quot;Feb&quot;</span> : 2,  <span class="pysrc-string">&quot;Mar&quot;</span> : 3,  <span class="pysrc-string">&quot;Apr&quot;</span> : 4,
<span class="pysrc-more">... </span>    <span class="pysrc-string">&quot;May&quot;</span> : 5, <span class="pysrc-string">&quot;Jun&quot;</span> : 6,  <span class="pysrc-string">&quot;Jul&quot;</span> : 7,  <span class="pysrc-string">&quot;Aug&quot;</span> : 8,
<span class="pysrc-more">... </span>    <span class="pysrc-string">&quot;Sep&quot;</span> : 9, <span class="pysrc-string">&quot;Oct&quot;</span> : 10, <span class="pysrc-string">&quot;Nov&quot;</span> : 11, <span class="pysrc-string">&quot;Dec&quot;</span> : 12
<span class="pysrc-more">... </span>}
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">date_cmp</span>(date_string1, date_string2):
<span class="pysrc-more">... </span>    (d1,m1,y1) = date_string1.split()
<span class="pysrc-more">... </span>    (d2,m2,y2) = date_string2.split()
<span class="pysrc-more">... </span>    conv1 = y1, month_index[m1], d1
<span class="pysrc-more">... </span>    conv2 = y2, month_index[m2], d2
<span class="pysrc-more">... </span>    return cmp(a2, b2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sort(date_list, date_cmp)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The comparison function says that we compare two times of the
form <tt class="doctest"><span class="pre">(<span class="pysrc-string">'Mar'</span>, <span class="pysrc-string">'2004'</span>)</span></tt> by reversing the order of the month and
year, and converting the month into a number to get <tt class="doctest"><span class="pre">(<span class="pysrc-string">'2004'</span>, <span class="pysrc-string">'3'</span>)</span></tt>,
then using Python's built-in <tt class="doctest"><span class="pre">cmp</span></tt> function to compare them.</p>
<p>Now do this using decorate-sort-undecorate, for large data size</p>
<p>Time comparison</p>
</div>
<div class="section" id="brute-force">
<h3>Brute Force</h3>
<p>Wordfinder Puzzle</p>
<p>Here we will generate a grid of letters, containing words found in the
dictionary.  First we remove any duplicates and disregard the order in
which the lexemes appeared in the dictionary.  We do this by converting
it to a set, then back to a list.  Then we select the first 200 words,
and then only keep those words having a reasonable length.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = list(set(lexemes))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = words[:200]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = [w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> words <span class="pysrc-keyword">if</span> 3 &lt;= len(w) &lt;= 12]</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now we generate the wordfinder grid, and print it out.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.misc.wordfinder <span class="pysrc-keyword">import</span> wordfinder
<span class="pysrc-prompt">&gt;&gt;&gt; </span>grid, used = wordfinder(words)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(len(grid)):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">for</span> j <span class="pysrc-keyword">in</span> range(len(grid[i])):
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span> grid[i][j],
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>
<span class="pysrc-output">O G H K U U V U V K U O R O V A K U N C</span>
<span class="pysrc-output">K Z O T O I S E K S N A I E R E P A K C</span>
<span class="pysrc-output">I A R A A K I O Y O V R S K A W J K U Y</span>
<span class="pysrc-output">L R N H N K R G V U K G I A U D J K V N</span>
<span class="pysrc-output">I I Y E A U N O K O O U K T R K Z A E L</span>
<span class="pysrc-output">A V U K O X V K E R V T I A A E R K R K</span>
<span class="pysrc-output">A U I U G O K U T X U I K N V V L I E O</span>
<span class="pysrc-output">R R K O K N U A J Z T K A K O O S U T R</span>
<span class="pysrc-output">I A U A U A S P V F O R O O K I C A O U</span>
<span class="pysrc-output">V K R R T U I V A O A U K V V S L P E K</span>
<span class="pysrc-output">A I O A I A K R S V K U S A A I X I K O</span>
<span class="pysrc-output">P S V I K R O E O A R E R S E T R O J X</span>
<span class="pysrc-output">O I I S U A G K R O R E R I T A I Y O A</span>
<span class="pysrc-output">R R R A T O O K O I K I W A K E A A R O</span>
<span class="pysrc-output">O E A K I K V O P I K H V O K K G I K T</span>
<span class="pysrc-output">K K L A K A A R M U G E P A U A V Q A I</span>
<span class="pysrc-output">O O O U K N X O G K G A R E A A P O O R</span>
<span class="pysrc-output">K V V P U J E T Z P K B E I E T K U R A</span>
<span class="pysrc-output">N E O A V A E O R U K B V K S Q A V U E</span>
<span class="pysrc-output">C E K K U K I K I R A E K O J I Q K K K</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Finally we generate the words which need to be found.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(len(used)):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> <span class="pysrc-string">&quot;%-12s&quot;</span> % used[i],
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> float(i+1)%5 == 0: <span class="pysrc-keyword">print</span>
<span class="pysrc-output">KOKOROPAVIRA KOROROVIVIRA KAEREASIVIRA KOTOKOTOARA  KOPUASIVIRA</span>
<span class="pysrc-output">KATAITOAREI  KAITUTUVIRA  KERIKERISI   KOKARAPATO   KOKOVURITO</span>
<span class="pysrc-output">KAUKAUVIRA   KOKOPUVIRA   KAEKAESOTO   KAVOVOVIRA   KOVAKOVARA</span>
<span class="pysrc-output">KAAREKOPIE   KAEPIEVIRA   KAPUUPIEPA   KOKORUUTO    KIKIRAEKO</span>
<span class="pysrc-output">KATAAVIRA    KOVOKOVOA    KARIVAITO    KARUVIRA     KAPOKARI</span>
<span class="pysrc-output">KUROVIRA     KITUKITU     KAKUPUTE     KAEREASI     KUKURIKO</span>
<span class="pysrc-output">KUPEROO      KAKAPUA      KIKISI       KAVORA       KIKIPI</span>
<span class="pysrc-output">KAPUA        KAARE        KOETO        KATAI        KUVA</span>
<span class="pysrc-output">KUSI         KOVO         KOAI</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="problem-transformation-aka-transform-and-conquer">
<h3>Problem Transformation (aka Transform-and-Conquer)</h3>
<p>Find words which, when reversed, make legal words.
Extremely wasteful brute force solution:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = nltk.corpus.words.words(<span class="pysrc-string">'en'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word1 <span class="pysrc-keyword">in</span> words:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">for</span> word2 <span class="pysrc-keyword">in</span> words:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">if</span> word1 == word2[::-1]:
<span class="pysrc-more">... </span>            <span class="pysrc-keyword">print</span> word1</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>More efficient:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wordlist = set(words)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>rev_wordlist = set(word[::-1] <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> words)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(wordlist.intersection(rev_wordlist))
<span class="pysrc-output">['ah', 'are', 'bag', 'ban', 'bard', 'bat', 'bats', 'bib', 'bob', 'boob', 'brag',</span>
<span class="pysrc-output">'bud', 'buns', 'bus', 'but', 'civic', 'dad', 'dam', 'decal', 'deed', 'deeps', 'deer',</span>
<span class="pysrc-output">'deliver', 'denier', 'desserts', 'deus', 'devil', 'dial', 'diaper', 'did', 'dim',</span>
<span class="pysrc-output">'dog', 'don', 'doom', 'drab', 'draw', 'drawer', 'dub', 'dud', 'edit', 'eel', 'eke',</span>
<span class="pysrc-output">'em', 'emit', 'era', 'ere', 'evil', 'ewe', 'eye', 'fires', 'flog', 'flow', 'gab',</span>
<span class="pysrc-output">'gag', 'garb', 'gas', 'gel', 'gig', 'gnat', 'god', 'golf', 'gulp', 'gum', 'gums',</span>
<span class="pysrc-output">'guns', 'gut', 'ha', 'huh', 'keel', 'keels', 'keep', 'knits', 'laced', 'lager',</span>
<span class="pysrc-output">'laid', 'lap', 'lee', 'leek', 'leer', 'leg', 'leper', 'level', 'lever', 'liar',</span>
<span class="pysrc-output">'live', 'lived', 'loop', 'loops', 'loot', 'loots', 'mad', 'madam', 'me', 'meet',</span>
<span class="pysrc-output">'mets', 'mid', 'mood', 'mug', 'nab', 'nap', 'naps', 'net', 'nip', 'nips', 'no',</span>
<span class="pysrc-output">'nod', 'non', 'noon', 'not', 'now', 'nun', 'nuts', 'on', 'pal', 'pals', 'pan',</span>
<span class="pysrc-output">'pans', 'par', 'part', 'parts', 'pat', 'paws', 'peek', 'peels', 'peep', 'pep',</span>
<span class="pysrc-output">'pets', 'pin', 'pins', 'pip', 'pit', 'plug', 'pool', 'pools', 'pop', 'pot', 'pots',</span>
<span class="pysrc-output">'pup', 'radar', 'rail', 'rap', 'rat', 'rats', 'raw', 'redder', 'redraw', 'reed',</span>
<span class="pysrc-output">'reel', 'refer', 'regal', 'reined', 'remit', 'repaid', 'repel', 'revel', 'reviled',</span>
<span class="pysrc-output">'reviver', 'reward', 'rotator', 'rotor', 'sag', 'saw', 'sees', 'serif', 'sexes',</span>
<span class="pysrc-output">'slap', 'sleek', 'sleep', 'sloop', 'smug', 'snap', 'snaps', 'snip', 'snoops',</span>
<span class="pysrc-output">'snub', 'snug', 'solos', 'span', 'spans', 'spat', 'speed', 'spin', 'spit', 'spool',</span>
<span class="pysrc-output">'spoons', 'spot', 'spots', 'stab', 'star', 'stem', 'step', 'stew', 'stink', 'stool',</span>
<span class="pysrc-output">'stop', 'stops', 'strap', 'straw', 'stressed', 'stun', 'sub', 'sued', 'swap', 'tab',</span>
<span class="pysrc-output">'tang', 'tap', 'taps', 'tar', 'teem', 'ten', 'tide', 'time', 'timer', 'tip', 'tips',</span>
<span class="pysrc-output">'tit', 'ton', 'tool', 'top', 'tops', 'trap', 'tub', 'tug', 'war', 'ward', 'warder',</span>
<span class="pysrc-output">'warts', 'was', 'wets', 'wolf', 'won']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Observe that this output contains redundant information; each word and its reverse is
included.  How could we remove this redundancy?</p>
<p>Presorting, sets:</p>
<p>Find words which have at least (or exactly) one instance of all vowels.
Instead of writing extremely complex regular expressions, some simple preprocessing
does the trick:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>words = [<span class="pysrc-string">&quot;sequoia&quot;</span>, <span class="pysrc-string">&quot;abacadabra&quot;</span>, <span class="pysrc-string">&quot;yiieeaouuu!&quot;</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>vowels = <span class="pysrc-string">&quot;aeiou&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> words <span class="pysrc-keyword">if</span> set(w).issuperset(vowels)]
<span class="pysrc-output">['sequoia', 'yiieeaouuu!']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> words <span class="pysrc-keyword">if</span> sorted(c <span class="pysrc-keyword">for</span> c <span class="pysrc-keyword">in</span> w <span class="pysrc-keyword">if</span> c <span class="pysrc-keyword">in</span> vowels) == list(vowels)]
<span class="pysrc-output">['sequoia']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="space-time-tradeoffs">
<h3>Space-Time Tradeoffs</h3>
<p>Indexing</p>
<p>Fuzzy Spelling</p>
</div>
</div>
<div class="section" id="exercises">
<h2>4.6&nbsp;&nbsp;&nbsp;Exercises</h2>
<ol class="arabic simple">
<li>&#9681; Consider again the problem of hyphenation across line-breaks.
Suppose that you have successfully written a tokenizer that
returns a list of strings, where some strings may contain
a hyphen followed by a newline character, e.g. <tt class="doctest"><span class="pre">long-\nterm</span></tt>.
Write a function that iterates over the tokens in a list,
removing the newline character from each, in each of the following
ways:<ol class="loweralpha">
<li>Use doubly-nested for loops.  The outer loop will iterate over
each token in the list, while the inner loop will iterate over
each character of a string.</li>
<li>Replace the inner loop with a call to <tt class="doctest"><span class="pre">re.sub()</span></tt></li>
<li>Finally, replace the outer loop with call to the <tt class="doctest"><span class="pre">map()</span></tt>
function, to apply this substitution to each token.</li>
<li>Discuss the clarity (or otherwise) of each of these approaches.</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="search">
<h2>4.7&nbsp;&nbsp;&nbsp;Search</h2>
<p>Many NLP tasks can be construed as search problems.
For example, the task of a parser is to identify one or more
parse trees for a given sentence.  As we saw in Part II,
there are several algorithms for parsing.  A <a name="recursive_descent_parser_index_term" /><span class="term">recursive descent parser</span>
performs <a name="backtracking_search_index_term" /><span class="termdef">backtracking search</span>, applying grammar productions in turn
until a match with the next input word is found, and backtracking when
there is no match.  As we will see in <a class="reference external" href="ch08.html#sec-grammar-development">8.6</a>,
the space of possible parse trees is very large; a parser can be thought
of as providing a relatively efficient way to find the right solution(s)
within a very large space of candidates.</p>
<p>As another example of search, suppose we want to find the most complex
sentence in a text corpus.  Before we can begin we have to be explicit
about how the complexity of a sentence is to be measured: word count,
verb count, character count, parse-tree depth, etc.  In the context
of learning this is known as the <a name="objective_function_index_term" /><span class="termdef">objective function</span>, the property
of candidate solutions we want to optimize.</p>
<div class="section" id="exhaustive-search">
<h3>Exhaustive Search</h3>
<ul class="simple">
<li>brute-force approach</li>
<li>enumerate search space, evaluate at each point</li>
<li>this example: search space size is 2<sup>55</sup> = 36,028,797,018,963,968</li>
</ul>
<p>For a computer that can do 100,000 evaluations per second, this
would take over 10,000 years!</p>
<p>Backtracking search -- saw this in the recursive descent parser.</p>
</div>
<div class="section" id="hill-climbing-search">
<h3>Hill-Climbing Search</h3>
<p>Starting from a given location in the search space, evaluate nearby locations and move to
a new location only if it is an improvement on the current location.</p>
<span class="target" id="code-hill-climb"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">flip</span>(segs, pos):
    return segs[:pos] + `1-int(segs[pos])` + segs[pos+1:]
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">hill_climb</span>(text, segs, iterations):
    <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(iterations):
        pos, best = 0, evaluate(text, segs)
        <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(len(segs)):
            score = evaluate(text, flip(segs, i))
            <span class="pysrc-keyword">if</span> score &lt; best:
                pos, best = i, score
        <span class="pysrc-keyword">if</span> pos != 0:
            segs = flip(segs, pos)
            <span class="pysrc-keyword">print</span> evaluate(text, segs), segment(text, segs)
    return segs</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span> evaluate(text, seg1), segment(text, seg1)
<span class="pysrc-output">63 ['doyouseethekitty', 'seethedoggy', 'doyoulikethekitty', 'likethedoggy']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>hill_climb(text, seg1, 20)
<span class="pysrc-output">61 ['doyouseethekittyseethedoggy', 'doyoulikethekitty', 'likethedoggy']</span>
<span class="pysrc-output">59 ['doyouseethekittyseethedoggydoyoulikethekitty', 'likethedoggy']</span>
<span class="pysrc-output">57 ['doyouseethekittyseethedoggydoyoulikethekittylikethedoggy']</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_hill_climb.py" type="text/x-python"><span class="caption-label">Example 4.4 (code_hill_climb.py)</span></a>: <span class="caption-label">Figure 4.4</span>: Hill-Climbing Search</td></tr></p>
</table></div>
</div>
</div>
<div class="section" id="object-oriented-programming-in-python-draft">
<h2>4.8&nbsp;&nbsp;&nbsp;Object-Oriented Programming in Python (DRAFT)</h2>
<p>Object-Oriented Programming is a programming paradigm in which
complex structures and processes are decomposed into <a name="classes_index_term" /><span class="termdef">classes</span>,
each encapsulating a single data type and the legal operations on
that type.  In this section we show you how to create simple data
classes and processing classes by example.  For a systematic
introduction to Object-Oriented design, please consult the large
literature of books on this topic.</p>
<div class="section" id="data-classes-trees-in-nltk">
<h3>Data Classes: Trees in NLTK</h3>
<p>An important data type in language processing is the syntactic tree.
Here we will review the parts of the NLTK code that defines the <tt class="doctest"><span class="pre">Tree</span></tt>
class.</p>
<p>The first line of a class definition is the <tt class="doctest"><span class="pre">class</span></tt> keyword followed
by the class name, in this case <tt class="doctest"><span class="pre">Tree</span></tt>.  This class is derived from
Python's built-in <tt class="doctest"><span class="pre">list</span></tt> class, permitting us to use standard list
operations to access the children of a tree node.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">class</span> <span class="pysrc-defname">Tree</span>(list):</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Next we define the <a name="initializer_index_term" /><span class="termdef">initializer</span> <tt class="doctest"><span class="pre">__init__()</span></tt>;
Python knows to call this function when you ask for a new tree object
by writing <tt class="doctest"><span class="pre">t = Tree(node, children)</span></tt>.  The constructor's first argument
is special, and is standardly called <tt class="doctest"><span class="pre">self</span></tt>, giving us a way to
refer to the current object from within its definition.  This
particular constructor calls the list initializer (similar to calling <tt class="doctest"><span class="pre">self =
list(children)</span></tt>), then defines the <tt class="doctest"><span class="pre">node</span></tt> property of a tree.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
...     def __init__(self, node, children):
...         list.__init__(self, children)
...         self.node = node</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Next we define another special function that Python knows to call when
we index a Tree.  The first case is the simplest, when the index is an
integer, e.g. <tt class="doctest"><span class="pre">t[2]</span></tt>, we just ask for the list item in the obvious
way.  The other cases are for handling slices, like <tt class="doctest"><span class="pre">t[1:2]</span></tt>, or <tt class="doctest"><span class="pre">t[:]</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
...     def __getitem__(self, index):
...         if isinstance(index, int):
...             return list.__getitem__(self, index)
...         else:
...             if len(index) == 0:
...                 return self
...             elif len(index) == 1:
...                 return self[int(index[0])]
...             else:
...                 return self[int(index[0])][index[1:]]
...</pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- SB: what is the len(index) == 0 case for??? -->
<p>This method was for accessing a child node.  Similar methods are
provided for setting and deleting a child (using <tt class="doctest"><span class="pre">__setitem__</span></tt>)
and <tt class="doctest"><span class="pre">__delitem__</span></tt>).</p>
<p>Two other special member functions are <tt class="doctest"><span class="pre">__repr__()</span></tt> and <tt class="doctest"><span class="pre">__str__()</span></tt>.
The <tt class="doctest"><span class="pre">__repr__()</span></tt> function produces a string representation of the
object, one that can be executed to re-create the object, and is
accessed from the interpreter simply by typing the name of the object
and pressing 'enter'.  The <tt class="doctest"><span class="pre">__str__()</span></tt> function produces a human-readable
version of the object; here we call a pretty-printing function we have
defined called <tt class="doctest"><span class="pre">pp()</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
...     def __repr__(self):
...         childstr = ' '.join([repr(c) for c in self])
...         return '(%s: %s)' % (self.node, childstr)
...     def __str__(self):
...         return self.pp()</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Next we define some member functions that do other standard operations
on trees.  First, for accessing the leaves:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
...     def leaves(self):
...         leaves = []
...         for child in self:
...             if isinstance(child, Tree):
...                 leaves.extend(child.leaves())
...             else:
...                 leaves.append(child)
...         return leaves</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Next, for computing the height:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
...     def height(self):
...         max_child_height = 0
...         for child in self:
...             if isinstance(child, Tree):
...                 max_child_height = max(max_child_height, child.height())
...             else:
...                 max_child_height = max(max_child_height, 1)
...         return 1 + max_child_height</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>And finally, for enumerating all the subtrees (optionally filtered):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
...     def subtrees(self, filter=None):
...         if not filter or filter(self):
...             yield self
...         for child in self:
...             if isinstance(child, Tree):
...                 for subtree in child.subtrees(filter):
...                     yield subtree</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="processing-classes-n-gram-taggers-in-nltk">
<h3>Processing Classes: N-gram Taggers in NLTK</h3>
<p>This section will discuss the <tt class="doctest"><span class="pre">tag.ngram</span></tt> module.</p>
</div>
<div class="section" id="duck-typing">
<h3>Duck Typing</h3>
<p>[to be written]</p>
<p><a class="reference external" href="bibliography.html#hunt2000" id="id1">(Hunt &amp; Thomas, 2000)</a></p>
<!-- Footer to be used in all chapters -->
<div class="admonition-about-this-document admonition">
<p class="first admonition-title">About this document...</p>
<p>This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://www.csse.unimelb.edu.au/~sb/">Steven Bird</a>, <a class="reference external" href="http://www.ltg.ed.ac.uk/~ewan/">Ewan Klein</a> and <a class="reference external" href="http://www.cis.upenn.edu/~edloper/">Edward Loper</a>,
Copyright &#169; 2009 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>],
Version 2.0.1rc1, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Mon 15 Oct 2012 16:46:09 EST</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
