
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>nltk.tag package &#8212; NLTK 3.5b1 documentation</title>
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="nltk.test package" href="nltk.test.html" />
    <link rel="prev" title="nltk.stem package" href="nltk.stem.html" /> 
  </head><body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 3.5b1 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="nltk.stem.html" title="nltk.stem package"
             accesskey="P">previous</a> |
          <a href="nltk.test.html" title="nltk.test package"
             accesskey="N">next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="nltk-tag-package">
<h1>nltk.tag package<a class="headerlink" href="#nltk-tag-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nltk.tag.api">
<span id="nltk-tag-api-module"></span><h2>nltk.tag.api module<a class="headerlink" href="#module-nltk.tag.api" title="Permalink to this headline">¶</a></h2>
<p>Interface for tagging each token in a sentence with supplementary
information, such as its part of speech.</p>
<dl class="class">
<dt id="nltk.tag.api.FeaturesetTaggerI">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.api.</code><code class="sig-name descname">FeaturesetTaggerI</code><a class="reference internal" href="../_modules/nltk/tag/api.html#FeaturesetTaggerI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.FeaturesetTaggerI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>A tagger that requires tokens to be <code class="docutils literal notranslate"><span class="pre">featuresets</span></code>.  A featureset
is a dictionary that maps from feature names to feature
values.  See <code class="docutils literal notranslate"><span class="pre">nltk.classify</span></code> for more information about features
and featuresets.</p>
</dd></dl>

<dl class="class">
<dt id="nltk.tag.api.TaggerI">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.api.</code><code class="sig-name descname">TaggerI</code><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A processing interface for assigning a tag to each token in a list.
Tags are case sensitive strings that identify some property of each
token, such as its part of speech or its sense.</p>
<p>Some taggers require specific types for their tokens.  This is
generally indicated by the use of a sub-interface to <code class="docutils literal notranslate"><span class="pre">TaggerI</span></code>.
For example, featureset taggers, which are subclassed from
<code class="docutils literal notranslate"><span class="pre">FeaturesetTagger</span></code>, require that each token be a <code class="docutils literal notranslate"><span class="pre">featureset</span></code>.</p>
<dl class="simple">
<dt>Subclasses must define:</dt><dd><ul class="simple">
<li><p>either <code class="docutils literal notranslate"><span class="pre">tag()</span></code> or <code class="docutils literal notranslate"><span class="pre">tag_sents()</span></code> (or both)</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.api.TaggerI.evaluate">
<code class="sig-name descname">evaluate</code><span class="sig-paren">(</span><em class="sig-param">gold</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the tagger against the gold standard.
Strip the tags from the gold standard text, retag it using
the tagger, then compute the accuracy score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gold</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>tuple</em><em>(</em><em>str</em><em>, </em><em>str</em><em>)</em><em>)</em><em>)</em>) – The list of tagged sentences to score the tagger on.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.api.TaggerI.tag">
<em class="property">abstract </em><code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the most appropriate tag sequence for the given
token sequence, and return a corresponding list of tagged
tokens.  A tagged token is encoded as a tuple <code class="docutils literal notranslate"><span class="pre">(token,</span> <span class="pre">tag)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(tuple(str, str))</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.api.TaggerI.tag_sents">
<code class="sig-name descname">tag_sents</code><span class="sig-paren">(</span><em class="sig-param">sentences</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/api.html#TaggerI.tag_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.api.TaggerI.tag_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <code class="docutils literal notranslate"><span class="pre">self.tag()</span></code> to each element of <em>sentences</em>.  I.e.:</p>
<blockquote>
<div><p>return [self.tag(sent) for sent in sentences]</p>
</div></blockquote>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.brill">
<span id="nltk-tag-brill-module"></span><h2>nltk.tag.brill module<a class="headerlink" href="#module-nltk.tag.brill" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.tag.brill.BrillTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">BrillTagger</code><span class="sig-paren">(</span><em class="sig-param">initial_tagger</em>, <em class="sig-param">rules</em>, <em class="sig-param">training_stats=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>Brill’s transformational rule-based tagger.  Brill taggers use an
initial tagger (such as <code class="docutils literal notranslate"><span class="pre">tag.DefaultTagger</span></code>) to assign an initial
tag sequence to a text; and then apply an ordered list of
transformational rules to correct the tags of individual tokens.
These transformation rules are specified by the <code class="docutils literal notranslate"><span class="pre">TagRule</span></code>
interface.</p>
<p>Brill taggers can be created directly, from an initial tagger and
a list of transformational rules; but more often, Brill taggers
are created by learning rules from a training corpus, using one
of the TaggerTrainers available.</p>
<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.batch_tag_incremental">
<code class="sig-name descname">batch_tag_incremental</code><span class="sig-paren">(</span><em class="sig-param">sequences</em>, <em class="sig-param">gold</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.batch_tag_incremental"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.batch_tag_incremental" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags by applying each rule to the entire corpus (rather than all rules to a
single sequence). The point is to collect statistics on the test set for
individual rules.</p>
<p>NOTE: This is inefficient (does not build any index, so will traverse the entire
corpus N times for N rules) – usually you would not care about statistics for
individual rules and thus use batch_tag() instead</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sequences</strong> (<em>list of list of strings</em>) – lists of token sequences (sentences, in some applications) to be tagged</p></li>
<li><p><strong>gold</strong> (<em>list of list of strings</em>) – the gold standard</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>tuple of (tagged_sequences, ordered list of rule scores (one for each rule))</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.decode_json_obj">
<em class="property">classmethod </em><code class="sig-name descname">decode_json_obj</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.decode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.decode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.encode_json_obj">
<code class="sig-name descname">encode_json_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.encode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.encode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.BrillTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.BrillTagger'</em><a class="headerlink" href="#nltk.tag.brill.BrillTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.print_template_statistics">
<code class="sig-name descname">print_template_statistics</code><span class="sig-paren">(</span><em class="sig-param">test_stats=None</em>, <em class="sig-param">printunused=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.print_template_statistics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.print_template_statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a list of all templates, ranked according to efficiency.</p>
<p>If test_stats is available, the templates are ranked according to their
relative contribution (summed for all rules created from a given template,
weighted by score) to the performance on the test set. If no test_stats, then
statistics collected during training are used instead. There is also
an unweighted measure (just counting the rules). This is less informative,
though, as many low-score rules will appear towards end of training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_stats</strong> (<em>dict of str -&gt; any</em><em> (</em><em>but usually numbers</em><em>)</em>) – dictionary of statistics collected during testing</p></li>
<li><p><strong>printunused</strong> (<em>bool</em>) – if True, print a list of all unused templates</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.rules">
<code class="sig-name descname">rules</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.rules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ordered list of  transformation rules that this tagger has learnt</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the ordered list of transformation rules that correct the initial tagging</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of Rules</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the most appropriate tag sequence for the given
token sequence, and return a corresponding list of tagged
tokens.  A tagged token is encoded as a tuple <code class="docutils literal notranslate"><span class="pre">(token,</span> <span class="pre">tag)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(tuple(str, str))</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.brill.BrillTagger.train_stats">
<code class="sig-name descname">train_stats</code><span class="sig-paren">(</span><em class="sig-param">statistic=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#BrillTagger.train_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.BrillTagger.train_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a named statistic collected during training, or a dictionary of all
available statistics if no name given</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>statistic</strong> (<em>str</em>) – name of statistic</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>some statistic collected during training of this tagger</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>any (but usually a number)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.Pos">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">Pos</code><span class="sig-paren">(</span><em class="sig-param">positions</em>, <em class="sig-param">end=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#Pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.Pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.tbl.html#nltk.tbl.feature.Feature" title="nltk.tbl.feature.Feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tbl.feature.Feature</span></code></a></p>
<p>Feature which examines the tags of nearby tokens.</p>
<dl class="method">
<dt id="nltk.tag.brill.Pos.extract_property">
<em class="property">static </em><code class="sig-name descname">extract_property</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#Pos.extract_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.Pos.extract_property" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: The given token’s tag.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.Pos.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.brill.Pos'</em><a class="headerlink" href="#nltk.tag.brill.Pos.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.brill.Word">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">Word</code><span class="sig-paren">(</span><em class="sig-param">positions</em>, <em class="sig-param">end=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#Word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.Word" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.tbl.html#nltk.tbl.feature.Feature" title="nltk.tbl.feature.Feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tbl.feature.Feature</span></code></a></p>
<p>Feature which examines the text (word) of nearby tokens.</p>
<dl class="method">
<dt id="nltk.tag.brill.Word.extract_property">
<em class="property">static </em><code class="sig-name descname">extract_property</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#Word.extract_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.Word.extract_property" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;return: The given token’s text.</p>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.brill.Word.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.brill.Word'</em><a class="headerlink" href="#nltk.tag.brill.Word.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.brill.brill24">
<code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">brill24</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#brill24"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.brill24" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 24 templates of the seminal TBL paper, Brill (1995)</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.brill.describe_template_sets">
<code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">describe_template_sets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#describe_template_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.describe_template_sets" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the available template sets in this demo, with a short description”</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.brill.fntbl37">
<code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">fntbl37</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#fntbl37"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.fntbl37" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 37 templates taken from the postagging task of the
fntbl distribution <a class="reference external" href="http://www.cs.jhu.edu/~rflorian/fntbl/">http://www.cs.jhu.edu/~rflorian/fntbl/</a>
(37 is after excluding a handful which do not condition on Pos[0];
fntbl can do that but the current nltk implementation cannot.)</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.brill.nltkdemo18">
<code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">nltkdemo18</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#nltkdemo18"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.nltkdemo18" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 18 templates, from the original nltk demo, in multi-feature syntax</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.brill.nltkdemo18plus">
<code class="sig-prename descclassname">nltk.tag.brill.</code><code class="sig-name descname">nltkdemo18plus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill.html#nltkdemo18plus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill.nltkdemo18plus" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 18 templates, from the original nltk demo, and additionally a few
multi-feature ones (the motivation is easy comparison with nltkdemo18)</p>
</dd></dl>

</div>
<div class="section" id="module-nltk.tag.brill_trainer">
<span id="nltk-tag-brill-trainer-module"></span><h2>nltk.tag.brill_trainer module<a class="headerlink" href="#module-nltk.tag.brill_trainer" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.tag.brill_trainer.BrillTaggerTrainer">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.brill_trainer.</code><code class="sig-name descname">BrillTaggerTrainer</code><span class="sig-paren">(</span><em class="sig-param">initial_tagger</em>, <em class="sig-param">templates</em>, <em class="sig-param">trace=0</em>, <em class="sig-param">deterministic=None</em>, <em class="sig-param">ruleformat='str'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill_trainer.html#BrillTaggerTrainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill_trainer.BrillTaggerTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A trainer for tbl taggers.</p>
<dl class="method">
<dt id="nltk.tag.brill_trainer.BrillTaggerTrainer.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">train_sents</em>, <em class="sig-param">max_rules=200</em>, <em class="sig-param">min_score=2</em>, <em class="sig-param">min_acc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/brill_trainer.html#BrillTaggerTrainer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.brill_trainer.BrillTaggerTrainer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the Brill tagger on the corpus <em>train_sents</em>,
producing at most <em>max_rules</em> transformations, each of which
reduces the net number of errors in the corpus by at least
<em>min_score</em>, and each of which has accuracy not lower than
<em>min_acc</em>.</p>
<p>#imports
&gt;&gt;&gt; from nltk.tbl.template import Template
&gt;&gt;&gt; from nltk.tag.brill import Pos, Word
&gt;&gt;&gt; from nltk.tag import untag, RegexpTagger, BrillTaggerTrainer</p>
<p>#some data
&gt;&gt;&gt; from nltk.corpus import treebank
&gt;&gt;&gt; training_data = treebank.tagged_sents()[:100]
&gt;&gt;&gt; baseline_data = treebank.tagged_sents()[100:200]
&gt;&gt;&gt; gold_data = treebank.tagged_sents()[200:300]
&gt;&gt;&gt; testing_data = [untag(s) for s in gold_data]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">backoff</span> <span class="o">=</span> <span class="n">RegexpTagger</span><span class="p">([</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^-?[0-9]+(.[0-9]+)?$&#39;</span><span class="p">,</span> <span class="s1">&#39;CD&#39;</span><span class="p">),</span>   <span class="c1"># cardinal numbers</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(The|the|A|a|An|an)$&#39;</span><span class="p">,</span> <span class="s1">&#39;AT&#39;</span><span class="p">),</span>   <span class="c1"># articles</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*able$&#39;</span><span class="p">,</span> <span class="s1">&#39;JJ&#39;</span><span class="p">),</span>                <span class="c1"># adjectives</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ness$&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span>                <span class="c1"># nouns formed from adjectives</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ly$&#39;</span><span class="p">,</span> <span class="s1">&#39;RB&#39;</span><span class="p">),</span>                  <span class="c1"># adverbs</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*s$&#39;</span><span class="p">,</span> <span class="s1">&#39;NNS&#39;</span><span class="p">),</span>                  <span class="c1"># plural nouns</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ing$&#39;</span><span class="p">,</span> <span class="s1">&#39;VBG&#39;</span><span class="p">),</span>                <span class="c1"># gerunds</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ed$&#39;</span><span class="p">,</span> <span class="s1">&#39;VBD&#39;</span><span class="p">),</span>                 <span class="c1"># past tense verbs</span>
<span class="gp">... </span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">)</span>                      <span class="c1"># nouns (default)</span>
<span class="gp">... </span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">baseline</span> <span class="o">=</span> <span class="n">backoff</span> <span class="c1">#see NOTE1</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">baseline</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">gold_data</span><span class="p">)</span> <span class="c1">#doctest: +ELLIPSIS</span>
<span class="go">0.2450142...</span>
</pre></div>
</div>
<p>#templates
&gt;&gt;&gt; Template._cleartemplates() #clear any templates created in earlier tests
&gt;&gt;&gt; templates = [Template(Pos([-1])), Template(Pos([-1]), Word([0]))]</p>
<p>#construct a BrillTaggerTrainer
&gt;&gt;&gt; tt = BrillTaggerTrainer(baseline, templates, trace=3)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger1</span> <span class="o">=</span> <span class="n">tt</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="n">max_rules</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: None)</span>
<span class="go">Finding initial useful rules...</span>
<span class="go">    Found 845 useful rules.</span>
<span class="go">&lt;BLANKLINE&gt;</span>
<span class="go">           B      |</span>
<span class="go">   S   F   r   O  |        Score = Fixed - Broken</span>
<span class="go">   c   i   o   t  |  R     Fixed = num tags changed incorrect -&gt; correct</span>
<span class="go">   o   x   k   h  |  u     Broken = num tags changed correct -&gt; incorrect</span>
<span class="go">   r   e   e   e  |  l     Other = num tags changed incorrect -&gt; incorrect</span>
<span class="go">   e   d   n   r  |  e</span>
<span class="go">------------------+-------------------------------------------------------</span>
<span class="go"> 132 132   0   0  | AT-&gt;DT if Pos:NN@[-1]</span>
<span class="go">  85  85   0   0  | NN-&gt;, if Pos:NN@[-1] &amp; Word:,@[0]</span>
<span class="go">  69  69   0   0  | NN-&gt;. if Pos:NN@[-1] &amp; Word:.@[0]</span>
<span class="go">  51  51   0   0  | NN-&gt;IN if Pos:NN@[-1] &amp; Word:of@[0]</span>
<span class="go">  47  63  16 161  | NN-&gt;IN if Pos:NNS@[-1]</span>
<span class="go">  33  33   0   0  | NN-&gt;TO if Pos:NN@[-1] &amp; Word:to@[0]</span>
<span class="go">  26  26   0   0  | IN-&gt;. if Pos:NNS@[-1] &amp; Word:.@[0]</span>
<span class="go">  24  24   0   0  | IN-&gt;, if Pos:NNS@[-1] &amp; Word:,@[0]</span>
<span class="go">  22  27   5  24  | NN-&gt;-NONE- if Pos:VBD@[-1]</span>
<span class="go">  17  17   0   0  | NN-&gt;CC if Pos:NN@[-1] &amp; Word:and@[0]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger1</span><span class="o">.</span><span class="n">rules</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="go">(Rule(&#39;001&#39;, &#39;NN&#39;, &#39;,&#39;, [(Pos([-1]),&#39;NN&#39;), (Word([0]),&#39;,&#39;)]), Rule(&#39;001&#39;, &#39;NN&#39;, &#39;.&#39;, [(Pos([-1]),&#39;NN&#39;), (Word([0]),&#39;.&#39;)]))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">train_stats</span> <span class="o">=</span> <span class="n">tagger1</span><span class="o">.</span><span class="n">train_stats</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">train_stats</span><span class="p">[</span><span class="n">stat</span><span class="p">]</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;initialerrors&#39;</span><span class="p">,</span> <span class="s1">&#39;finalerrors&#39;</span><span class="p">,</span> <span class="s1">&#39;rulescores&#39;</span><span class="p">]]</span>
<span class="go">[1775, 1269, [132, 85, 69, 51, 47, 33, 26, 24, 22, 17]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger1</span><span class="o">.</span><span class="n">print_template_statistics</span><span class="p">(</span><span class="n">printunused</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">TEMPLATE STATISTICS (TRAIN)  2 templates, 10 rules)</span>
<span class="go">TRAIN (   2417 tokens) initial  1775 0.2656 final:  1269 0.4750</span>
<span class="go">#ID | Score (train) |  #Rules     | Template</span>
<span class="go">--------------------------------------------</span>
<span class="go">001 |   305   0.603 |   7   0.700 | Template(Pos([-1]),Word([0]))</span>
<span class="go">000 |   201   0.397 |   3   0.300 | Template(Pos([-1]))</span>
<span class="go">&lt;BLANKLINE&gt;</span>
<span class="go">&lt;BLANKLINE&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger1</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">gold_data</span><span class="p">)</span> <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">0.43996...</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagged</span><span class="p">,</span> <span class="n">test_stats</span> <span class="o">=</span> <span class="n">tagger1</span><span class="o">.</span><span class="n">batch_tag_incremental</span><span class="p">(</span><span class="n">testing_data</span><span class="p">,</span> <span class="n">gold_data</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagged</span><span class="p">[</span><span class="mi">33</span><span class="p">][</span><span class="mi">12</span><span class="p">:]</span> <span class="o">==</span> <span class="p">[(</span><span class="s1">&#39;foreign&#39;</span><span class="p">,</span> <span class="s1">&#39;IN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;debt&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="s1">&#39;IN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;$&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;64&#39;</span><span class="p">,</span> <span class="s1">&#39;CD&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">&#39;billion&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;*U*&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;DT&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;third-highest&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">(</span><span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;DT&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;developing&#39;</span><span class="p">,</span> <span class="s1">&#39;VBG&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">)]</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">test_stats</span><span class="p">[</span><span class="n">stat</span><span class="p">]</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;initialerrors&#39;</span><span class="p">,</span> <span class="s1">&#39;finalerrors&#39;</span><span class="p">,</span> <span class="s1">&#39;rulescores&#39;</span><span class="p">]]</span>
<span class="go">[1855, 1376, [100, 85, 67, 58, 27, 36, 27, 16, 31, 32]]</span>
</pre></div>
</div>
<p># a high-accuracy tagger
&gt;&gt;&gt; tagger2 = tt.train(training_data, max_rules=10, min_acc=0.99)
TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: 0.99)
Finding initial useful rules…</p>
<blockquote>
<div><p>Found 845 useful rules.</p>
</div></blockquote>
<dl>
<dt>&lt;BLANKLINE&gt;</dt><dd><blockquote>
<div><p>B      |</p>
</div></blockquote>
<p>S   F   r   O  |        Score = Fixed - Broken
c   i   o   t  |  R     Fixed = num tags changed incorrect -&gt; correct
o   x   k   h  |  u     Broken = num tags changed correct -&gt; incorrect
r   e   e   e  |  l     Other = num tags changed incorrect -&gt; incorrect
e   d   n   r  |  e</p>
</dd>
<dt>——————+——————————————————-</dt><dd><dl class="simple">
<dt>132 132   0   0  | AT-&gt;DT if Pos:NN&#64;[-1]</dt><dd><p>85  85   0   0  | NN-&gt;, if Pos:NN&#64;[-1] &amp; Word:,&#64;[0]
69  69   0   0  | NN-&gt;. if Pos:NN&#64;[-1] &amp; Word:.&#64;[0]
51  51   0   0  | NN-&gt;IN if Pos:NN&#64;[-1] &amp; Word:of&#64;[0]
36  36   0   0  | NN-&gt;TO if Pos:NN&#64;[-1] &amp; Word:to&#64;[0]
26  26   0   0  | NN-&gt;. if Pos:NNS&#64;[-1] &amp; Word:.&#64;[0]
24  24   0   0  | NN-&gt;, if Pos:NNS&#64;[-1] &amp; Word:,&#64;[0]
19  19   0   6  | NN-&gt;VB if Pos:TO&#64;[-1]
18  18   0   0  | CD-&gt;-NONE- if Pos:NN&#64;[-1] &amp; Word:0&#64;[0]
18  18   0   0  | NN-&gt;CC if Pos:NN&#64;[-1] &amp; Word:and&#64;[0]</p>
</dd>
</dl>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger2</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">gold_data</span><span class="p">)</span>  <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">0.44159544...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagger2</span><span class="o">.</span><span class="n">rules</span><span class="p">()[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">(Rule(&#39;001&#39;, &#39;NN&#39;, &#39;.&#39;, [(Pos([-1]),&#39;NN&#39;), (Word([0]),&#39;.&#39;)]), Rule(&#39;001&#39;, &#39;NN&#39;, &#39;IN&#39;, [(Pos([-1]),&#39;NN&#39;), (Word([0]),&#39;of&#39;)]))</span>
</pre></div>
</div>
<p># NOTE1: (!!FIXME) A far better baseline uses nltk.tag.UnigramTagger,
# with a RegexpTagger only as backoff. For instance,
# &gt;&gt;&gt; baseline = UnigramTagger(baseline_data, backoff=backoff)
# However, as of Nov 2013, nltk.tag.UnigramTagger does not yield consistent results
# between python versions. The simplistic backoff above is a workaround to make doctests
# get consistent input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train_sents</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>tuple</em><em>)</em><em>)</em>) – training data</p></li>
<li><p><strong>max_rules</strong> (<em>int</em>) – output at most max_rules rules</p></li>
<li><p><strong>min_score</strong> (<em>int</em>) – stop training when no rules better than min_score can be found</p></li>
<li><p><strong>min_acc</strong> (<em>float</em><em> or </em><em>None</em>) – discard any rule with lower accuracy than min_acc</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the learned tagger</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#nltk.tag.brill.BrillTagger" title="nltk.tag.brill.BrillTagger">BrillTagger</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.crf">
<span id="nltk-tag-crf-module"></span><h2>nltk.tag.crf module<a class="headerlink" href="#module-nltk.tag.crf" title="Permalink to this headline">¶</a></h2>
<p>A module for POS tagging using CRFSuite</p>
<dl class="class">
<dt id="nltk.tag.crf.CRFTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.crf.</code><code class="sig-name descname">CRFTagger</code><span class="sig-paren">(</span><em class="sig-param">feature_func=None</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">training_opt={}</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>A module for POS tagging using CRFSuite <a class="reference external" href="https://pypi.python.org/pypi/python-crfsuite">https://pypi.python.org/pypi/python-crfsuite</a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">CRFTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">CRFTagger</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">train_data</span> <span class="o">=</span> <span class="p">[[(</span><span class="s1">&#39;University&#39;</span><span class="p">,</span><span class="s1">&#39;Noun&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;is&#39;</span><span class="p">,</span><span class="s1">&#39;Verb&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;Det&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;good&#39;</span><span class="p">,</span><span class="s1">&#39;Adj&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;place&#39;</span><span class="p">,</span><span class="s1">&#39;Noun&#39;</span><span class="p">)],</span>
<span class="gp">... </span><span class="p">[(</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span><span class="s1">&#39;Noun&#39;</span><span class="p">),(</span><span class="s1">&#39;eat&#39;</span><span class="p">,</span><span class="s1">&#39;Verb&#39;</span><span class="p">),(</span><span class="s1">&#39;meat&#39;</span><span class="p">,</span><span class="s1">&#39;Noun&#39;</span><span class="p">)]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span><span class="s1">&#39;model.crf.tagger&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span><span class="o">.</span><span class="n">tag_sents</span><span class="p">([[</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span><span class="s1">&#39;is&#39;</span><span class="p">,</span><span class="s1">&#39;good&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Cat&#39;</span><span class="p">,</span><span class="s1">&#39;eat&#39;</span><span class="p">,</span><span class="s1">&#39;meat&#39;</span><span class="p">]])</span>
<span class="go">[[(&#39;dog&#39;, &#39;Noun&#39;), (&#39;is&#39;, &#39;Verb&#39;), (&#39;good&#39;, &#39;Adj&#39;)], [(&#39;Cat&#39;, &#39;Noun&#39;), (&#39;eat&#39;, &#39;Verb&#39;), (&#39;meat&#39;, &#39;Noun&#39;)]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gold_sentences</span> <span class="o">=</span> <span class="p">[[(</span><span class="s1">&#39;dog&#39;</span><span class="p">,</span><span class="s1">&#39;Noun&#39;</span><span class="p">),(</span><span class="s1">&#39;is&#39;</span><span class="p">,</span><span class="s1">&#39;Verb&#39;</span><span class="p">),(</span><span class="s1">&#39;good&#39;</span><span class="p">,</span><span class="s1">&#39;Adj&#39;</span><span class="p">)]</span> <span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Cat&#39;</span><span class="p">,</span><span class="s1">&#39;Noun&#39;</span><span class="p">),(</span><span class="s1">&#39;eat&#39;</span><span class="p">,</span><span class="s1">&#39;Verb&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;meat&#39;</span><span class="p">,</span><span class="s1">&#39;Noun&#39;</span><span class="p">)]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">gold_sentences</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
<p>Setting learned model file
&gt;&gt;&gt; ct = CRFTagger()
&gt;&gt;&gt; ct.set_model_file(‘model.crf.tagger’)
&gt;&gt;&gt; ct.evaluate(gold_sentences)
1.0</p>
<dl class="method">
<dt id="nltk.tag.crf.CRFTagger.set_model_file">
<code class="sig-name descname">set_model_file</code><span class="sig-paren">(</span><em class="sig-param">model_file</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFTagger.set_model_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFTagger.set_model_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.CRFTagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Tag a sentence using Python CRFSuite Tagger. NB before using this function, user should specify the mode_file either by</dt><dd><ul class="simple">
<li><p>Train a new model using <a href="#id1"><span class="problematic" id="id2">``</span></a>train’’ function</p></li>
<li><p>Use the pre-trained model which is set via <a href="#id3"><span class="problematic" id="id4">``</span></a>set_model_file’’ function</p></li>
</ul>
</dd>
</dl>
<p>:params tokens : list of tokens needed to tag.
:type tokens : list(str)
:return : list of tagged tokens.
:rtype : list (tuple(str,str))</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.CRFTagger.tag_sents">
<code class="sig-name descname">tag_sents</code><span class="sig-paren">(</span><em class="sig-param">sents</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFTagger.tag_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFTagger.tag_sents" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Tag a list of sentences. NB before using this function, user should specify the mode_file either by</dt><dd><ul class="simple">
<li><p>Train a new model using <a href="#id5"><span class="problematic" id="id6">``</span></a>train’’ function</p></li>
<li><p>Use the pre-trained model which is set via <a href="#id7"><span class="problematic" id="id8">``</span></a>set_model_file’’ function</p></li>
</ul>
</dd>
</dl>
<p>:params sentences : list of sentences needed to tag.
:type sentences : list(list(str))
:return : list of tagged sentences.
:rtype : list (list (tuple(str,str)))</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.crf.CRFTagger.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">train_data</em>, <em class="sig-param">model_file</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/crf.html#CRFTagger.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.crf.CRFTagger.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the CRF tagger using CRFSuite
:params train_data : is the list of annotated sentences.
:type train_data : list (list(tuple(str,str)))
:params model_file : the model will be saved to this file.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.hmm">
<span id="nltk-tag-hmm-module"></span><h2>nltk.tag.hmm module<a class="headerlink" href="#module-nltk.tag.hmm" title="Permalink to this headline">¶</a></h2>
<p>Hidden Markov Models (HMMs) largely used to assign the correct label sequence
to sequential data or assess the probability of a given label and data
sequence. These models are finite state machines characterised by a number of
states, transitions between these states, and output symbols emitted while in
each state. The HMM is an extension to the Markov chain, where each state
corresponds deterministically to a given event. In the HMM the observation is
a probabilistic function of the state. HMMs share the Markov chain’s
assumption, being that the probability of transition from one state to another
only depends on the current state - i.e. the series of states that led to the
current state are not used. They are also time invariant.</p>
<p>The HMM is a directed graph, with probability weighted edges (representing the
probability of a transition between the source and sink states) where each
vertex emits an output symbol when entered. The symbol (or observation) is
non-deterministically generated. For this reason, knowing that a sequence of
output observations was generated by a given HMM does not mean that the
corresponding sequence of states (and what the current state is) is known.
This is the ‘hidden’ in the hidden markov model.</p>
<p>Formally, a HMM can be characterised by:</p>
<ul class="simple">
<li><p>the output observation alphabet. This is the set of symbols which may be
observed as output of the system.</p></li>
<li><p>the set of states.</p></li>
<li><p>the transition probabilities <em>a_{ij} = P(s_t = j | s_{t-1} = i)</em>. These
represent the probability of transition to each state from a given state.</p></li>
<li><p>the output probability matrix <em>b_i(k) = P(X_t = o_k | s_t = i)</em>. These
represent the probability of observing each symbol in a given state.</p></li>
<li><p>the initial state distribution. This gives the probability of starting
in each state.</p></li>
</ul>
<p>To ground this discussion, take a common NLP application, part-of-speech (POS)
tagging. An HMM is desirable for this task as the highest probability tag
sequence can be calculated for a given sequence of word forms. This differs
from other tagging techniques which often tag each word individually, seeking
to optimise each individual tagging greedily without regard to the optimal
combination of tags for a larger unit, such as a sentence. The HMM does this
with the Viterbi algorithm, which efficiently computes the optimal path
through the graph given the sequence of words forms.</p>
<p>In POS tagging the states usually have a 1:1 correspondence with the tag
alphabet - i.e. each state represents a single tag. The output observation
alphabet is the set of word forms (the lexicon), and the remaining three
parameters are derived by a training regime. With this information the
probability of a given sentence can be easily derived, by simply summing the
probability of each distinct path through the model. Similarly, the highest
probability tagging sequence can be derived with the Viterbi algorithm,
yielding a state sequence which can be mapped into a tag sequence.</p>
<p>This discussion assumes that the HMM has been trained. This is probably the
most difficult task with the model, and requires either MLE estimates of the
parameters or unsupervised learning using the Baum-Welch algorithm, a variant
of EM.</p>
<p>For more information, please consult the source code for this module,
which includes extensive demonstration code.</p>
<dl class="class">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">HiddenMarkovModelTagger</code><span class="sig-paren">(</span><em class="sig-param">symbols</em>, <em class="sig-param">states</em>, <em class="sig-param">transitions</em>, <em class="sig-param">outputs</em>, <em class="sig-param">priors</em>, <em class="sig-param">transform=&lt;function _identity&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>Hidden Markov model class, a generative model for labelling sequence data.
These models define the joint probability of a sequence of symbols and
their labels (state transitions) as the product of the starting state
probability, the probability of each state transition, and the probability
of each observation being generated from each state. This is described in
more detail in the module documentation.</p>
<p>This implementation is based on the HMM description in Chapter 8, Huang,
Acero and Hon, Spoken Language Processing and includes an extension for
training shallow HMM parsers or specialized HMMs as in Molina et.
al, 2002.  A specialized HMM modifies training data by applying a
specialization function to create a new training set that is more
appropriate for sequential tagging with an HMM.  A typical use case is
chunking.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>symbols</strong> (<em>seq of any</em>) – the set of output symbols (alphabet)</p></li>
<li><p><strong>states</strong> (<em>seq of any</em>) – a set of states representing state space</p></li>
<li><p><strong>transitions</strong> (<a class="reference internal" href="nltk.html#nltk.probability.ConditionalProbDistI" title="nltk.probability.ConditionalProbDistI"><em>ConditionalProbDistI</em></a>) – transition probabilities; Pr(s_i | s_j) is the
probability of transition from state i given the model is in
state_j</p></li>
<li><p><strong>outputs</strong> (<a class="reference internal" href="nltk.html#nltk.probability.ConditionalProbDistI" title="nltk.probability.ConditionalProbDistI"><em>ConditionalProbDistI</em></a>) – output probabilities; Pr(o_k | s_i) is the probability
of emitting symbol k when entering state i</p></li>
<li><p><strong>priors</strong> (<a class="reference internal" href="nltk.html#nltk.probability.ProbDistI" title="nltk.probability.ProbDistI"><em>ProbDistI</em></a>) – initial state distribution; Pr(s_i) is the probability
of starting in state i</p></li>
<li><p><strong>transform</strong> (<em>callable</em>) – an optional function for transforming training
instances, defaults to the identity function.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.best_path">
<code class="sig-name descname">best_path</code><span class="sig-paren">(</span><em class="sig-param">unlabeled_sequence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.best_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.best_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the state sequence of the optimal (most probable) path through
the HMM. Uses the Viterbi algorithm to calculate this part by dynamic
programming.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the state sequence</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>sequence of any</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>unlabeled_sequence</strong> (<em>list</em>) – the sequence of unlabeled symbols</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.best_path_simple">
<code class="sig-name descname">best_path_simple</code><span class="sig-paren">(</span><em class="sig-param">unlabeled_sequence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.best_path_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.best_path_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the state sequence of the optimal (most probable) path through
the HMM. Uses the Viterbi algorithm to calculate this part by dynamic
programming.  This uses a simple, direct method, and is included for
teaching purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the state sequence</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>sequence of any</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>unlabeled_sequence</strong> (<em>list</em>) – the sequence of unlabeled symbols</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.entropy">
<code class="sig-name descname">entropy</code><span class="sig-paren">(</span><em class="sig-param">unlabeled_sequence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the entropy over labellings of the given sequence. This is
given by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span><span class="p">(</span><span class="n">O</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sum_S</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S</span> <span class="o">|</span> <span class="n">O</span><span class="p">)</span> <span class="n">log</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S</span> <span class="o">|</span> <span class="n">O</span><span class="p">)</span>
</pre></div>
</div>
<p>where the summation ranges over all state sequences, S. Let
<em>Z = Pr(O) = sum_S Pr(S, O)}</em> where the summation ranges over all state
sequences and O is the observation sequence. As such the entropy can
be re-expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sum_S</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S</span> <span class="o">|</span> <span class="n">O</span><span class="p">)</span> <span class="n">log</span> <span class="p">[</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span> <span class="o">/</span> <span class="n">Z</span> <span class="p">]</span>
<span class="o">=</span> <span class="n">log</span> <span class="n">Z</span> <span class="o">-</span> <span class="n">sum_S</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S</span> <span class="o">|</span> <span class="n">O</span><span class="p">)</span> <span class="n">log</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">=</span> <span class="n">log</span> <span class="n">Z</span> <span class="o">-</span> <span class="n">sum_S</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S</span> <span class="o">|</span> <span class="n">O</span><span class="p">)</span> <span class="p">[</span> <span class="n">log</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">sum_t</span> <span class="n">Pr</span><span class="p">(</span><span class="n">S_t</span> <span class="o">|</span> <span class="n">S_</span><span class="p">{</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">})</span> <span class="o">+</span> <span class="n">sum_t</span> <span class="n">Pr</span><span class="p">(</span><span class="n">O_t</span> <span class="o">|</span> <span class="n">S_t</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</div>
<p>The order of summation for the log terms can be flipped, allowing
dynamic programming to be used to calculate the entropy. Specifically,
we use the forward and backward probabilities (alpha, beta) giving:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">log</span> <span class="n">Z</span> <span class="o">-</span> <span class="n">sum_s0</span> <span class="n">alpha_0</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span> <span class="n">beta_0</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Z</span> <span class="o">*</span> <span class="n">log</span> <span class="n">Pr</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
<span class="o">+</span> <span class="n">sum_t</span><span class="p">,</span><span class="n">si</span><span class="p">,</span><span class="n">sj</span> <span class="n">alpha_t</span><span class="p">(</span><span class="n">si</span><span class="p">)</span> <span class="n">Pr</span><span class="p">(</span><span class="n">sj</span> <span class="o">|</span> <span class="n">si</span><span class="p">)</span> <span class="n">Pr</span><span class="p">(</span><span class="n">O_t</span><span class="o">+</span><span class="mi">1</span> <span class="o">|</span> <span class="n">sj</span><span class="p">)</span> <span class="n">beta_t</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span> <span class="o">/</span> <span class="n">Z</span> <span class="o">*</span> <span class="n">log</span> <span class="n">Pr</span><span class="p">(</span><span class="n">sj</span> <span class="o">|</span> <span class="n">si</span><span class="p">)</span>
<span class="o">+</span> <span class="n">sum_t</span><span class="p">,</span><span class="n">st</span> <span class="n">alpha_t</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="n">beta_t</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">/</span> <span class="n">Z</span> <span class="o">*</span> <span class="n">log</span> <span class="n">Pr</span><span class="p">(</span><span class="n">O_t</span> <span class="o">|</span> <span class="n">st</span><span class="p">)</span>
</pre></div>
</div>
<p>This simply uses alpha and beta to find the probabilities of partial
sequences, constrained to include the given state(s) at some point in
time.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.log_probability">
<code class="sig-name descname">log_probability</code><span class="sig-paren">(</span><em class="sig-param">sequence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.log_probability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.log_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the log-probability of the given symbol sequence. If the
sequence is labelled, then returns the joint log-probability of the
symbol, state sequence. Otherwise, uses the forward algorithm to find
the log-probability over all label sequences.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the log-probability of the sequence</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sequence</strong> (<a class="reference internal" href="nltk.ccg.html#nltk.ccg.lexicon.Token" title="nltk.ccg.lexicon.Token"><em>Token</em></a>) – the sequence of symbols which must contain the TEXT
property, and optionally the TAG property</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.point_entropy">
<code class="sig-name descname">point_entropy</code><span class="sig-paren">(</span><em class="sig-param">unlabeled_sequence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.point_entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.point_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pointwise entropy over the possible states at each
position in the chain, given the observation sequence.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.probability">
<code class="sig-name descname">probability</code><span class="sig-paren">(</span><em class="sig-param">sequence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.probability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the probability of the given symbol sequence. If the sequence
is labelled, then returns the joint probability of the symbol, state
sequence. Otherwise, uses the forward algorithm to find the
probability over all label sequences.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the probability of the sequence</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sequence</strong> (<a class="reference internal" href="nltk.ccg.html#nltk.ccg.lexicon.Token" title="nltk.ccg.lexicon.Token"><em>Token</em></a>) – the sequence of symbols which must contain the TEXT
property, and optionally the TAG property</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.random_sample">
<code class="sig-name descname">random_sample</code><span class="sig-paren">(</span><em class="sig-param">rng</em>, <em class="sig-param">length</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.random_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.random_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly sample the HMM to generate a sentence of a given length. This
samples the prior distribution then the observation distribution and
transition distribution for each subsequent observation and state.
This will mostly generate unintelligible garbage, but can provide some
amusement.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the randomly created state/observation sequence,
generated according to the HMM’s probability
distributions. The SUBTOKENS have TEXT and TAG
properties containing the observation and state
respectively.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rng</strong> (<em>Random</em><em> (or </em><em>any object with a random</em><em>(</em><em>) </em><em>method</em><em>)</em>) – random number generator</p></li>
<li><p><strong>length</strong> (<em>int</em>) – desired output length</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.reset_cache">
<code class="sig-name descname">reset_cache</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.reset_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.reset_cache" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">unlabeled_sequence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags the sequence with the highest probability state sequence. This
uses the best_path method to find the Viterbi path.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a labelled sequence of symbols</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>unlabeled_sequence</strong> (<em>list</em>) – the sequence of unlabeled symbols</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.test">
<code class="sig-name descname">test</code><span class="sig-paren">(</span><em class="sig-param">test_sequence</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the HiddenMarkovModelTagger instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>test_sequence</strong> (<em>list</em><em>(</em><em>list</em><em>)</em>) – a sequence of labeled test instances</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – boolean flag indicating whether training should be
verbose or include printed output</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTagger.train">
<em class="property">classmethod </em><code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">labeled_sequence</em>, <em class="sig-param">test_sequence=None</em>, <em class="sig-param">unlabeled_sequence=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTagger.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTagger.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a new HiddenMarkovModelTagger using the given labeled and
unlabeled training instances. Testing will be performed if test
instances are provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a hidden markov model tagger</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#nltk.tag.hmm.HiddenMarkovModelTagger" title="nltk.tag.hmm.HiddenMarkovModelTagger">HiddenMarkovModelTagger</a></p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labeled_sequence</strong> (<em>list</em><em>(</em><em>list</em><em>)</em>) – a sequence of labeled training instances,
i.e. a list of sentences represented as tuples</p></li>
<li><p><strong>test_sequence</strong> (<em>list</em><em>(</em><em>list</em><em>)</em>) – a sequence of labeled test instances</p></li>
<li><p><strong>unlabeled_sequence</strong> (<em>list</em><em>(</em><em>list</em><em>)</em>) – a sequence of unlabeled training instances,
i.e. a list of sentences represented as words</p></li>
<li><p><strong>transform</strong> (<em>function</em>) – an optional function for transforming training
instances, defaults to the identity function, see <code class="docutils literal notranslate"><span class="pre">transform()</span></code></p></li>
<li><p><strong>estimator</strong> (<em>class</em><em> or </em><em>function</em>) – an optional function or class that maps a
condition’s frequency distribution to its probability
distribution, defaults to a Lidstone distribution with gamma = 0.1</p></li>
<li><p><strong>verbose</strong> (<em>bool</em>) – boolean flag indicating whether training should be
verbose or include printed output</p></li>
<li><p><strong>max_iterations</strong> (<em>int</em>) – number of Baum-Welch interations to perform</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">HiddenMarkovModelTrainer</code><span class="sig-paren">(</span><em class="sig-param">states=None</em>, <em class="sig-param">symbols=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Algorithms for learning HMM parameters from training data. These include
both supervised learning (MLE) and unsupervised learning (Baum-Welch).</p>
<p>Creates an HMM trainer to induce an HMM with the given states and
output symbol alphabet. A supervised and unsupervised training
method may be used. If either of the states or symbols are not given,
these may be derived from supervised training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>states</strong> (<em>sequence of any</em>) – the set of state labels</p></li>
<li><p><strong>symbols</strong> (<em>sequence of any</em>) – the set of observation symbols</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">labeled_sequences=None</em>, <em class="sig-param">unlabeled_sequences=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the HMM using both (or either of) supervised and unsupervised
techniques.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the trained model</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#nltk.tag.hmm.HiddenMarkovModelTagger" title="nltk.tag.hmm.HiddenMarkovModelTagger">HiddenMarkovModelTagger</a></p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labelled_sequences</strong> (<em>list</em>) – the supervised training data, a set of
labelled sequences of observations
ex: [ (word_1, tag_1),…,(word_n,tag_n) ]</p></li>
<li><p><strong>unlabeled_sequences</strong> (<em>list</em>) – the unsupervised training data, a set of
sequences of observations
ex: [ word_1, …, word_n ]</p></li>
<li><p><strong>kwargs</strong> – additional arguments to pass to the training methods</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer.train_supervised">
<code class="sig-name descname">train_supervised</code><span class="sig-paren">(</span><em class="sig-param">labelled_sequences</em>, <em class="sig-param">estimator=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer.train_supervised"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer.train_supervised" title="Permalink to this definition">¶</a></dt>
<dd><p>Supervised training maximising the joint probability of the symbol and
state sequences. This is done via collecting frequencies of
transitions between states, symbol observations while within each
state and which states start a sentence. These frequency distributions
are then normalised into probability estimates, which can be
smoothed if desired.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the trained model</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#nltk.tag.hmm.HiddenMarkovModelTagger" title="nltk.tag.hmm.HiddenMarkovModelTagger">HiddenMarkovModelTagger</a></p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labelled_sequences</strong> (<em>list</em>) – the training data, a set of
labelled sequences of observations</p></li>
<li><p><strong>estimator</strong> – a function taking
a FreqDist and a number of bins and returning a CProbDistI;
otherwise a MLE estimate is used</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hmm.HiddenMarkovModelTrainer.train_unsupervised">
<code class="sig-name descname">train_unsupervised</code><span class="sig-paren">(</span><em class="sig-param">unlabeled_sequences</em>, <em class="sig-param">update_outputs=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#HiddenMarkovModelTrainer.train_unsupervised"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.HiddenMarkovModelTrainer.train_unsupervised" title="Permalink to this definition">¶</a></dt>
<dd><p>Trains the HMM using the Baum-Welch algorithm to maximise the
probability of the data sequence. This is a variant of the EM
algorithm, and is unsupervised in that it doesn’t need the state
sequences for the symbols. The code is based on ‘A Tutorial on Hidden
Markov Models and Selected Applications in Speech Recognition’,
Lawrence Rabiner, IEEE, 1989.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the trained model</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#nltk.tag.hmm.HiddenMarkovModelTagger" title="nltk.tag.hmm.HiddenMarkovModelTagger">HiddenMarkovModelTagger</a></p>
</dd>
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>unlabeled_sequences</strong> (<em>list</em>) – the training data, a set of
sequences of observations</p>
</dd>
</dl>
<p>kwargs may include following parameters:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – a HiddenMarkovModelTagger instance used to begin
the Baum-Welch algorithm</p></li>
<li><p><strong>max_iterations</strong> – the maximum number of EM iterations</p></li>
<li><p><strong>convergence_logprob</strong> – the maximum change in log probability to
allow convergence</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo">
<code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">demo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo_bw">
<code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">demo_bw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo_bw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo_bw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo_pos">
<code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">demo_pos</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.demo_pos_bw">
<code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">demo_pos_bw</code><span class="sig-paren">(</span><em class="sig-param">test=10</em>, <em class="sig-param">supervised=20</em>, <em class="sig-param">unsupervised=10</em>, <em class="sig-param">verbose=True</em>, <em class="sig-param">max_iterations=5</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#demo_pos_bw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.demo_pos_bw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.load_pos">
<code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">load_pos</code><span class="sig-paren">(</span><em class="sig-param">num_sents</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#load_pos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.load_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.hmm.logsumexp2">
<code class="sig-prename descclassname">nltk.tag.hmm.</code><code class="sig-name descname">logsumexp2</code><span class="sig-paren">(</span><em class="sig-param">arr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hmm.html#logsumexp2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hmm.logsumexp2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.hunpos">
<span id="nltk-tag-hunpos-module"></span><h2>nltk.tag.hunpos module<a class="headerlink" href="#module-nltk.tag.hunpos" title="Permalink to this headline">¶</a></h2>
<p>A module for interfacing with the HunPos open-source POS-tagger.</p>
<dl class="class">
<dt id="nltk.tag.hunpos.HunposTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.hunpos.</code><code class="sig-name descname">HunposTagger</code><span class="sig-paren">(</span><em class="sig-param">path_to_model</em>, <em class="sig-param">path_to_bin=None</em>, <em class="sig-param">encoding='ISO-8859-1'</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hunpos.html#HunposTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hunpos.HunposTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<dl class="simple">
<dt>A class for pos tagging with HunPos. The input is the paths to:</dt><dd><ul class="simple">
<li><p>a model trained on training data</p></li>
<li><p>(optionally) the path to the hunpos-tag binary</p></li>
<li><p>(optionally) the encoding of the training data (default: ISO-8859-1)</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">HunposTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ht</span> <span class="o">=</span> <span class="n">HunposTagger</span><span class="p">(</span><span class="s1">&#39;en_wsj.model&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ht</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;What is the airspeed of an unladen swallow ?&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">[(&#39;What&#39;, &#39;WP&#39;), (&#39;is&#39;, &#39;VBZ&#39;), (&#39;the&#39;, &#39;DT&#39;), (&#39;airspeed&#39;, &#39;NN&#39;), (&#39;of&#39;, &#39;IN&#39;), (&#39;an&#39;, &#39;DT&#39;), (&#39;unladen&#39;, &#39;NN&#39;), (&#39;swallow&#39;, &#39;VB&#39;), (&#39;?&#39;, &#39;.&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ht</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>This class communicates with the hunpos-tag binary via pipes. When the
tagger object is no longer needed, the close() method should be called to
free system resources. The class supports the context manager interface; if
used in a with statement, the close() method is invoked automatically:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">HunposTagger</span><span class="p">(</span><span class="s1">&#39;en_wsj.model&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ht</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">ht</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;What is the airspeed of an unladen swallow ?&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="gp">...</span>
<span class="go">[(&#39;What&#39;, &#39;WP&#39;), (&#39;is&#39;, &#39;VBZ&#39;), (&#39;the&#39;, &#39;DT&#39;), (&#39;airspeed&#39;, &#39;NN&#39;), (&#39;of&#39;, &#39;IN&#39;), (&#39;an&#39;, &#39;DT&#39;), (&#39;unladen&#39;, &#39;NN&#39;), (&#39;swallow&#39;, &#39;VB&#39;), (&#39;?&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
<dl class="method">
<dt id="nltk.tag.hunpos.HunposTagger.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hunpos.html#HunposTagger.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hunpos.HunposTagger.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the pipe to the hunpos executable.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.hunpos.HunposTagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hunpos.html#HunposTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hunpos.HunposTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags a single sentence: a list of words.
The tokens should not contain any newline characters.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.hunpos.setup_module">
<code class="sig-prename descclassname">nltk.tag.hunpos.</code><code class="sig-name descname">setup_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/hunpos.html#setup_module"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.hunpos.setup_module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.mapping">
<span id="nltk-tag-mapping-module"></span><h2>nltk.tag.mapping module<a class="headerlink" href="#module-nltk.tag.mapping" title="Permalink to this headline">¶</a></h2>
<p>Interface for converting POS tags from various treebanks
to the universal tagset of Petrov, Das, &amp; McDonald.</p>
<p>The tagset consists of the following 12 coarse tags:</p>
<p>VERB - verbs (all tenses and modes)
NOUN - nouns (common and proper)
PRON - pronouns
ADJ - adjectives
ADV - adverbs
ADP - adpositions (prepositions and postpositions)
CONJ - conjunctions
DET - determiners
NUM - cardinal numbers
PRT - particles or other function words
X - other: foreign words, typos, abbreviations
. - punctuation</p>
<p>&#64;see: <a class="reference external" href="http://arxiv.org/abs/1104.2086">http://arxiv.org/abs/1104.2086</a> and <a class="reference external" href="http://code.google.com/p/universal-pos-tags/">http://code.google.com/p/universal-pos-tags/</a></p>
<dl class="function">
<dt id="nltk.tag.mapping.map_tag">
<code class="sig-prename descclassname">nltk.tag.mapping.</code><code class="sig-name descname">map_tag</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">target</em>, <em class="sig-param">source_tag</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/mapping.html#map_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.mapping.map_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the tag from the source tagset to the target tagset.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">map_tag</span><span class="p">(</span><span class="s1">&#39;en-ptb&#39;</span><span class="p">,</span> <span class="s1">&#39;universal&#39;</span><span class="p">,</span> <span class="s1">&#39;VBZ&#39;</span><span class="p">)</span>
<span class="go">&#39;VERB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_tag</span><span class="p">(</span><span class="s1">&#39;en-ptb&#39;</span><span class="p">,</span> <span class="s1">&#39;universal&#39;</span><span class="p">,</span> <span class="s1">&#39;VBP&#39;</span><span class="p">)</span>
<span class="go">&#39;VERB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">map_tag</span><span class="p">(</span><span class="s1">&#39;en-ptb&#39;</span><span class="p">,</span> <span class="s1">&#39;universal&#39;</span><span class="p">,</span> <span class="s1">&#39;``&#39;</span><span class="p">)</span>
<span class="go">&#39;.&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.mapping.tagset_mapping">
<code class="sig-prename descclassname">nltk.tag.mapping.</code><code class="sig-name descname">tagset_mapping</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">target</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/mapping.html#tagset_mapping"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.mapping.tagset_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the mapping dictionary between tagsets.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagset_mapping</span><span class="p">(</span><span class="s1">&#39;ru-rnc&#39;</span><span class="p">,</span> <span class="s1">&#39;universal&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;!&#39;</span><span class="p">:</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="s1">&#39;ADJ&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="s1">&#39;CONJ&#39;</span><span class="p">,</span> <span class="s1">&#39;AD&#39;</span><span class="p">:</span> <span class="s1">&#39;ADV&#39;</span><span class="p">,</span>            <span class="s1">&#39;NN&#39;</span><span class="p">:</span> <span class="s1">&#39;NOUN&#39;</span><span class="p">,</span> <span class="s1">&#39;VG&#39;</span><span class="p">:</span> <span class="s1">&#39;VERB&#39;</span><span class="p">,</span> <span class="s1">&#39;COMP&#39;</span><span class="p">:</span> <span class="s1">&#39;CONJ&#39;</span><span class="p">,</span> <span class="s1">&#39;NC&#39;</span><span class="p">:</span> <span class="s1">&#39;NUM&#39;</span><span class="p">,</span> <span class="s1">&#39;VP&#39;</span><span class="p">:</span> <span class="s1">&#39;VERB&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="s1">&#39;ADP&#39;</span><span class="p">,</span>            <span class="s1">&#39;IJ&#39;</span><span class="p">:</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="s1">&#39;VERB&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;VI&#39;</span><span class="p">:</span> <span class="s1">&#39;VERB&#39;</span><span class="p">,</span> <span class="s1">&#39;YES_NO_SENT&#39;</span><span class="p">:</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;PTCL&#39;</span><span class="p">:</span> <span class="s1">&#39;PRT&#39;</span><span class="p">}</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-nltk.tag.perceptron">
<span id="nltk-tag-perceptron-module"></span><h2>nltk.tag.perceptron module<a class="headerlink" href="#module-nltk.tag.perceptron" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nltk.tag.perceptron.AveragedPerceptron">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.perceptron.</code><code class="sig-name descname">AveragedPerceptron</code><span class="sig-paren">(</span><em class="sig-param">weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An averaged perceptron, as implemented by Matthew Honnibal.</p>
<dl class="simple">
<dt>See more implementation details here:</dt><dd><p><a class="reference external" href="https://explosion.ai/blog/part-of-speech-pos-tagger-in-python">https://explosion.ai/blog/part-of-speech-pos-tagger-in-python</a></p>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.perceptron.AveragedPerceptron.average_weights">
<code class="sig-name descname">average_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron.average_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.average_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Average weights from all iterations.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.AveragedPerceptron.decode_json_obj">
<em class="property">classmethod </em><code class="sig-name descname">decode_json_obj</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron.decode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.decode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.AveragedPerceptron.encode_json_obj">
<code class="sig-name descname">encode_json_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron.encode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.encode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.perceptron.AveragedPerceptron.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.perceptron.AveragedPerceptron'</em><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.AveragedPerceptron.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the pickled model weights.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.AveragedPerceptron.predict">
<code class="sig-name descname">predict</code><span class="sig-paren">(</span><em class="sig-param">features</em>, <em class="sig-param">return_conf=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron.predict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot-product the features and current weights and return the best label.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.AveragedPerceptron.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the pickled model weights.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.AveragedPerceptron.update">
<code class="sig-name descname">update</code><span class="sig-paren">(</span><em class="sig-param">truth</em>, <em class="sig-param">guess</em>, <em class="sig-param">features</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#AveragedPerceptron.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.AveragedPerceptron.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the feature weights.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.perceptron.PerceptronTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.perceptron.</code><code class="sig-name descname">PerceptronTagger</code><span class="sig-paren">(</span><em class="sig-param">load=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#PerceptronTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>Greedy Averaged Perceptron tagger, as implemented by Matthew Honnibal.
See more implementation details here:</p>
<blockquote>
<div><p><a class="reference external" href="https://explosion.ai/blog/part-of-speech-pos-tagger-in-python">https://explosion.ai/blog/part-of-speech-pos-tagger-in-python</a></p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.perceptron</span> <span class="kn">import</span> <span class="n">PerceptronTagger</span>
</pre></div>
</div>
<p>Train the model</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span> <span class="o">=</span> <span class="n">PerceptronTagger</span><span class="p">(</span><span class="n">load</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span><span class="o">.</span><span class="n">train</span><span class="p">([[(</span><span class="s1">&#39;today&#39;</span><span class="p">,</span><span class="s1">&#39;NN&#39;</span><span class="p">),(</span><span class="s1">&#39;is&#39;</span><span class="p">,</span><span class="s1">&#39;VBZ&#39;</span><span class="p">),(</span><span class="s1">&#39;good&#39;</span><span class="p">,</span><span class="s1">&#39;JJ&#39;</span><span class="p">),(</span><span class="s1">&#39;day&#39;</span><span class="p">,</span><span class="s1">&#39;NN&#39;</span><span class="p">)],</span>
<span class="gp">... </span><span class="p">[(</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span><span class="s1">&#39;NNS&#39;</span><span class="p">),(</span><span class="s1">&#39;it&#39;</span><span class="p">,</span><span class="s1">&#39;PRP&#39;</span><span class="p">),(</span><span class="s1">&#39;beautiful&#39;</span><span class="p">,</span><span class="s1">&#39;JJ&#39;</span><span class="p">)]])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">([</span><span class="s1">&#39;today&#39;</span><span class="p">,</span><span class="s1">&#39;is&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;beautiful&#39;</span><span class="p">,</span><span class="s1">&#39;day&#39;</span><span class="p">])</span>
<span class="go">[(&#39;today&#39;, &#39;NN&#39;), (&#39;is&#39;, &#39;PRP&#39;), (&#39;a&#39;, &#39;PRP&#39;), (&#39;beautiful&#39;, &#39;JJ&#39;), (&#39;day&#39;, &#39;NN&#39;)]</span>
</pre></div>
</div>
<p>Use the pretrain model (the default constructor)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pretrain</span> <span class="o">=</span> <span class="n">PerceptronTagger</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pretrain</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;The quick brown fox jumps over the lazy dog&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">[(&#39;The&#39;, &#39;DT&#39;), (&#39;quick&#39;, &#39;JJ&#39;), (&#39;brown&#39;, &#39;NN&#39;), (&#39;fox&#39;, &#39;NN&#39;), (&#39;jumps&#39;, &#39;VBZ&#39;), (&#39;over&#39;, &#39;IN&#39;), (&#39;the&#39;, &#39;DT&#39;), (&#39;lazy&#39;, &#39;JJ&#39;), (&#39;dog&#39;, &#39;NN&#39;)]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pretrain</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s2">&quot;The red cat&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">[(&#39;The&#39;, &#39;DT&#39;), (&#39;red&#39;, &#39;JJ&#39;), (&#39;cat&#39;, &#39;NN&#39;)]</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="nltk.tag.perceptron.PerceptronTagger.END">
<code class="sig-name descname">END</code><em class="property"> = ['-END-', '-END2-']</em><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.END" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.perceptron.PerceptronTagger.START">
<code class="sig-name descname">START</code><em class="property"> = ['-START-', '-START2-']</em><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.START" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.PerceptronTagger.decode_json_obj">
<em class="property">classmethod </em><code class="sig-name descname">decode_json_obj</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#PerceptronTagger.decode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.decode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.PerceptronTagger.encode_json_obj">
<code class="sig-name descname">encode_json_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#PerceptronTagger.encode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.encode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.perceptron.PerceptronTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.PerceptronTagger'</em><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.PerceptronTagger.load">
<code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">loc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#PerceptronTagger.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.load" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>loc</strong> (<em>str</em>) – Load a pickled model at location.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.PerceptronTagger.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><em class="sig-param">word</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#PerceptronTagger.normalize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalization used in pre-processing.
- All words are lower cased
- Groups of digits of length 4 are represented as !YEAR;
- Other digits are represented as !DIGITS</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.PerceptronTagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">return_conf=False</em>, <em class="sig-param">use_tagdict=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#PerceptronTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tag tokenized sentences.
:params tokens: list of word
:type tokens: list(str)</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.perceptron.PerceptronTagger.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">sentences</em>, <em class="sig-param">save_loc=None</em>, <em class="sig-param">nr_iter=5</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/perceptron.html#PerceptronTagger.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.perceptron.PerceptronTagger.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Train a model from sentences, and save it at <code class="docutils literal notranslate"><span class="pre">save_loc</span></code>. <code class="docutils literal notranslate"><span class="pre">nr_iter</span></code>
controls the number of Perceptron training iterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sentences</strong> – A list or iterator of sentences, where each sentence
is a list of (words, tags) tuples.</p></li>
<li><p><strong>save_loc</strong> – If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, saves a pickled model in this location.</p></li>
<li><p><strong>nr_iter</strong> – Number of training iterations.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.senna">
<span id="nltk-tag-senna-module"></span><h2>nltk.tag.senna module<a class="headerlink" href="#module-nltk.tag.senna" title="Permalink to this headline">¶</a></h2>
<p>Senna POS tagger, NER Tagger, Chunk Tagger</p>
<p>The input is:
- path to the directory that contains SENNA executables. If the path is incorrect,</p>
<blockquote>
<div><p>SennaTagger will automatically search for executable file specified in SENNA environment variable</p>
</div></blockquote>
<ul class="simple">
<li><p>(optionally) the encoding of the input data (default:utf-8)</p></li>
</ul>
<p>Note: Unit tests for this module can be found in test/unit/test_senna.py</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">SennaTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span> <span class="o">=</span> <span class="n">SennaTagger</span><span class="p">(</span><span class="s1">&#39;/usr/share/senna-v3.0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;What is the airspeed of an unladen swallow ?&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;What&#39;, &#39;WP&#39;), (&#39;is&#39;, &#39;VBZ&#39;), (&#39;the&#39;, &#39;DT&#39;), (&#39;airspeed&#39;, &#39;NN&#39;),</span>
<span class="go">(&#39;of&#39;, &#39;IN&#39;), (&#39;an&#39;, &#39;DT&#39;), (&#39;unladen&#39;, &#39;NN&#39;), (&#39;swallow&#39;, &#39;NN&#39;), (&#39;?&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">SennaChunkTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chktagger</span> <span class="o">=</span> <span class="n">SennaChunkTagger</span><span class="p">(</span><span class="s1">&#39;/usr/share/senna-v3.0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chktagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;What is the airspeed of an unladen swallow ?&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;What&#39;, &#39;B-NP&#39;), (&#39;is&#39;, &#39;B-VP&#39;), (&#39;the&#39;, &#39;B-NP&#39;), (&#39;airspeed&#39;, &#39;I-NP&#39;),</span>
<span class="go">(&#39;of&#39;, &#39;B-PP&#39;), (&#39;an&#39;, &#39;B-NP&#39;), (&#39;unladen&#39;, &#39;I-NP&#39;), (&#39;swallow&#39;, &#39;I-NP&#39;),</span>
<span class="go">(&#39;?&#39;, &#39;O&#39;)]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">SennaNERTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nertagger</span> <span class="o">=</span> <span class="n">SennaNERTagger</span><span class="p">(</span><span class="s1">&#39;/usr/share/senna-v3.0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nertagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;Shakespeare theatre was in London .&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;Shakespeare&#39;, &#39;B-PER&#39;), (&#39;theatre&#39;, &#39;O&#39;), (&#39;was&#39;, &#39;O&#39;), (&#39;in&#39;, &#39;O&#39;),</span>
<span class="go">(&#39;London&#39;, &#39;B-LOC&#39;), (&#39;.&#39;, &#39;O&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nertagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;UN headquarters are in NY , USA .&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;UN&#39;, &#39;B-ORG&#39;), (&#39;headquarters&#39;, &#39;O&#39;), (&#39;are&#39;, &#39;O&#39;), (&#39;in&#39;, &#39;O&#39;),</span>
<span class="go">(&#39;NY&#39;, &#39;B-LOC&#39;), (&#39;,&#39;, &#39;O&#39;), (&#39;USA&#39;, &#39;B-LOC&#39;), (&#39;.&#39;, &#39;O&#39;)]</span>
</pre></div>
</div>
<dl class="class">
<dt id="nltk.tag.senna.SennaChunkTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.senna.</code><code class="sig-name descname">SennaChunkTagger</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">encoding='utf-8'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaChunkTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaChunkTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.classify.html#nltk.classify.senna.Senna" title="nltk.classify.senna.Senna"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.classify.senna.Senna</span></code></a></p>
<dl class="method">
<dt id="nltk.tag.senna.SennaChunkTagger.bio_to_chunks">
<code class="sig-name descname">bio_to_chunks</code><span class="sig-paren">(</span><em class="sig-param">tagged_sent</em>, <em class="sig-param">chunk_type</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaChunkTagger.bio_to_chunks"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaChunkTagger.bio_to_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts the chunks in a BIO chunk-tagged sentence.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">SennaChunkTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chktagger</span> <span class="o">=</span> <span class="n">SennaChunkTagger</span><span class="p">(</span><span class="s1">&#39;/usr/share/senna-v3.0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent</span> <span class="o">=</span> <span class="s1">&#39;What is the airspeed of an unladen swallow ?&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagged_sent</span> <span class="o">=</span> <span class="n">chktagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagged_sent</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;What&#39;, &#39;B-NP&#39;), (&#39;is&#39;, &#39;B-VP&#39;), (&#39;the&#39;, &#39;B-NP&#39;), (&#39;airspeed&#39;, &#39;I-NP&#39;),</span>
<span class="go">(&#39;of&#39;, &#39;B-PP&#39;), (&#39;an&#39;, &#39;B-NP&#39;), (&#39;unladen&#39;, &#39;I-NP&#39;), (&#39;swallow&#39;, &#39;I-NP&#39;),</span>
<span class="go">(&#39;?&#39;, &#39;O&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">chktagger</span><span class="o">.</span><span class="n">bio_to_chunks</span><span class="p">(</span><span class="n">tagged_sent</span><span class="p">,</span> <span class="n">chunk_type</span><span class="o">=</span><span class="s1">&#39;NP&#39;</span><span class="p">))</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;What&#39;, &#39;0&#39;), (&#39;the airspeed&#39;, &#39;2-3&#39;), (&#39;an unladen swallow&#39;, &#39;5-6-7&#39;)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tagged_sent</strong> (<em>str</em>) – A list of tuples of word and BIO chunk tag.</p></li>
<li><p><strong>tagged_sent</strong> – The chunk tag that users want to extract, e.g. ‘NP’ or ‘VP’</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An iterable of tuples of chunks that users want to extract
and their corresponding indices.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>iter(tuple(str))</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.senna.SennaChunkTagger.tag_sents">
<code class="sig-name descname">tag_sents</code><span class="sig-paren">(</span><em class="sig-param">sentences</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaChunkTagger.tag_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaChunkTagger.tag_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the tag method over a list of sentences. This method will return
for each sentence a list of tuples of (word, tag).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.senna.SennaNERTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.senna.</code><code class="sig-name descname">SennaNERTagger</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">encoding='utf-8'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaNERTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaNERTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.classify.html#nltk.classify.senna.Senna" title="nltk.classify.senna.Senna"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.classify.senna.Senna</span></code></a></p>
<dl class="method">
<dt id="nltk.tag.senna.SennaNERTagger.tag_sents">
<code class="sig-name descname">tag_sents</code><span class="sig-paren">(</span><em class="sig-param">sentences</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaNERTagger.tag_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaNERTagger.tag_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the tag method over a list of sentences. This method will return
for each sentence a list of tuples of (word, tag).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.senna.SennaTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.senna.</code><code class="sig-name descname">SennaTagger</code><span class="sig-paren">(</span><em class="sig-param">path</em>, <em class="sig-param">encoding='utf-8'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.classify.html#nltk.classify.senna.Senna" title="nltk.classify.senna.Senna"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.classify.senna.Senna</span></code></a></p>
<dl class="method">
<dt id="nltk.tag.senna.SennaTagger.tag_sents">
<code class="sig-name descname">tag_sents</code><span class="sig-paren">(</span><em class="sig-param">sentences</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#SennaTagger.tag_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.SennaTagger.tag_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the tag method over a list of sentences. This method will return
for each sentence a list of tuples of (word, tag).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.senna.setup_module">
<code class="sig-prename descclassname">nltk.tag.senna.</code><code class="sig-name descname">setup_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/senna.html#setup_module"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.senna.setup_module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.sequential">
<span id="nltk-tag-sequential-module"></span><h2>nltk.tag.sequential module<a class="headerlink" href="#module-nltk.tag.sequential" title="Permalink to this headline">¶</a></h2>
<p>Classes for tagging sentences sequentially, left to right.  The
abstract base class SequentialBackoffTagger serves as the base
class for all the taggers in this module.  Tagging of individual words
is performed by the method <code class="docutils literal notranslate"><span class="pre">choose_tag()</span></code>, which is defined by
subclasses of SequentialBackoffTagger.  If a tagger is unable to
determine a tag for the specified token, then its backoff tagger is
consulted instead.  Any SequentialBackoffTagger may serve as a
backoff tagger for any other SequentialBackoffTagger.</p>
<dl class="class">
<dt id="nltk.tag.sequential.AffixTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">AffixTagger</code><span class="sig-paren">(</span><em class="sig-param">train=None</em>, <em class="sig-param">model=None</em>, <em class="sig-param">affix_length=-3</em>, <em class="sig-param">min_stem_length=2</em>, <em class="sig-param">backoff=None</em>, <em class="sig-param">cutoff=0</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#AffixTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.AffixTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.ContextTagger" title="nltk.tag.sequential.ContextTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.ContextTagger</span></code></a></p>
<p>A tagger that chooses a token’s tag based on a leading or trailing
substring of its word string.  (It is important to note that these
substrings are not necessarily “true” morphological affixes).  In
particular, a fixed-length substring of the word is looked up in a
table, and the corresponding tag is returned.  Affix taggers are
typically constructed by training them on a tagged corpus.</p>
<p>Construct a new affix tagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>affix_length</strong> – The length of the affixes that should be
considered during training and tagging.  Use negative
numbers for suffixes.</p></li>
<li><p><strong>min_stem_length</strong> – Any words whose length is less than
min_stem_length+abs(affix_length) will be assigned a
tag of None by this tagger.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.AffixTagger.context">
<code class="sig-name descname">context</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#AffixTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.AffixTagger.context" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the context that should be used to look up the tag
for the specified token; or None if the specified token
should not be handled by this tagger.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(hashable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.AffixTagger.decode_json_obj">
<em class="property">classmethod </em><code class="sig-name descname">decode_json_obj</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#AffixTagger.decode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.AffixTagger.decode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.AffixTagger.encode_json_obj">
<code class="sig-name descname">encode_json_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#AffixTagger.encode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.AffixTagger.encode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.AffixTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.AffixTagger'</em><a class="headerlink" href="#nltk.tag.sequential.AffixTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.BigramTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">BigramTagger</code><span class="sig-paren">(</span><em class="sig-param">train=None</em>, <em class="sig-param">model=None</em>, <em class="sig-param">backoff=None</em>, <em class="sig-param">cutoff=0</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#BigramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.BigramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.NgramTagger" title="nltk.tag.sequential.NgramTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.NgramTagger</span></code></a></p>
<p>A tagger that chooses a token’s tag based its word string and on
the preceding words’ tag.  In particular, a tuple consisting
of the previous tag and the word is looked up in a table, and
the corresponding tag is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>tuple</em><em>(</em><em>str</em><em>, </em><em>str</em><em>)</em><em>)</em><em>)</em>) – The corpus of training data, a list of tagged sentences</p></li>
<li><p><strong>model</strong> (<em>dict</em>) – The tagger model</p></li>
<li><p><strong>backoff</strong> (<a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><em>TaggerI</em></a>) – Another tagger which this tagger will consult when it is
unable to tag a word</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – The number of instances of training data the tagger must see
in order not to use the backoff tagger</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="nltk.tag.sequential.BigramTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.BigramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.BigramTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.ClassifierBasedPOSTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">ClassifierBasedPOSTagger</code><span class="sig-paren">(</span><em class="sig-param">feature_detector=None</em>, <em class="sig-param">train=None</em>, <em class="sig-param">classifier_builder=&lt;bound method NaiveBayesClassifier.train of &lt;class 'nltk.classify.naivebayes.NaiveBayesClassifier'&gt;&gt;</em>, <em class="sig-param">classifier=None</em>, <em class="sig-param">backoff=None</em>, <em class="sig-param">cutoff_prob=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedPOSTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedPOSTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.ClassifierBasedTagger" title="nltk.tag.sequential.ClassifierBasedTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.ClassifierBasedTagger</span></code></a></p>
<p>A classifier based part of speech tagger.</p>
<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedPOSTagger.feature_detector">
<code class="sig-name descname">feature_detector</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedPOSTagger.feature_detector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedPOSTagger.feature_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the feature detector that this tagger uses to generate
featuresets for its classifier.  The feature detector is a
function with the signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">feature_detector</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">history</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">featureset</span>
</pre></div>
</div>
<p>See <code class="docutils literal notranslate"><span class="pre">classifier()</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.ClassifierBasedTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">ClassifierBasedTagger</code><span class="sig-paren">(</span><em class="sig-param">feature_detector=None</em>, <em class="sig-param">train=None</em>, <em class="sig-param">classifier_builder=&lt;bound method NaiveBayesClassifier.train of &lt;class 'nltk.classify.naivebayes.NaiveBayesClassifier'&gt;&gt;</em>, <em class="sig-param">classifier=None</em>, <em class="sig-param">backoff=None</em>, <em class="sig-param">cutoff_prob=None</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></code></a>, <a class="reference internal" href="#nltk.tag.api.FeaturesetTaggerI" title="nltk.tag.api.FeaturesetTaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.FeaturesetTaggerI</span></code></a></p>
<p>A sequential tagger that uses a classifier to choose the tag for
each token in a sentence.  The featureset input for the classifier
is generated by a feature detector function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">feature_detector</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">history</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">featureset</span>
</pre></div>
</div>
<p>Where tokens is the list of unlabeled tokens in the sentence;
index is the index of the token for which feature detection
should be performed; and history is list of the tags for all
tokens before index.</p>
<p>Construct a new classifier-based sequential tagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feature_detector</strong> – A function used to generate the
featureset input for the classifier::
feature_detector(tokens, index, history) -&gt; featureset</p></li>
<li><p><strong>train</strong> – A tagged corpus consisting of a list of tagged
sentences, where each sentence is a list of (word, tag) tuples.</p></li>
<li><p><strong>backoff</strong> – A backoff tagger, to be used by the new tagger
if it encounters an unknown context.</p></li>
<li><p><strong>classifier_builder</strong> – A function used to train a new
classifier based on the data in <em>train</em>.  It should take
one argument, a list of labeled featuresets (i.e.,
(featureset, label) tuples).</p></li>
<li><p><strong>classifier</strong> – The classifier that should be used by the
tagger.  This is only useful if you want to manually
construct the classifier; normally, you would use <em>train</em>
instead.</p></li>
<li><p><strong>backoff</strong> – A backoff tagger, used if this tagger is
unable to determine a tag for a given token.</p></li>
<li><p><strong>cutoff_prob</strong> – If specified, then this tagger will fall
back on its backoff tagger if the probability of the most
likely tag is less than <em>cutoff_prob</em>.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedTagger.choose_tag">
<code class="sig-name descname">choose_tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide which tag should be used for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, return None – do not consult
the backoff tagger.  This method should be overridden by
subclasses of SequentialBackoffTagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tokens</strong> (<em>list</em>) – The list of words that are being tagged.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The index of the word whose tag should be
returned.</p></li>
<li><p><strong>history</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – A list of the tags for all words before <em>index</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedTagger.classifier">
<code class="sig-name descname">classifier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger.classifier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger.classifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the classifier that this tagger uses to choose a tag
for each word in a sentence.  The input for this classifier is
generated using this tagger’s feature detector.
See <code class="docutils literal notranslate"><span class="pre">feature_detector()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ClassifierBasedTagger.feature_detector">
<code class="sig-name descname">feature_detector</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ClassifierBasedTagger.feature_detector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ClassifierBasedTagger.feature_detector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the feature detector that this tagger uses to generate
featuresets for its classifier.  The feature detector is a
function with the signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">feature_detector</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">history</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">featureset</span>
</pre></div>
</div>
<p>See <code class="docutils literal notranslate"><span class="pre">classifier()</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.ContextTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">ContextTagger</code><span class="sig-paren">(</span><em class="sig-param">context_to_tag</em>, <em class="sig-param">backoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></code></a></p>
<p>An abstract base class for sequential backoff taggers that choose
a tag for a token based on the value of its “context”.  Different
subclasses are used to define different contexts.</p>
<p>A ContextTagger chooses the tag for a token by calculating the
token’s context, and looking up the corresponding tag in a table.
This table can be constructed manually; or it can be automatically
constructed based on a training corpus, using the <code class="docutils literal notranslate"><span class="pre">_train()</span></code>
factory method.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>_context_to_tag</strong> – Dictionary mapping contexts to tags.</p>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.ContextTagger.choose_tag">
<code class="sig-name descname">choose_tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide which tag should be used for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, return None – do not consult
the backoff tagger.  This method should be overridden by
subclasses of SequentialBackoffTagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tokens</strong> (<em>list</em>) – The list of words that are being tagged.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The index of the word whose tag should be
returned.</p></li>
<li><p><strong>history</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – A list of the tags for all words before <em>index</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ContextTagger.context">
<em class="property">abstract </em><code class="sig-name descname">context</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger.context" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the context that should be used to look up the tag
for the specified token; or None if the specified token
should not be handled by this tagger.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(hashable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.ContextTagger.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#ContextTagger.size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.ContextTagger.size" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of entries in the table used by this
tagger to map from contexts to tags.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.DefaultTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">DefaultTagger</code><span class="sig-paren">(</span><em class="sig-param">tag</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#DefaultTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></code></a></p>
<p>A tagger that assigns the same tag to every token.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">DefaultTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">default_tagger</span> <span class="o">=</span> <span class="n">DefaultTagger</span><span class="p">(</span><span class="s1">&#39;NN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">default_tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;This is a test&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="go">[(&#39;This&#39;, &#39;NN&#39;), (&#39;is&#39;, &#39;NN&#39;), (&#39;a&#39;, &#39;NN&#39;), (&#39;test&#39;, &#39;NN&#39;)]</span>
</pre></div>
</div>
<p>This tagger is recommended as a backoff tagger, in cases where
a more powerful tagger is unable to assign a tag to the word
(e.g. because the word was not seen during training).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag</strong> (<em>str</em>) – The tag to assign to each token</p>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.DefaultTagger.choose_tag">
<code class="sig-name descname">choose_tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#DefaultTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide which tag should be used for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, return None – do not consult
the backoff tagger.  This method should be overridden by
subclasses of SequentialBackoffTagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tokens</strong> (<em>list</em>) – The list of words that are being tagged.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The index of the word whose tag should be
returned.</p></li>
<li><p><strong>history</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – A list of the tags for all words before <em>index</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.DefaultTagger.decode_json_obj">
<em class="property">classmethod </em><code class="sig-name descname">decode_json_obj</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#DefaultTagger.decode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger.decode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.DefaultTagger.encode_json_obj">
<code class="sig-name descname">encode_json_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#DefaultTagger.encode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger.encode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.DefaultTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.DefaultTagger'</em><a class="headerlink" href="#nltk.tag.sequential.DefaultTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.NgramTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">NgramTagger</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">train=None</em>, <em class="sig-param">model=None</em>, <em class="sig-param">backoff=None</em>, <em class="sig-param">cutoff=0</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#NgramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.NgramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.ContextTagger" title="nltk.tag.sequential.ContextTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.ContextTagger</span></code></a></p>
<p>A tagger that chooses a token’s tag based on its word string and
on the preceding n word’s tags.  In particular, a tuple
(tags[i-n:i-1], words[i]) is looked up in a table, and the
corresponding tag is returned.  N-gram taggers are typically
trained on a tagged corpus.</p>
<p>Train a new NgramTagger using the given training data or
the supplied model.  In particular, construct a new tagger
whose table maps from each context (tag[i-n:i-1], word[i])
to the most frequent tag for that context.  But exclude any
contexts that are already tagged perfectly by the backoff
tagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train</strong> – A tagged corpus consisting of a list of tagged
sentences, where each sentence is a list of (word, tag) tuples.</p></li>
<li><p><strong>backoff</strong> – A backoff tagger, to be used by the new
tagger if it encounters an unknown context.</p></li>
<li><p><strong>cutoff</strong> – If the most likely tag for a context occurs
fewer than <em>cutoff</em> times, then exclude it from the
context-to-tag table for the new tagger.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.NgramTagger.context">
<code class="sig-name descname">context</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#NgramTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.NgramTagger.context" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the context that should be used to look up the tag
for the specified token; or None if the specified token
should not be handled by this tagger.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(hashable)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.NgramTagger.decode_json_obj">
<em class="property">classmethod </em><code class="sig-name descname">decode_json_obj</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#NgramTagger.decode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.NgramTagger.decode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.NgramTagger.encode_json_obj">
<code class="sig-name descname">encode_json_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#NgramTagger.encode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.NgramTagger.encode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.NgramTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.NgramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.NgramTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.RegexpTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">RegexpTagger</code><span class="sig-paren">(</span><em class="sig-param">regexps</em>, <em class="sig-param">backoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#RegexpTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.SequentialBackoffTagger" title="nltk.tag.sequential.SequentialBackoffTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.SequentialBackoffTagger</span></code></a></p>
<p>Regular Expression Tagger</p>
<p>The RegexpTagger assigns tags to tokens by comparing their
word strings to a series of regular expressions.  The following tagger
uses word suffixes to make guesses about the correct Brown Corpus part
of speech tag:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">RegexpTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_sent</span> <span class="o">=</span> <span class="n">brown</span><span class="o">.</span><span class="n">sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s1">&#39;news&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regexp_tagger</span> <span class="o">=</span> <span class="n">RegexpTagger</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[(</span><span class="sa">r</span><span class="s1">&#39;^-?[0-9]+(.[0-9]+)?$&#39;</span><span class="p">,</span> <span class="s1">&#39;CD&#39;</span><span class="p">),</span>   <span class="c1"># cardinal numbers</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(The|the|A|a|An|an)$&#39;</span><span class="p">,</span> <span class="s1">&#39;AT&#39;</span><span class="p">),</span>   <span class="c1"># articles</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*able$&#39;</span><span class="p">,</span> <span class="s1">&#39;JJ&#39;</span><span class="p">),</span>                <span class="c1"># adjectives</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ness$&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">),</span>                <span class="c1"># nouns formed from adjectives</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ly$&#39;</span><span class="p">,</span> <span class="s1">&#39;RB&#39;</span><span class="p">),</span>                  <span class="c1"># adverbs</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*s$&#39;</span><span class="p">,</span> <span class="s1">&#39;NNS&#39;</span><span class="p">),</span>                  <span class="c1"># plural nouns</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ing$&#39;</span><span class="p">,</span> <span class="s1">&#39;VBG&#39;</span><span class="p">),</span>                <span class="c1"># gerunds</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*ed$&#39;</span><span class="p">,</span> <span class="s1">&#39;VBD&#39;</span><span class="p">),</span>                 <span class="c1"># past tense verbs</span>
<span class="gp">... </span>     <span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">)</span>                      <span class="c1"># nouns (default)</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regexp_tagger</span>
<span class="go">&lt;Regexp Tagger: size=9&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regexp_tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">test_sent</span><span class="p">)</span>
<span class="go">[(&#39;The&#39;, &#39;AT&#39;), (&#39;Fulton&#39;, &#39;NN&#39;), (&#39;County&#39;, &#39;NN&#39;), (&#39;Grand&#39;, &#39;NN&#39;), (&#39;Jury&#39;, &#39;NN&#39;),</span>
<span class="go">(&#39;said&#39;, &#39;NN&#39;), (&#39;Friday&#39;, &#39;NN&#39;), (&#39;an&#39;, &#39;AT&#39;), (&#39;investigation&#39;, &#39;NN&#39;), (&#39;of&#39;, &#39;NN&#39;),</span>
<span class="go">(&quot;Atlanta&#39;s&quot;, &#39;NNS&#39;), (&#39;recent&#39;, &#39;NN&#39;), (&#39;primary&#39;, &#39;NN&#39;), (&#39;election&#39;, &#39;NN&#39;),</span>
<span class="go">(&#39;produced&#39;, &#39;VBD&#39;), (&#39;``&#39;, &#39;NN&#39;), (&#39;no&#39;, &#39;NN&#39;), (&#39;evidence&#39;, &#39;NN&#39;), (&quot;&#39;&#39;&quot;, &#39;NN&#39;),</span>
<span class="go">(&#39;that&#39;, &#39;NN&#39;), (&#39;any&#39;, &#39;NN&#39;), (&#39;irregularities&#39;, &#39;NNS&#39;), (&#39;took&#39;, &#39;NN&#39;),</span>
<span class="go">(&#39;place&#39;, &#39;NN&#39;), (&#39;.&#39;, &#39;NN&#39;)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>regexps</strong> (<em>list</em><em>(</em><em>tuple</em><em>(</em><em>str</em><em>, </em><em>str</em><em>)</em><em>)</em>) – A list of <code class="docutils literal notranslate"><span class="pre">(regexp,</span> <span class="pre">tag)</span></code> pairs, each of
which indicates that a word matching <code class="docutils literal notranslate"><span class="pre">regexp</span></code> should
be tagged with <code class="docutils literal notranslate"><span class="pre">tag</span></code>.  The pairs will be evalutated in
order.  If none of the regexps match a word, then the
optional backoff tagger is invoked, else it is
assigned the tag None.</p>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.RegexpTagger.choose_tag">
<code class="sig-name descname">choose_tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#RegexpTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide which tag should be used for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, return None – do not consult
the backoff tagger.  This method should be overridden by
subclasses of SequentialBackoffTagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tokens</strong> (<em>list</em>) – The list of words that are being tagged.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The index of the word whose tag should be
returned.</p></li>
<li><p><strong>history</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – A list of the tags for all words before <em>index</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.RegexpTagger.decode_json_obj">
<em class="property">classmethod </em><code class="sig-name descname">decode_json_obj</code><span class="sig-paren">(</span><em class="sig-param">obj</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#RegexpTagger.decode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger.decode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.RegexpTagger.encode_json_obj">
<code class="sig-name descname">encode_json_obj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#RegexpTagger.encode_json_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger.encode_json_obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.RegexpTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.RegexpTagger'</em><a class="headerlink" href="#nltk.tag.sequential.RegexpTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.SequentialBackoffTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">SequentialBackoffTagger</code><span class="sig-paren">(</span><em class="sig-param">backoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>An abstract base class for taggers that tags words sequentially,
left to right.  Tagging of individual words is performed by the
<code class="docutils literal notranslate"><span class="pre">choose_tag()</span></code> method, which should be defined by subclasses.  If
a tagger is unable to determine a tag for the specified token,
then its backoff tagger is consulted.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><p><strong>_taggers</strong> – A list of all the taggers that should be tried to
tag a token (i.e., self and its backoff taggers).</p>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.backoff">
<em class="property">property </em><code class="sig-name descname">backoff</code><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.backoff" title="Permalink to this definition">¶</a></dt>
<dd><p>The backoff tagger for this tagger.</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.choose_tag">
<em class="property">abstract </em><code class="sig-name descname">choose_tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger.choose_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.choose_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Decide which tag should be used for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, return None – do not consult
the backoff tagger.  This method should be overridden by
subclasses of SequentialBackoffTagger.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tokens</strong> (<em>list</em>) – The list of words that are being tagged.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The index of the word whose tag should be
returned.</p></li>
<li><p><strong>history</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – A list of the tags for all words before <em>index</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the most appropriate tag sequence for the given
token sequence, and return a corresponding list of tagged
tokens.  A tagged token is encoded as a tuple <code class="docutils literal notranslate"><span class="pre">(token,</span> <span class="pre">tag)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(tuple(str, str))</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.sequential.SequentialBackoffTagger.tag_one">
<code class="sig-name descname">tag_one</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#SequentialBackoffTagger.tag_one"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.SequentialBackoffTagger.tag_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine an appropriate tag for the specified token, and
return that tag.  If this tagger is unable to determine a tag
for the specified token, then its backoff tagger is consulted.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>tokens</strong> (<em>list</em>) – The list of words that are being tagged.</p></li>
<li><p><strong>index</strong> (<em>int</em>) – The index of the word whose tag should be
returned.</p></li>
<li><p><strong>history</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – A list of the tags for all words before <em>index</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.TrigramTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">TrigramTagger</code><span class="sig-paren">(</span><em class="sig-param">train=None</em>, <em class="sig-param">model=None</em>, <em class="sig-param">backoff=None</em>, <em class="sig-param">cutoff=0</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#TrigramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.TrigramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.NgramTagger" title="nltk.tag.sequential.NgramTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.NgramTagger</span></code></a></p>
<p>A tagger that chooses a token’s tag based its word string and on
the preceding two words’ tags.  In particular, a tuple consisting
of the previous two tags and the word is looked up in a table, and
the corresponding tag is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>tuple</em><em>(</em><em>str</em><em>, </em><em>str</em><em>)</em><em>)</em><em>)</em>) – The corpus of training data, a list of tagged sentences</p></li>
<li><p><strong>model</strong> (<em>dict</em>) – The tagger model</p></li>
<li><p><strong>backoff</strong> (<a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><em>TaggerI</em></a>) – Another tagger which this tagger will consult when it is
unable to tag a word</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – The number of instances of training data the tagger must see
in order not to use the backoff tagger</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="nltk.tag.sequential.TrigramTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.TrigramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.TrigramTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.sequential.UnigramTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.sequential.</code><code class="sig-name descname">UnigramTagger</code><span class="sig-paren">(</span><em class="sig-param">train=None</em>, <em class="sig-param">model=None</em>, <em class="sig-param">backoff=None</em>, <em class="sig-param">cutoff=0</em>, <em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#UnigramTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.UnigramTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.sequential.NgramTagger" title="nltk.tag.sequential.NgramTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.NgramTagger</span></code></a></p>
<p>Unigram Tagger</p>
<p>The UnigramTagger finds the most likely tag for each word in a training
corpus, and then uses that information to assign tags to new tokens.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">UnigramTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_sent</span> <span class="o">=</span> <span class="n">brown</span><span class="o">.</span><span class="n">sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s1">&#39;news&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unigram_tagger</span> <span class="o">=</span> <span class="n">UnigramTagger</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s1">&#39;news&#39;</span><span class="p">)[:</span><span class="mi">500</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">tok</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">unigram_tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">test_sent</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">), &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span>
<span class="go">(The, AT), (Fulton, NP-TL), (County, NN-TL), (Grand, JJ-TL),</span>
<span class="go">(Jury, NN-TL), (said, VBD), (Friday, NR), (an, AT),</span>
<span class="go">(investigation, NN), (of, IN), (Atlanta&#39;s, NP$), (recent, JJ),</span>
<span class="go">(primary, NN), (election, NN), (produced, VBD), (``, ``),</span>
<span class="go">(no, AT), (evidence, NN), (&#39;&#39;, &#39;&#39;), (that, CS), (any, DTI),</span>
<span class="go">(irregularities, NNS), (took, VBD), (place, NN), (., .),</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>train</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>tuple</em><em>(</em><em>str</em><em>, </em><em>str</em><em>)</em><em>)</em><em>)</em>) – The corpus of training data, a list of tagged sentences</p></li>
<li><p><strong>model</strong> (<em>dict</em>) – The tagger model</p></li>
<li><p><strong>backoff</strong> (<a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><em>TaggerI</em></a>) – Another tagger which this tagger will consult when it is
unable to tag a word</p></li>
<li><p><strong>cutoff</strong> (<em>int</em>) – The number of instances of training data the tagger must see
in order not to use the backoff tagger</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="nltk.tag.sequential.UnigramTagger.context">
<code class="sig-name descname">context</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">index</em>, <em class="sig-param">history</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/sequential.html#UnigramTagger.context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.sequential.UnigramTagger.context" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the context that should be used to look up the tag
for the specified token; or None if the specified token
should not be handled by this tagger.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(hashable)</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="nltk.tag.sequential.UnigramTagger.json_tag">
<code class="sig-name descname">json_tag</code><em class="property"> = 'nltk.tag.sequential.UnigramTagger'</em><a class="headerlink" href="#nltk.tag.sequential.UnigramTagger.json_tag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.tag.stanford">
<span id="nltk-tag-stanford-module"></span><h2>nltk.tag.stanford module<a class="headerlink" href="#module-nltk.tag.stanford" title="Permalink to this headline">¶</a></h2>
<p>A module for interfacing with the Stanford taggers.</p>
<p>Tagger models need to be downloaded from <a class="reference external" href="https://nlp.stanford.edu/software">https://nlp.stanford.edu/software</a>
and the STANFORD_MODELS environment variable set (a colon-separated
list of paths).</p>
<p>For more details see the documentation for StanfordPOSTagger and StanfordNERTagger.</p>
<dl class="class">
<dt id="nltk.tag.stanford.StanfordNERTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.stanford.</code><code class="sig-name descname">StanfordNERTagger</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordNERTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordNERTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.stanford.StanfordTagger" title="nltk.tag.stanford.StanfordTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.stanford.StanfordTagger</span></code></a></p>
<p>A class for Named-Entity Tagging with Stanford Tagger. The input is the paths to:</p>
<ul class="simple">
<li><p>a model trained on training data</p></li>
<li><p>(optionally) the path to the stanford tagger jar file. If not specified here,
then this jar file must be specified in the CLASSPATH envinroment variable.</p></li>
<li><p>(optionally) the encoding of the training data (default: UTF-8)</p></li>
</ul>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">StanfordNERTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">StanfordNERTagger</span><span class="p">(</span><span class="s1">&#39;english.all.3class.distsim.crf.ser.gz&#39;</span><span class="p">)</span> <span class="c1"># doctest: +SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;Rami Eid is studying at Stony Brook University in NY&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;Rami&#39;, &#39;PERSON&#39;), (&#39;Eid&#39;, &#39;PERSON&#39;), (&#39;is&#39;, &#39;O&#39;), (&#39;studying&#39;, &#39;O&#39;),</span>
<span class="go"> (&#39;at&#39;, &#39;O&#39;), (&#39;Stony&#39;, &#39;ORGANIZATION&#39;), (&#39;Brook&#39;, &#39;ORGANIZATION&#39;),</span>
<span class="go"> (&#39;University&#39;, &#39;ORGANIZATION&#39;), (&#39;in&#39;, &#39;O&#39;), (&#39;NY&#39;, &#39;LOCATION&#39;)]</span>
</pre></div>
</div>
<dl class="method">
<dt id="nltk.tag.stanford.StanfordNERTagger.parse_output">
<code class="sig-name descname">parse_output</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">sentences</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordNERTagger.parse_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordNERTagger.parse_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="nltk.tag.stanford.StanfordPOSTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.stanford.</code><code class="sig-name descname">StanfordPOSTagger</code><span class="sig-paren">(</span><em class="sig-param">*args</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordPOSTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordPOSTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.stanford.StanfordTagger" title="nltk.tag.stanford.StanfordTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.stanford.StanfordTagger</span></code></a></p>
<dl class="simple">
<dt>A class for pos tagging with Stanford Tagger. The input is the paths to:</dt><dd><ul class="simple">
<li><p>a model trained on training data</p></li>
<li><p>(optionally) the path to the stanford tagger jar file. If not specified here,
then this jar file must be specified in the CLASSPATH envinroment variable.</p></li>
<li><p>(optionally) the encoding of the training data (default: UTF-8)</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">StanfordPOSTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span> <span class="o">=</span> <span class="n">StanfordPOSTagger</span><span class="p">(</span><span class="s1">&#39;english-bidirectional-distsim.tagger&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">st</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="s1">&#39;What is the airspeed of an unladen swallow ?&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">[(&#39;What&#39;, &#39;WP&#39;), (&#39;is&#39;, &#39;VBZ&#39;), (&#39;the&#39;, &#39;DT&#39;), (&#39;airspeed&#39;, &#39;NN&#39;), (&#39;of&#39;, &#39;IN&#39;), (&#39;an&#39;, &#39;DT&#39;), (&#39;unladen&#39;, &#39;JJ&#39;), (&#39;swallow&#39;, &#39;VB&#39;), (&#39;?&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="nltk.tag.stanford.StanfordTagger">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.stanford.</code><code class="sig-name descname">StanfordTagger</code><span class="sig-paren">(</span><em class="sig-param">model_filename</em>, <em class="sig-param">path_to_jar=None</em>, <em class="sig-param">encoding='utf8'</em>, <em class="sig-param">verbose=False</em>, <em class="sig-param">java_options='-mx1000m'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>An interface to Stanford taggers. Subclasses must define:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">_cmd</span></code> property: A property that returns the command that will be
executed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_SEPARATOR</span></code>: Class constant that represents that character that
is used to separate the tokens from their tags.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_JAR</span></code> file: Class constant that represents the jar file name.</p></li>
</ul>
<dl class="method">
<dt id="nltk.tag.stanford.StanfordTagger.parse_output">
<code class="sig-name descname">parse_output</code><span class="sig-paren">(</span><em class="sig-param">text</em>, <em class="sig-param">sentences=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger.parse_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger.parse_output" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nltk.tag.stanford.StanfordTagger.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the most appropriate tag sequence for the given
token sequence, and return a corresponding list of tagged
tokens.  A tagged token is encoded as a tuple <code class="docutils literal notranslate"><span class="pre">(token,</span> <span class="pre">tag)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(tuple(str, str))</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.stanford.StanfordTagger.tag_sents">
<code class="sig-name descname">tag_sents</code><span class="sig-paren">(</span><em class="sig-param">sentences</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#StanfordTagger.tag_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.StanfordTagger.tag_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply <code class="docutils literal notranslate"><span class="pre">self.tag()</span></code> to each element of <em>sentences</em>.  I.e.:</p>
<p>return [self.tag(sent) for sent in sentences]</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.stanford.setup_module">
<code class="sig-prename descclassname">nltk.tag.stanford.</code><code class="sig-name descname">setup_module</code><span class="sig-paren">(</span><em class="sig-param">module</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/stanford.html#setup_module"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.stanford.setup_module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.tnt">
<span id="nltk-tag-tnt-module"></span><h2>nltk.tag.tnt module<a class="headerlink" href="#module-nltk.tag.tnt" title="Permalink to this headline">¶</a></h2>
<p>Implementation of ‘TnT - A Statisical Part of Speech Tagger’
by Thorsten Brants</p>
<p><a class="reference external" href="http://acl.ldc.upenn.edu/A/A00/A00-1031.pdf">http://acl.ldc.upenn.edu/A/A00/A00-1031.pdf</a></p>
<dl class="class">
<dt id="nltk.tag.tnt.TnT">
<em class="property">class </em><code class="sig-prename descclassname">nltk.tag.tnt.</code><code class="sig-name descname">TnT</code><span class="sig-paren">(</span><em class="sig-param">unk=None</em>, <em class="sig-param">Trained=False</em>, <em class="sig-param">N=1000</em>, <em class="sig-param">C=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.tag.api.TaggerI" title="nltk.tag.api.TaggerI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.api.TaggerI</span></code></a></p>
<p>TnT - Statistical POS tagger</p>
<p>IMPORTANT NOTES:</p>
<ul class="simple">
<li><p>DOES NOT AUTOMATICALLY DEAL WITH UNSEEN WORDS</p>
<ul>
<li><p>It is possible to provide an untrained POS tagger to
create tags for unknown words, see __init__ function</p></li>
</ul>
</li>
<li><p>SHOULD BE USED WITH SENTENCE-DELIMITED INPUT</p>
<ul>
<li><p>Due to the nature of this tagger, it works best when
trained over sentence delimited input.</p></li>
<li><p>However it still produces good results if the training
data and testing data are separated on all punctuation eg: [,.?!]</p></li>
<li><p>Input for training is expected to be a list of sentences
where each sentence is a list of (word, tag) tuples</p></li>
<li><p>Input for tag function is a single sentence
Input for tagdata function is a list of sentences
Output is of a similar form</p></li>
</ul>
</li>
<li><p>Function provided to process text that is unsegmented</p>
<ul>
<li><p>Please see basic_sent_chop()</p></li>
</ul>
</li>
</ul>
<p>TnT uses a second order Markov model to produce tags for
a sequence of input, specifically:</p>
<blockquote>
<div><p>argmax [Proj(P(t_i|t_i-1,t_i-2)P(w_i|t_i))] P(t_T+1 | t_T)</p>
</div></blockquote>
<p>IE: the maximum projection of a set of probabilities</p>
<p>The set of possible tags for a given word is derived
from the training data. It is the set of all tags
that exact word has been assigned.</p>
<p>To speed up and get more precision, we can use log addition
to instead multiplication, specifically:</p>
<blockquote>
<div><dl class="simple">
<dt>argmax [Sigma(log(P(t_i|t_i-1,t_i-2))+log(P(w_i|t_i)))] +</dt><dd><p>log(P(t_T+1|t_T))</p>
</dd>
</dl>
</div></blockquote>
<p>The probability of a tag for a given word is the linear
interpolation of 3 markov models; a zero-order, first-order,
and a second order model.</p>
<blockquote>
<div><dl class="simple">
<dt>P(t_i| t_i-1, t_i-2) = l1*P(t_i) + l2*P(t_i| t_i-1) +</dt><dd><p>l3*P(t_i| t_i-1, t_i-2)</p>
</dd>
</dl>
</div></blockquote>
<p>A beam search is used to limit the memory usage of the algorithm.
The degree of the beam can be changed using N in the initialization.
N represents the maximum number of possible solutions to maintain
while tagging.</p>
<p>It is possible to differentiate the tags which are assigned to
capitalized words. However this does not result in a significant
gain in the accuracy of the results.</p>
<dl class="method">
<dt id="nltk.tag.tnt.TnT.tag">
<code class="sig-name descname">tag</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags a single sentence</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>[</em><em>string</em><em>,</em><em>]</em>) – list of words</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[(word, tag),]</p>
</dd>
</dl>
<p>Calls recursive function ‘_tagword’
to produce a list of tags</p>
<p>Associates the sequence of returned tags
with the correct words in the input sequence</p>
<p>returns a list of (word, tag) tuples</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.tnt.TnT.tagdata">
<code class="sig-name descname">tagdata</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT.tagdata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT.tagdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags each sentence in a list of sentences</p>
<p>:param <a class="reference external" href="data:list">data:list</a> of list of words
:type data: [[string,],]
:return: list of list of (word, tag) tuples</p>
<p>Invokes tag(sent) function for each sentence
compiles the results into a list of tagged sentences
each tagged sentence is a list of (word, tag) tuples</p>
</dd></dl>

<dl class="method">
<dt id="nltk.tag.tnt.TnT.train">
<code class="sig-name descname">train</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#TnT.train"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.TnT.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a set of tagged data to train the tagger.
If an unknown word tagger is specified,
it is trained on the same data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>tuple</em><em>(</em><em>str</em><em>)</em>) – List of lists of (word, tag) tuples</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.basic_sent_chop">
<code class="sig-prename descclassname">nltk.tag.tnt.</code><code class="sig-name descname">basic_sent_chop</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">raw=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#basic_sent_chop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.basic_sent_chop" title="Permalink to this definition">¶</a></dt>
<dd><p>Basic method for tokenizing input into sentences
for this tagger:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>str</em><em> or </em><em>tuple</em><em>(</em><em>str</em><em>, </em><em>str</em><em>)</em>) – list of tokens (words or (word, tag) tuples)</p></li>
<li><p><strong>raw</strong> (<em>bool</em>) – boolean flag marking the input data
as a list of words or a list of tagged words</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of sentences
sentences are a list of tokens
tokens are the same as the input</p>
</dd>
</dl>
<p>Function takes a list of tokens and separates the tokens into lists
where each list represents a sentence fragment
This function can separate both tagged and raw sequences into
basic sentences.</p>
<p>Sentence markers are the set of [,.!?]</p>
<p>This is a simple method which enhances the performance of the TnT
tagger. Better sentence tokenization will further enhance the results.</p>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.demo">
<code class="sig-prename descclassname">nltk.tag.tnt.</code><code class="sig-name descname">demo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#demo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.demo2">
<code class="sig-prename descclassname">nltk.tag.tnt.</code><code class="sig-name descname">demo2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#demo2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.demo2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nltk.tag.tnt.demo3">
<code class="sig-prename descclassname">nltk.tag.tnt.</code><code class="sig-name descname">demo3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/tnt.html#demo3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.tnt.demo3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.tag.util">
<span id="nltk-tag-util-module"></span><h2>nltk.tag.util module<a class="headerlink" href="#module-nltk.tag.util" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nltk.tag.util.str2tuple">
<code class="sig-prename descclassname">nltk.tag.util.</code><code class="sig-name descname">str2tuple</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">sep='/'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/util.html#str2tuple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.util.str2tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the string representation of a tagged token, return the
corresponding tuple representation.  The rightmost occurrence of
<em>sep</em> in <em>s</em> will be used to divide <em>s</em> into a word string and
a tag string.  If <em>sep</em> does not occur in <em>s</em>, return (s, None).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.util</span> <span class="kn">import</span> <span class="n">str2tuple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str2tuple</span><span class="p">(</span><span class="s1">&#39;fly/NN&#39;</span><span class="p">)</span>
<span class="go">(&#39;fly&#39;, &#39;NN&#39;)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<em>str</em>) – The string representation of a tagged token.</p></li>
<li><p><strong>sep</strong> (<em>str</em>) – The separator string used to separate word strings
from tags.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.util.tuple2str">
<code class="sig-prename descclassname">nltk.tag.util.</code><code class="sig-name descname">tuple2str</code><span class="sig-paren">(</span><em class="sig-param">tagged_token</em>, <em class="sig-param">sep='/'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/util.html#tuple2str"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.util.tuple2str" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the tuple representation of a tagged token, return the
corresponding string representation.  This representation is
formed by concatenating the token’s word string, followed by the
separator, followed by the token’s tag.  (If the tag is None,
then just return the bare word string.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.util</span> <span class="kn">import</span> <span class="n">tuple2str</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagged_token</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;fly&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tuple2str</span><span class="p">(</span><span class="n">tagged_token</span><span class="p">)</span>
<span class="go">&#39;fly/NN&#39;</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tagged_token</strong> (<em>tuple</em><em>(</em><em>str</em><em>, </em><em>str</em><em>)</em>) – The tuple representation of a tagged token.</p></li>
<li><p><strong>sep</strong> (<em>str</em>) – The separator string used to separate word strings
from tags.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.util.untag">
<code class="sig-prename descclassname">nltk.tag.util.</code><code class="sig-name descname">untag</code><span class="sig-paren">(</span><em class="sig-param">tagged_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag/util.html#untag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.util.untag" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a tagged sentence, return an untagged version of that
sentence.  I.e., return a list containing the first element
of each tuple in <em>tagged_sentence</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag.util</span> <span class="kn">import</span> <span class="n">untag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">untag</span><span class="p">([(</span><span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;NNP&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;saw&#39;</span><span class="p">,</span> <span class="s1">&#39;VBD&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Mary&#39;</span><span class="p">,</span> <span class="s1">&#39;NNP&#39;</span><span class="p">)])</span>
<span class="go">[&#39;John&#39;, &#39;saw&#39;, &#39;Mary&#39;]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-nltk.tag">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nltk.tag" title="Permalink to this headline">¶</a></h2>
<p>NLTK Taggers</p>
<p>This package contains classes and interfaces for part-of-speech
tagging, or simply “tagging”.</p>
<p>A “tag” is a case-sensitive string that specifies some property of a token,
such as its part of speech.  Tagged tokens are encoded as tuples
<code class="docutils literal notranslate"><span class="pre">(tag,</span> <span class="pre">token)</span></code>.  For example, the following tagged token combines
the word <code class="docutils literal notranslate"><span class="pre">'fly'</span></code> with a noun part of speech tag (<code class="docutils literal notranslate"><span class="pre">'NN'</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagged_tok</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;fly&#39;</span><span class="p">,</span> <span class="s1">&#39;NN&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>An off-the-shelf tagger is available for English. It uses the Penn Treebank tagset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk</span> <span class="kn">import</span> <span class="n">pos_tag</span><span class="p">,</span> <span class="n">word_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_tag</span><span class="p">(</span><span class="n">word_tokenize</span><span class="p">(</span><span class="s2">&quot;John&#39;s big idea isn&#39;t all that bad.&quot;</span><span class="p">))</span>
<span class="go">[(&#39;John&#39;, &#39;NNP&#39;), (&quot;&#39;s&quot;, &#39;POS&#39;), (&#39;big&#39;, &#39;JJ&#39;), (&#39;idea&#39;, &#39;NN&#39;), (&#39;is&#39;, &#39;VBZ&#39;),</span>
<span class="go">(&quot;n&#39;t&quot;, &#39;RB&#39;), (&#39;all&#39;, &#39;PDT&#39;), (&#39;that&#39;, &#39;DT&#39;), (&#39;bad&#39;, &#39;JJ&#39;), (&#39;.&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
<p>A Russian tagger is also available if you specify lang=”rus”. It uses
the Russian National Corpus tagset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos_tag</span><span class="p">(</span><span class="n">word_tokenize</span><span class="p">(</span><span class="s2">&quot;Илья оторопел и дважды перечитал бумажку.&quot;</span><span class="p">),</span> <span class="n">lang</span><span class="o">=</span><span class="s1">&#39;rus&#39;</span><span class="p">)</span>    <span class="c1"># doctest: +SKIP</span>
<span class="go">[(&#39;Илья&#39;, &#39;S&#39;), (&#39;оторопел&#39;, &#39;V&#39;), (&#39;и&#39;, &#39;CONJ&#39;), (&#39;дважды&#39;, &#39;ADV&#39;), (&#39;перечитал&#39;, &#39;V&#39;),</span>
<span class="go">(&#39;бумажку&#39;, &#39;S&#39;), (&#39;.&#39;, &#39;NONLEX&#39;)]</span>
</pre></div>
</div>
<p>This package defines several taggers, which take a list of tokens,
assign a tag to each one, and return the resulting list of tagged tokens.
Most of the taggers are built automatically based on a training corpus.
For example, the unigram tagger tags each word <em>w</em> by checking what
the most frequent tag for <em>w</em> was in a training corpus:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">brown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">UnigramTagger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span> <span class="o">=</span> <span class="n">UnigramTagger</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s1">&#39;news&#39;</span><span class="p">)[:</span><span class="mi">500</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mitchell&#39;</span><span class="p">,</span> <span class="s1">&#39;decried&#39;</span><span class="p">,</span> <span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="s1">&#39;rate&#39;</span><span class="p">,</span> <span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="s1">&#39;unemployment&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">tagger</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">sent</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
<span class="go">Mitchell -&gt; NP</span>
<span class="go">decried -&gt; None</span>
<span class="go">the -&gt; AT</span>
<span class="go">high -&gt; JJ</span>
<span class="go">rate -&gt; NN</span>
<span class="go">of -&gt; IN</span>
<span class="go">unemployment -&gt; None</span>
</pre></div>
</div>
<p>Note that words that the tagger has not seen during training receive a tag
of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>We evaluate a tagger on data that was not seen during training:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tagger</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">brown</span><span class="o">.</span><span class="n">tagged_sents</span><span class="p">(</span><span class="n">categories</span><span class="o">=</span><span class="s1">&#39;news&#39;</span><span class="p">)[</span><span class="mi">500</span><span class="p">:</span><span class="mi">600</span><span class="p">])</span>
<span class="go">0.73...</span>
</pre></div>
</div>
<p>For more information, please consult chapter 5 of the NLTK Book.</p>
<dl class="function">
<dt id="nltk.tag.pos_tag">
<code class="sig-prename descclassname">nltk.tag.</code><code class="sig-name descname">pos_tag</code><span class="sig-paren">(</span><em class="sig-param">tokens</em>, <em class="sig-param">tagset=None</em>, <em class="sig-param">lang='eng'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag.html#pos_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.pos_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK’s currently recommended part of speech tagger to
tag the given list of tokens.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tag</span> <span class="kn">import</span> <span class="n">pos_tag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">word_tokenize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_tag</span><span class="p">(</span><span class="n">word_tokenize</span><span class="p">(</span><span class="s2">&quot;John&#39;s big idea isn&#39;t all that bad.&quot;</span><span class="p">))</span>
<span class="go">[(&#39;John&#39;, &#39;NNP&#39;), (&quot;&#39;s&quot;, &#39;POS&#39;), (&#39;big&#39;, &#39;JJ&#39;), (&#39;idea&#39;, &#39;NN&#39;), (&#39;is&#39;, &#39;VBZ&#39;),</span>
<span class="go">(&quot;n&#39;t&quot;, &#39;RB&#39;), (&#39;all&#39;, &#39;PDT&#39;), (&#39;that&#39;, &#39;DT&#39;), (&#39;bad&#39;, &#39;JJ&#39;), (&#39;.&#39;, &#39;.&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos_tag</span><span class="p">(</span><span class="n">word_tokenize</span><span class="p">(</span><span class="s2">&quot;John&#39;s big idea isn&#39;t all that bad.&quot;</span><span class="p">),</span> <span class="n">tagset</span><span class="o">=</span><span class="s1">&#39;universal&#39;</span><span class="p">)</span>
<span class="go">[(&#39;John&#39;, &#39;NOUN&#39;), (&quot;&#39;s&quot;, &#39;PRT&#39;), (&#39;big&#39;, &#39;ADJ&#39;), (&#39;idea&#39;, &#39;NOUN&#39;), (&#39;is&#39;, &#39;VERB&#39;),</span>
<span class="go">(&quot;n&#39;t&quot;, &#39;ADV&#39;), (&#39;all&#39;, &#39;DET&#39;), (&#39;that&#39;, &#39;DET&#39;), (&#39;bad&#39;, &#39;ADJ&#39;), (&#39;.&#39;, &#39;.&#39;)]</span>
</pre></div>
</div>
<p>NB. Use <cite>pos_tag_sents()</cite> for efficient tagging of more than one sentence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tokens</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – Sequence of tokens to be tagged</p></li>
<li><p><strong>tagset</strong> (<em>str</em>) – the tagset to be used, e.g. universal, wsj, brown</p></li>
<li><p><strong>lang</strong> (<em>str</em>) – the ISO 639 code of the language, e.g. ‘eng’ for English, ‘rus’ for Russian</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tagged tokens</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(tuple(str, str))</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nltk.tag.pos_tag_sents">
<code class="sig-prename descclassname">nltk.tag.</code><code class="sig-name descname">pos_tag_sents</code><span class="sig-paren">(</span><em class="sig-param">sentences</em>, <em class="sig-param">tagset=None</em>, <em class="sig-param">lang='eng'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/tag.html#pos_tag_sents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nltk.tag.pos_tag_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK’s currently recommended part of speech tagger to tag the
given list of sentences, each consisting of a list of tokens.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sentences</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>str</em><em>)</em><em>)</em>) – List of sentences to be tagged</p></li>
<li><p><strong>tagset</strong> (<em>str</em>) – the tagset to be used, e.g. universal, wsj, brown</p></li>
<li><p><strong>lang</strong> (<em>str</em>) – the ISO 639 code of the language, e.g. ‘eng’ for English, ‘rus’ for Russian</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The list of tagged sentences</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(list(tuple(str, str)))</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
            </form>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="nltk.stem.html" title="nltk.stem package"
              >previous</a> |
            <a href="nltk.test.html" title="nltk.test package"
              >next</a> |
            <a href="../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
              <br/>
              <a href="../_sources/api/nltk.tag.rst.txt"
                rel="nofollow">Show Source</a>
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, NLTK Project.
      Last updated on Mar 08, 2020.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>