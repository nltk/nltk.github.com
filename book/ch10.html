<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.15: http://docutils.sourceforge.net/" />
<title>10. Analyzing the Meaning of Sentences</title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}
table pre span {
  white-space: pre-wrap;
}
table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document" id="analyzing-the-meaning-of-sentences">
<span id="chap-semantics"></span>
<h1 class="title">10. Analyzing the Meaning of Sentences</h1>

<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<!-- standard global imports

>>> import nltk, re, pprint -->
<!-- try not to increment the variable indexes

>>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<!-- TO-DO:
* we are using lc feature names here, but capitalized ones in ch09! :-(
* use capitalized proper names in DRSs? -->
<p>We have seen how useful it is to harness the power of a computer to
process text on a large scale.  However, now that we have the
machinery of parsers and feature based grammars, can we do anything
similarly useful by analyzing the meaning of sentences?
The goal of this chapter is to answer the following questions:</p>
<ol class="arabic simple">
<li>How can we represent natural language meaning so that a computer
can process these representations?</li>
<li>How can we associate meaning representations with an
unlimited set of sentences?</li>
<li>How can we use programs that connect the meaning representations of sentences to
stores of knowledge?</li>
</ol>
<p>Along the way we will learn some formal techniques in the field of logical semantics,
and see how these can be used for interrogating databases that store facts
about the world.</p>
<div class="section" id="natural-language-understanding">
<span id="sec-nlu-introduction"></span><h1>1&nbsp;&nbsp;&nbsp;Natural Language Understanding</h1>
<div class="section" id="querying-a-database">
<h2>1.1&nbsp;&nbsp;&nbsp;Querying a Database</h2>
<p>Suppose we have a program that lets us type in a natural language question and gives
us back the right answer:</p>
<span class="target" id="ex-dbq0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><span class="target" id="ex-dbq01"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Which country is Athens in?</td></tr></table></p>
<span class="target" id="ex-dbq02"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Greece.</td></tr></table></p>
</td></tr></table></p>
<p>How hard is it to write such a program? And can we just use the same techniques that
we've encountered so far in this book, or does it involve something new?
In this section, we will show that solving the task in a restricted domain is pretty
straightforward. But we will also see that to address the problem in a more
general way, we have to open up a whole new box of ideas and techniques, involving the
representation of meaning.</p>
<p>So let's start off by assuming that we have data about cities and
countries in a structured form. To be concrete, we will use a database
table whose first few rows are shown in <a class="reference internal" href="#tab-cities">1.1</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The data illustrated in <a class="reference internal" href="#tab-cities">1.1</a> is drawn from the Chat-80 system
<a class="reference external" href="bibliography.html#warren1982eea" id="id1">(Warren &amp; Pereira, 1982)</a>.  Population figures are given in thousands,
but note that the data used in these examples dates back at least
to the 1980s, and was already somewhat out of date at the point
when <a class="reference external" href="bibliography.html#warren1982eea" id="id2">(Warren &amp; Pereira, 1982)</a> was published.</p>
</div>
<span class="target" id="tab-cities"></span><table border="1" class="docutils" id="tab-cities">
<colgroup>
<col width="32%" />
<col width="38%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">City</th>
<th class="head">Country</th>
<th class="head">Population</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>athens</td>
<td>greece</td>
<td>1368</td>
</tr>
<tr><td>bangkok</td>
<td>thailand</td>
<td>1178</td>
</tr>
<tr><td>barcelona</td>
<td>spain</td>
<td>1280</td>
</tr>
<tr><td>berlin</td>
<td>east_germany</td>
<td>3481</td>
</tr>
<tr><td>birmingham</td>
<td>united_kingdom</td>
<td>1112</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 1.1</span>: <p><tt class="doctest"><span class="pre">city_table</span></tt>: A table of cities, countries and populations</p>
</p>
</table>
<p>The obvious way to retrieve answers from this tabular data involves
writing queries in a database query language such as SQL.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">SQL (Structured Query Language) is a language designed for
retrieving and managing data in relational databases.
If you want to find out more about SQL,
<tt class="doctest"><span class="pre">http://www.w3schools.com/sql/</span></tt> is a convenient online
reference.</p>
</div>
<p>For example, executing the query <a class="reference internal" href="#ex-dbq1">(2)</a> will pull out the value <tt class="doctest"><span class="pre"><span class="pysrc-string">'greece'</span></span></tt>:</p>
<span class="target" id="ex-dbq1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(2)</td><td width="15"></td><td><tt class="doctest"><span class="pre">SELECT Country FROM city_table WHERE City = <span class="pysrc-string">'athens'</span></span></tt></td></tr></table></p>
<p>This specifies a result set consisting of all values for the column
<tt class="doctest"><span class="pre">Country</span></tt> in data rows where the value of the <tt class="doctest"><span class="pre">City</span></tt> column is
<tt class="doctest"><span class="pre"><span class="pysrc-string">'athens'</span></span></tt>.</p>
<p>How can we get the same effect using English as our input to the query
system? The feature-based grammar formalism described in
<a class="reference external" href="ch09.html#chap-featgram">9.</a> makes it easy to translate from
English to SQL. The grammar <tt class="doctest"><span class="pre">sql0.fcfg</span></tt> illustrates how to assemble
a meaning representation for a sentence in tandem with parsing the
sentence. Each phrase structure rule is supplemented with a recipe for
constructing a value for the feature <tt class="doctest"><span class="pre">sem</span></tt>. You can see that these
recipes are extremely simple; in each case, we use the string
concatenation operation <tt class="doctest"><span class="pre">+</span></tt> to splice
the values for the child constituents to make a value for the
parent constituent.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.data.show_cfg(<span class="pysrc-string">'grammars/book_grammars/sql0.fcfg'</span>)
<span class="pysrc-output">% start S</span>
<span class="pysrc-output">S[SEM=(?np + WHERE + ?vp)] -&gt; NP[SEM=?np] VP[SEM=?vp]</span>
<span class="pysrc-output">VP[SEM=(?v + ?pp)] -&gt; IV[SEM=?v] PP[SEM=?pp]</span>
<span class="pysrc-output">VP[SEM=(?v + ?ap)] -&gt; IV[SEM=?v] AP[SEM=?ap]</span>
<span class="pysrc-output">NP[SEM=(?det + ?n)] -&gt; Det[SEM=?det] N[SEM=?n]</span>
<span class="pysrc-output">PP[SEM=(?p + ?np)] -&gt; P[SEM=?p] NP[SEM=?np]</span>
<span class="pysrc-output">AP[SEM=?pp] -&gt; A[SEM=?a] PP[SEM=?pp]</span>
<span class="pysrc-output">NP[SEM='Country=&quot;greece&quot;'] -&gt; 'Greece'</span>
<span class="pysrc-output">NP[SEM='Country=&quot;china&quot;'] -&gt; 'China'</span>
<span class="pysrc-output">Det[SEM='SELECT'] -&gt; 'Which' | 'What'</span>
<span class="pysrc-output">N[SEM='City FROM city_table'] -&gt; 'cities'</span>
<span class="pysrc-output">IV[SEM=''] -&gt; 'are'</span>
<span class="pysrc-output">A[SEM=''] -&gt; 'located'</span>
<span class="pysrc-output">P[SEM=''] -&gt; 'in'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This allows us to parse a query into SQL.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk <span class="pysrc-keyword">import</span> load_parser
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = load_parser(<span class="pysrc-string">'grammars/book_grammars/sql0.fcfg'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>query = <span class="pysrc-string">'What cities are located in China'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = list(cp.parse(query.split()))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>answer = trees[0].label()[<span class="pysrc-string">'SEM'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>answer = [s <span class="pysrc-keyword">for</span> s <span class="pysrc-keyword">in</span> answer <span class="pysrc-keyword">if</span> s]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>q = <span class="pysrc-string">' '</span>.join(answer)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(q)
<span class="pysrc-output">SELECT City FROM city_table WHERE Country=&quot;china&quot;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Run the parser with maximum tracing on, i.e.,
<tt class="doctest"><span class="pre">cp = load_parser(<span class="pysrc-string">'grammars/book_grammars/sql0.fcfg'</span>, trace=3)</span></tt>, and examine
how the values of <tt class="doctest"><span class="pre">sem</span></tt> are built up as complete edges are added
to the chart.</p>
</div>
<p>Finally, we execute the query over the database <tt class="doctest"><span class="pre">city.db</span></tt> and
retrieve some results.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.sem <span class="pysrc-keyword">import</span> chat80
<span class="pysrc-prompt">&gt;&gt;&gt; </span>rows = chat80.sql_query(<span class="pysrc-string">'corpora/city_database/city.db'</span>, q)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> r <span class="pysrc-keyword">in</span> rows: <span class="pysrc-keyword">print</span>(r[0], end=<span class="pysrc-string">&quot; &quot;</span>) <a name="tuple-val" /><a href="#ref-tuple-val"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">canton chungking dairen harbin kowloon mukden peking shanghai sian tientsin</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Since each row <tt class="doctest"><span class="pre">r</span></tt> is a one-element tuple, we print out the member of
the tuple rather than tuple itself <a class="reference internal" href="#tuple-val"><span id="ref-tuple-val"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.</p>
<p>To summarize, we have defined a task where the computer returns useful data
in response to a natural language query, and we implemented this
by translating a small subset of English into SQL. We can say that
our NLTK code already &quot;understands&quot; SQL, given that Python is
able to execute SQL queries against a database, and by extension it also &quot;understands&quot;
queries such as <span class="example">What cities are located in China</span>. This parallels
being able to translate from Dutch into English as an example of
natural language understanding.
Suppose that you are a native speaker of English, and have started to
learn Dutch. Your teacher asks if you understand what <a class="reference internal" href="#ex-sem1">(3)</a> means:</p>
<span class="target" id="ex-sem1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(3)</td><td width="15"></td><td>Margrietje houdt van Brunoke.</td></tr></table></p>
<p>If you know the meanings of the individual words in <a class="reference internal" href="#ex-sem1">(3)</a>, and know
how these meanings are combined to make up the meaning of the whole
sentence, you might say that <a class="reference internal" href="#ex-sem1">(3)</a> means the same as <span class="example">Margrietje loves
Brunoke</span></p>
<p>An observer &#8212; let's call her Olga &#8212; might well take
this as evidence that you do grasp the meaning of <a class="reference internal" href="#ex-sem1">(3)</a>. But this
would depend on Olga herself understanding English. If she doesn't,
then your translation from Dutch to English is not going to convince
her of your ability to understand Dutch. We will return to this issue shortly.</p>
<p>The grammar <tt class="doctest"><span class="pre">sql0.fcfg</span></tt>, together with the NLTK Earley parser, is
instrumental in carrying out the translation from English to SQL. How adequate is this
grammar? You saw that the SQL translation for the whole sentence was
built up from the translations of the components. However, there does
not seem to be a lot of justification for these component meaning
representations. For example, if we look at the analysis of the
noun phrase <span class="example">Which cities</span>, the determiner and noun correspond
respectively to the SQL fragments <tt class="doctest"><span class="pre">SELECT</span></tt> and <tt class="doctest"><span class="pre">City FROM
city_table</span></tt>. But neither of
these have a well-defined meaning in isolation from the other.</p>
<p>There is another criticism we can level at the grammar: we have
&quot;hard-wired&quot; an embarrassing amount of detail about the database into
it.  We need to know the name of the relevant table (e.g.,
<tt class="doctest"><span class="pre">city_table</span></tt>) and the names of the fields. But our database could
have contained exactly the same rows of data yet used a different
table name and different field names, in which case the SQL queries
would not be executable. Equally, we could have stored our data in a
different format, such as XML, in which case retrieving the same
results would require us to translate our English queries into an XML
query language rather than SQL. These considerations suggest that we
should be translating English into something that is more abstract and
generic than SQL.</p>
<p>In order to sharpen the point, let's consider another English query
and its translation:</p>
<span class="target" id="ex-dbq2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(4)</td><td width="15"></td><td><span class="target" id="ex-dbq21"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>What cities are in China and have populations above 1,000,000?</td></tr></table></p>
<span class="target" id="ex-dbq22"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">SELECT City FROM city_table WHERE Country = <span class="pysrc-string">'china'</span> AND
Population &gt; 1000</span></tt></td></tr></table></p>
</td></tr></table></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>Your Turn:</strong>
Extend the grammar <tt class="doctest"><span class="pre">sql0.fcfg</span></tt> so that it will translate
<a class="reference internal" href="#ex-dbq21">(4a)</a> into <a class="reference internal" href="#ex-dbq22">(4b)</a>, and check the values returned by
the query.</p>
<p class="last">You will probably find it easiest to first extend the grammar to
handle queries like <span class="example">What cities have populations above
1,000,000</span> before tackling conjunction. After you have had a go
at this task, you can compare your solution to <tt class="doctest"><span class="pre">grammars/book_grammars/sql1.fcfg</span></tt> in
the NLTK data distribution.</p>
</div>
<p>Observe that the <span class="example">and</span> conjunction in <a class="reference internal" href="#ex-dbq21">(4a)</a> is translated
into an <tt class="doctest"><span class="pre">AND</span></tt> in the SQL counterpart, <a class="reference internal" href="#ex-dbq22">(4b)</a>. The latter tells us
to select results from rows where two conditions are true
together: the value of the <tt class="doctest"><span class="pre">Country</span></tt> column is <tt class="doctest"><span class="pre"><span class="pysrc-string">'china'</span></span></tt> and the
value of the <tt class="doctest"><span class="pre">Population</span></tt> column is greater than 1000.
This interpretation for <span class="example">and</span> involves a new idea: it talks about
<span class="emphasis">what is true in some particular situation</span>, and tells us that
<tt class="doctest"><span class="pre">Cond1 AND Cond2</span></tt> is true in situation <em>s</em> just in case that
condition <tt class="doctest"><span class="pre">Cond1</span></tt> is true in <em>s</em> and condition <tt class="doctest"><span class="pre">Cond2</span></tt> is true in
<em>s</em>. Although this doesn't account for the full range of
meanings of <span class="example">and</span> in English, it has the nice property that it is
independent of any query language. In fact, we have given it the
standard interpretation from classical logic. In the following
sections, we will explore an approach in which sentences of natural
language are translated into logic instead of an executable query
language such as SQL. One advantage of logical formalisms is that they
are more abstract
and therefore more generic. If we wanted to, once we had our
translation into logic, we could then translate it into various other
special-purpose languages. In fact, most serious attempts to query
databases via natural language have used this methodology.</p>
</div>
<div class="section" id="natural-language-semantics-and-logic">
<h2>1.2&nbsp;&nbsp;&nbsp;Natural Language, Semantics and Logic</h2>
<p>We started out trying to capture the meaning of <a class="reference internal" href="#ex-dbq01">(1a)</a> by translating it into a
query in another language, SQL, which the computer could interpret and execute. But
this still begged the question whether the translation was correct. Stepping back
from database query, we noted that the meaning of <span class="example">and</span> seems to depend on being
able to specify when statements are true or not in a particular situation. Instead of
translating a sentence <em>S</em> from one language to another, we try to say what <em>S</em> is
<span class="emphasis">about</span> by relating it to a situation in the world. Let's pursue this
further. Imagine there is a situation <em>s</em> where there are two entities, Margrietje
and her favourite doll, Brunoke. In addition, there is a relation holding between the
two entities, which we will call the <em>love</em> relation. If you understand the meaning
of <a class="reference internal" href="#ex-sem1">(3)</a>, then you know that it is true in situation <em>s</em>. In part, you know this
because you know that <span class="example">Margrietje</span> refers to Margrietje, <span class="example">Brunoke</span> refers to
Brunoke, and <span class="example">houdt van</span> refers to the <em>love</em> relation.</p>
<p>We have introduced two
fundamental notions in semantics. The
first is that declarative sentences are <span class="emphasis">true or false in certain situations</span>.
The second is that definite noun phrases and proper nouns <span class="emphasis">refer to things
in the world</span>. So <a class="reference internal" href="#ex-sem1">(3)</a>
is true in a situation where Margrietje loves the doll Brunoke,
here illustrated in <a class="reference internal" href="#fig-mimo-and-bruno">1.1</a>.</p>
<span class="target" id="fig-mimo-and-bruno"></span><div class="figure" id="fig-mimo-and-bruno">
<img alt="../images/mimo-and-bruno.png" src="../images/mimo-and-bruno.png" style="width: 540.0px; height: 355.0px;" />
<p class="caption"><span class="caption-label">Figure 1.1</span>: Depiction of a situation in which Margrietje loves Brunoke.</p>
</div>
<p>Once we have adopted the notion of truth in a situation, we have a
powerful tool for reasoning.  In particular, we can look at
sets of sentences, and ask whether they could be true together in some
situation. For example, the sentences in <a class="reference internal" href="#ex-cons1">(5)</a> can be both true,
while those in <a class="reference internal" href="#ex-cons2">(6)</a> and  <a class="reference internal" href="#ex-cons3">(7)</a> cannot be. In other words, the sentences in
<a class="reference internal" href="#ex-cons1">(5)</a> are <a name="consistent_index_term" /><span class="termdef">consistent</span>, while those in <a class="reference internal" href="#ex-cons2">(6)</a> and <a class="reference internal" href="#ex-cons3">(7)</a> are
<a name="inconsistent_index_term" /><span class="termdef">inconsistent</span>.</p>
<span class="target" id="ex-cons1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(5)</td><td width="15"></td><td><span class="target" id="ex-cons11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Sylvania is to the north of Freedonia.</td></tr></table></p>
<span class="target" id="ex-cons12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Freedonia is a republic.</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-cons2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(6)</td><td width="15"></td><td><span class="target" id="ex-cons21"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The capital of Freedonia has a population of 9,000.</td></tr></table></p>
<span class="target" id="ex-cons22"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>No city in Freedonia has a population of 9,000.</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-cons3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(7)</td><td width="15"></td><td><span class="target" id="ex-cons31"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Sylvania is to the north of Freedonia.</td></tr></table></p>
<span class="target" id="ex-cons32"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Freedonia is to the north of Sylvania.</td></tr></table></p>
</td></tr></table></p>
<p>We have chosen sentences about fictional countries (featured in the
Marx Brothers' 1933 movie <em>Duck Soup</em>) to emphasize that your ability
to reason about these examples does not depend on what is true
or false in the actual world. If you know the meaning of the word <span class="example">no</span>, and
also know that the capital of a country is a city in that country, then you
should be able to conclude that the two sentences in <a class="reference internal" href="#ex-cons2">(6)</a> are
inconsistent, regardless of where Freedonia is or what the population
of its capital is. That is, there's no possible situation in which
both sentences could be true. Similarly, if you know that the relation
expressed by <span class="example">to the north of</span> is asymmetric, then you should be
able to conclude that the two sentences in <a class="reference internal" href="#ex-cons3">(7)</a> are inconsistent.</p>
<p>Broadly speaking, logic-based approaches to natural language semantics
focus on those aspects of natural language which guide our
judgments of consistency and inconsistency. The syntax of a logical
language is designed to make these features formally explicit. As a
result, determining properties like consistency can often be reduced
to symbolic manipulation, that is, to a task that can be carried out
by a computer. In order to pursue this approach, we first want to
develop a technique for representing a possible situation. We do this
in terms of something that logicians call a model.</p>
<!-- XXX is "sentence" being used with it linguistic or logical meaning?
(The ambiguity is probably harmless.) -->
<p>A <a name="model_index_term" /><span class="termdef">model</span> for a set <em>W</em> of sentences is a formal
representation of a situation in which all the sentences in <em>W</em>
are true. The usual way of representing models involves set theory. The domain
<em>D</em> of discourse (all the entities we currently care about) is a set of
individuals, while relations are treated as
sets built up from <em>D</em>. Let's look at a concrete example. Our domain
<em>D</em> will consist of three
children, Stefan, Klaus and Evi, represented respectively as <tt class="doctest"><span class="pre">s</span></tt>,
<tt class="doctest"><span class="pre">k</span></tt> and <tt class="doctest"><span class="pre">e</span></tt>. We write this as <em>D</em> = <tt class="doctest"><span class="pre">{s, k, e}</span></tt>. The expression <span class="example">boy</span> denotes the
set consisting of Stefan and Klaus, the expression <span class="example">girl</span> denotes the
set consisting of Evi, and the expression <span class="example">is running</span> denotes the
set consisting of Stefan and Evi. <a class="reference internal" href="#fig-model-kids">1.2</a> is a graphical
rendering of the model.</p>
<span class="target" id="fig-model-kids"></span><div class="figure" id="fig-model-kids">
<img alt="../images/model_kids.png" src="../images/model_kids.png" style="width: 385.0px; height: 328.40000000000003px;" />
<p class="caption"><span class="caption-label">Figure 1.2</span>: Diagram of a model containing a domain <em>D</em> and subsets of <em>D</em>
corresponding to the predicates <span class="math">boy</span>, <span class="math">girl</span> and <span class="math">is
running</span>.</p>
</div>
<p>Later in this chapter we will use models to help evaluate the truth or falsity of
English sentences, and in this way to illustrate some methods for representing
meaning. However, before going into more detail, let's put the discussion into a
broader perspective, and link back to a topic that we briefly raised in
<a class="reference external" href="ch01.html#sec-automatic-natural-language-understanding">5</a>.  Can a computer understand the meaning
of a sentence? And how could we tell if it did?  This is similar to asking &quot;Can a
computer think?&quot; Alan Turing famously proposed to answer this by examining the
ability of a computer to hold sensible conversations with a human
<a class="reference external" href="bibliography.html#turing1950cmi" id="id3">(Turing, 1950)</a>. Suppose you are having a chat session with a person and a computer,
but you are not told at the outset which is which. If you cannot identify which of
your partners is the computer after chatting with each of them, then the computer has
successfully imitated a human. If a computer succeeds in passing itself off as human
in this &quot;imitation game&quot; (or &quot;Turing Test&quot; as it is popularly known), then according
to Turing, we should be prepared to say that the computer <span class="emphasis">can</span> think and can be
said to be intelligent. So Turing side-stepped the question of somehow examining the
internal states of a computer by instead using its <span class="emphasis">behavior</span> as evidence of
intelligence. By the same reasoning, we have assumed that in order to say that a
computer understands English, it just needs to behave as though it did.  What is
important here is not so much the specifics of Turing's imitation game, but rather
the proposal to judge a capacity for natural language understanding in terms of
observable behavior.</p>
</div>
</div>
<div class="section" id="propositional-logic">
<span id="sec-proplog"></span><h1>2&nbsp;&nbsp;&nbsp;Propositional Logic</h1>
<p>A logical language is designed to make reasoning formally explicit. As
a result, it can capture aspects of natural language
which determine whether a set of sentences is consistent. As part of
this approach, we need to develop logical representations of a
sentence &#966; which formally capture the <a name="truth_conditions_index_term" /><span class="termdef">truth-conditions</span> of &#966;. We'll start
off with a simple example:</p>
<span class="target" id="ex-proplog1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(8)</td><td width="15"></td><td>[Klaus chased Evi] and [Evi ran away].</td></tr></table></p>
<p>Let's replace the two sub-sentences in <a class="reference internal" href="#ex-proplog1">(8)</a> by &#966; and &#968;
respectively, and put <tt class="doctest"><span class="pre">&amp;</span></tt> for the logical operator corresponding to
the English word <span class="example">and</span>: &#966; <tt class="doctest"><span class="pre">&amp;</span></tt> &#968;. This structure is the
<a name="logical_form_index_term" /><span class="termdef">logical form</span> of <a class="reference internal" href="#ex-proplog1">(8)</a>.</p>
<p><a name="propositional_logic_index_term" /><span class="termdef">Propositional logic</span>  allows us to represent
just those parts of linguistic structure which correspond to certain
sentential connectives. We have just looked at <span class="example">and</span>. Other such
connectives are <span class="example">not</span>, <span class="example">or</span> and <span class="example">if...,
then...</span>. In the formalization of propositional logic, the
counterparts of such connectives are sometimes called <a name="boolean_operators_index_term" /><span class="termdef">boolean
operators</span>.  The basic expressions of propositional logic are
<a name="propositional_symbols_index_term" /><span class="termdef">propositional symbols</span>, often written as <span class="math">P</span>,
<span class="math">Q</span>, <span class="math">R</span>, etc.  There are varying conventions for
representing boolean operators. Since we will be focusing on ways of
exploring logic within NLTK, we will stick to the following ASCII
versions of the operators:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.boolean_ops()
<span class="pysrc-output">negation            -</span>
<span class="pysrc-output">conjunction         &amp;</span>
<span class="pysrc-output">disjunction         |</span>
<span class="pysrc-output">implication         -&gt;</span>
<span class="pysrc-output">equivalence         &lt;-&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>From the propositional symbols and the boolean operators we can build
an infinite set of <a name="well_formed_formulas_index_term" /><span class="termdef">well formed formulas</span> (or just formulas, for
short) of propositional logic. First, every propositional letter is a
formula. Then if &#966; is a formula, so is <tt class="doctest"><span class="pre">-</span></tt>&#966;. And if  &#966; and
&#968; are formulas, then so are
<tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">&amp;</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt>
<tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">|</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt>
<tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">-&gt;</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt>
<tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">&lt;-&gt;</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt>.</p>
<p>The <a class="reference internal" href="#tab-boolean-tcs">2.1</a> specifies the truth-conditions for
formulas containing these operators. As before we use &#966; and
&#968; as variables over sentences, and abbreviate <span class="example">if and only if</span>
as <span class="example">iff</span>.</p>
<span class="target" id="tab-boolean-tcs"></span><table border="1" class="docutils" id="tab-boolean-tcs">
<colgroup>
<col width="28%" />
<col width="28%" />
<col width="8%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Boolean Operator</th>
<th class="head" colspan="3">Truth Conditions</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>negation (<span class="example">it is not the case that ...</span>)</td>
<td><tt class="doctest"><span class="pre">-</span></tt>&#966; is true in <em>s</em></td>
<td>iff</td>
<td>&#966; is false in <em>s</em></td>
</tr>
<tr><td>conjunction (<span class="example">and</span>)</td>
<td><tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">&amp;</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt> is true in <em>s</em></td>
<td>iff</td>
<td>&#966; is true in <em>s</em> and &#968; is true in <em>s</em></td>
</tr>
<tr><td>disjunction (<span class="example">or</span>)</td>
<td><tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">|</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt> is true in <em>s</em></td>
<td>iff</td>
<td>&#966; is true in <em>s</em> or &#968; is true in <em>s</em></td>
</tr>
<tr><td>implication (<span class="example">if ..., then ...</span>)</td>
<td><tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">-&gt;</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt> is true in <em>s</em></td>
<td>iff</td>
<td>&#966; is false in <em>s</em> or &#968; is true in <em>s</em></td>
</tr>
<tr><td>equivalence (<span class="example">if and only if</span>)</td>
<td><tt class="doctest"><span class="pre">(</span></tt>&#966; <tt class="doctest"><span class="pre">&lt;-&gt;</span></tt> &#968;<tt class="doctest"><span class="pre">)</span></tt> is true in <em>s</em></td>
<td>iff</td>
<td>&#966; and &#968; are both true in <em>s</em> or both false in <em>s</em></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 2.1</span>: <p>Truth conditions for the Boolean Operators in Propositional Logic.</p>
</p>
</table>
<p>These rules are generally straightforward, though the truth conditions for
implication departs in many cases from our usual intuitions about the
conditional in English. A formula of the form <tt class="doctest"><span class="pre">(P -&gt; Q)</span></tt> is only false
when <tt class="doctest"><span class="pre">P</span></tt> is true and <tt class="doctest"><span class="pre">Q</span></tt> is false. If <tt class="doctest"><span class="pre">P</span></tt> is false (say <tt class="doctest"><span class="pre">P</span></tt>
corresponds to <span class="example">The moon is made of green cheese</span>) and <tt class="doctest"><span class="pre">Q</span></tt> is
true (say <tt class="doctest"><span class="pre">Q</span></tt> corresponds to <span class="example">Two plus two equals four</span>) then <tt class="doctest"><span class="pre">P
-&gt; Q</span></tt> will come out true.</p>
<p>NLTKs <tt class="doctest"><span class="pre">Expression</span></tt> object can process logical expressions into
various subclasses of <tt class="doctest"><span class="pre">Expression</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr = nltk.sem.Expression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'-(P &amp; Q)'</span>)
<span class="pysrc-output">&lt;NegatedExpression -(P &amp; Q)&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'P &amp; Q'</span>)
<span class="pysrc-output">&lt;AndExpression (P &amp; Q)&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'P | (R -&gt; Q)'</span>)
<span class="pysrc-output">&lt;OrExpression (P | (R -&gt; Q))&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'P &lt;-&gt; -- P'</span>)
<span class="pysrc-output">&lt;IffExpression (P &lt;-&gt; --P)&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>From a computational perspective, logics give us an important tool for performing
inference.  Suppose you state that Freedonia is not to the north of Sylvania, and
you give as your reasons that Sylvania is to the north of Freedonia. In this case,
you have produced an <a name="argument_index_term" /><span class="termdef">argument</span>. The sentence <span class="example">Sylvania is to the north of
Freedonia</span> is the <a name="assumption_index_term" /><span class="termdef">assumption</span> of the argument while <span class="example">Freedonia is not to the
north of Sylvania</span> is the <a name="conclusion_index_term" /><span class="termdef">conclusion</span>. The step of moving from one or more assumptions
to a conclusion is called <a name="inference_index_term" /><span class="termdef">inference</span>. Informally, it is common to write arguments in a
format where the conclusion is preceded by <span class="example">therefore</span>.</p>
<span class="target" id="ex-proplog8"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(9)</td><td width="15"></td><td><div class="line-block">
<div class="line">Sylvania is to the north of Freedonia.</div>
<div class="line">Therefore, Freedonia is not to the north of Sylvania</div>
</div>
</td></tr></table></p>
<p>An argument is <a name="valid_index_term" /><span class="termdef">valid</span> if there is no possible situation in which
its premises are all true and its conclusion is not true.</p>
<p>Now, the validity of <a class="reference internal" href="#ex-proplog8">(9)</a> crucially depends on the meaning of the phrase <span class="example">to
the north of</span>, in particular, the fact that it is an asymmetric
relation:</p>
<span class="target" id="ex-north"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(10)</td><td width="15"></td><td>if <span class="math">x</span> is to the north of <span class="math">y</span> then <span class="math">y</span> is not to the north of
<span class="math">x</span>.</td></tr></table></p>
<p>Unfortunately, we can't express such rules in propositional logic: the smallest
elements we have to play with are atomic propositions, and we cannot &quot;look inside&quot;
these to talk about relations between individuals <span class="math">x</span> and <span class="math">y</span>.  The best
we can do in this case is capture a particular case of the asymmetry. Let's use the
propositional symbol <tt class="doctest"><span class="pre">SnF</span></tt> to stand for <span class="example">Sylvania is to the north of Freedonia</span>
and <tt class="doctest"><span class="pre">FnS</span></tt> for <span class="example">Freedonia is to the north of Sylvania</span>. To say that <span class="example">Freedonia
is not to the north of Sylvania</span>, we write <tt class="doctest"><span class="pre">-FnS</span></tt> That is, we treat <span class="example">not</span>
as equivalent to the phrase <span class="example">it is not the case that ...</span>, and translate this as
the one-place boolean operator <tt class="doctest"><span class="pre">-</span></tt>.  So now we can write the implication in
<a class="reference internal" href="#ex-north">(10)</a> as</p>
<span class="target" id="ex-northprop"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(11)</td><td width="15"></td><td><tt class="doctest"><span class="pre">SnF -&gt; -FnS</span></tt></td></tr></table></p>
<p>How about giving a version of the complete argument? We will replace the first
sentence of <a class="reference internal" href="#ex-proplog8">(9)</a> by two formulas of propositional logic: <tt class="doctest"><span class="pre">SnF</span></tt>, and also
the implication in <a class="reference internal" href="#ex-northprop">(11)</a>, which expresses (rather poorly) our background
knowledge of the meaning of <span class="example">to the north of</span>.  We'll write <tt class="doctest"><span class="pre">[A1, ..., An] / C</span></tt>
to represent the argument that conclusion <tt class="doctest"><span class="pre">C</span></tt> follows from assumptions <tt class="doctest"><span class="pre">[A1, ...,
An]</span></tt>. This leads to the following as a representation of argument <a class="reference internal" href="#ex-proplog8">(9)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(12)</td><td width="15"></td><td><tt class="doctest"><span class="pre">[SnF, SnF -&gt; -FnS] / -FnS</span></tt></td></tr></table></p>
<p>This is a valid argument: if <tt class="doctest"><span class="pre">SnF</span></tt> and <tt class="doctest"><span class="pre">SnF -&gt; -FnS</span></tt> are both true in a situation
<em>s</em>, then <tt class="doctest"><span class="pre">-FnS</span></tt> must also be true in <em>s</em>. By contrast, if <tt class="doctest"><span class="pre">FnS</span></tt> were true, this would
conflict with our understanding that two objects cannot both be to the north of each
other in any possible situation. Equivalently, the list <tt class="doctest"><span class="pre">[SnF, SnF -&gt; -FnS, FnS]</span></tt>
is inconsistent &#8212; these sentences cannot all be true together.</p>
<p>Arguments can be tested for &quot;syntactic validity&quot; by using a proof system.  We will
say a little bit more about this later on in <a class="reference internal" href="#sec-fol">3</a>.  Logical proofs can be carried out with
NLTK's <tt class="doctest"><span class="pre">inference</span></tt> module, for example <em>via</em> an interface to the
third-party theorem prover Prover9. The inputs to the inference mechanism first have to
be converted into logical expressions.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lp = nltk.sem.Expression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>SnF = read_expr(<span class="pysrc-string">'SnF'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>NotFnS = read_expr(<span class="pysrc-string">'-FnS'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>R = read_expr(<span class="pysrc-string">'SnF -&gt; -FnS'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prover = nltk.Prover9()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prover.prove(NotFnS, [SnF, R])
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Here's another way of seeing why the conclusion follows.  <tt class="doctest"><span class="pre">SnF -&gt; -FnS</span></tt> is semantically
equivalent to <tt class="doctest"><span class="pre">-SnF | -FnS</span></tt>, where &quot;<tt class="doctest"><span class="pre">|</span></tt>&quot; is the
two-place operator corresponding to <span class="example">or</span>. In general, &#966; <tt class="doctest"><span class="pre">|</span></tt> &#968; is true in
a situation <em>s</em> if either &#966; is true in <em>s</em> or &#966; is true in
<em>s</em>. Now, suppose  both <tt class="doctest"><span class="pre">SnF</span></tt> and <tt class="doctest"><span class="pre">-SnF | -FnS</span></tt> are true in situation <em>s</em>. If <tt class="doctest"><span class="pre">SnF</span></tt> is
true, then <tt class="doctest"><span class="pre">-SnF</span></tt> cannot
also be true; a fundamental assumption of classical logic is that a
sentence cannot be both true and false in a situation. Consequently,
<tt class="doctest"><span class="pre">-FnS</span></tt> must be true.</p>
<p>Recall that we interpret sentences of a logical language relative to a
model, which is a very simplified version of the world. A model for
propositional logic needs to assign the values <tt class="doctest"><span class="pre">True</span></tt> or <tt class="doctest"><span class="pre">False</span></tt>
to every possible formula. We do this inductively: first, every
propositional symbol is assigned a value, and then we compute the
value of complex formulas by consulting the meanings of the boolean
operators (i.e, <a class="reference internal" href="#tab-boolean-tcs">2.1</a>) and applying them to the values of
the formula's components. A <tt class="doctest"><span class="pre">Valuation</span></tt> is a mapping from basic
expressions of the logic to their values. Here's an example:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>val = nltk.Valuation([(<span class="pysrc-string">'P'</span>, True), (<span class="pysrc-string">'Q'</span>, True), (<span class="pysrc-string">'R'</span>, False)])</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We initialize a <tt class="doctest"><span class="pre">Valuation</span></tt> with a list of pairs, each of which
consists of a semantic symbol and a semantic value. The resulting
object is essentially just a dictionary that maps logical expressions
(treated as strings) to appropriate values.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>val[<span class="pysrc-string">'P'</span>]
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>As we will see later, our models need to be somewhat more complicated
in order to handle the more complex logical forms discussed in the
next section; for the time being, just ignore the <tt class="doctest"><span class="pre">dom</span></tt> and
<tt class="doctest"><span class="pre">g</span></tt> parameters in the following declarations.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dom = set()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g = nltk.Assignment(dom)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now let's initialize a model <tt class="doctest"><span class="pre">m</span></tt> that uses <tt class="doctest"><span class="pre">val</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m = nltk.Model(dom, val)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Every model comes with an <tt class="doctest"><span class="pre">evaluate()</span></tt> method, which will determine
the semantic value of logical expressions, such as formulas of
propositional logic; of course, these values depend on the initial
truth values we assigned to propositional symbols such as <tt class="doctest"><span class="pre">P</span></tt>,
<tt class="doctest"><span class="pre">Q</span></tt> and <tt class="doctest"><span class="pre">R</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(m.evaluate(<span class="pysrc-string">'(P &amp; Q)'</span>, g))
<span class="pysrc-output">True</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(m.evaluate(<span class="pysrc-string">'-(P &amp; Q)'</span>, g))
<span class="pysrc-output">False</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(m.evaluate(<span class="pysrc-string">'(P &amp; R)'</span>, g))
<span class="pysrc-output">False</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(m.evaluate(<span class="pysrc-string">'(P | R)'</span>, g))
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Experiment with evaluating different formulas of propositional logic.
Does the model give the values that you expected?</p>
</div>
<p>Up until now, we have been translating our English sentences into
propositional logic. Because we are confined to representing atomic
sentences with letters like <tt class="doctest"><span class="pre">P</span></tt> and <tt class="doctest"><span class="pre">Q</span></tt>, we cannot dig into their
internal structure. In effect, we are saying that there is nothing of
logical interest to dividing atomic sentences into subjects, objects
and predicates. However, this seems wrong: if we want to formalize
arguments such as <a class="reference internal" href="#ex-proplog8">(9)</a>, we have to be able to &quot;look inside&quot;
basic sentences. As a result, we will move beyond Propositional Logic
to a something more expressive, namely First-Order Logic. This is what
we turn to in the next section.</p>
</div>
<div class="section" id="first-order-logic">
<span id="sec-fol"></span><h1>3&nbsp;&nbsp;&nbsp;First-Order Logic</h1>
<p>In the remainder of this chapter, we will represent the meaning of natural language
expressions by translating them into first-order logic.
Not all of natural language semantics can be expressed in first-order logic. But it is a good
choice for computational semantics because it is expressive enough to represent a
good deal, and on the other hand, there are excellent systems available off the shelf
for carrying out automated inference in first order logic.</p>
<p>Our next step will be to describe how formulas of first-order logic are constructed, and then how
such formulas can be evaluated in a model.</p>
<div class="section" id="syntax">
<h2>3.1&nbsp;&nbsp;&nbsp;Syntax</h2>
<p>First-order logic keeps all the boolean operators of Propositional Logic. But it
adds some important new mechanisms. To start with, propositions are
analyzed into predicates and arguments, which takes us a step closer
to the structure of natural languages. The standard construction rules
for first-order logic recognize <a name="terms_index_term" /><span class="termdef">terms</span> such as individual variables and
individual constants, and <a name="predicates_index_term" /><span class="termdef">predicates</span> which take differing
numbers of arguments. For example, <span class="example">Angus walks</span> might be
formalized as <span class="mathit">walk(angus)</span> and <span class="example">Angus sees Bertie</span> as
<span class="mathit">see(angus, bertie)</span>. We will call <span class="mathit">walk</span> a <a name="unary_predicate_index_term" /><span class="termdef">unary
predicate</span>, and <span class="mathit">see</span> a <a name="binary_predicate_index_term" /><span class="termdef">binary predicate</span>. The
symbols used as predicates do not have intrinsic meaning, although it
is hard to remember this. Returning to one of our earlier examples,
there is no <span class="emphasis">logical</span> difference between <a class="reference internal" href="#ex-predlog11">(13a)</a> and
<a class="reference internal" href="#ex-predlog12">(13b)</a>.</p>
<span class="target" id="ex-predlog1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(13)</td><td width="15"></td><td><span class="target" id="ex-predlog11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>love(margrietje, brunoke)</td></tr></table></p>
<span class="target" id="ex-predlog12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>houden_van(margrietje, brunoke)</td></tr></table></p>
</td></tr></table></p>
<!-- XXX is it important enough to tell the reader that some theories
of lexical semantics can be encoded in FOL? -->
<p>By itself, first-order logic has nothing substantive to say about lexical
semantics &#8212; the meaning of individual words &#8212; although
some theories of lexical semantics can be encoded in first-order logic. Whether an
atomic predication like <span class="mathit">see(angus, bertie)</span> is true or false in
a situation is not a matter of logic, but depends on the particular
valuation that we have chosen for the constants <span class="mathit">see</span>,
<span class="mathit">angus</span> and <span class="mathit">bertie</span>. For this reason, such expressions
are called <a name="non_logical_constants_index_term" /><span class="termdef">non-logical constants</span>. By contrast, <a name="logical_constants_index_term" /><span class="termdef">logical
constants</span> (such as the boolean operators) always receive the same
interpretation in every model for first-order logic.</p>
<p>We should mention here that one binary predicate has special
status, namely equality, as in formulas such as <span class="mathit">angus =
aj</span>. Equality is regarded as a logical constant, since for
individual terms <span class="math">t1</span> and <span class="math">t2</span>, the formula <span class="math">t1 = t2</span> is
true if and only if <span class="math">t1</span> and <span class="math">t2</span> refer to one and the
same entity.</p>
<!-- SB: Note that the angle brackets don't appear in the PDF output version -->
<p>It is often helpful to inspect the syntactic structure of expressions
of first-order logic, and the usual way of doing this is to assign <a name="types_index_term" /><span class="termdef">types</span> to
expressions. Following the tradition of Montague grammar, we
will use two <a name="basic_types_index_term" /><span class="termdef">basic types</span>: <span class="math">e</span> is the type of entities,
while  <span class="math">t</span> is the type of formulas, i.e., expressions which have
truth values. Given these two basic types, we can form <a name="complex_types_index_term" /><span class="termdef">complex
types</span> for function expressions. That is, given any types &#963; and &#964;, &#9001;&#963;,
&#964;&#9002; is a complex type corresponding to functions from
'&#963; things' to '&#964; things'. For example, &#9001;<span class="mathit">e</span>,
<span class="mathit">t</span>&#9002; is the type of expressions from entities to
truth values, namely unary predicates. The logical expression can be
processed with type checking.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr = nltk.sem.Expression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr = read_expr(<span class="pysrc-string">'walk(angus)'</span>, type_check=True)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr.argument
<span class="pysrc-output">&lt;ConstantExpression angus&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>expr.argument.type
<span class="pysrc-output">e</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>expr.function
<span class="pysrc-output">&lt;ConstantExpression walk&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>expr.function.type
<span class="pysrc-output">&lt;e,?&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Why do we see <tt class="doctest"><span class="pre">&lt;e,?&gt;</span></tt> at the end of this example? Although the
type-checker will try to infer as many types as possible, in this case
it has not managed to fully specify the type of <tt class="doctest"><span class="pre">walk</span></tt>,
since its result type is unknown. Although we are intending <tt class="doctest"><span class="pre">walk</span></tt>
to receive type <tt class="doctest"><span class="pre">&lt;e, t&gt;</span></tt>, as far as the type-checker knows, in this
context it could be of some other type such as <tt class="doctest"><span class="pre">&lt;e, e&gt;</span></tt> or <tt class="doctest"><span class="pre">&lt;e, &lt;e, t&gt;</span></tt>. To help
the type-checker, we need to specify a <a name="signature_index_term" /><span class="termdef">signature</span>, implemented as
a dictionary that explicitly associates types with non-logical
constants:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sig = {<span class="pysrc-string">'walk'</span>: <span class="pysrc-string">'&lt;e, t&gt;'</span>}
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr = read_expr(<span class="pysrc-string">'walk(angus)'</span>, signature=sig)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr.function.type
<span class="pysrc-output">e</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A binary predicate has type &#9001;<span class="mathit">e</span>, &#9001;<span class="mathit">e</span>, <span class="mathit">t</span>&#9002;&#9002;. Although this is the type of
something which combines first with an argument of type <span class="mathit">e</span> to make
a unary predicate, we represent binary predicates as combining
directly with their two arguments. For example, the predicate <span class="math">see</span> in the
translation of <cite>Angus sees Cyril</cite> will
combine with its arguments to give the result <span class="math">see(angus, cyril)</span>.</p>
<p>In first-order logic, arguments of predicates can also be individual variables
such as <span class="math">x</span>, <span class="math">y</span> and <span class="math">z</span>. In NLTK, we adopt the convention that
variables of type <em>e</em> are all lowercase.
Individual variables are similar to
personal pronouns like <span class="example">he</span>, <span class="example">she</span> and <span class="example">it</span>, in that we
need to know about the context of use in order to figure out their
denotation.</p>
<p>One way of interpreting the pronoun in <a class="reference internal" href="#ex-predlog2">(14)</a> is by
pointing to a relevant individual in the local context.</p>
<span class="target" id="ex-predlog2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(14)</td><td width="15"></td><td>He disappeared.</td></tr></table></p>
<p>Another way is to supply a textual antecedent for the pronoun
<span class="example">he</span>, for example by uttering <a class="reference internal" href="#ex-predlog31">(15a)</a> prior to
<a class="reference internal" href="#ex-predlog2">(14)</a>. Here, we say that <span class="example">he</span> is <a name="coreferential_index_term" /><span class="termdef">coreferential</span> with
the noun phrase <span class="example">Cyril</span>. As a result, <a class="reference internal" href="#ex-predlog2">(14)</a> is semantically
equivalent to <a class="reference internal" href="#ex-predlog32">(15b)</a>.</p>
<span class="target" id="ex-predlog3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(15)</td><td width="15"></td><td><span class="target" id="ex-predlog31"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Cyril is Angus's dog.</td></tr></table></p>
<span class="target" id="ex-predlog32"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Cyril disappeared.</td></tr></table></p>
</td></tr></table></p>
<p>Consider by contrast the occurrence of <span class="example">he</span> in <a class="reference internal" href="#ex-predlog41">(16a)</a>. In
this case, it is <a name="bound_index_term" /><span class="termdef">bound</span> by the indefinite <tt class="doctest"><span class="pre">NP</span></tt>
<span class="example">a dog</span>,
and this is a different relationship than
coreference. If we replace the pronoun <span class="example">he</span> by <span class="example">a dog</span>,
the result <a class="reference internal" href="#ex-predlog42">(16b)</a> is <span class="emphasis">not</span> semantically equivalent to <a class="reference internal" href="#ex-predlog41">(16a)</a>.</p>
<span class="target" id="ex-predlog4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(16)</td><td width="15"></td><td><span class="target" id="ex-predlog41"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Angus had a dog but he disappeared.</td></tr></table></p>
<span class="target" id="ex-predlog42"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Angus had a dog but a dog disappeared.</td></tr></table></p>
</td></tr></table></p>
<p>Corresponding to <a class="reference internal" href="#ex-predlog51">(17a)</a>, we can construct an <a name="open_formula_index_term" /><span class="termdef">open formula</span>
<a class="reference internal" href="#ex-predlog52">(17b)</a> with two occurrences of the variable <span class="math">x</span>. (We
ignore tense to simplify exposition.)</p>
<span class="target" id="ex-predlog5"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(17)</td><td width="15"></td><td><span class="target" id="ex-predlog51"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>He is a dog and he disappeared.</td></tr></table></p>
<span class="target" id="ex-predlog52"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><span class="mathit">dog(x)</span>  &#8743; <span class="mathit">disappear(x)</span></td></tr></table></p>
</td></tr></table></p>
<p>By placing an <a name="existential_quantifier_index_term" /><span class="termdef">existential quantifier</span> &#8707;<span class="math">x</span> ('for
some <span class="math">x</span>') in front of <a class="reference internal" href="#ex-predlog52">(17b)</a>, we can <a name="bind_index_term" /><span class="termdef">bind</span> these
variables, as in <a class="reference internal" href="#ex-predlog61">(18a)</a>, which means <a class="reference internal" href="#ex-predlog62">(18b)</a> or, more
idiomatically, <a class="reference internal" href="#ex-predlog63">(18c)</a>.</p>
<span class="target" id="ex-predlog6"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(18)</td><td width="15"></td><td><span class="target" id="ex-predlog61"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>&#8707;<span class="mathit">x.(dog(x)</span>  &#8743; <span class="mathit">disappear(x))</span></td></tr></table></p>
<span class="target" id="ex-predlog62"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>At least one entity is a dog and disappeared.</td></tr></table></p>
<span class="target" id="ex-predlog63"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>A dog disappeared.</td></tr></table></p>
</td></tr></table></p>
<p>The NLTK rendering of <a class="reference internal" href="#ex-predlog61">(18a)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(19)</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.(dog(x) &amp; disappear(x))</span></tt></td></tr></table></p>
<p>In addition to the existential quantifier, first-order logic offers us the
<a name="universal_quantifier_index_term" /><span class="termdef">universal quantifier</span> &#8704;<span class="math">x</span> ('for all
<span class="math">x</span>'), illustrated in <a class="reference internal" href="#ex-predlog7">(20)</a>.</p>
<span class="target" id="ex-predlog7"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(20)</td><td width="15"></td><td><span class="target" id="ex-predlog71"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>&#8704;<span class="mathit">x.(dog(x)</span> &#8594; <span class="mathit">disappear(x))</span></td></tr></table></p>
<span class="target" id="ex-predlog72"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Everything has the property that if it is a dog, it disappears.</td></tr></table></p>
<span class="target" id="ex-predlog73"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>Every dog disappeared.</td></tr></table></p>
</td></tr></table></p>
<p>The NLTK syntax for <a class="reference internal" href="#ex-predlog71">(20a)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(21)</td><td width="15"></td><td><tt class="doctest"><span class="pre">all x.(dog(x) -&gt; disappear(x))</span></tt></td></tr></table></p>
<p>Although <a class="reference internal" href="#ex-predlog71">(20a)</a> is the standard first-order logic translation of <a class="reference internal" href="#ex-predlog73">(20c)</a>, the truth
conditions aren't necessarily what you expect.
The formula says that <span class="emphasis">if</span> some <em>x</em> is a dog, then
<em>x</em> disappears &#8212; but it doesn't say that there are any dogs. So
in a situation where there are no dogs, <a class="reference internal" href="#ex-predlog71">(20a)</a> will still
come out true. (Remember that <tt class="doctest"><span class="pre">(P -&gt; Q)</span></tt> is true when <tt class="doctest"><span class="pre">P</span></tt>
is false.) Now you might argue that <span class="example">every dog disappeared</span> does presuppose the
existence of dogs, and that the logic formalization is simply wrong.  But it
is possible to find other examples which lack such a presupposition.
For instance, we might explain that the value of the Python expression
<tt class="doctest"><span class="pre">astring.replace(<span class="pysrc-string">'ate'</span>, <span class="pysrc-string">'8'</span>)</span></tt> is the result of replacing every
occurrence of <tt class="doctest"><span class="pre"><span class="pysrc-string">'ate'</span></span></tt> in <tt class="doctest"><span class="pre">astring</span></tt> by <tt class="doctest"><span class="pre"><span class="pysrc-string">'8'</span></span></tt>, even though there
may in fact be no such occurrences (<a class="reference external" href="ch03.html#tab-string-methods">3.2</a>).</p>
<p>We have seen a number of examples where variables are bound by quantifiers. What
happens in formulas such as the following?:</p>
<pre class="literal-block">
((exists x. dog(x)) -&gt; bark(x))
</pre>
<p>The scope of the <tt class="doctest"><span class="pre">exists x</span></tt> quantifier is <tt class="doctest"><span class="pre">dog(x)</span></tt>, so the occurrence of <tt class="doctest"><span class="pre">x</span></tt>
in <tt class="doctest"><span class="pre">bark(x)</span></tt> is unbound. Consequently it can become bound by some other quantifier,
for example <tt class="doctest"><span class="pre">all x</span></tt> in the next formula:</p>
<pre class="literal-block">
all x.((exists x. dog(x)) -&gt; bark(x))
</pre>
<p>In general, an occurrence of a variable <tt class="doctest"><span class="pre">x</span></tt> in a formula &#966; is <a name="free_index_term" /><span class="termdef">free</span> in
&#966; if that occurrence doesn't fall within the scope of <tt class="doctest"><span class="pre">all x</span></tt> or <tt class="doctest"><span class="pre">some x</span></tt> in
&#966;. Conversely, if <tt class="doctest"><span class="pre">x</span></tt> is free in formula &#966;, then it is <a name="bound_index_term_2" /><span class="termdef">bound</span> in
<tt class="doctest"><span class="pre">all x.</span></tt>&#966; and <tt class="doctest"><span class="pre">exists x.</span></tt>&#966;. If all variable occurrences in a formula are bound, the formula is said
to be <a name="closed_index_term" /><span class="termdef">closed</span>.</p>
<p>We mentioned before that the <tt class="doctest"><span class="pre">Expression</span></tt> object can process
strings, and returns objects of class <tt class="doctest"><span class="pre">Expression</span></tt>. Each
instance <tt class="doctest"><span class="pre">expr</span></tt> of this class comes with a method <tt class="doctest"><span class="pre">free()</span></tt> which returns the set
of variables that are free in <tt class="doctest"><span class="pre">expr</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr = nltk.sem.Expression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'dog(cyril)'</span>).free()
<span class="pysrc-output">set()</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'dog(x)'</span>).free()
<span class="pysrc-output">{Variable('x')}</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'own(angus, cyril)'</span>).free()
<span class="pysrc-output">set()</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'exists x.dog(x)'</span>).free()
<span class="pysrc-output">set()</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'((some x. walk(x)) -&gt; sing(x))'</span>).free()
<span class="pysrc-output">{Variable('x')}</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr(<span class="pysrc-string">'exists x.own(y, x)'</span>).free()
<span class="pysrc-output">{Variable('y')}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="first-order-theorem-proving">
<h2>3.2&nbsp;&nbsp;&nbsp;First Order Theorem Proving</h2>
<p>Recall the constraint on <span class="example">to the north of</span> which we proposed earlier as <a class="reference internal" href="#ex-north">(10)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(22)</td><td width="15"></td><td>if <span class="math">x</span> is to the north of <span class="math">y</span> then <span class="math">y</span> is not to the north of
<span class="math">x</span>.</td></tr></table></p>
<p>We observed that propositional logic is not expressive enough to
represent generalizations about binary predicates, and as a result we
did not properly capture the argument <span class="example">Sylvania is to the north of
Freedonia. Therefore, Freedonia is not to the north of Sylvania</span>.</p>
<p>You have no doubt realized that first order logic, by contrast, is
ideal for formalizing such rules:</p>
<pre class="literal-block">
all x. all y.(north_of(x, y) -&gt; -north_of(y, x))
</pre>
<p>Even better, we can perform automated inference to
show the validity of the argument.</p>
<p>The general case in theorem proving is to
determine whether a formula that we want to prove (a <a name="proof_goal_index_term" /><span class="termdef">proof goal</span>) can be derived
by a finite sequence of inference steps from a list of assumed formulas. We write this
as <span class="mathit">S</span> &#8866; <span class="mathit">g</span>, where <tt class="doctest"><span class="pre">S</span></tt> is a (possibly empty) list of assumptions,
and <tt class="doctest"><span class="pre">g</span></tt> is a proof goal. We will illustrate this with NLTK's interface to the
theorem prover Prover9.  First, we parse the required
proof goal <a class="reference internal" href="#goal"><span id="ref-goal"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> and the two assumptions <a class="reference internal" href="#ass1"><span id="ref-ass1"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a> <a class="reference internal" href="#ass2"><span id="ref-ass2"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>. Then we create a <tt class="doctest"><span class="pre">Prover9</span></tt>
instance <a class="reference internal" href="#new-prover"><span id="ref-new-prover"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>, and call its <tt class="doctest"><span class="pre">prove()</span></tt> method on the goal, given the list of
assumptions <a class="reference internal" href="#prove"><span id="ref-prove"><img src="callouts/callout5.gif" alt="[5]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>NotFnS = read_expr(<span class="pysrc-string">'-north_of(f, s)'</span>)  <a name="goal" /><a href="#ref-goal"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>SnF = read_expr(<span class="pysrc-string">'north_of(s, f)'</span>)    <a name="ass1" /><a href="#ref-ass1"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>R = read_expr(<span class="pysrc-string">'all x. all y. (north_of(x, y) -&gt; -north_of(y, x))'</span>)  <a name="ass2" /><a href="#ref-ass2"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prover = nltk.Prover9()   <a name="new-prover" /><a href="#ref-new-prover"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prover.prove(NotFnS, [SnF, R])  <a name="prove" /><a href="#ref-prove"><img src="callouts/callout5.gif" alt="[5]" class="callout" /></a>
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Happily, the theorem prover agrees with us that the argument is valid.  By contrast,
it concludes that it is not possible to infer <tt class="doctest"><span class="pre">north_of(f, s)</span></tt> from our
assumptions:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>FnS = read_expr(<span class="pysrc-string">'north_of(f, s)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>prover.prove(FnS, [SnF, R])
<span class="pysrc-output">False</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="summarizing-the-language-of-first-order-logic">
<h2>3.3&nbsp;&nbsp;&nbsp;Summarizing the Language of First Order Logic</h2>
<p>We'll take this opportunity to restate our earlier syntactic rules for
propositional logic and add the formation rules for quantifiers;
together, these give us the syntax of first order logic. In
addition, we make explicit the types of the expressions
involved. We'll adopt the convention that
&#9001;<span class="mathit">e</span><sup>n</sup>, <span class="mathit">t</span>&#9002;
is the type of a predicate which combines with <span class="mathit">n</span> arguments
of type <span class="mathit">e</span> to yield an expression
of type <span class="mathit">t</span>. In this case, we say that <span class="mathit">n</span> is the
<a name="arity_index_term" /><span class="termdef">arity</span> of the predicate.</p>
<blockquote>
<ol class="lowerroman simple">
<li>If <span class="math">P</span> is a predicate of type &#9001;<span class="mathit">e</span><sup>n</sup>,
<span class="mathit">t</span>&#9002;,
and &#945;<sub>1</sub>, ... &#945;<sub>n</sub>
are terms of type <span class="mathit">e</span>, then
<span class="math">P</span>(&#945;<sub>1</sub>, ... &#945;<sub>n</sub>) is
of type <span class="mathit">t</span>.</li>
<li>If &#945; and &#946; are both of type <span class="mathit">e</span>, then (&#945; = &#946;) and
(&#945; != &#946;) are of type <span class="mathit">t</span>.</li>
<li>If &#966; is of type <span class="mathit">t</span>, then so is <tt class="doctest"><span class="pre">-</span></tt>&#966;.</li>
<li>If &#966; and  &#968; are of type <span class="mathit">t</span>, then so are
(&#966; <tt class="doctest"><span class="pre">&amp;</span></tt> &#968;),
(&#966; <tt class="doctest"><span class="pre">|</span></tt> &#968;),
(&#966; <tt class="doctest"><span class="pre">-&gt;</span></tt> &#968;) and
(&#966; <tt class="doctest"><span class="pre">&lt;-&gt;</span></tt> &#968;).</li>
<li>If &#966; is of type <span class="mathit">t</span>, and <span class="math">x</span> is a variable of type <span class="mathit">e</span>, then
<tt class="doctest"><span class="pre">exists x.</span></tt>&#966; and  <tt class="doctest"><span class="pre">all x.</span></tt>&#966; are of
type <span class="mathit">t</span>.</li>
</ol>
</blockquote>
<p><a class="reference internal" href="#tab-nltk-logic">3.1</a> summarizes the new logical constants of the <tt class="doctest"><span class="pre">logic</span></tt>
module, and two of the methods of <tt class="doctest"><span class="pre">Expression</span></tt>s.</p>
<span class="target" id="tab-nltk-logic"></span><table border="1" class="docutils" id="tab-nltk-logic">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Example</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">=</span></tt></td>
<td>equality</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">!=</span></tt></td>
<td>inequality</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">exists</span></tt></td>
<td>existential quantifier</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">all</span></tt></td>
<td>universal quantifier</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">e.free()</span></tt></td>
<td>show free variables of <tt class="doctest"><span class="pre">e</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">e.simplify()</span></tt></td>
<td>carry out &#946;-reduction on <tt class="doctest"><span class="pre">e</span></tt></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 3.1</span>: <p>Summary of new logical relations and operators required for First
Order Logic, together with two useful methods of the
<tt class="doctest"><span class="pre">Expression</span></tt> class.</p>
</p>
</table>
</div>
<div class="section" id="truth-in-model">
<h2>3.4&nbsp;&nbsp;&nbsp;Truth in Model</h2>
<p>We have looked at the syntax of first-order logic, and in
<a class="reference internal" href="#sec-evaluating-english-sentences">4</a> we will examine the task of
translating English into first-order logic. Yet as we argued in
<a class="reference internal" href="#sec-nlu-introduction">1</a>, this only gets us further forward if
we can give a meaning to sentences of first-order logic. In other words, we need
to give a <span class="emphasis">truth-conditional semantics</span> to first-order logic.
From the point of view of computational semantics, there are obvious
limits in how far one can push this approach. Although we want to talk
about sentences being true or false in situations, we only have the
means of representing situations in the computer in a symbolic
manner. Despite this limitation, it is still possible to gain a
clearer picture of truth-conditional semantics by encoding models in
NLTK.</p>
<p>Given a first-order logic language <span class="math">L</span>, a model <span class="math">M</span> for <span class="math">L</span> is a
pair &#9001;<span class="math">D</span>, <span class="math">Val</span>&#9002;, where <span class="math">D</span> is an
nonempty set called the <a name="domain_index_term" /><span class="termdef">domain</span> of the model, and <span class="math">Val</span> is
a function called the <a name="valuation_function_index_term" /><span class="termdef">valuation function</span> which assigns values
from <span class="math">D</span> to expressions of <span class="math">L</span> as follows:</p>
<blockquote>
<ol class="lowerroman simple">
<li>For every individual constant <span class="math">c</span> in <span class="math">L</span>,
<span class="math">Val(c)</span> is an element of  <span class="math">D</span>.</li>
<li>For every predicate symbol <span class="math">P</span> of arity <span class="math">n</span> &#8805; 0,
<span class="math">Val(P)</span> is a function from  <span class="math">D</span><sup>n</sup> to
{<span class="mathit">True</span>, <span class="mathit">False</span>}. (If the arity of  <span class="math">P</span>
is 0, then <span class="math">Val(P)</span> is simply a truth value, the
<span class="math">P</span> is regarded as a propositional symbol.)</li>
</ol>
</blockquote>
<p>According to (ii), if <span class="math">P</span> is of arity 2, then <span class="math">Val(P)</span>
will be a function <span class="math">f</span> from pairs of elements of  <span class="math">D</span> to
{<span class="mathit">True</span>, <span class="mathit">False</span>}. In the models we shall build in
NLTK, we'll adopt a more convenient alternative, in which
<span class="math">Val(P)</span> is a set <span class="math">S</span> of pairs, defined as follows:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(23)</td><td width="15"></td><td><span class="math">S</span> = {<span class="math">s</span> | <span class="math">f(s)</span> = <span class="mathit">True</span>}</td></tr></table></p>
<p>Such an <span class="math">f</span> is called the <a name="characteristic_function_index_term" /><span class="termdef">characteristic function</span> of <span class="math">S</span>
(as discussed in the further readings).</p>
<p>Relations are represented semantically in NLTK in the standard
set-theoretic way: as sets of tuples. For example, let's suppose we
have a domain of discourse consisting of the individuals Bertie, Olive and Cyril,
where Bertie is a boy, Olive is a girl and Cyril is a dog. For mnemonic
reasons, we use <tt class="doctest"><span class="pre">b</span></tt>, <tt class="doctest"><span class="pre">o</span></tt> and <tt class="doctest"><span class="pre">c</span></tt> as the corresponding labels
in the model. We can declare the domain as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dom = {<span class="pysrc-string">'b'</span>, <span class="pysrc-string">'o'</span>, <span class="pysrc-string">'c'</span>}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We will use the utility function <tt class="doctest"><span class="pre">Valuation.fromstring()</span></tt> to convert a
list of strings of the form <span class="mathit">symbol</span> <tt class="doctest"><span class="pre">=&gt;</span></tt> <span class="mathit">value</span>
into a <tt class="doctest"><span class="pre">Valuation</span></tt> object.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>v = <span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-more">... </span><span class="pysrc-string">bertie =&gt; b</span>
<span class="pysrc-more">... </span><span class="pysrc-string">olive =&gt; o</span>
<span class="pysrc-more">... </span><span class="pysrc-string">cyril =&gt; c</span>
<span class="pysrc-more">... </span><span class="pysrc-string">boy =&gt; {b}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">girl =&gt; {o}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">dog =&gt; {c}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">walk =&gt; {o, c}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">see =&gt; {(b, o), (c, b), (o, c)}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>val = nltk.Valuation.fromstring(v)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(val)
<span class="pysrc-output">{'bertie': 'b',</span>
<span class="pysrc-output"> 'boy': {('b',)},</span>
<span class="pysrc-output"> 'cyril': 'c',</span>
<span class="pysrc-output"> 'dog': {('c',)},</span>
<span class="pysrc-output"> 'girl': {('o',)},</span>
<span class="pysrc-output"> 'olive': 'o',</span>
<span class="pysrc-output"> 'see': {('o', 'c'), ('c', 'b'), ('b', 'o')},</span>
<span class="pysrc-output"> 'walk': {('c',), ('o',)}}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>So according to this valuation, the value of <tt class="doctest"><span class="pre">see</span></tt> is a set of
tuples such that Bertie sees Olive, Cyril sees Bertie, and
Olive sees Cyril.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Draw a picture of the domain of <tt class="doctest"><span class="pre">m</span></tt> and the sets corresponding to
each of the unary predicates, by analogy with the diagram shown in
<a class="reference internal" href="#fig-model-kids">1.2</a>.</p>
</div>
<p>You may have noticed that our unary predicates (i.e, <tt class="doctest"><span class="pre">boy</span></tt>, <tt class="doctest"><span class="pre">girl</span></tt>,
<tt class="doctest"><span class="pre">dog</span></tt>) also come out as sets of singleton tuples, rather
than just sets of individuals. This is a convenience which allows us
to have a uniform treatment of relations of any arity. A predication
of the form <span class="math">P</span>(&#964;<sub>1</sub>,  ... &#964;<sub>n</sub>), where
<span class="math">P</span> is of arity <span class="math">n</span>, comes out true just in case the
tuple of values corresponding to (&#964;<sub>1</sub>,  ... &#964;<sub>n</sub>) belongs to the set of tuples in the value of  <span class="math">P</span>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>(<span class="pysrc-string">'o'</span>, <span class="pysrc-string">'c'</span>) <span class="pysrc-keyword">in</span> val[<span class="pysrc-string">'see'</span>]
<span class="pysrc-output">True</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>(<span class="pysrc-string">'b'</span>,) <span class="pysrc-keyword">in</span> val[<span class="pysrc-string">'boy'</span>]
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="individual-variables-and-assignments">
<h2>3.5&nbsp;&nbsp;&nbsp;Individual Variables and Assignments</h2>
<p>In our models, the counterpart of a context of use is a variable
<a name="assignment_index_term" /><span class="termdef">assignment</span>. This is a mapping from individual variables to
entities in the domain.  Assignments are created using the
<tt class="doctest"><span class="pre">Assignment</span></tt> constructor, which also takes the model's domain of
discourse as a parameter. We are not required to actually enter any
bindings, but if we do, they are in a (<span class="mathit">variable</span>,
<span class="mathit">value</span>) format similar to what we saw earlier for valuations.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g = nltk.Assignment(dom, [(<span class="pysrc-string">'x'</span>, <span class="pysrc-string">'o'</span>), (<span class="pysrc-string">'y'</span>, <span class="pysrc-string">'c'</span>)])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g
<span class="pysrc-output">{'y': 'c', 'x': 'o'}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In addition, there is a <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span>()</span></tt> format for assignments which
uses a notation closer to that often found in logic textbooks:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(g)
<span class="pysrc-output">g[c/y][o/x]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Let's now look at how we can evaluate an atomic formula of
first-order logic. First, we create a model, then we call the <tt class="doctest"><span class="pre">evaluate()</span></tt> method
to compute the truth value.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m = nltk.Model(dom, val)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.evaluate(<span class="pysrc-string">'see(olive, y)'</span>, g)
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>What's happening here? We are evaluating a formula which is similar to
our earlier examplle, <tt class="doctest"><span class="pre">see(olive, cyril)</span></tt>.
However, when the interpretation function encounters the variable <tt class="doctest"><span class="pre">y</span></tt>,
rather than checking for a value in <tt class="doctest"><span class="pre">val</span></tt>, it asks the variable
assignment <tt class="doctest"><span class="pre">g</span></tt> to come up with a value:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g[<span class="pysrc-string">'y'</span>]
<span class="pysrc-output">'c'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Since we already know that individuals <tt class="doctest"><span class="pre">o</span></tt> and <tt class="doctest"><span class="pre">c</span></tt> stand in the <span class="mathit">see</span>
relation, the value <tt class="doctest"><span class="pre">True</span></tt> is what we expected. In this case, we can
say that assignment <tt class="doctest"><span class="pre">g</span></tt> <a name="satisfies_index_term" /><span class="termdef">satisfies</span> the formula <tt class="doctest"><span class="pre">see(olive, y)</span></tt>.
By contrast, the following formula evaluates to <tt class="doctest"><span class="pre">False</span></tt> relative to
<tt class="doctest"><span class="pre">g</span></tt> &#8212; check that you see why this is.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.evaluate(<span class="pysrc-string">'see(y, x)'</span>, g)
<span class="pysrc-output">False</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In our approach (though not in standard first-order logic), variable assignments
are <span class="emphasis">partial</span>. For example, <tt class="doctest"><span class="pre">g</span></tt> says nothing about any variables
apart from <tt class="doctest"><span class="pre">x</span></tt> and <tt class="doctest"><span class="pre">y</span></tt>. The method <tt class="doctest"><span class="pre">purge()</span></tt> clears all
bindings from an assignment.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g.purge()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g
<span class="pysrc-output">{}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>If we now try to evaluate a formula such as <tt class="doctest"><span class="pre">see(olive, y)</span></tt> relative to
<tt class="doctest"><span class="pre">g</span></tt>, it is like trying to interpret a sentence containing a <span class="example">him</span> when
we don't know what <span class="example">him</span> refers to. In this case, the evaluation function
fails to deliver a truth value.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.evaluate(<span class="pysrc-string">'see(olive, y)'</span>, g)
<span class="pysrc-output">'Undefined'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Since our models already contain rules for interpreting boolean
operators, arbitrarily complex formulas can be composed and evaluated.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.evaluate(<span class="pysrc-string">'see(bertie, olive) &amp; boy(bertie) &amp; -walk(bertie)'</span>, g)
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The general process of determining truth or falsity of a formula in a
model is called <a name="model_checking_index_term" /><span class="termdef">model checking</span>.</p>
</div>
<div class="section" id="quantification">
<h2>3.6&nbsp;&nbsp;&nbsp;Quantification</h2>
<p>One of the crucial insights of modern
logic is that the notion of variable satisfaction can be used to
provide an interpretation to quantified formulas. Let's
use <a class="reference internal" href="#ex-exists1">(24)</a> as an example.</p>
<span class="target" id="ex-exists1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(24)</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.(girl(x) &amp; walk(x))</span></tt></td></tr></table></p>
<p>When is it true? Let's think about all the individuals in our domain,
i.e., in <tt class="doctest"><span class="pre">dom</span></tt>. We want to check whether any of these individuals
have the property of being a girl and walking. In other words, we want
to know if there is some <em>u</em> in <tt class="doctest"><span class="pre">dom</span></tt> such that <tt class="doctest"><span class="pre">g[u/x]</span></tt>
satisfies the open formula <a class="reference internal" href="#ex-exists2">(25)</a>.</p>
<span class="target" id="ex-exists2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(25)</td><td width="15"></td><td><tt class="doctest"><span class="pre">girl(x) &amp; walk(x)</span></tt></td></tr></table></p>
<p>Consider the following:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.evaluate(<span class="pysrc-string">'exists x.(girl(x) &amp; walk(x))'</span>, g)
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p><tt class="doctest"><span class="pre">evaluate()</span></tt> returns <tt class="doctest"><span class="pre">True</span></tt> here because there is some <em>u</em> in
<tt class="doctest"><span class="pre">dom</span></tt> such that <a class="reference internal" href="#ex-exists2">(25)</a> is satisfied by an assignment which binds
<tt class="doctest"><span class="pre">x</span></tt> to <em>u</em>. In fact, <tt class="doctest"><span class="pre">o</span></tt> is such a <em>u</em>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.evaluate(<span class="pysrc-string">'girl(x) &amp; walk(x)'</span>, g.add(<span class="pysrc-string">'x'</span>, <span class="pysrc-string">'o'</span>))
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>One useful tool offered by NLTK is the <tt class="doctest"><span class="pre">satisfiers()</span></tt> method. This
returns a set of all the individuals that satisfy an open formula. The
method parameters are a parsed formula, a variable, and an
assignment. Here are a few examples:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fmla1 = read_expr(<span class="pysrc-string">'girl(x) | boy(x)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.satisfiers(fmla1, <span class="pysrc-string">'x'</span>, g)
<span class="pysrc-output">{'b', 'o'}</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fmla2 = read_expr(<span class="pysrc-string">'girl(x) -&gt; walk(x)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.satisfiers(fmla2, <span class="pysrc-string">'x'</span>, g)
<span class="pysrc-output">{'c', 'b', 'o'}</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fmla3 = read_expr(<span class="pysrc-string">'walk(x) -&gt; girl(x)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.satisfiers(fmla3, <span class="pysrc-string">'x'</span>, g)
<span class="pysrc-output">{'b', 'o'}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>It's useful to think about why <tt class="doctest"><span class="pre">fmla2</span></tt> and <tt class="doctest"><span class="pre">fmla3</span></tt> receive the
values they do. The truth conditions for <tt class="doctest"><span class="pre">-&gt;</span></tt> mean that
<tt class="doctest"><span class="pre">fmla2</span></tt> is equivalent to <tt class="doctest"><span class="pre">-girl(x) | walk(x)</span></tt>, which  is satisfied
by something which either isn't a girl
or walks. Since neither <tt class="doctest"><span class="pre">b</span></tt> (Bertie) nor <tt class="doctest"><span class="pre">c</span></tt> (Cyril)
are girls, according to model <tt class="doctest"><span class="pre">m</span></tt>, they both satisfy
the whole formula. And of course <tt class="doctest"><span class="pre">o</span></tt> satisfies the formula because <tt class="doctest"><span class="pre">o</span></tt>
satisfies both disjuncts. Now, since every member of the domain of
discourse satisfies <tt class="doctest"><span class="pre">fmla2</span></tt>, the corresponding universally
quantified formula is also true.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m.evaluate(<span class="pysrc-string">'all x.(girl(x) -&gt; walk(x))'</span>, g)
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In other words, a universally quantified formula &#8704;<span class="mathit">x.</span>&#966; is true with respect to <tt class="doctest"><span class="pre">g</span></tt> just in case for
every <em>u</em>, &#966; is true with respect to <tt class="doctest"><span class="pre">g[u/x]</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try to figure out, first with pencil and paper, and then using
<tt class="doctest"><span class="pre">m.evaluate()</span></tt>, what the truth values are for <tt class="doctest"><span class="pre">all x.(girl(x) &amp;
walk(x))</span></tt> and <tt class="doctest"><span class="pre">exists x.(boy(x) -&gt; walk(x))</span></tt>. Make sure you
understand why they receive these values.</p>
</div>
</div>
<div class="section" id="quantifier-scope-ambiguity">
<h2>3.7&nbsp;&nbsp;&nbsp;Quantifier Scope Ambiguity</h2>
<p>What happens when we want to give a formal representation of a
sentence with <em>two</em> quantifiers, such as the following?</p>
<span class="target" id="ex-scope1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(26)</td><td width="15"></td><td>Everybody admires someone.</td></tr></table></p>
<p>There are (at least) two ways of expressing <a class="reference internal" href="#ex-scope1">(26)</a> in first-order logic:</p>
<span class="target" id="ex-scope2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(27)</td><td width="15"></td><td><span class="target" id="ex-scope2a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">all x.(person(x) -&gt; exists y.(person(y) &amp; admire(x,y)))</span></tt></td></tr></table></p>
<span class="target" id="ex-scope2b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists y.(person(y) &amp; all x.(person(x) -&gt; admire(x,y)))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Can we use both of these? The answer is Yes, but they have different
meanings. <a class="reference internal" href="#ex-scope2b">(27b)</a> is logically stronger than <a class="reference internal" href="#ex-scope2a">(27a)</a>: it claims that
there is a unique person, say Bruce, who is admired by everyone.
<a class="reference internal" href="#ex-scope2a">(27a)</a>, on the other hand, just requires that for every person
<span class="mathit">u</span>, we can find some person <span class="mathit">u'</span> whom <span class="mathit">u</span>
admires; but this could be a different person  <span class="mathit">u'</span> in each case. We
distinguish between <a class="reference internal" href="#ex-scope2a">(27a)</a> and <a class="reference internal" href="#ex-scope2b">(27b)</a> in terms of the <a name="scope_index_term" /><span class="termdef">scope</span>
of the quantifiers. In the first, &#8704; has wider scope than
&#8707;, while in <a class="reference internal" href="#ex-scope2b">(27b)</a>, the scope ordering is reversed. So now we
have two ways of representing the meaning of <a class="reference internal" href="#ex-scope1">(26)</a>, and they are
both quite legitimate. In other words, we are claiming that <a class="reference internal" href="#ex-scope1">(26)</a> is
<em>ambiguous</em> with respect to quantifier scope, and the formulas in
<a class="reference internal" href="#ex-scope2">(27)</a> give us a way to make the two readings explicit.
However, we are not just interested in associating two
distinct representations with <a class="reference internal" href="#ex-scope1">(26)</a>. We also want to show in detail
how the two representations lead to different conditions for truth in
a model.</p>
<p>In order to examine the ambiguity more closely, let's fix our
valuation as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>v2 = <span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-more">... </span><span class="pysrc-string">bruce =&gt; b</span>
<span class="pysrc-more">... </span><span class="pysrc-string">elspeth =&gt; e</span>
<span class="pysrc-more">... </span><span class="pysrc-string">julia =&gt; j</span>
<span class="pysrc-more">... </span><span class="pysrc-string">matthew =&gt; m</span>
<span class="pysrc-more">... </span><span class="pysrc-string">person =&gt; {b, e, j, m}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">admire =&gt; {(j, b), (b, b), (m, e), (e, m)}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>val2 = nltk.Valuation.fromstring(v2)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The <span class="mathit">admire</span> relation can be visualized using the
mapping diagram shown in <a class="reference internal" href="#ex-admire-mapping">(28)</a>.</p>
<span class="target" id="ex-admire-mapping"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(28)</td><td width="15"></td><td><img alt="../images/models_admire.png" src="../images/models_admire.png" style="width: 35.2px; height: 38.400000000000006px;" /></td></tr></table></p>
<p>In <a class="reference internal" href="#ex-admire-mapping">(28)</a>, an arrow between two individuals <span class="math">x</span> and
<span class="math">y</span> indicates that <span class="math">x</span> admires
<span class="math">y</span>. So <tt class="doctest"><span class="pre">j</span></tt> and <tt class="doctest"><span class="pre">b</span></tt> both admire <tt class="doctest"><span class="pre">b</span></tt> (Bruce is very vain), while <tt class="doctest"><span class="pre">e</span></tt> admires
<tt class="doctest"><span class="pre">m</span></tt> and <tt class="doctest"><span class="pre">m</span></tt> admires <tt class="doctest"><span class="pre">e</span></tt>. In this model, formula <a class="reference internal" href="#ex-scope2a">(27a)</a> above
is true but <a class="reference internal" href="#ex-scope2b">(27b)</a> is false. One way of exploring these results is by
using the <tt class="doctest"><span class="pre">satisfiers()</span></tt> method of <tt class="doctest"><span class="pre">Model</span></tt> objects.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dom2 = val2.domain
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m2 = nltk.Model(dom2, val2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g2 = nltk.Assignment(dom2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fmla4 = read_expr(<span class="pysrc-string">'(person(x) -&gt; exists y.(person(y) &amp; admire(x, y)))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m2.satisfiers(fmla4, <span class="pysrc-string">'x'</span>, g2)
<span class="pysrc-output">{'e', 'b', 'm', 'j'}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This shows that <tt class="doctest"><span class="pre">fmla4</span></tt> holds of every individual in the domain.
By contrast, consider the formula <tt class="doctest"><span class="pre">fmla5</span></tt> below; this has no
satisfiers for the variable <tt class="doctest"><span class="pre">y</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fmla5 = read_expr(<span class="pysrc-string">'(person(y) &amp; all x.(person(x) -&gt; admire(x, y)))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m2.satisfiers(fmla5, <span class="pysrc-string">'y'</span>, g2)
<span class="pysrc-output">set()</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>That is, there is no person that is admired by everybody. Taking a
different open formula, <tt class="doctest"><span class="pre">fmla6</span></tt>, we can verify that there is a
person, namely Bruce, who is admired by both Julia and Bruce.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fmla6 = read_expr(<span class="pysrc-string">'(person(y) &amp; all x.((x = bruce | x = julia) -&gt; admire(x, y)))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m2.satisfiers(fmla6, <span class="pysrc-string">'y'</span>, g2)
<span class="pysrc-output">{'b'}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Devise a new model based on <tt class="doctest"><span class="pre">m2</span></tt> such that <a class="reference internal" href="#ex-scope2a">(27a)</a>
comes out false in your model; similarly, devise a new model such that <a class="reference internal" href="#ex-scope2b">(27b)</a>
comes out true.</p>
</div>
</div>
<div class="section" id="model-building">
<h2>3.8&nbsp;&nbsp;&nbsp;Model Building</h2>
<p>We have been assuming that we already had a model, and wanted to check
the truth of a sentence in the model.  By contrast, model building
tries to create a new model, given some set of sentences. If it
succeeds, then we know that the set is consistent, since we have an
existence proof of the model.</p>
<p>We invoke the Mace4 model builder by creating an instance of
<tt class="doctest"><span class="pre">Mace()</span></tt> and calling its <tt class="doctest"><span class="pre">build_model()</span></tt>  method, in an
analogous way to calling the Prover9 theorem prover. One option is to
treat our candidate set of sentences as assumptions, while leaving the
goal unspecified.  The following interaction shows how both
<tt class="doctest"><span class="pre">[a, c1]</span></tt> and <tt class="doctest"><span class="pre">[a, c2]</span></tt> are consistent lists, since Mace succeeds
in building a model for each of them, while <tt class="doctest"><span class="pre">[c1, c2]</span></tt> is
inconsistent.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>a3 = read_expr(<span class="pysrc-string">'exists x.(man(x) &amp; walks(x))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>c1 = read_expr(<span class="pysrc-string">'mortal(socrates)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>c2 = read_expr(<span class="pysrc-string">'-mortal(socrates)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>mb = nltk.Mace(5)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(mb.build_model(None, [a3, c1]))
<span class="pysrc-output">True</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(mb.build_model(None, [a3, c2]))
<span class="pysrc-output">True</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(mb.build_model(None, [c1, c2]))
<span class="pysrc-output">False</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also use the model builder as an adjunct to the theorem prover.
Let's suppose we are trying to prove <tt class="doctest"><span class="pre">S</span></tt> &#8866; <tt class="doctest"><span class="pre">g</span></tt>, i.e. that <tt class="doctest"><span class="pre">g</span></tt> is
logically derivable from assumptions <tt class="doctest"><span class="pre">S = [s1, s2, ..., sn]</span></tt>.  We
can feed this same input to Mace4, and the model builder will try to find a
counterexample, that is, to show that <tt class="doctest"><span class="pre">g</span></tt> does <em>not</em> follow from
<tt class="doctest"><span class="pre">S</span></tt>. So, given this input, Mace4 will try to find a model for the
set <tt class="doctest"><span class="pre">S</span></tt> together with the negation of <tt class="doctest"><span class="pre">g</span></tt>, namely the list <tt class="doctest"><span class="pre">S' =
[s1, s2, ..., sn, -g]</span></tt>. If <tt class="doctest"><span class="pre">g</span></tt> fails to follow from <tt class="doctest"><span class="pre">S</span></tt>, then
Mace4 may well return with a counterexample faster than Prover9
concludes that it cannot find the required proof.  Conversely, if
<tt class="doctest"><span class="pre">g</span></tt> <span class="emphasis">is</span> provable from <tt class="doctest"><span class="pre">S</span></tt>, Mace4 may take a long time
unsuccessfully trying to find a countermodel, and will eventually
give up.</p>
<p>Let's consider a concrete scenario. Our assumptions are the list [<span class="example">There is a
woman that every man loves</span>, <span class="example">Adam is a man</span>, <span class="example">Eve is a
woman</span>]. Our conclusion is <span class="example">Adam loves Eve</span>. Can Mace4 find a
model in which the premises are true but the conclusion is false? In
the following code, we use <tt class="doctest"><span class="pre">MaceCommand()</span></tt> which will let us inspect
the model that has been built.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>a4 = read_expr(<span class="pysrc-string">'exists y. (woman(y) &amp; all x. (man(x) -&gt; love(x,y)))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>a5 = read_expr(<span class="pysrc-string">'man(adam)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>a6 = read_expr(<span class="pysrc-string">'woman(eve)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g = read_expr(<span class="pysrc-string">'love(adam,eve)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>mc = nltk.MaceCommand(g, assumptions=[a4, a5, a6])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>mc.build_model()
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>So the answer is Yes: Mace4 found a countermodel in which there is some woman other than
Eve that Adam loves. But let's have a closer look at Mace4's model,
converted to the format we use for valuations.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(mc.valuation)
<span class="pysrc-output">{'C1': 'b',</span>
<span class="pysrc-output"> 'adam': 'a',</span>
<span class="pysrc-output"> 'eve': 'a',</span>
<span class="pysrc-output"> 'love': {('a', 'b')},</span>
<span class="pysrc-output"> 'man': {('a',)},</span>
<span class="pysrc-output"> 'woman': {('a',), ('b',)}}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The general form of this valuation should be familiar to you: it contains
some individual constants and predicates, each with an appropriate
kind of value. What might be puzzling is the
<tt class="doctest"><span class="pre">C1</span></tt>. This is a &quot;skolem constant&quot; that the model builder introduces as a
representative of the existential quantifier. That is, when the model
builder encountered the <tt class="doctest"><span class="pre">exists y</span></tt> part of <tt class="doctest"><span class="pre">a4</span></tt> above, it knew
that there is some individual <tt class="doctest"><span class="pre">b</span></tt> in the domain which satisfies the open
formula in the body of <tt class="doctest"><span class="pre">a4</span></tt>. However, it doesn't know
whether <tt class="doctest"><span class="pre">b</span></tt> is also the denotation of an individual constant
anywhere else in its input, so it makes up a new name for <tt class="doctest"><span class="pre">b</span></tt> on the fly,
namely  <tt class="doctest"><span class="pre">C1</span></tt>. Now, since our premises said nothing about
the individual constants <tt class="doctest"><span class="pre">adam</span></tt> and <tt class="doctest"><span class="pre">eve</span></tt>, the model builder has decided there is no
reason to treat them as denoting different entities, and they both get mapped
to <tt class="doctest"><span class="pre">a</span></tt>. Moreover, we didn't specify that <tt class="doctest"><span class="pre">man</span></tt> and <tt class="doctest"><span class="pre">woman</span></tt>
denote disjoint sets, so the model builder lets their denotations overlap. This
illustrates quite dramatically the implicit knowledge that we bring to
bear in interpreting our scenario, but which the model builder knows
nothing about.
So let's add a new assumption which makes the sets of men and women disjoint. The model builder
still produces a countermodel, but this time it is more in accord with our intuitions
about the situation:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>a7 = read_expr(<span class="pysrc-string">'all x. (man(x) -&gt; -woman(x))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g = read_expr(<span class="pysrc-string">'love(adam,eve)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>mc = nltk.MaceCommand(g, assumptions=[a4, a5, a6, a7])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>mc.build_model()
<span class="pysrc-output">True</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(mc.valuation)
<span class="pysrc-output">{'C1': 'c',</span>
<span class="pysrc-output"> 'adam': 'a',</span>
<span class="pysrc-output"> 'eve': 'b',</span>
<span class="pysrc-output"> 'love': {('a', 'c')},</span>
<span class="pysrc-output"> 'man': {('a',)},</span>
<span class="pysrc-output"> 'woman': {('c',), ('b',)}}</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>On reflection, we can see that there is nothing in our premises which says that
Eve is the only woman in the domain of discourse, so the countermodel in fact
is acceptable. If we wanted to rule it out, we would have to add a further
assumption such as <tt class="doctest"><span class="pre">exists y. all x. (woman(x) -&gt; (x = y))</span></tt> to ensure that
there is only one woman in the model.</p>
</div>
</div>
<div class="section" id="the-semantics-of-english-sentences">
<span id="sec-evaluating-english-sentences"></span><h1>4&nbsp;&nbsp;&nbsp;The Semantics of English Sentences</h1>
<div class="section" id="compositional-semantics-in-feature-based-grammar">
<h2>4.1&nbsp;&nbsp;&nbsp;Compositional Semantics in Feature-Based Grammar</h2>
<p>At the beginning of the chapter we briefly illustrated a method of
building semantic representations on the basis of a syntactic parse,
using the grammar framework developed in <a class="reference external" href="ch09.html#chap-featgram">9.</a>. This
time, rather than constructing an SQL query, we will build a logical
form. One of our guiding ideas for designing such grammars is the
<a name="principle_of_compositionality_index_term" /><span class="termdef">Principle of Compositionality</span>.  (Also known as Frege's
Principle; see <a class="reference external" href="bibliography.html#partee1995lsc" id="id4">(Gleitman &amp; Liberman, 1995)</a> for the formulation given below.)</p>
<p><strong>Principle of Compositionality:</strong>
The meaning of a whole is a function of the meanings of the parts
and of the way they are syntactically combined.</p>
<p>We will assume that the semantically relevant parts of a complex
expression are given by a theory of syntactic analysis. Within this
chapter, we will take it for granted that expressions are parsed
against a context-free grammar. However, this is not entailed by the
Principle of Compositionality.</p>
<p>Our goal now is integrate the construction of a semantic representation
in a manner that can be smoothly with the process of parsing. <a class="reference internal" href="#ex-sem3">(29)</a>
illustrates a first approximation to the kind of analyses we would
like to build.</p>
<span class="target" id="ex-sem3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(29)</td><td width="15"></td><td><img alt="tree_images/ch10-tree-1.png" class="align-top" src="tree_images/ch10-tree-1.png" /></td></tr></table></p>
<p>In <a class="reference internal" href="#ex-sem3">(29)</a>, the <tt class="doctest"><span class="pre">sem</span></tt> value at the root node shows a semantic
representation for the whole sentence, while the <tt class="doctest"><span class="pre">sem</span></tt> values at
lower nodes show semantic representations for constituents of the
sentence. Since the values of <tt class="doctest"><span class="pre">sem</span></tt> have to be treated in special
manner, they are distinguished from other feature values by being
enclosed in angle brackets.</p>
<p>So far, so good, but how do we write grammar rules which will give us
this kind of result? Our approach will be similar to that adopted for
the grammar <tt class="doctest"><span class="pre">sql0.fcfg</span></tt> at the start of this chapter, in that we
will assign semantic representations to lexical nodes, and then
compose the semantic representations for each phrase from those of its
child nodes. However, in the present case we will use function
application rather than string concatenation as the mode of
composition. To be more specific, suppose we have a <tt class="doctest"><span class="pre">NP</span></tt> and
<tt class="doctest"><span class="pre">VP</span></tt> constituents with appropriate values for their <tt class="doctest"><span class="pre">sem</span></tt>
nodes. Then the <tt class="doctest"><span class="pre">sem</span></tt> value of an <tt class="doctest"><span class="pre">S</span></tt> is handled by a rule like
<a class="reference internal" href="#ex-sem4">(30)</a>. (Observe that in the case where the value of <tt class="doctest"><span class="pre">sem</span></tt> is a
variable, we omit the angle brackets.)</p>
<span class="target" id="ex-sem4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(30)</td><td width="15"></td><td><tt class="doctest"><span class="pre">S[SEM=&lt;?vp(?np)&gt;] -&gt; NP[SEM=?np] VP[SEM=?vp]</span></tt></td></tr></table></p>
<p><a class="reference internal" href="#ex-sem4">(30)</a> tells us that given some <tt class="doctest"><span class="pre">sem</span></tt> value <tt class="doctest"><span class="pre">?np</span></tt> for the subject
<tt class="doctest"><span class="pre">NP</span></tt> and some <tt class="doctest"><span class="pre">sem</span></tt> value <tt class="doctest"><span class="pre">?vp</span></tt> for the <tt class="doctest"><span class="pre">VP</span></tt>, the <tt class="doctest"><span class="pre">sem</span></tt>
value of the <tt class="doctest"><span class="pre">S</span></tt> parent is constructed by applying <tt class="doctest"><span class="pre">?vp</span></tt> as a
function expression to <tt class="doctest"><span class="pre">?np</span></tt>.  From this, we can conclude that <tt class="doctest"><span class="pre">?vp</span></tt> has to
denote a function which has the denotation of <tt class="doctest"><span class="pre">?np</span></tt> in its
domain. <a class="reference internal" href="#ex-sem4">(30)</a> is a nice example of
building semantics using the principle of compositionality.</p>
<p>To complete the grammar is very straightforward; all we require are the
rules shown below.</p>
<pre class="literal-block">
VP[SEM=?v] -&gt; IV[SEM=?v]
NP[SEM=&lt;cyril&gt;] -&gt; 'Cyril'
IV[SEM=&lt;\x.bark(x)&gt;] -&gt; 'barks'
</pre>
<p>The <tt class="doctest"><span class="pre">VP</span></tt> rule says that the parent's semantics is the same as the
head child's semantics. The two lexical rules provide non-logical
constants to serve as the semantic values of <span class="example">Cyril</span> and
<span class="example">barks</span> respectively. There is an additional piece of notation in
the entry for <span class="example">barks</span> which we will explain shortly.</p>
<p>Before launching into compositional semantic rules in more detail, we need to add a
new tool to our kit, namely the &#955; calculus. This provides us with an
invaluable tool for combining expressions of first-order logic as we assemble a meaning
representation for an English sentence.</p>
</div>
<div class="section" id="the-lambda-calculus">
<h2>4.2&nbsp;&nbsp;&nbsp;The &#955;-Calculus</h2>
<p>In <a class="reference external" href="ch01.html#sec-computing-with-language-simple-statistics">3</a>, we pointed out that
mathematical set notation was a helpful method of specifying
properties <span class="math">P</span> of words that we wanted to select from a
document. We illustrated this with <a class="reference internal" href="#ex-set-comprehension-math2">(31)</a>, which we
glossed as &quot;the set of all <span class="math">w</span> such that <span class="math">w</span> is an element
of <span class="math">V</span> (the vocabulary) and <span class="math">w</span> has property <span class="math">P</span>&quot;.</p>
<span class="target" id="ex-set-comprehension-math2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(31)</td><td width="15"></td><td>{<span class="math">w</span> | <span class="math">w</span> &#8712; <span class="math">V</span> &amp; <span class="math">P(w)</span>}</td></tr></table></p>
<p>It turns out to be extremely useful to add something to first-order logic that
will achieve the same effect. We do this with the <a name="&#955;_operator_index_term" /><span class="termdef">&#955; operator</span>
(pronounced &quot;lambda&quot;). The &#955; counterpart to
<a class="reference internal" href="#ex-set-comprehension-math2">(31)</a> is <a class="reference internal" href="#ex-lambda1">(32)</a>. (Since we are not trying
to do set theory here, we just treat <span class="math">V</span> as a unary predicate.)</p>
<span class="target" id="ex-lambda1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(32)</td><td width="15"></td><td>&#955;<span class="math">w</span>. (<span class="math">V(w)</span> &#8743; <span class="math">P(w)</span>)</td></tr></table></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">&#955; expressions were originally designed by Alonzo Church to represent
computable functions and to provide a foundation for mathematics
and logic. The theory in which &#955; expressions are studied is
known as the &#955;-calculus. Note that the &#955;-calculus is
not part of first-order logic &#8212; both can be used independently of the other.</p>
</div>
<p>&#955; is a binding operator, just as the first-order logic quantifiers are. If
we have an open formula such as <a class="reference internal" href="#ex-walk-chewgum11">(33a)</a>, then we can bind
the variable <span class="math">x</span> with the &#955; operator, as shown in
<a class="reference internal" href="#ex-walk-chewgum12">(33b)</a>.  The corresponding NLTK representation is given in
<a class="reference internal" href="#ex-lambda">(33c)</a>.</p>
<span class="target" id="ex-walk-chewgum1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(33)</td><td width="15"></td><td><span class="target" id="ex-walk-chewgum11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>(<span class="mathit">walk(x)</span> &#8743; <span class="mathit">chew_gum(x)</span>)</td></tr></table></p>
<span class="target" id="ex-walk-chewgum12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>&#955;<span class="mathit">x.(walk(x)</span> &#8743; <span class="mathit">chew_gum(x)</span>)</td></tr></table></p>
<span class="target" id="ex-lambda"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\x.(walk(x) &amp; chew_gum(x))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Remember that <tt class="doctest"><span class="pre">\</span></tt> is a special character in Python strings.
We could escape it (with another <tt class="doctest"><span class="pre">\</span></tt>), or else use &quot;raw strings&quot;
(<a class="reference external" href="ch03.html#sec-regular-expressions-word-patterns">3.4</a>):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr = nltk.sem.Expression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr = read_expr(r<span class="pysrc-string">'\x.(walk(x) &amp; chew_gum(x))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr
<span class="pysrc-output">&lt;LambdaExpression \x.(walk(x) &amp; chew_gum(x))&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>expr.free()
<span class="pysrc-output">set()</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(read_expr(r<span class="pysrc-string">'\x.(walk(x) &amp; chew_gum(y))'</span>))
<span class="pysrc-output">\x.(walk(x) &amp; chew_gum(y))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX next sentence has a bad linebreak: ab-straction (tweak?) -->
<p>We have a special name for the result of binding the variables in an
expression: <a name="&#955;_abstraction_index_term" /><span class="termdef">&#955; abstraction</span>. When you first encounter
&#955;-abstracts, it can be hard to get an intuitive sense of their
meaning. A couple of English glosses for <a class="reference internal" href="#ex-walk-chewgum12">(33b)</a> are: &quot;be
an <span class="math">x</span> such that <span class="math">x</span> walks and <span class="math">x</span> chews gum&quot; or
&quot;have the property of walking and chewing gum&quot;.  It has often been suggested
that &#955;-abstracts are good representations for verb phrases (or
subjectless clauses), particularly when these occur as arguments in
their own right. This is illustrated in <a class="reference internal" href="#ex-walk-chewgum21">(34a)</a> and its
translation <a class="reference internal" href="#ex-walk-chewgum22">(34b)</a>.</p>
<span class="target" id="ex-walk-chewgum2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(34)</td><td width="15"></td><td><span class="target" id="ex-walk-chewgum21"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>To walk and chew-gum is hard</td></tr></table></p>
<span class="target" id="ex-walk-chewgum22"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">hard(\x.(walk(x) &amp; chew_gum(x)))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>So the general picture is this: given an open formula &#966; with
free variable <span class="math">x</span>, abstracting over <span class="math">x</span> yields a property
expression &#955;<span class="math">x.</span>&#966; &#8212; the property of being
an <span class="math">x</span> such that &#966;. Here's a more official version of how abstracts are built:</p>
<!-- XXX strange formatting of next paragraph, with initial "#." deleted, for docbook processing -->
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(35)</td><td width="15"></td><td>If &#945; is of type &#964;, and <span class="math">x</span> is a variable of type e, then
<tt class="doctest"><span class="pre">\x.</span></tt>&#945; is of type &#9001;<span class="mathit">e</span>, &#964;&#9002;.</td></tr></table></p>
<p><a class="reference internal" href="#ex-walk-chewgum22">(34b)</a> illustrated a case where we say something about a property, namely
that it is hard. But what we usually do with properties is attribute them to
individuals. And in fact if &#966; is an open formula, then the abstract &#955;<span class="math">x.</span>&#966; can be used as a unary predicate. In <a class="reference internal" href="#ex-walk-chewgum3">(36)</a>,
<a class="reference internal" href="#ex-walk-chewgum12">(33b)</a> is predicated of the term <span class="mathit">gerald</span>.</p>
<span class="target" id="ex-walk-chewgum3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(36)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\x.(walk(x) &amp; chew_gum(x)) (gerald)</span></tt></td></tr></table></p>
<p>Now <a class="reference internal" href="#ex-walk-chewgum3">(36)</a> says that Gerald has the property of walking and chewing gum,
which has the same meaning as <a class="reference internal" href="#ex-walk-chewgum4">(37)</a>.</p>
<span class="target" id="ex-walk-chewgum4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(37)</td><td width="15"></td><td><tt class="doctest"><span class="pre">(walk(gerald) &amp; chew_gum(gerald))</span></tt></td></tr></table></p>
<p>What we have done here is remove the <tt class="doctest"><span class="pre">\x</span></tt> from the beginning of <tt class="doctest"><span class="pre">\x.(walk(x) &amp;
chew_gum(x))</span></tt> and replaced all occurrences of <tt class="doctest"><span class="pre">x</span></tt> in <tt class="doctest"><span class="pre">(walk(x) &amp;
chew_gum(x))</span></tt> by <tt class="doctest"><span class="pre">gerald</span></tt>. We'll use &#945;[&#946;<span class="mathit">/x</span>] as
notation for the operation of replacing all free occurrences of  <span class="mathit">x</span> in
&#945; by the expression &#946;. So:</p>
<pre class="literal-block">
(walk(x) &amp; chew_gum(x))[gerald/x]
</pre>
<p>is the same expression as <a class="reference internal" href="#ex-walk-chewgum4">(37)</a>.  The &quot;reduction&quot; of <a class="reference internal" href="#ex-walk-chewgum3">(36)</a> to
<a class="reference internal" href="#ex-walk-chewgum4">(37)</a> is an extremely useful operation in simplifying semantic
representations, and we shall use it a lot in the rest of this chapter. The operation
is often called <a name="&#946;_reduction_index_term" /><span class="termdef">&#946;-reduction</span>. In order for it to be semantically justified, we
want it to hold that &#955;<span class="math">x.</span> &#945;(&#946;) has the same semantic
values as &#945;[&#946;<span class="math">/x</span>]. This is indeed true, subject to a slight
complication that we will come to shortly.  In order to carry of &#946;-reduction of
expressions in NLTK, we can call the <tt class="doctest"><span class="pre">simplify()</span></tt> method <a class="reference internal" href="#simplify"><span id="ref-simplify"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr = read_expr(r<span class="pysrc-string">'\x.(walk(x) &amp; chew_gum(x))(gerald)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr)
<span class="pysrc-output">\x.(walk(x) &amp; chew_gum(x))(gerald)</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr.simplify()) <a name="simplify" /><a href="#ref-simplify"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">(walk(gerald) &amp; chew_gum(gerald))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Although we have so far only considered cases where the body of the
&#955; abstract is an open formula, i.e., of type <span class="math">t</span>, this is not a
necessary restriction; the body can be any well-formed
expression. Here's an example with two &#955;s.</p>
<span class="target" id="ex-double-lambda"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(38)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\x.\y.(dog(x) &amp; own(y, x))</span></tt></td></tr></table></p>
<p>Just as <a class="reference internal" href="#ex-walk-chewgum12">(33b)</a> plays the role of a unary predicate,
<a class="reference internal" href="#ex-double-lambda">(38)</a> works like a binary predicate: it can be applied directly to
two arguments <a class="reference internal" href="#dbl-lambda"><span id="ref-dbl-lambda"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>. Logical expressions may contain nested &#955;s  such as <tt class="doctest"><span class="pre">\x.\y.</span></tt> to be
written in the abbreviated form <tt class="doctest"><span class="pre">\x y.</span></tt> <a class="reference internal" href="#dbl-lambda"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(read_expr(r<span class="pysrc-string">'\x.\y.(dog(x) &amp; own(y, x))(cyril)'</span>).simplify())
<span class="pysrc-output">\y.(dog(cyril) &amp; own(y,cyril))</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(read_expr(r<span class="pysrc-string">'\x y.(dog(x) &amp; own(y, x))(cyril, angus)'</span>).simplify()) <a name="dbl-lambda" /><a href="#ref-dbl-lambda"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">(dog(cyril) &amp; own(angus,cyril))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>All our &#955; abstracts so far have involved the familiar first order variables:
<tt class="doctest"><span class="pre">x</span></tt>, <tt class="doctest"><span class="pre">y</span></tt> and so on &#8212; variables of type <em>e</em>. But suppose we want to treat one abstract, say
<tt class="doctest"><span class="pre">\x.walk(x)</span></tt> as the
<span class="emphasis">argument</span> of another &#955; abstract? We might try this:</p>
<pre class="literal-block">
\y.y(angus)(\x.walk(x))
</pre>
<p>But since the variable <tt class="doctest"><span class="pre">y</span></tt> is stipulated to be of type <em>e</em>,
<tt class="doctest"><span class="pre">\y.y(angus)</span></tt> only applies to arguments of type  <em>e</em>  while <tt class="doctest"><span class="pre">\x.walk(x)</span></tt> is
of type &#9001;<em>e</em>, <em>t</em>&#9002;! Instead, we need to allow
abstraction over variables of higher type. Let's use <tt class="doctest"><span class="pre">P</span></tt> and <tt class="doctest"><span class="pre">Q</span></tt> as variables of
type  &#9001;<em>e</em>, <em>t</em>&#9002;, and then we can have an abstract such as
<tt class="doctest"><span class="pre">\P.P(angus)</span></tt>. Since <tt class="doctest"><span class="pre">P</span></tt> is of
type  &#9001;<em>e</em>, <em>t</em>&#9002;, the whole abstract is of type &#9001;&#9001;<em>e</em>, <em>t</em>&#9002;, <em>t</em>&#9002;. Then <tt class="doctest"><span class="pre">\P.P(angus)(\x.walk(x))</span></tt> is legal, and can
be simplified via &#946;-reduction to <tt class="doctest"><span class="pre">\x.walk(x)(angus)</span></tt> and then again to <tt class="doctest"><span class="pre">walk(angus)</span></tt></p>
<p>When carrying out &#946;-reduction, some care has to be taken with
variables. Consider, for example, the &#955; terms <a class="reference internal" href="#ex-alpha1a">(39a)</a> and
<a class="reference internal" href="#ex-alpha1b">(39b)</a>, which differ only in the identity of a free variable.</p>
<span class="target" id="ex-alpha1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(39)</td><td width="15"></td><td><span class="target" id="ex-alpha1a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\y.see(y, x)</span></tt></td></tr></table></p>
<span class="target" id="ex-alpha1b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\y.see(y, z)</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Suppose now that we apply the &#955;-term <tt class="doctest"><span class="pre">\P.exists x.P(x)</span></tt> to each of these terms:</p>
<span class="target" id="ex-alpha2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(40)</td><td width="15"></td><td><span class="target" id="ex-alpha2a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.P(x)(\y.see(y, x))</span></tt></td></tr></table></p>
<span class="target" id="ex-alpha2b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.P(x)(\y.see(y, z))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>We pointed out earlier that the results of the application should be semantically
equivalent.
But if we let the free variable <tt class="doctest"><span class="pre">x</span></tt> in <a class="reference internal" href="#ex-alpha1a">(39a)</a> fall inside the scope of the
existential quantifier in <a class="reference internal" href="#ex-alpha2a">(40a)</a>, then after reduction, the results
will be different:</p>
<span class="target" id="ex-alpha3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(41)</td><td width="15"></td><td><span class="target" id="ex-alpha3a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.see(x, x)</span></tt></td></tr></table></p>
<span class="target" id="ex-alpha3b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.see(x, z)</span></tt></td></tr></table></p>
</td></tr></table></p>
<p><a class="reference internal" href="#ex-alpha3a">(41a)</a> means there is some <tt class="doctest"><span class="pre">x</span></tt> that sees him/herself, whereas
<a class="reference internal" href="#ex-alpha3b">(41b)</a> means that there is some <tt class="doctest"><span class="pre">x</span></tt> that sees an unspecified
individual <tt class="doctest"><span class="pre">z</span></tt>. What has gone wrong here? Clearly, we want to forbid
the kind of variable &quot;capture&quot; shown in <a class="reference internal" href="#ex-alpha3a">(41a)</a>.</p>
<p>In order to deal with this problem, let's step back a moment. Does it matter what
particular name we use for the variable bound
by the existential quantifier in the function expression of <a class="reference internal" href="#ex-alpha2a">(40a)</a>? The answer is No.
In fact, given any variable-binding expression (involving &#8704;,
&#8707; or &#955;), the name chosen for the bound
variable is completely arbitrary. For example, <tt class="doctest"><span class="pre">exists x.P(x)</span></tt> and
<tt class="doctest"><span class="pre">exists y.P(y)</span></tt> are equivalent; they are called <a name="&#945;_equivalents_index_term" /><span class="termdef">&#945; equivalents</span>,
or <a name="alphabetic_variants_index_term" /><span class="termdef">alphabetic variants</span>. The process of relabeling bound
variables is known as <a name="&#945;_conversion_index_term" /><span class="termdef">&#945;-conversion</span>. When we test for equality of
<tt class="doctest"><span class="pre">VariableBinderExpression</span></tt>s in the <tt class="doctest"><span class="pre">logic</span></tt> module (i.e., using
<tt class="doctest"><span class="pre">==</span></tt>), we are in fact testing for &#945;-equivalence:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr1 = read_expr(<span class="pysrc-string">'exists x.P(x)'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr1)
<span class="pysrc-output">exists x.P(x)</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>expr2 = expr1.alpha_convert(nltk.sem.Variable(<span class="pysrc-string">'z'</span>))
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr2)
<span class="pysrc-output">exists z.P(z)</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>expr1 == expr2
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>When &#946;-reduction is carried out on an application
<tt class="doctest"><span class="pre">f(a)</span></tt>, we check whether there are free variables in <tt class="doctest"><span class="pre">a</span></tt>
which also occur as bound variables in any subterms of
<tt class="doctest"><span class="pre">f</span></tt>. Suppose, as in the example discussed above, that
<tt class="doctest"><span class="pre">x</span></tt> is free in <tt class="doctest"><span class="pre">a</span></tt>, and that <tt class="doctest"><span class="pre">f</span></tt> contains the
subterm <tt class="doctest"><span class="pre">exists x.P(x)</span></tt>. In this case, we
produce an alphabetic variant of <tt class="doctest"><span class="pre">exists x.P(x)</span></tt>,
say, <tt class="doctest"><span class="pre">exists z1.P(z1)</span></tt>, and then
carry on with the reduction. This relabeling is carried out
automatically by the &#946;-reduction code in <tt class="doctest"><span class="pre">logic</span></tt>, and the
results can be seen in the following example.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>expr3 = read_expr(<span class="pysrc-string">'\P.(exists x.P(x))(\y.see(y, x))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr3)
<span class="pysrc-output">(\P.exists x.P(x))(\y.see(y,x))</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(expr3.simplify())
<span class="pysrc-output">exists z1.see(z1,x)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As you work through examples like these in the following sections, you may
find that the logical expressions which are returned have different variable
names; for example you might see <tt class="doctest"><span class="pre">z14</span></tt> in place of <tt class="doctest"><span class="pre">z1</span></tt> in the above
formula. This change in labeling is innocuous &#8212; in fact, it is just an
illustration of alphabetic variants.</p>
</div>
<p>After this excursus, let's return to the task of building logical forms for English
sentences.</p>
</div>
<div class="section" id="quantified-nps">
<h2>4.3&nbsp;&nbsp;&nbsp;Quantified NPs</h2>
<p>At the start of this section, we briefly described how to build a semantic
representation for <span class="example">Cyril barks</span>. You would be forgiven for thinking this was all
too easy &#8212; surely there is a bit more to building compositional semantics. What
about quantifiers, for instance? Right, this is a crucial issue. For example, we want
<a class="reference internal" href="#ex-sem5a">(42a)</a> to be given the logical form in <a class="reference internal" href="#ex-sem5b">(42b)</a>. How can this be accomplished?</p>
<span class="target" id="ex-sem5"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(42)</td><td width="15"></td><td><span class="target" id="ex-sem5a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>A dog barks.</td></tr></table></p>
<span class="target" id="ex-sem5b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists x.(dog(x) &amp; bark(x))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>Let's make the assumption that our <span class="emphasis">only</span> operation for building
complex semantic representations is function
application. Then our problem is this: how do we give a semantic
representation to the quantified <tt class="doctest"><span class="pre">NP</span></tt>s <span class="example">a dog</span> so that
it can be combined with <tt class="doctest"><span class="pre">bark</span></tt> to give the result
in <a class="reference internal" href="#ex-sem5b">(42b)</a>? As a first step, let's make the subject's <tt class="doctest"><span class="pre">sem</span></tt> value
act as the function expression rather than the argument. (This is sometimes called
<a name="type_raising_index_term" /><span class="termdef">type-raising</span>.) Now we are
looking for way of instantiating <tt class="doctest"><span class="pre">?np</span></tt> so that <tt class="doctest"><span class="pre">[SEM=&lt;?np(\x.bark(x))&gt;]</span></tt>
is equivalent
to <tt class="doctest"><span class="pre">[SEM=&lt;exists x.(dog(x) &amp; bark(x))&gt;]</span></tt>.
Doesn't this look a bit reminiscent of carrying out &#946;-reduction
in the &#955;-calculus? In other words, we want a &#955; term
<span class="mathit">M</span> to replace <tt class="doctest"><span class="pre">?np</span></tt> so that applying <span class="mathit">M</span> to
<tt class="doctest"><span class="pre"><span class="pysrc-string">'bark'</span></span></tt> yields <a class="reference internal" href="#ex-sem5b">(42b)</a>.  To do this, we replace the occurrence of
<tt class="doctest"><span class="pre"><span class="pysrc-string">'bark'</span></span></tt> in <a class="reference internal" href="#ex-sem5b">(42b)</a> by a predicate variable <tt class="doctest"><span class="pre"><span class="pysrc-string">'P'</span></span></tt>, and bind the variable with
&#955;, as shown in <a class="reference internal" href="#ex-sem7">(43)</a>.</p>
<span class="target" id="ex-sem7"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(43)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.(dog(x) &amp; P(x))</span></tt></td></tr></table></p>
<p>We have used a different style of variable in
<a class="reference internal" href="#ex-sem7">(43)</a> &#8212; that is <tt class="doctest"><span class="pre"><span class="pysrc-string">'P'</span></span></tt> rather than <tt class="doctest"><span class="pre"><span class="pysrc-string">'x'</span></span></tt> or <tt class="doctest"><span class="pre"><span class="pysrc-string">'y'</span></span></tt> &#8212; to signal
that we are abstracting over a different kind of object &#8212; not an
individual, but a function expression of type  &#9001;<span class="mathit">e</span>, <span class="mathit">t</span>&#9002;. So the type of
<a class="reference internal" href="#ex-sem7">(43)</a> as a whole is  &#9001;&#9001;<span class="mathit">e</span>, <span class="mathit">t</span>&#9002;, <span class="mathit">t</span>&#9002;. We
will take this to be the type of <tt class="doctest"><span class="pre">NP</span></tt>s in general. To illustrate
further, a universally quantified <tt class="doctest"><span class="pre">NP</span></tt> will look like <a class="reference internal" href="#ex-sem7univ">(44)</a>.</p>
<span class="target" id="ex-sem7univ"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(44)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.all x.(dog(x) -&gt; P(x))</span></tt></td></tr></table></p>
<p>We are pretty much done now, except that we also want to carry out a
further abstraction plus application for the process of combining the
semantics of the determiner <span class="example">a</span>, namely <a class="reference internal" href="#ex-sem7">(43)</a>, with the semantics of
<span class="example">dog</span>.</p>
<span class="target" id="ex-sem7det"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(45)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\Q P.exists x.(Q(x) &amp; P(x))</span></tt></td></tr></table></p>
<p>Applying <a class="reference internal" href="#ex-sem8">(46)</a> as a function expression to <tt class="doctest"><span class="pre">dog</span></tt> yields <a class="reference internal" href="#ex-sem7">(43)</a>, and applying
that to <tt class="doctest"><span class="pre">bark</span></tt> gives us
<tt class="doctest"><span class="pre">\P.exists x.(dog(x) &amp; P(x))(\x.bark(x))</span></tt>. Finally, carrying out
&#946;-reduction
yields just what we wanted, namely <a class="reference internal" href="#ex-sem5b">(42b)</a>.</p>
</div>
<div class="section" id="transitive-verbs">
<h2>4.4&nbsp;&nbsp;&nbsp;Transitive Verbs</h2>
<p>Our next challenge is to deal with sentences containing transitive
verbs, such as <a class="reference internal" href="#ex-sem8">(46)</a>.</p>
<span class="target" id="ex-sem8"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(46)</td><td width="15"></td><td>Angus chases a dog.</td></tr></table></p>
<p>The output semantics that we want to build is <tt class="doctest"><span class="pre">exists x.(dog(x) &amp; chase(angus, x))</span></tt>.
Let's look at how we can use &#955;-abstraction to get this
result. A significant constraint on possible solutions is to require
that the semantic representation of <span class="example">a dog</span> be independent of
whether the <tt class="doctest"><span class="pre">NP</span></tt> acts as subject or object of the sentence. In
other words, we want to get the formula above as our output while sticking to
<a class="reference internal" href="#ex-sem7">(43)</a> as the <tt class="doctest"><span class="pre">NP</span></tt> semantics. A second constraint is that
<tt class="doctest"><span class="pre">VP</span></tt>s should have a uniform type of interpretation regardless
of whether they consist of just an intransitive verb or a transitive
verb plus object. More specifically, we stipulate that <tt class="doctest"><span class="pre">VP</span></tt>s
are always of type &#9001;<em>e</em>, <em>t</em>&#9002;. Given these
constraints, here's a semantic representation for <span class="example">chases a dog</span>
which does the trick.</p>
<span class="target" id="ex-sem99"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(47)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\y.exists x.(dog(x) &amp; chase(y, x))</span></tt></td></tr></table></p>
<p>Think of <a class="reference internal" href="#ex-sem99">(47)</a> as the property of being a <span class="math">y</span> such that
for some dog <span class="math">x</span>, <span class="math">y</span> chases <span class="math">x</span>; or more
colloquially, being a <span class="math">y</span> who chases a dog. Our task now
resolves to designing a semantic representation for
<span class="example">chases</span> which can combine with <a class="reference internal" href="#ex-sem7">(43)</a> so as to allow
<a class="reference internal" href="#ex-sem99">(47)</a> to be derived.</p>
<p>Let's carry out the inverse of &#946;-reduction on <a class="reference internal" href="#ex-sem99">(47)</a>,
giving rise to <a class="reference internal" href="#ex-sem10">(48)</a>.</p>
<span class="target" id="ex-sem10"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(48)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.exists x.(dog(x) &amp; P(x))(\z.chase(y, z))</span></tt></td></tr></table></p>
<p><a class="reference internal" href="#ex-sem10">(48)</a> may be slightly hard to read at first; you need to see that
it involves applying the quantified <tt class="doctest"><span class="pre">NP</span></tt> representation from
<a class="reference internal" href="#ex-sem7">(43)</a> to <tt class="doctest"><span class="pre">\z.chase(y,z)</span></tt>. <a class="reference internal" href="#ex-sem10">(48)</a> is
equivalent via &#946;-reduction to <tt class="doctest"><span class="pre">exists x.(dog(x) &amp; chase(y, x))</span></tt>.</p>
<p>Now let's replace the function expression in <a class="reference internal" href="#ex-sem10">(48)</a> by a variable <tt class="doctest"><span class="pre">X</span></tt> of the
same type as an <tt class="doctest"><span class="pre">NP</span></tt>; that is, of type
&#9001;&#9001;<em>e</em>, <em>t</em>&#9002;, <em>t</em>&#9002;.</p>
<span class="target" id="ex-sem11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(49)</td><td width="15"></td><td><tt class="doctest"><span class="pre">X(\z.chase(y, z))</span></tt></td></tr></table></p>
<p>The representation of a transitive verb will have to apply to
an argument of the type of <tt class="doctest"><span class="pre">X</span></tt> to yield a function expression of the type of
<tt class="doctest"><span class="pre">VP</span></tt>s, that is, of type &#9001;<em>e</em>, <em>t</em>&#9002;. We can ensure
this by abstracting over both the <tt class="doctest"><span class="pre">X</span></tt> variable in <a class="reference internal" href="#ex-sem11">(49)</a> and also
the subject variable <tt class="doctest"><span class="pre">y</span></tt>. So the full solution is reached by
giving <span class="example">chases</span> the semantic representation shown in <a class="reference internal" href="#ex-sem12">(50)</a>.</p>
<span class="target" id="ex-sem12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(50)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\X y.X(\x.chase(y, x))</span></tt></td></tr></table></p>
<p>If <a class="reference internal" href="#ex-sem12">(50)</a> is applied to <a class="reference internal" href="#ex-sem7">(43)</a>, the result after &#946;-reduction is
equivalent to <a class="reference internal" href="#ex-sem99">(47)</a>, which is what we wanted all along:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr = nltk.sem.Expression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tvp = read_expr(r<span class="pysrc-string">'\X x.X(\y.chase(x,y))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>np = read_expr(r<span class="pysrc-string">'(\P.exists x.(dog(x) &amp; P(x)))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>vp = nltk.sem.ApplicationExpression(tvp, np)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(vp)
<span class="pysrc-output">(\X x.X(\y.chase(x,y)))(\P.exists x.(dog(x) &amp; P(x)))</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(vp.simplify())
<span class="pysrc-output">\x.exists z2.(dog(z2) &amp; chase(x,z2))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In order to build a semantic representation for a sentence, we also
need to combine in the semantics of the subject <tt class="doctest"><span class="pre">NP</span></tt>. If the
latter is a quantified expression like <span class="example">every girl</span>, everything
proceeds in the same way as we showed for <span class="example">a dog barks</span> earlier
on; the subject is translated as a function expression which is applied to the
semantic representation of the <tt class="doctest"><span class="pre">VP</span></tt>.  However, we now seem to have
created another problem for ourselves with proper names. So far, these
have been treated semantically as individual constants, and these
cannot be applied as functions to expressions like
<a class="reference internal" href="#ex-sem99">(47)</a>. Consequently, we need to come up with a different semantic
representation for them. What we do
in this case is re-interpret proper names so that they too are
function expressions, like quantified <tt class="doctest"><span class="pre">NP</span></tt>s. Here is the required
&#955; expression for <span class="example">Angus</span>.</p>
<span class="target" id="ex-sem13"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(51)</td><td width="15"></td><td><tt class="doctest"><span class="pre">\P.P(angus)</span></tt></td></tr></table></p>
<p><a class="reference internal" href="#ex-sem13">(51)</a> denotes the characteristic function corresponding to the set of
all properties which are true of Angus. Converting from an individual
constant <tt class="doctest"><span class="pre">angus</span></tt> to <tt class="doctest"><span class="pre">\P.P(angus)</span></tt> is another example of
type-raising, briefly mentioned earlier, and allows us to replace a
Boolean-valued application such as <tt class="doctest"><span class="pre">\x.walk(x)(angus)</span></tt> with an
equivalent function application <tt class="doctest"><span class="pre">\P.P(angus)(\x.walk(x))</span></tt>. By
&#946;-reduction, both expressions reduce to <tt class="doctest"><span class="pre">walk(angus)</span></tt>.</p>
<!-- >>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<p>The grammar <tt class="doctest"><span class="pre">simple-sem.fcfg</span></tt> contains a small set of rules for parsing
and translating simple examples of the kind that we have been looking
at. Here's a slightly more complicated example.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk <span class="pysrc-keyword">import</span> load_parser
<span class="pysrc-prompt">&gt;&gt;&gt; </span>parser = load_parser(<span class="pysrc-string">'grammars/book_grammars/simple-sem.fcfg'</span>, trace=0)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sentence = <span class="pysrc-string">'Angus gives a bone to every dog'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = sentence.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> parser.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree.label()[<span class="pysrc-string">'SEM'</span>])
<span class="pysrc-output">all z2.(dog(z2) -&gt; exists z1.(bone(z1) &amp; give(angus,z1,z2)))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>NLTK provides some utilities to make it easier to derive and inspect
semantic interpretations. The function <tt class="doctest"><span class="pre">interpret_sents()</span></tt> is
intended for interpretation of a list of input sentences. It
builds a dictionary <tt class="doctest"><span class="pre">d</span></tt> where for each sentence <tt class="doctest"><span class="pre">sent</span></tt> in the
input, <tt class="doctest"><span class="pre">d[sent]</span></tt> is a list of pairs (<em>synrep</em>, <em>semrep</em>) consisting
of trees and semantic representations for <tt class="doctest"><span class="pre">sent</span></tt>. The value
is a list since <tt class="doctest"><span class="pre">sent</span></tt> may be syntactically ambiguous; in the
following example, however, there is only one parse tree per sentence
in the list.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sents = [<span class="pysrc-string">'Irene walks'</span>, <span class="pysrc-string">'Cyril bites an ankle'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>grammar_file = <span class="pysrc-string">'grammars/book_grammars/simple-sem.fcfg'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> results <span class="pysrc-keyword">in</span> nltk.interpret_sents(sents, grammar_file):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">for</span> (synrep, semrep) <span class="pysrc-keyword">in</span> results:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span>(synrep)
<span class="pysrc-output">(S[SEM=&lt;walk(irene)&gt;]</span>
<span class="pysrc-output">  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(irene)&gt;]</span>
<span class="pysrc-output">    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(irene)&gt;] Irene))</span>
<span class="pysrc-output">  (VP[NUM='sg', SEM=&lt;\x.walk(x)&gt;]</span>
<span class="pysrc-output">    (IV[NUM='sg', SEM=&lt;\x.walk(x)&gt;, TNS='pres'] walks)))</span>
<span class="pysrc-output">(S[SEM=&lt;exists z3.(ankle(z3) &amp; bite(cyril,z3))&gt;]</span>
<span class="pysrc-output">  (NP[-LOC, NUM='sg', SEM=&lt;\P.P(cyril)&gt;]</span>
<span class="pysrc-output">    (PropN[-LOC, NUM='sg', SEM=&lt;\P.P(cyril)&gt;] Cyril))</span>
<span class="pysrc-output">  (VP[NUM='sg', SEM=&lt;\x.exists z3.(ankle(z3) &amp; bite(x,z3))&gt;]</span>
<span class="pysrc-output">    (TV[NUM='sg', SEM=&lt;\X x.X(\y.bite(x,y))&gt;, TNS='pres'] bites)</span>
<span class="pysrc-output">    (NP[NUM='sg', SEM=&lt;\Q.exists x.(ankle(x) &amp; Q(x))&gt;]</span>
<span class="pysrc-output">      (Det[NUM='sg', SEM=&lt;\P Q.exists x.(P(x) &amp; Q(x))&gt;] an)</span>
<span class="pysrc-output">      (Nom[NUM='sg', SEM=&lt;\x.ankle(x)&gt;]</span>
<span class="pysrc-output">        (N[NUM='sg', SEM=&lt;\x.ankle(x)&gt;] ankle)))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We have seen now how to convert English sentences into logical forms, and
earlier we saw how logical forms could be checked as true or false in a
model. Putting these two mappings together, we can check the truth
value of English sentences in a given model. Let's take model <tt class="doctest"><span class="pre">m</span></tt> as
defined above. The utility <tt class="doctest"><span class="pre">evaluate_sents()</span></tt> resembles
<tt class="doctest"><span class="pre">interpret_sents()</span></tt> except that we need to pass a model and a
variable assignment as parameters. The output is a triple  (<em>synrep</em>,
<em>semrep</em>, <em>value</em>) where <em>synrep</em>,
<em>semrep</em> are as before, and <em>value</em> is a truth value. For simplicity,
the following example only processes a single sentence.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>v = <span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-more">... </span><span class="pysrc-string">bertie =&gt; b</span>
<span class="pysrc-more">... </span><span class="pysrc-string">olive =&gt; o</span>
<span class="pysrc-more">... </span><span class="pysrc-string">cyril =&gt; c</span>
<span class="pysrc-more">... </span><span class="pysrc-string">boy =&gt; {b}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">girl =&gt; {o}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">dog =&gt; {c}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">walk =&gt; {o, c}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">see =&gt; {(b, o), (c, b), (o, c)}</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>val = nltk.Valuation.fromstring(v)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>g = nltk.Assignment(val.domain)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>m = nltk.Model(val.domain, val)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">'Cyril sees every boy'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>grammar_file = <span class="pysrc-string">'grammars/book_grammars/simple-sem.fcfg'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>results = nltk.evaluate_sents([sent], grammar_file, m, g)[0]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> (syntree, semrep, value) <span class="pysrc-keyword">in</span> results:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(semrep)
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(value)
<span class="pysrc-output">all z4.(boy(z4) -&gt; see(cyril,z4))</span>
<span class="pysrc-output">True</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX seems strange to use evaluate_sents() for a single sentence. -->
</div>
<div class="section" id="quantifier-ambiguity-revisited">
<h2>4.5&nbsp;&nbsp;&nbsp;Quantifier Ambiguity Revisited</h2>
<!-- try not to increment the variable indexes

>>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<p>One important limitation of the methods described above is
that they do not deal with scope ambiguity. Our translation method is
syntax-driven, in the sense that the semantic representation is
closely coupled with the syntactic analysis, and the scope of
the quantifiers in the semantics therefore reflects the relative scope of
the corresponding <tt class="doctest"><span class="pre">NP</span></tt> s in the syntactic parse tree.
Consequently, a sentence like <a class="reference internal" href="#ex-scope1">(26)</a>, repeated here, will always
be translated as <a class="reference internal" href="#ex-scope12a">(53a)</a>, not <a class="reference internal" href="#ex-scope12b">(53b)</a>.</p>
<span class="target" id="ex-scope11"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(52)</td><td width="15"></td><td>Every girl chases a dog.</td></tr></table></p>
<span class="target" id="ex-scope12"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(53)</td><td width="15"></td><td><span class="target" id="ex-scope12a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">all x.(girl(x) -&gt; exists y.(dog(y) &amp; chase(x,y)))</span></tt></td></tr></table></p>
<span class="target" id="ex-scope12b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">exists y.(dog(y) &amp; all x.(girl(x) -&gt; chase(x,y)))</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>There are numerous approaches to dealing with scope ambiguity, and we
will look very briefly at one of the simplest. To start with, let's
briefly consider the structure of scoped formulas. <a class="reference internal" href="#fig-quant-ambig">4.1</a>
depicts the way in which the two readings of <a class="reference internal" href="#ex-scope11">(52)</a> differ.</p>
<span class="target" id="fig-quant-ambig"></span><div class="figure" id="fig-quant-ambig">
<img alt="../images/quant-ambig.png" src="../images/quant-ambig.png" style="width: 623.4000000000001px; height: 208.4px;" />
<p class="caption"><span class="caption-label">Figure 4.1</span>: Quantifier Scopings</p>
</div>
<p>Let's consider the left hand structure first. At the top, we have the
quantifier corresponding to <span class="example">every girl</span>. The &#966; can be thought
of as a placeholder for whatever is inside the scope of the
quantifier. Moving downwards, we see that we can plug in the
quantifier corresponding to <span class="example">a dog</span> as an instantiation of
&#966;. This gives a new placeholder &#968;, representing the scope of
<span class="example">a dog</span>, and into this we can plug the 'core' of the semantics,
namely the open sentence corresponding to <span class="mathit">x</span> <span class="example">chases</span>
<span class="mathit">y</span>. The structure on the right hand side is identical, except we have
swapped round the order of the two quantifiers.</p>
<p>In the method known as <a name="cooper_storage_index_term" /><span class="termdef">Cooper storage</span>, a semantic
representation is no longer an expression of first-order logic, but instead a pair
consisting of a &quot;core&quot; semantic representation plus a list of <a name="binding_operators_index_term" /><span class="termdef">binding
operators</span>. For the moment, think of a binding operator as being
identical to the semantic representation of a quantified <tt class="doctest"><span class="pre">NP</span></tt> such
as <a class="reference internal" href="#ex-sem7univ">(44)</a> or <a class="reference internal" href="#ex-sem7det">(45)</a>. Following along the lines indicated in
<a class="reference internal" href="#fig-quant-ambig">4.1</a>, let's assume that we have constructed a
Cooper-storage style semantic representation of sentence <a class="reference internal" href="#ex-scope11">(52)</a>, and
let's take our core to be the open formula <tt class="doctest"><span class="pre">chase(x,y)</span></tt>. Given a
list of binding operators corresponding to the two <tt class="doctest"><span class="pre">NP</span></tt>s in
<a class="reference internal" href="#ex-scope11">(52)</a>, we pick a binding operator off the list, and combine it with
the core.</p>
<pre class="literal-block">
\P.exists y.(dog(y) &amp; P(y))(\z2.chase(z1,z2))
</pre>
<p>Then we take the result, and apply the next binding operator from the
list to it.</p>
<pre class="literal-block">
\P.all x.(girl(x) -&gt; P(x))(\z1.exists x.(dog(x) &amp; chase(z1,x)))
</pre>
<p>Once the list is empty, we have a conventional logical form for the
sentence. Combining binding operators with the core in this way is
called <a name="s_retrieval_index_term" /><span class="termdef">S-Retrieval</span>. If we are careful to allow every possible
order of binding operators (for example, by taking all permutations
of the list, cf <a class="reference external" href="ch04.html#sec-doing-more-with-functions">4.5</a>),
then we will be able to generate every possible scope ordering of quantifiers.</p>
<p>The next question to address is how we build up a core+store
representation compositionally. As before, each phrasal and lexical
rule in the grammar will have a <tt class="doctest"><span class="pre">sem</span></tt> feature, but now there will be
embedded features <tt class="doctest"><span class="pre">core</span></tt> and <tt class="doctest"><span class="pre">store</span></tt>. To illustrate the machinery,
let's consider a simpler example, namely <span class="example">Cyril smiles</span>. Here's a
lexical rule for the verb <span class="example">smiles</span> (taken from the grammar
<tt class="doctest"><span class="pre">storage.fcfg</span></tt>) which looks pretty innocuous.</p>
<pre class="literal-block">
IV[SEM=[core=&lt;\x.smile(x)&gt;, store=(/)]] -&gt; 'smiles'
</pre>
<p>The rule for the proper name <span class="example">Cyril</span> is more complex.</p>
<pre class="literal-block">
NP[SEM=[core=&lt;&#64;x&gt;, store=(&lt;bo(\P.P(cyril),&#64;x)&gt;)]] -&gt; 'Cyril'
</pre>
<p>The <tt class="doctest"><span class="pre">bo</span></tt> predicate has two subparts: the standard (type-raised)
representation of a proper name, and the expression <tt class="doctest"><span class="pre">&#64;x</span></tt>, which is
called the <a name="address_index_term" /><span class="termdef">address</span> of the binding operator. (We'll explain the
need for the address variable shortly.) <tt class="doctest"><span class="pre">&#64;x</span></tt> is a
metavariable, that is, a variable that ranges over individual
variables of the logic and, as you will see, it also provides the
value of <tt class="doctest"><span class="pre">core</span></tt>.
The rule for <tt class="doctest"><span class="pre">VP</span></tt> just
percolates up the semantics of the  <tt class="doctest"><span class="pre">IV</span></tt>, and the
interesting work is done by the <tt class="doctest"><span class="pre">S</span></tt> rule.</p>
<pre class="literal-block">
VP[SEM=?s] -&gt; IV[SEM=?s]

S[SEM=[core=&lt;?vp(?np)&gt;, store=(?b1+?b2)]] -&gt;
   NP[SEM=[core=?np, store=?b1]] VP[SEM=[core=?vp, store=?b2]]
</pre>
<p>The <tt class="doctest"><span class="pre">core</span></tt> value at the <tt class="doctest"><span class="pre">S</span></tt> node is the result of applying the
<tt class="doctest"><span class="pre">VP</span></tt>'s <tt class="doctest"><span class="pre">core</span></tt> value, namely <tt class="doctest"><span class="pre">\x.smile(x)</span></tt>, to the subject
<tt class="doctest"><span class="pre">NP</span></tt>'s value. The latter will not be <tt class="doctest"><span class="pre">&#64;x</span></tt>, but rather an
instantiation of <tt class="doctest"><span class="pre">&#64;x</span></tt>, say <tt class="doctest"><span class="pre">z3</span></tt>. After &#946;-reduction,
<tt class="doctest"><span class="pre">&lt;?vp(?np)&gt;</span></tt> will be unified with <tt class="doctest"><span class="pre">&lt;smile(z3)&gt;</span></tt>. Now, when
<tt class="doctest"><span class="pre">&#64;x</span></tt> is instantiated as part of the parsing process, it will be
instantiated uniformly. In particular, the occurrence of <tt class="doctest"><span class="pre">&#64;x</span></tt> in the
subject <tt class="doctest"><span class="pre">NP</span></tt>'s <tt class="doctest"><span class="pre">store</span></tt> will also be mapped to <tt class="doctest"><span class="pre">z3</span></tt>, yielding
the element <tt class="doctest"><span class="pre">bo(\P.P(cyril),z3)</span></tt>. These steps can be seen in
the following parse tree.</p>
<pre class="literal-block">
(S[SEM=[core=&lt;smile(z3)&gt;, store=(bo(\P.P(cyril),z3))]]
  (NP[SEM=[core=&lt;z3&gt;, store=(bo(\P.P(cyril),z3))]] Cyril)
  (VP[SEM=[core=&lt;\x.smile(x)&gt;, store=()]]
    (IV[SEM=[core=&lt;\x.smile(x)&gt;, store=()]] smiles)))
</pre>
<p>Let's return to our more complex example, <a class="reference internal" href="#ex-scope11">(52)</a>, and see what the
storage style <tt class="doctest"><span class="pre">sem</span></tt> value is, after parsing with grammar
<tt class="doctest"><span class="pre">storage.fcfg</span></tt>.</p>
<pre class="literal-block">
core  = &lt;chase(z1,z2)&gt;
store = (bo(\P.all x.(girl(x) -&gt; P(x)),z1), bo(\P.exists x.(dog(x) &amp; P(x)),z2))
</pre>
<!-- XXX next sentence says "should be clearer" having just displayed the
most complex structure seen so far.  It would be better to explain the
structure, then follow up by saying it should be clearer.  (But perhaps
such meta-comments serve only to alienate many readers for whom its not
going to be clearer?) -->
<p>It should be clearer now why the address variables are an important
part of the binding operator. Recall that during S-retrieval, we will
be taking binding operators off the <tt class="doctest"><span class="pre">store</span></tt> list and applying them
successively to the core. Suppose we start with <tt class="doctest"><span class="pre">bo(\P.all x.(girl(x)
-&gt; P(x)),z1)</span></tt>, which we want to combine with <tt class="doctest"><span class="pre">chase(z1,z2)</span></tt>. The
quantifier part of binding operator is <tt class="doctest"><span class="pre">\P.all x.(girl(x) -&gt; P(x))</span></tt>,
and to combine this with  <tt class="doctest"><span class="pre">chase(z1,z2)</span></tt>, the latter needs to first be
turned into a &#955;-abstract. How do we know which variable to
abstract over? This is what the address <tt class="doctest"><span class="pre">z1</span></tt> tells us; i.e. that
<span class="example">every girl</span> has the role of chaser rather than chasee.</p>
<p>The module <tt class="doctest"><span class="pre">nltk.sem.cooper_storage</span></tt> deals with the task of turning
storage-style semantic representations into standard logical
forms. First, we construct a <tt class="doctest"><span class="pre">CooperStore</span></tt> instance, and inspect its
<tt class="doctest"><span class="pre">store</span></tt> and <tt class="doctest"><span class="pre">core</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.sem <span class="pysrc-keyword">import</span> cooper_storage <span class="pysrc-keyword">as</span> cs
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sentence = <span class="pysrc-string">'every girl chases a dog'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = cs.parse_with_bindops(sentence, grammar=<span class="pysrc-string">'grammars/book_grammars/storage.fcfg'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>semrep = trees[0].label()[<span class="pysrc-string">'SEM'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cs_semrep = cs.CooperStore(semrep)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(cs_semrep.core)
<span class="pysrc-output">chase(z2,z4)</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> bo <span class="pysrc-keyword">in</span> cs_semrep.store:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(bo)
<span class="pysrc-output">bo(\P.all x.(girl(x) -&gt; P(x)),z2)</span>
<span class="pysrc-output">bo(\P.exists x.(dog(x) &amp; P(x)),z4)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Finally we call <tt class="doctest"><span class="pre">s_retrieve()</span></tt> and check the readings.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cs_semrep.s_retrieve(trace=True)
<span class="pysrc-output">Permutation 1</span>
<span class="pysrc-output">   (\P.all x.(girl(x) -&gt; P(x)))(\z2.chase(z2,z4))</span>
<span class="pysrc-output">   (\P.exists x.(dog(x) &amp; P(x)))(\z4.all x.(girl(x) -&gt; chase(x,z4)))</span>
<span class="pysrc-output">Permutation 2</span>
<span class="pysrc-output">   (\P.exists x.(dog(x) &amp; P(x)))(\z4.chase(z2,z4))</span>
<span class="pysrc-output">   (\P.all x.(girl(x) -&gt; P(x)))(\z2.exists x.(dog(x) &amp; chase(z2,x)))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> reading <span class="pysrc-keyword">in</span> cs_semrep.readings:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(reading)
<span class="pysrc-output">exists x.(dog(x) &amp; all z3.(girl(z3) -&gt; chase(z3,x)))</span>
<span class="pysrc-output">all x.(girl(x) -&gt; exists z4.(dog(z4) &amp; chase(x,z4)))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="discourse-semantics">
<h1>5&nbsp;&nbsp;&nbsp;Discourse Semantics</h1>
<p>A <a name="discourse_index_term" /><span class="termdef">discourse</span> is a sequence of sentences. Very often, the
interpretation of a sentence in a discourse depends what preceded
it. A clear example of this comes from anaphoric pronouns, such as
<span class="example">he</span>, <span class="example">she</span> and <span class="example">it</span>. Given discourse such as <span class="example">Angus used
to have a dog. But he recently disappeared.</span>, you will probably
interpret <span class="example">he</span> as referring to Angus's dog. However, in <span class="example">Angus
used to have a dog. He took him for walks in New Town.</span>, you are
more likely to interpret <span class="example">he</span> as referring to Angus himself.</p>
<div class="section" id="discourse-representation-theory">
<h2>5.1&nbsp;&nbsp;&nbsp;Discourse Representation Theory</h2>
<!-- try not to increment the variable indexes

>>> from nltk.sem import logic
>>> logic._counter._value = 0 -->
<p>The standard approach to quantification in first-order logic is limited to single
sentences. Yet there seem to be examples where the scope of a
quantifier can extend over two or more sentences. We saw one above,
and here's a second example, together with a translation.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(54)</td><td width="15"></td><td><span class="target" id="ex-drs0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Angus owns a dog. It bit Irene.</td></tr></table></p>
<span class="target" id="ex-drs1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>&#8707;<span class="mathit">x.(dog(x)</span> &#8743; <span class="mathit">own(Angus, x)</span> &#8743; <span class="mathit">bite(x, Irene))</span></td></tr></table></p>
</td></tr></table></p>
<!-- XXX reworked the respectively sentence in the following paragraph
so that the discussion is easier to follow; needs to be checked. -->
<p>That is, the <tt class="doctest"><span class="pre">NP</span></tt> <span class="example">a dog</span> acts like a quantifier which binds
the <span class="example">it</span> in the second sentence.  Discourse Representation Theory
(DRT) was developed with the specific goal of
providing a means for handling this and other semantic phenomena which
seem to be characteristic of discourse.
A <a name="discourse_representation_structure_index_term" /><span class="termdef">discourse representation structure</span> (DRS) presents the meaning
of discourse in terms of a list of discourse referents and a list
of conditions.  The <a name="discourse_referents_index_term" /><span class="termdef">discourse referents</span> are the things
under discussion in the discourse, and they correspond to the
individual variables of first-order logic.  The <a name="drs_conditions_index_term" /><span class="termdef">DRS conditions</span> apply
to those discourse referents, and correspond to atomic open
formulas of first-order logic.
<a class="reference internal" href="#fig-drs1">5.1</a> illustrates how DRS for the first sentence
in <a class="reference internal" href="#ex-drs0">(54a)</a> is augmented to become a DRS for both sentences.</p>
<span class="target" id="fig-drs1"></span><div class="figure" id="fig-drs1">
<img alt="../images/drs1.png" src="../images/drs1.png" style="width: 471.29999999999995px; height: 287.55px;" />
<p class="caption"><span class="caption-label">Figure 5.1</span>: Building a DRS; the DRS on the left hand side represents the result of processing
the first sentence in the discourse, while the DRS on the right hand side shows the effect of
processing the second sentence and integrating its content.</p>
</div>
<p>When the second sentence of <a class="reference internal" href="#ex-drs0">(54a)</a> is processed, it is interpreted in
the context of what is already present in the left hand side of <a class="reference internal" href="#fig-drs1">5.1</a>. The pronoun <span class="example">it</span>
triggers the addition of a new discourse referent, say <span class="mathit">u</span>,
and we need to find an <a name="anaphoric_antecedent_index_term" /><span class="termdef">anaphoric antecedent</span> for it &#8212; that
is, we want to work out what <span class="example">it</span> refers to. In DRT, the task
of finding the antecedent for an anaphoric pronoun involves
linking it to a discourse referent already within the current DRS,
and <span class="mathit">y</span> is the obvious choice. (We will say more about
anaphora resolution shortly.) This processing step gives rise
to a new condition <span class="mathit">u</span> = <span class="mathit">y</span>.
The remaining content contributed by
the second sentence is also merged with the content of the first, and
this is shown on the right hand side of <a class="reference internal" href="#fig-drs1">5.1</a>.</p>
<p><a class="reference internal" href="#fig-drs1">5.1</a> illustrates how a DRS can represent more than just
a single sentence. In this case, it is a two-sentence discourse, but
in principle a single DRS could correspond to the interpretation of
a whole text. We can inquire into the truth conditions of the
right hand DRS in <a class="reference internal" href="#fig-drs1">5.1</a>. Informally, it is true in some
situation <span class="mathit">s</span> if there are entities <strong>a</strong>, <strong>c</strong> and <strong>i</strong> in
<span class="mathit">s</span> corresponding to the discourse referents in the DRS such
that all the conditions are true in <span class="mathit">s</span> ; that is, <strong>a</strong> is named
<span class="example">Angus</span>, <strong>c</strong> is a dog, <strong>a</strong> owns <strong>c</strong>, <strong>i</strong> is named
<span class="example">Irene</span> and <strong>c</strong> bit <strong>i</strong>.</p>
<p>In order to process DRSs computationally, we need to convert them
into a linear format. Here's an example, where the DRS is a pair consisting of a
list of discourse of referents and a list of DRS conditions:</p>
<pre class="literal-block">
([x, y], [angus(x), dog(y), own(x,y)])
</pre>
<p>The easiest way to build a <tt class="doctest"><span class="pre">DRS</span></tt> object in NLTK is by parsing a
string representation <a class="reference internal" href="#parse-drs"><span id="ref-parse-drs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_dexpr = nltk.sem.DrtExpression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>drs1 = read_dexpr(<span class="pysrc-string">'([x, y], [angus(x), dog(y), own(x, y)])'</span>) <a name="parse-drs" /><a href="#ref-parse-drs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(drs1)
<span class="pysrc-output">([x,y],[angus(x), dog(y), own(x,y)])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX reinstated the split example since otherwise a bunch of subsequent doctests -->
<!-- fail. -->
<p>We can use the <tt class="doctest"><span class="pre">draw()</span></tt> method <a class="reference internal" href="#draw-drs"><span id="ref-draw-drs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>
to visualize the result, as shown in <a class="reference internal" href="#fig-drs-screenshot">5.2</a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>drs1.draw() <a name="draw-drs" /><a href="#ref-draw-drs"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a></pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-drs-screenshot"></span><div class="figure" id="fig-drs-screenshot">
<img alt="../images/drs_screenshot0.png" src="../images/drs_screenshot0.png" style="width: 190.8px; height: 198.0px;" />
<p class="caption"><span class="caption-label">Figure 5.2</span>: DRS Screenshot</p>
</div>
<p>When we discussed the truth conditions of the DRSs in
<a class="reference internal" href="#fig-drs1">5.1</a>, we assumed that the topmost discourse referents were
interpreted as existential quantifiers, while the conditions were
interpreted as though they are conjoined. In fact, every DRS can be
translated into a formula of first-order logic, and the <tt class="doctest"><span class="pre">fol()</span></tt> method
implements this translation.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(drs1.fol())
<span class="pysrc-output">exists x y.(angus(x) &amp; dog(y) &amp; own(x,y))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In addition to the functionality available for first-order logic
expressions, DRT <tt class="doctest"><span class="pre">Expression</span></tt>s have a DRS-concatenation operator,
represented as the <tt class="doctest"><span class="pre">+</span></tt> symbol.  The concatenation of two DRSs
is a single DRS containing the merged discourse referents and the
conditions from both arguments.  DRS-concatenation automatically
&#945;-converts bound variables to avoid name-clashes.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>drs2 = read_dexpr(<span class="pysrc-string">'([x], [walk(x)]) + ([y], [run(y)])'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(drs2)
<span class="pysrc-output">(([x],[walk(x)]) + ([y],[run(y)]))</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(drs2.simplify())
<span class="pysrc-output">([x,y],[walk(x), run(y)])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>While all the conditions seen so far have been atomic, it is possible
to embed one DRS within another, and this is how universal
quantification is handled. In <tt class="doctest"><span class="pre">drs3</span></tt>, there are no top-level
discourse referents, and the sole condition is made up of two
sub-DRSs, connected by an implication. Again, we can use
<tt class="doctest"><span class="pre">fol()</span></tt> to get a handle on the truth conditions.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>drs3 = read_dexpr(<span class="pysrc-string">'([], [(([x], [dog(x)]) -&gt; ([y],[ankle(y), bite(x, y)]))])'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(drs3.fol())
<span class="pysrc-output">all x.(dog(x) -&gt; exists y.(ankle(y) &amp; bite(x,y)))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We pointed out earlier that DRT is designed to allow anaphoric pronouns to be
interpreted by linking to existing discourse referents. DRT sets
constraints on which discourse referents are &quot;accessible&quot; as possible
antecedents, but is not intended to explain how a particular antecedent
is chosen from the set of candidates.
The  module <tt class="doctest"><span class="pre">nltk.sem.drt_resolve_anaphora</span></tt> adopts a similarly
conservative strategy: if the DRS contains a condition of the form
<tt class="doctest"><span class="pre">PRO(x)</span></tt>, the method <tt class="doctest"><span class="pre">resolve_anaphora()</span></tt> replaces this with a
condition of the form <tt class="doctest"><span class="pre">x = [...]</span></tt>, where <tt class="doctest"><span class="pre">[...]</span></tt> is a list of
possible antecedents.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>drs4 = read_dexpr(<span class="pysrc-string">'([x, y], [angus(x), dog(y), own(x, y)])'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>drs5 = read_dexpr(<span class="pysrc-string">'([u, z], [PRO(u), irene(z), bite(u, z)])'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>drs6 = drs4 + drs5
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(drs6.simplify())
<span class="pysrc-output">([u,x,y,z],[angus(x), dog(y), own(x,y), PRO(u), irene(z), bite(u,z)])</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(drs6.simplify().resolve_anaphora())
<span class="pysrc-output">([u,x,y,z],[angus(x), dog(y), own(x,y), (u = [x,y,z]), irene(z), bite(u,z)])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Since the algorithm for anaphora resolution has been separated into
its own module, this facilitates swapping in alternative procedures
which try to make more intelligent guesses about the correct
antecedent.</p>
<p>Our treatment of DRSs  is fully
compatible with the existing machinery for handling &#955;
abstraction, and consequently it is straightforward to build compositional semantic
representations which are based on DRT rather than first-order logic. This
technique is illustrated in the following rule for indefinites
(which is part of the grammar <tt class="doctest"><span class="pre">drt.fcfg</span></tt>). For ease of comparison,
we have added the parallel rule for indefinites from
<tt class="doctest"><span class="pre">simple-sem.fcfg</span></tt>.</p>
<pre class="literal-block">
Det[num=sg,SEM=&lt;\P Q.(([x],[]) + P(x) + Q(x))&gt;] -&gt; 'a'
Det[num=sg,SEM=&lt;\P Q. exists x.(P(x) &amp; Q(x))&gt;] -&gt; 'a'
</pre>
<p>To get a better idea of how the DRT rule works, look at this subtree
for the <tt class="doctest"><span class="pre">NP</span></tt> <span class="example">a dog</span>.</p>
<pre class="literal-block">
(NP[num='sg', SEM=&lt;\Q.(([x],[dog(x)]) + Q(x))&gt;]
  (Det[num='sg', SEM=&lt;\P Q.((([x],[]) + P(x)) + Q(x))&gt;] a)
  (Nom[num='sg', SEM=&lt;\x.([],[dog(x)])&gt;]
    (N[num='sg', SEM=&lt;\x.([],[dog(x)])&gt;] dog)))))
</pre>
<p>The &#955; abstract for the indefinite is applied as a function expression to
<tt class="doctest"><span class="pre">\x.([],[dog(x)])</span></tt> which leads to <tt class="doctest"><span class="pre">\Q.(([x],[]) + ([],[dog(x)]) +
Q(x))</span></tt>; after simplification, we get <tt class="doctest"><span class="pre">\Q.(([x],[dog(x)]) + Q(x))</span></tt>
as the representation for the <tt class="doctest"><span class="pre">NP</span></tt> as a whole.</p>
<p>In order to parse with grammar <tt class="doctest"><span class="pre">drt.fcfg</span></tt>, we specify in the call to
<tt class="doctest"><span class="pre">load_parser()</span></tt> that <tt class="doctest"><span class="pre">SEM</span></tt> values in feature structures are to be
parsed using <tt class="doctest"><span class="pre">DrtParser</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk <span class="pysrc-keyword">import</span> load_parser
<span class="pysrc-prompt">&gt;&gt;&gt; </span>parser = load_parser(<span class="pysrc-string">'grammars/book_grammars/drt.fcfg'</span>, logic_parser=nltk.sem.drt.DrtParser())
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = list(parser.parse(<span class="pysrc-string">'Angus owns a dog'</span>.split()))
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(trees[0].label()[<span class="pysrc-string">'SEM'</span>].simplify())
<span class="pysrc-output">([x,z2],[Angus(x), dog(z2), own(x,z2)])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="discourse-processing">
<h2>5.2&nbsp;&nbsp;&nbsp;Discourse Processing</h2>
<p>When we interpret a sentence, we use a rich context for
interpretation, determined in part by the preceding context and in
part by our background assumptions. DRT provides a theory of how the
meaning of a sentence is integrated into a representation of the prior
discourse, but two things have been glaringly absent from the
processing approach just discussed. First, there has been no attempt
to incorporate any kind of inference; and second, we have only
processed individual sentences. These omissions are redressed by the
module <tt class="doctest"><span class="pre">nltk.inference.discourse</span></tt>.</p>
<!-- XXX The s_1-r_i ... s_n-r_j suggests the possibility of two sentences
sharing the same reading.  Should it be s_1-r_{1,i} ... s_n-r_{n,j} ? -->
<p>Whereas a discourse is a
sequence <span class="mathit">s</span><sub>1</sub>, ... <span class="mathit">s</span><sub>n</sub> of
sentences, a <span class="example">discourse thread</span> is a sequence
<span class="mathit">s</span><sub>1</sub><span class="mathit">-r</span><sub>i</sub>, ... <span class="mathit">s</span><sub>n</sub><span class="mathit">-r</span><sub>j</sub>
of readings, one for each sentence in the discourse.  The
module processes sentences incrementally, keeping track of all possible
threads when there is ambiguity. For simplicity, the following example
ignores scope ambiguity.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt = nltk.DiscourseTester([<span class="pysrc-string">'A student dances'</span>, <span class="pysrc-string">'Every student is a person'</span>])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt.readings()
<span class="pysrc-output"></span>
<span class="pysrc-output">s0 readings:</span>
<span class="pysrc-output"></span>
<span class="pysrc-output">s0-r0: exists x.(student(x) &amp; dance(x))</span>
<span class="pysrc-output"></span>
<span class="pysrc-output">s1 readings:</span>
<span class="pysrc-output"></span>
<span class="pysrc-output">s1-r0: all x.(student(x) -&gt; person(x))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>When a new sentence is added to the current discourse, setting the
parameter <tt class="doctest"><span class="pre">consistchk=True</span></tt> causes consistency to be checked
by invoking the model checker for each thread, i.e., sequence of
admissible readings. In this case, the user has the option
of retracting the sentence in question.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt.add_sentence(<span class="pysrc-string">'No person dances'</span>, consistchk=True)
<span class="pysrc-output">Inconsistent discourse: d0 ['s0-r0', 's1-r0', 's2-r0']:</span>
<span class="pysrc-output">    s0-r0: exists x.(student(x) &amp; dance(x))</span>
<span class="pysrc-output">    s1-r0: all x.(student(x) -&gt; person(x))</span>
<span class="pysrc-output">    s2-r0: -exists x.(person(x) &amp; dance(x))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt.retract_sentence(<span class="pysrc-string">'No person dances'</span>, verbose=True)
<span class="pysrc-output">Current sentences are</span>
<span class="pysrc-output">s0: A student dances</span>
<span class="pysrc-output">s1: Every student is a person</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In a similar manner, we use <tt class="doctest"><span class="pre">informchk=True</span></tt> to check whether a new sentence &#966;
is informative relative to the current discourse. The theorem prover treats existing
sentences in the thread as assumptions and attempts to prove &#966;; it is informative
if no such proof can be found.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt.add_sentence(<span class="pysrc-string">'A person dances'</span>, informchk=True)
<span class="pysrc-output">Sentence 'A person dances' under reading 'exists x.(person(x) &amp; dance(x))':</span>
<span class="pysrc-output">Not informative relative to thread 'd0'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>It is also possible to pass in an additional set of assumptions as
background knowledge and use these to filter out inconsistent
readings; see the Discourse HOWTO at <tt class="doctest"><span class="pre">http://nltk.org/howto</span></tt> for more details.</p>
<p>The <tt class="doctest"><span class="pre">discourse</span></tt> module can accommodate semantic
ambiguity and filter out readings that are not admissible.
The following example invokes both Glue Semantics as well as DRT. Since the Glue
Semantics module is configured to use the wide-coverage Malt dependency parser, the
input (<span class="example">Every dog chases a boy.  He runs</span>.) needs to be tagged as well as tokenized.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.tag <span class="pysrc-keyword">import</span> RegexpTagger
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tagger = RegexpTagger(
<span class="pysrc-more">... </span>    [(<span class="pysrc-string">'^(chases|runs)$'</span>, <span class="pysrc-string">'VB'</span>),
<span class="pysrc-more">... </span>     (<span class="pysrc-string">'^(a)$'</span>, <span class="pysrc-string">'ex_quant'</span>),
<span class="pysrc-more">... </span>     (<span class="pysrc-string">'^(every)$'</span>, <span class="pysrc-string">'univ_quant'</span>),
<span class="pysrc-more">... </span>     (<span class="pysrc-string">'^(dog|boy)$'</span>, <span class="pysrc-string">'NN'</span>),
<span class="pysrc-more">... </span>     (<span class="pysrc-string">'^(He)$'</span>, <span class="pysrc-string">'PRP'</span>)
<span class="pysrc-more">... </span>])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>rc = nltk.DrtGlueReadingCommand(depparser=nltk.MaltParser(tagger=tagger))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt = nltk.DiscourseTester([<span class="pysrc-string">'Every dog chases a boy'</span>, <span class="pysrc-string">'He runs'</span>], rc)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt.readings()
<span class="pysrc-output"></span>
<span class="pysrc-output">s0 readings:</span>
<span class="pysrc-output"></span>
<span class="pysrc-output">s0-r0: ([],[(([x],[dog(x)]) -&gt; ([z3],[boy(z3), chases(x,z3)]))])</span>
<span class="pysrc-output">s0-r1: ([z4],[boy(z4), (([x],[dog(x)]) -&gt; ([],[chases(x,z4)]))])</span>
<span class="pysrc-output"></span>
<span class="pysrc-output">s1 readings:</span>
<span class="pysrc-output"></span>
<span class="pysrc-output">s1-r0: ([x],[PRO(x), runs(x)])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The first sentence of the discourse has two possible readings, depending on the
quantfier scoping. The unique reading of the second sentence represents the pronoun
<span class="example">He</span> via the condition <cite>PRO(x)`</cite>. Now let's look at the discourse threads that
result:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt.readings(show_thread_readings=True)
<span class="pysrc-output">d0: ['s0-r0', 's1-r0'] : INVALID: AnaphoraResolutionException</span>
<span class="pysrc-output">d1: ['s0-r1', 's1-r0'] : ([z6,z10],[boy(z6), (([x],[dog(x)]) -&gt;</span>
<span class="pysrc-output">([],[chases(x,z6)])), (z10 = z6), runs(z10)])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>When we examine threads <tt class="doctest"><span class="pre">d0</span></tt> and <tt class="doctest"><span class="pre">d1</span></tt>, we see
that reading <tt class="doctest"><span class="pre">s0-r0</span></tt>, where <span class="example">every dog</span> out-scopes
<tt class="doctest"><span class="pre">a boy</span></tt>, is deemed inadmissible because the pronoun in the
second sentence cannot be resolved.  By contrast, in thread <tt class="doctest"><span class="pre">d1</span></tt> the
pronoun (relettered to <tt class="doctest"><span class="pre">z24</span></tt>) has been bound <em>via</em> the
equation <tt class="doctest"><span class="pre">(z24 = z20)</span></tt>.</p>
<p>Inadmissible readings can be filtered out by passing the parameter
<tt class="doctest"><span class="pre">filter=True</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>dt.readings(show_thread_readings=True, filter=True)
<span class="pysrc-output">d1: ['s0-r1', 's1-r0'] : ([z12,z15],[boy(z12), (([x],[dog(x)]) -&gt;</span>
<span class="pysrc-output">([],[chases(x,z12)])), (z17 = z12), runs(z15)])</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Although this little discourse is extremely limited, it should give you a feel for
the kind of semantic processing issues that arise when we go beyond single sentences, and also a
feel for the techniques that can be deployed to address them.</p>
</div>
</div>
<div class="section" id="summary">
<h1>6&nbsp;&nbsp;&nbsp;Summary</h1>
<ul class="simple">
<li>First order logic is a suitable language for representing
natural language meaning in a computational setting since it is
flexible enough to represent many useful aspects of natural meaning, and
there are efficient theorem provers for reasoning with first order
logic. (Equally, there are a variety of phenomena in natural language semantics
which are believed to require more powerful logical mechanisms.)</li>
<li>As well as translating natural language sentences into first order
logic, we can state the truth conditions of these sentences by
examining models of first order formulas.</li>
<li>In order to build meaning representations compositionally, we
supplement first order logic with the &#955; calculus.</li>
<li>&#946;-reduction in the &#955;-calculus corresponds semantically
to application of a function to an argument. Syntactically, it
involves replacing a variable bound by &#955; in the function expression with
the expression that provides the argument in the function
application.</li>
<li>A key part of constructing a model lies in building a valuation
which assigns interpretations to non-logical constants. These are
interpreted as either <em>n</em>-ary predicates or as
individual constants.</li>
<li>An open expression is an expression containing one or more free
variables. Open expressions only receive an interpretation when
their free variables receive values from a
variable assignment.</li>
<li>Quantifiers are interpreted by constructing, for a formula &#966;[<span class="mathit">x</span>] open in variable <span class="mathit">x</span>, the set of individuals
which make &#966;[<span class="mathit">x</span>] true when an assignment <em>g</em>
assigns them as the value of <span class="mathit">x</span>. The quantifier then places
constraints on that set.</li>
<li>A closed expression is one that has no free variables; that is, the
variables are all bound. A closed sentence is true or
false with respect to all variable assignments.</li>
<li>If two formulas differ only in the label of the variable bound by
binding operator (i.e, &#955; or a quantifier) , they are said to
be &#945; equivalents. The result of relabeling a bound variable in
a formula is
called &#945;-conversion.</li>
<li>Given a formula with two nested quantifiers <em>Q</em><sub>1</sub> and <em>Q</em><sub>2</sub>, the outermost quantifier <em>Q</em><sub>1</sub> is said to have wide
scope (or scope over <em>Q</em><sub>2</sub>). English sentences are frequently
ambiguous with respect to the scope of the quantifiers they
contain.</li>
<li>English sentences can be associated with a semantic representation
by treating <tt class="doctest"><span class="pre">sem</span></tt> as a feature in a feature-based grammar. The
<tt class="doctest"><span class="pre">sem</span></tt> value of a complex expressions typically involves functional
application of the <tt class="doctest"><span class="pre">sem</span></tt> values of the component expressions.</li>
</ul>
</div>
<div class="section" id="further-reading">
<h1>7&nbsp;&nbsp;&nbsp;Further Reading</h1>
<p>Consult <tt class="doctest"><span class="pre">http://nltk.org/</span></tt> for further materials on this chapter and on how to install the
Prover9 theorem prover and Mace4 model builder. General information about these two
inference tools is given by <a class="reference external" href="bibliography.html#mccune" id="id5">(McCune, 2008)</a>.</p>
<p>For more examples of semantic analysis with NLTK, please see the semantics and
logic HOWTOs at <tt class="doctest"><span class="pre">http://nltk.org/howto</span></tt>.  Note that there are implementations of two other
approaches to scope ambiguity, namely <a name="hole_semantics_index_term" /><span class="termdef">Hole semantics</span> as described in
<a class="reference external" href="bibliography.html#blackburn2005rin" id="id6">(Blackburn &amp; Bos, 2005)</a> and <a name="glue_semantics_index_term" /><span class="termdef">Glue semantics</span> as described in <a class="reference external" href="bibliography.html#dalrymple:1999:rrb" id="id7">(Dalrymple, 1999)</a>.</p>
<p>There are many phenomena in natural language semantics which have not been touched on
in this chapter, most notably:</p>
<ol class="lowerroman simple">
<li>events, tense and aspect;</li>
<li>semantic roles;</li>
<li>generalized quantifiers such as <span class="example">most</span>;</li>
<li>intensional constructions involving, for example, verbs like <span class="example">may</span> and
<span class="example">believe</span>.</li>
</ol>
<p>While (1) and (2) can be dealt with using first-order logic, (3) and (4) require different logics.
These issues are covered by many of the references in the readings below.</p>
<p>A comprehensive overview of results and techniques in building natural language
front-ends to databases can be found in <a class="reference external" href="bibliography.html#androutsopoulos1995nli" id="id8">(Androutsopoulos, Ritchie, &amp; Thanisch, 1995)</a>.</p>
<p>Any introductory book to modern logic will present propositional and first order
logic. <a class="reference external" href="bibliography.html#hodges1977l" id="id9">(Hodges, 1977)</a> is highly recommended as an entertaining and insightful text
with many insightful illustrations from natural language.</p>
<p>For a wide-ranging, two-volume textbook on logic that also presents contemporary
material on the formal semantics of natural language, including Montague Grammar and
intensional logic, see <a class="reference external" href="bibliography.html#gamut1991il" id="id10">(Gamut, 1991)</a> and <a class="reference external" href="bibliography.html#gamut1991illg" id="id11">(Gamut, 1991)</a>. <a class="reference external" href="bibliography.html#kampreyle1993" id="id12">(Kamp &amp; Reyle, 1993)</a> provides
the definitive account of Discourse Representation Theory, and covers a large and
interesting fragment of natural language, including tense, aspect and
modality. Another comprehensive study of the semantics of many natural language
constructions is <a class="reference external" href="bibliography.html#carpenter1997tls" id="id13">(Carpenter, 1997)</a>.</p>
<p>There are numerous works that introduce logical semantics within the framework of
linguistic theory. <a class="reference external" href="bibliography.html#chierchia1990mg" id="id14">(Chierchia &amp; McConnell-Ginet, 1990)</a> is relatively agnostic about syntax, while
<a class="reference external" href="bibliography.html#heim1998sgg" id="id15">(Heim &amp; Kratzer, 1998)</a> and <a class="reference external" href="bibliography.html#larson1995km" id="id16">(Larson &amp; Segal, 1995)</a> are both more explicitly oriented towards
integrating truth-conditional semantics into a Chomskyan framework.</p>
<p><a class="reference external" href="bibliography.html#blackburn2005rin" id="id17">(Blackburn &amp; Bos, 2005)</a> is the first textbook devoted to computational
semantics, and provides an excellent introduction to the area. It
expands on many of the topics covered in this chapter, including
underspecification of quantifier scope ambiguity, first order
inference, and discourse processing.</p>
<p>To gain an overview of more advanced contemporary approaches to semantics, including
treatments of tense and generalized quantifiers, try consulting <a class="reference external" href="bibliography.html#lappin1996hcs" id="id18">(Lappin, 1996)</a> or
<a class="reference external" href="bibliography.html#vanbenthem1997hll" id="id19">(Benthem &amp; Meulen, 1997)</a>.</p>
</div>
<div class="section" id="exercises">
<h1>8&nbsp;&nbsp;&nbsp;Exercises</h1>
<ol class="arabic">
<li><p class="first">&#9788; Translate the following sentences into propositional logic
and verify that they can be processed with <tt class="doctest"><span class="pre">Expression.fromstring()</span></tt>.
Provide a key which shows how the propositional variables in your
translation correspond to expressions of English.</p>
<ol class="loweralpha simple">
<li>If Angus sings, it is not the case that Bertie sulks.</li>
<li>Cyril runs and barks.</li>
<li>It will snow if it doesn't rain.</li>
<li>It's not the case that Irene will be happy if Olive or Tofu comes.</li>
<li>Pat didn't cough or sneeze.</li>
<li>If you don't come if I call, I won't come if you call.</li>
</ol>
</li>
<li><p class="first">&#9788; Translate the following sentences into
predicate-argument formula of first order logic.</p>
<ol class="arabic simple">
<li>Angus likes Cyril and Irene hates Cyril.</li>
<li>Tofu is taller than Bertie.</li>
<li>Bruce loves himself and Pat does too.</li>
<li>Cyril saw Bertie, but Angus didn't.</li>
<li>Cyril is a fourlegged friend.</li>
<li>Tofu and Olive are near each other.</li>
</ol>
</li>
<li><p class="first">&#9788; Translate the following sentences into
quantified formulas of first order logic.</p>
<ol class="arabic simple">
<li>Angus likes someone and someone likes Julia.</li>
<li>Angus loves a dog who loves him.</li>
<li>Nobody smiles at Pat.</li>
<li>Somebody coughs and sneezes.</li>
<li>Nobody coughed or sneezed.</li>
<li>Bruce loves somebody other than Bruce.</li>
<li>Nobody other than Matthew loves somebody Pat.</li>
<li>Cyril likes everyone except for Irene.</li>
<li>Exactly one person is asleep.</li>
</ol>
</li>
<li><p class="first">&#9788; Translate the following verb phrases using &#955; abstracts.
quantified formulas of first order logic.</p>
<ol class="arabic simple">
<li>feed Cyril and give a capuccino to Angus</li>
<li>be given 'War and Peace' by Pat</li>
<li>be loved by everyone</li>
<li>be loved or detested by everyone</li>
<li>be loved by everyone and detested by no-one</li>
</ol>
</li>
<li><p class="first">&#9788; Consider the following statements:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>read_expr = nltk.sem.Expression.fromstring
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e2 = read_expr(<span class="pysrc-string">'pat'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e3 = nltk.sem.ApplicationExpression(e1, e2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">exists y.love(pat, y)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Clearly something is missing here, namely a declaration of the
value of <tt class="doctest"><span class="pre">e1</span></tt>. In order for <tt class="doctest"><span class="pre">ApplicationExpression(e1, e2)</span></tt>
to be &#946;-convertible to <tt class="doctest"><span class="pre">exists y.love(pat, y)</span></tt>, <tt class="doctest"><span class="pre">e1</span></tt>
must be a &#955;-abstract which can take <tt class="doctest"><span class="pre">pat</span></tt> as an
argument. Your task is to construct such an abstract, bind it to
<tt class="doctest"><span class="pre">e1</span></tt>, and satisfy yourself that the statements above are all
satisfied (up to alphabetic variance). In addition, provide an
informal English translation of <tt class="doctest"><span class="pre">e3.simplify()</span></tt>.</p>
<p>Now carry on doing this same task for the further cases of
<tt class="doctest"><span class="pre">e3.simplify()</span></tt> shown below.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">exists y.(love(pat,y) | love(y,pat))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">exists y.(love(pat,y) | love(y,pat))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">walk(fido)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">&#9788; As in the preceding exercise, find a &#955; abstract <tt class="doctest"><span class="pre">e1</span></tt> that yields
results equivalent to those shown below.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e2 = read_expr(<span class="pysrc-string">'chase'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e3 = nltk.sem.ApplicationExpression(e1, e2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">\x.all y.(dog(y) -&gt; chase(x,pat))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e2 = read_expr(<span class="pysrc-string">'chase'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e3 = nltk.sem.ApplicationExpression(e1, e2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">\x.exists y.(dog(y) &amp; chase(pat,x))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e2 = read_expr(<span class="pysrc-string">'give'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e3 = nltk.sem.ApplicationExpression(e1, e2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">\x0 x1.exists y.(present(y) &amp; give(x1,y,x0))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">&#9788; As in the preceding exercise, find a &#955; abstract <tt class="doctest"><span class="pre">e1</span></tt> that yields
results equivalent to those shown below.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e2 = read_expr(<span class="pysrc-string">'bark'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e3 = nltk.sem.ApplicationExpression(e1, e2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">exists y.(dog(x) &amp; bark(x))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e2 = read_expr(<span class="pysrc-string">'bark'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e3 = nltk.sem.ApplicationExpression(e1, e2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">bark(fido)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e2 = read_expr(<span class="pysrc-string">'\\P. all x. (dog(x) -&gt; P(x))'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>e3 = nltk.sem.ApplicationExpression(e1, e2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(e3.simplify())
<span class="pysrc-output">all x.(dog(x) -&gt; bark(x))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">&#9681; Develop a method for translating English sentences into
formulas with binary <a name="generalized_quantifiers_index_term" /><span class="termdef">generalized quantifiers</span>. In such an
approach, given a generalized quantifier <tt class="doctest"><span class="pre">Q</span></tt>, a quantified
formula is of the form <tt class="doctest"><span class="pre">Q(A, B)</span></tt>, where both <tt class="doctest"><span class="pre">A</span></tt> and <tt class="doctest"><span class="pre">B</span></tt> are
expressions of type &#9001;<em>e</em>, <em>t</em>&#9002;. Then, for example,
<tt class="doctest"><span class="pre">all(A, B)</span></tt> is true iff <tt class="doctest"><span class="pre">A</span></tt> denotes a subset of what <tt class="doctest"><span class="pre">B</span></tt> denotes.</p>
</li>
<li><p class="first">&#9681; Extend the approach in the preceding exercise so that the
truth conditions for quantifiers like <span class="example">most</span> and <span class="example">exactly three</span> can be
computed in a model.</p>
</li>
<li><p class="first">&#9681; Modify the <tt class="doctest"><span class="pre">sem.evaluate</span></tt> code so that it will
give a helpful error message if an expression is not in the domain
of a model's valuation function.</p>
</li>
<li><p class="first">&#9733; Select three or four contiguous sentences from a book for children. A possible
source of examples are the collections of stories in
<tt class="doctest"><span class="pre">nltk.corpus.gutenberg</span></tt>: <tt class="doctest"><span class="pre">bryant-stories.txt</span></tt>,
<tt class="doctest"><span class="pre">burgess-busterbrown.txt</span></tt> and
<tt class="doctest"><span class="pre">edgeworth-parents.txt</span></tt>. Develop a grammar which will allow your
sentences to be translated into first order logic, and build a
model which will allow those translations to be checked for truth
or falsity.</p>
</li>
<li><p class="first">&#9733; Carry out the preceding exercise, but use DRT as the meaning representation.</p>
</li>
<li><p class="first">&#9733; Taking <a class="reference external" href="bibliography.html#warren1982eea" id="id20">(Warren &amp; Pereira, 1982)</a> as a starting point, develop a technique
for converting a natural language query into a form that can be
evaluated more efficiently in a model. For example, given a query
of the form <tt class="doctest"><span class="pre">(P(x) &amp; Q(x))</span></tt>, convert it to <tt class="doctest"><span class="pre">(Q(x) &amp; P(x))</span></tt> if
the extension of <tt class="doctest"><span class="pre">Q</span></tt> is smaller than the extension of
<tt class="doctest"><span class="pre">P</span></tt>.</p>
</li>
</ol>
<!-- Footer to be used in all chapters -->
<div class="admonition admonition-about-this-document">
<p class="first admonition-title">About this document...</p>
<p>UPDATED FOR NLTK 3.0.
This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://stevenbird.net/">Steven Bird</a>, <a class="reference external" href="http://homepages.inf.ed.ac.uk/ewan/">Ewan Klein</a> and <a class="reference external" href="http://ed.loper.org/">Edward Loper</a>,
Copyright &#169; 2019 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://nltk.org/</span></tt>],
Version 3.0, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Wed  4 Sep 2019 11:40:48 ACST</p>
</div>
</div>
</div>
</body>
</html>
