<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.15: http://docutils.sourceforge.net/" />
<title>8. Analyzing Sentence Structure</title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}
table pre span {
  white-space: pre-wrap;
}
table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document" id="analyzing-sentence-structure">
<span id="chap-parse"></span>
<h1 class="title">8. Analyzing Sentence Structure</h1>

<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<!-- standard global imports

>>> from __future__ import division
>>> import nltk, re, pprint -->
<!-- TODO: include overview of ContextFreeGrammar and Production in 8.4 -->
<!-- TODO: make URLs clickable in the HTML version -->
<!-- TODO: mention Chomsky Normal Form -->
<!-- TODO: give an example of a text generated from bigrams, then talk the
reader through constructing a simple grammar over this by talking
about local contexts, and contrast this with the grammar -->
<!-- TODO: update images in parser-problem table (NP -> NP PP replaced
by Nom -> Nom PP -->
<!-- TODO: find a different example of left-recursive rules -->
<!-- TODO: Add discussion of non-projective dependency parsing -->
<p>Earlier chapters focused on words: how to identify them,
analyze their structure, assign them to lexical categories,
and access their meanings.
We have also seen how to identify patterns in word sequences or n-grams.
However, these methods only scratch the surface of the complex constraints
that govern sentences.
We need a way to deal with the ambiguity that natural language is famous for.
We also need to be able to cope with the fact that there are an unlimited number
of possible sentences, and we can only write finite programs to analyze their
structures and discover their meanings.</p>
<p>The goal of this chapter is to answer the following questions:</p>
<ol class="arabic simple">
<li>How can we use a formal grammar to describe the structure of an unlimited set of sentences?</li>
<li>How do we represent the structure of sentences using syntax trees?</li>
<li>How do parsers analyze a sentence and automatically build a syntax tree?</li>
</ol>
<p>Along the way, we will cover the fundamentals of English syntax, and
see that there are systematic aspects of meaning that are much easier
to capture once we have identified the structure of sentences.</p>
<div class="section" id="some-grammatical-dilemmas">
<span id="sec-dilemmas"></span><h1>1&nbsp;&nbsp;&nbsp;Some Grammatical Dilemmas</h1>
<div class="section" id="linguistic-data-and-unlimited-possibilities">
<h2>1.1&nbsp;&nbsp;&nbsp;Linguistic Data and Unlimited Possibilities</h2>
<p>Previous chapters have shown you how to process and analyse text
corpora, and we have stressed the challenges for NLP in dealing with
the vast amount of electronic language data that is growing
daily. Let's consider this data more closely, and make the thought
experiment that we have a gigantic corpus consisting of everything
that has been either uttered or written in English over, say, the last
50 years. Would we be justified in calling this corpus &quot;the language
of modern English&quot;? There are a number of reasons why we might answer
No. Recall that in <a class="reference external" href="ch03.html#chap-words">3</a>, we asked you to search
the web for instances of the pattern <span class="example">the of</span>.  Although it is
easy to find examples on the web containing this word sequence, such as
<span class="example">New man at the of IMG</span>
(<tt class="doctest"><span class="pre">http://www.telegraph.co.uk/sport/2387900/New-man-at-the-of-IMG.html</span></tt>),
speakers of English will say that most such examples are errors, and
therefore not part of English after all.</p>
<p>Accordingly, we can argue
that the &quot;modern English&quot; is not equivalent to the very big
set of word sequences in our imaginary corpus. Speakers
of English can make judgements about these sequences, and will reject
some of them as being ungrammatical.</p>
<p>Equally, it is easy to compose a new sentence and have speakers agree that it is perfectly
good English.  For example, sentences have an interesting property
that they can be embedded inside larger sentences.  Consider the
following sentences:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Usain Bolt broke the 100m record</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>The Jamaica Observer reported that Usain Bolt broke the 100m record</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>Andre said The Jamaica Observer reported that Usain Bolt broke the 100m record</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">d.</td><td width="15"></td><td>I think Andre said the Jamaica Observer reported that Usain Bolt broke the 100m record</td></tr></table></p>
</td></tr></table></p>
<p>If we replaced whole sentences with the symbol <tt class="doctest"><span class="pre">S</span></tt>, we would see patterns like
<span class="example">Andre said</span> <tt class="doctest"><span class="pre">S</span></tt> and <span class="example">I think</span> <tt class="doctest"><span class="pre">S</span></tt>.  These are templates for taking a sentence
and constructing a bigger sentence.  There are other templates we can use, like
<tt class="doctest"><span class="pre">S</span></tt> <span class="example">but</span> <tt class="doctest"><span class="pre">S</span></tt>, and <tt class="doctest"><span class="pre">S</span></tt> <span class="example">when</span> <tt class="doctest"><span class="pre">S</span></tt>.  With a bit of ingenuity we can
construct some really long sentences using these templates.
Here's an impressive example from a Winnie the Pooh story by A.A. Milne,
<em>In which Piglet is Entirely Surrounded by Water</em>:</p>
<blockquote>
[You can imagine Piglet's joy when at last the ship came in sight of
him.] In after-years he liked to think that he had been in Very
Great Danger during the Terrible Flood, but the only danger he had
really been in was the last half-hour of his imprisonment, when
Owl, who had just flown up, sat on a branch of his tree to comfort
him, and told him a very long story about an aunt who had once laid
a seagull's egg by mistake, and the story went on and on, rather
like this sentence, until Piglet who was listening out of his
window without much hope, went to sleep quietly and naturally,
slipping slowly out of the window towards the water until he was
only hanging on by his toes, at which moment, luckily, a sudden
loud squawk from Owl, which was really part of the story, being
what his aunt said, woke the Piglet up and just gave him time to
jerk himself back into safety and say, &quot;How interesting, and did
she?&quot; when &#8212; well, you can imagine his joy when at last he saw
the good ship, Brain of Pooh (Captain, C. Robin; 1st Mate, P. Bear)
coming over the sea to rescue him...</blockquote>
<p>This long sentence actually has a simple structure that begins
<span class="example">S but S when S</span>.  We can see from this example that language
provides us with constructions which seem to allow us to extend
sentences indefinitely.  It is also striking that
we can understand sentences of arbitrary length
that we've never heard before:  it's not hard to concoct an
entirely novel sentence, one that has probably never been used before
in the history of the language, yet all speakers of the language
will understand it.</p>
<p>The purpose of a grammar is to give an explicit description of a
language. But the way in which we think of a grammar is closely
intertwined with what we consider to be a language. Is it a
large but finite set of observed utterances and written texts? Is it
something more abstract like the implicit knowledge that competent
speakers have about grammatical sentences? Or is it some combination
of the two? We won't take a stand on this issue, but instead will
introduce the main approaches.</p>
<p>In this chapter, we will adopt the formal framework
of &quot;generative grammar&quot;, in which
a &quot;language&quot; is considered to be nothing more than an
enormous collection of all grammatical sentences, and a
grammar is a formal notation that can be used for &quot;generating&quot; the
members of this set.  Grammars use recursive <a name="productions_index_term" /><span class="termdef">productions</span>
of the form <tt class="doctest"><span class="pre">S</span></tt> &#8594; <tt class="doctest"><span class="pre">S</span></tt> <span class="example">and</span> <tt class="doctest"><span class="pre">S</span></tt>, as we will explore in
<a class="reference internal" href="#sec-context-free-grammar">3</a>.  In <a class="reference external" href="ch10.html#chap-semantics">10.</a> we will extend this,
to automatically build up the meaning of a sentence out of the meanings
of its parts.</p>
</div>
<div class="section" id="ubiquitous-ambiguity">
<h2>1.2&nbsp;&nbsp;&nbsp;Ubiquitous Ambiguity</h2>
<p>A well-known example of ambiguity is shown in <a class="reference internal" href="#ex-marx-elephant">(2)</a>,
from the Groucho Marx movie, <em>Animal Crackers</em> (1930):</p>
<!-- http://www.youtube.com/watch?v=NfN_gcjGoJo -->
<span class="target" id="ex-marx-elephant"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(2)</td><td width="15"></td><td>While hunting in Africa, I shot an elephant in my pajamas.
How he got into my pajamas, I don't know.</td></tr></table></p>
<p>Let's take a closer look at the ambiguity in the phrase:
<span class="example">I shot an elephant in my pajamas</span>.  First we
need to define a simple grammar:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>groucho_grammar = nltk.CFG.fromstring(<span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-more">... </span><span class="pysrc-string">S -&gt; NP VP</span>
<span class="pysrc-more">... </span><span class="pysrc-string">PP -&gt; P NP</span>
<span class="pysrc-more">... </span><span class="pysrc-string">NP -&gt; Det N | Det N PP | 'I'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">VP -&gt; V NP | VP PP</span>
<span class="pysrc-more">... </span><span class="pysrc-string">Det -&gt; 'an' | 'my'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">N -&gt; 'elephant' | 'pajamas'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">V -&gt; 'shot'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">P -&gt; 'in'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;&quot;&quot;</span>)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This grammar permits the sentence to be analyzed in two ways,
depending on whether the prepositional phrase <span class="example">in my pajamas</span>
describes the elephant or the shooting event.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'I'</span>, <span class="pysrc-string">'shot'</span>, <span class="pysrc-string">'an'</span>, <span class="pysrc-string">'elephant'</span>, <span class="pysrc-string">'in'</span>, <span class="pysrc-string">'my'</span>, <span class="pysrc-string">'pajamas'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>parser = nltk.ChartParser(groucho_grammar)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> parser.parse(sent):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-more">...</span>
<span class="pysrc-output">(S</span>
<span class="pysrc-output">  (NP I)</span>
<span class="pysrc-output">  (VP</span>
<span class="pysrc-output">    (VP (V shot) (NP (Det an) (N elephant)))</span>
<span class="pysrc-output">    (PP (P in) (NP (Det my) (N pajamas)))))</span>
<span class="pysrc-output">(S</span>
<span class="pysrc-output">  (NP I)</span>
<span class="pysrc-output">  (VP</span>
<span class="pysrc-output">    (V shot)</span>
<span class="pysrc-output">    (NP (Det an) (N elephant) (PP (P in) (NP (Det my) (N pajamas))))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The program produces two bracketed structures, which we can depict as
trees, as shown in <a class="reference internal" href="#ex-elephant">(3b)</a>:</p>
<span class="target" id="ex-elephant"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(3)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch08-tree-1.png" class="align-top" src="tree_images/ch08-tree-1.png" /></td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch08-tree-2.png" class="align-top" src="tree_images/ch08-tree-2.png" /></td></tr></table></p>
</td></tr></table></p>
<p>Notice that there's no ambiguity concerning the meaning of any of the words;
e.g. the word <span class="example">shot</span> doesn't refer to the act of using a gun in the first sentence,
and using a camera in the second sentence.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Consider the following sentences and see if you can think of two quite different
interpretations: <span class="example">Fighting animals could be dangerous.</span>
<span class="example">Visiting relatives can be tiresome.</span>  Is ambiguity of the individual
words to blame?  If not, what is the cause of the ambiguity?</p>
</div>
<p>This chapter presents grammars and parsing, as the formal and
computational methods for investigating and modeling the linguistic
phenomena we have been discussing.
As we shall see, patterns of well-formedness and ill-formedness in a
sequence of words can be understood with respect to the
phrase structure and dependencies.  We can develop formal
models of these structures using grammars and parsers.
As before, a key motivation is natural language <em>understanding</em>.  How
much more of the meaning of a text can we access when we can reliably
recognize the linguistic structures it contains?  Having read in a
text, can a program &quot;understand&quot; it enough to be able to answer simple
questions about &quot;what happened&quot; or &quot;who did what to whom&quot;?  Also as
before, we will develop simple programs to process annotated corpora
and perform useful tasks.</p>
</div>
</div>
<div class="section" id="what-s-the-use-of-syntax">
<span id="sec-whats-the-use-of-syntax"></span><h1>2&nbsp;&nbsp;&nbsp;What's the Use of Syntax?</h1>
<div class="section" id="beyond-n-grams">
<h2>2.1&nbsp;&nbsp;&nbsp;Beyond n-grams</h2>
<p>We gave an example in <a class="reference external" href="ch02.html#chap-corpora">2.</a> of how to use
the frequency information in bigrams to generate text that seems
perfectly acceptable for small sequences of words but rapidly
degenerates into nonsense. Here's another pair of examples that we created by
computing the bigrams over the text of a childrens' story, <em>The
Adventures of Buster Brown</em> (<tt class="doctest"><span class="pre">http://www.gutenberg.org/files/22816/22816.txt</span></tt>):</p>
<span class="target" id="ex-salad"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(4)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>He roared with me the pail slip down his back</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>The worst part and clumsy looking for whoever heard light</td></tr></table></p>
</td></tr></table></p>
<p>You intuitively know that these sequences are &quot;word-salad&quot;, but you
probably find it hard to pin down what's wrong with them. One
benefit of studying grammar is that it provides a conceptual framework
and vocabulary for spelling out these intuitions. Let's take a closer look
at the sequence <span class="example">the worst part and clumsy looking</span>. This looks like a <a name="coordinate_structure_index_term" /><span class="termdef">coordinate
structure</span>, where two phrases are joined by a coordinating
conjunction such as <span class="example">and</span>, <span class="example">but</span> or <span class="example">or</span>. Here's an
informal (and simplified) statement of how coordination works
syntactically:</p>
<p>Coordinate Structure:</p>
<blockquote>
If <em>v</em><sub>1</sub> and <em>v</em><sub>2</sub> are both phrases of grammatical
category <em>X</em>, then <em>v</em><sub>1</sub> <span class="example">and</span> <em>v</em><sub>2</sub> is also a
phrase of category  <em>X</em>.</blockquote>
<p>Here are a couple of examples. In the first, two <tt class="doctest"><span class="pre">NP</span></tt>s (noun
phrases) have been conjoined to make an <tt class="doctest"><span class="pre">NP</span></tt>, while in the second,
two <tt class="doctest"><span class="pre">AP</span></tt>s (adjective phrases) have been conjoined to make an
<tt class="doctest"><span class="pre">AP</span></tt>.</p>
<span class="target" id="ex-coord"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(5)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The book's ending was (NP <em>the worst part and the best part</em>) for me.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>On land they are (AP <em>slow and clumsy looking</em>).</td></tr></table></p>
</td></tr></table></p>
<p>What we <span class="emphasis">can't</span> do is conjoin an <tt class="doctest"><span class="pre">NP</span></tt> and an <tt class="doctest"><span class="pre">AP</span></tt>, which is
why <span class="example">the worst part and clumsy looking</span> is ungrammatical.
Before we can formalize these ideas, we need to
understand the concept of <a name="constituent_structure_index_term" /><span class="termdef">constituent structure</span>.</p>
<p>Constituent structure is based on the observation that words combine
with other words to form units. The evidence that a sequence of words
forms such a unit is given by substitutability &#8212; that is, a
sequence of words in a well-formed sentence can be replaced by a
shorter sequence without rendering the sentence ill-formed. To clarify
this idea, consider the following sentence:</p>
<span class="target" id="ex-bb0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(6)</td><td width="15"></td><td>The little bear saw the fine fat trout in the brook.</td></tr></table></p>
<p>The fact that we can substitute <span class="example">He</span> for <span class="example">The little bear</span>
indicates that the latter sequence is a unit. By contrast, we cannot
replace  <span class="example">little bear saw</span> in the same way.</p>
<!-- explain * ? -->
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(7)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>He saw the fine fat trout in the brook.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*The he the fine fat trout in the brook.</td></tr></table></p>
</td></tr></table></p>
<p>In <a class="reference internal" href="#fig-ic-diagram">2.1</a>, we systematically substitute longer sequences
by shorter ones in a way which preserves grammaticality. Each sequence
that forms a unit can in fact be replaced by a single word, and we end
up with just two elements.</p>
<span class="target" id="fig-ic-diagram"></span><div class="figure" id="fig-ic-diagram">
<img alt="../images/ic_diagram.png" src="../images/ic_diagram.png" style="width: 463.75px; height: 152.25px;" />
<p class="caption"><span class="caption-label">Figure 2.1</span>: Substitution of Word Sequences: working from the top row, we can replace
particular sequences of words (e.g. <span class="example">the brook</span>) with individual
words (e.g. <span class="example">it</span>); repeating this process we arrive at a grammatical
two-word sentence.</p>
</div>
<p>In <a class="reference internal" href="#fig-ic-diagram-labeled">2.2</a>, we have added
grammatical category labels to the words we saw in the earlier figure.
The labels <tt class="doctest"><span class="pre">NP</span></tt>, <tt class="doctest"><span class="pre">VP</span></tt>, and <tt class="doctest"><span class="pre">PP</span></tt> stand for <a name="noun_phrase_index_term" /><span class="termdef">noun phrase</span>,
<a name="verb_phrase_index_term" /><span class="termdef">verb phrase</span> and <a name="prepositional_phrase_index_term" /><span class="termdef">prepositional phrase</span> respectively.</p>
<span class="target" id="fig-ic-diagram-labeled"></span><div class="figure" id="fig-ic-diagram-labeled">
<img alt="../images/ic_diagram_labeled.png" src="../images/ic_diagram_labeled.png" style="width: 463.75px; height: 152.25px;" />
<p class="caption"><span class="caption-label">Figure 2.2</span>: Substitution of Word Sequences Plus Grammatical Categories:
This diagram reproduces <a class="reference internal" href="#fig-ic-diagram">2.1</a> along with grammatical
categories corresponding to noun phrases (<tt class="doctest"><span class="pre">NP</span></tt>), verb phrases (<tt class="doctest"><span class="pre">VP</span></tt>),
prepositional phrases (<tt class="doctest"><span class="pre">PP</span></tt>), and nominals (<tt class="doctest"><span class="pre">Nom</span></tt>).</p>
</div>
<p>If we now strip out the words apart from the topmost row, add an
<tt class="doctest"><span class="pre">S</span></tt> node, and flip the figure over, we end up with a standard
phrase structure tree, shown in <a class="reference internal" href="#ex-phrase-structure-tree">(8)</a>.
Each node in this tree (including the words) is called
a <a name="constituent_index_term" /><span class="termdef">constituent</span>.  The <a name="immediate_constituents_index_term" /><span class="termdef">immediate constituents</span> of
<tt class="doctest"><span class="pre">S</span></tt> are <tt class="doctest"><span class="pre">NP</span></tt> and <tt class="doctest"><span class="pre">VP</span></tt>.</p>
<span class="target" id="ex-phrase-structure-tree"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(8)</td><td width="15"></td><td><img alt="tree_images/ch08-tree-3.png" class="align-top" src="tree_images/ch08-tree-3.png" /></td></tr></table></p>
<p>As we will see in the next section, a grammar specifies how the sentence
can be subdivided into its immediate constituents, and how these can be further
subdivided until we reach the level of individual words.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As we saw in <a class="reference internal" href="#sec-dilemmas">1</a>, sentences can have arbitrary length.
Consequently, phrase structure trees can have arbitrary <span class="emphasis">depth</span>.
The cascaded chunk parsers we saw in <a class="reference external" href="ch07.html#sec-recursion-in-linguistic-structure">4</a>
can only produce structures of bounded depth, so chunking methods
aren't applicable here.</p>
</div>
</div>
</div>
<div class="section" id="context-free-grammar">
<span id="sec-context-free-grammar"></span><h1>3&nbsp;&nbsp;&nbsp;Context Free Grammar</h1>
<div class="section" id="a-simple-grammar">
<h2>3.1&nbsp;&nbsp;&nbsp;A Simple Grammar</h2>
<!-- XXX say more about what "admitted by a grammar" means? -->
<p>Let's start off by looking at a simple context-free grammar.  By
convention, the left-hand-side of the first production is the
<a name="start_symbol_index_term" /><span class="termdef">start-symbol</span> of the grammar, typically <tt class="doctest"><span class="pre">S</span></tt>, and all
well-formed trees must have this symbol as their root label. In
NLTK, context-free grammars are defined in the <tt class="doctest"><span class="pre">nltk.grammar</span></tt>
module.  In <a class="reference internal" href="#code-cfg1">3.1</a> we define a grammar and show how to parse a
simple sentence admitted by the grammar.</p>
<span class="target" id="code-cfg1"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
grammar1 = nltk.CFG.fromstring(<span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-string">  S -&gt; NP VP</span>
<span class="pysrc-string">  VP -&gt; V NP | V NP PP</span>
<span class="pysrc-string">  PP -&gt; P NP</span>
<span class="pysrc-string">  V -&gt; &quot;saw&quot; | &quot;ate&quot; | &quot;walked&quot;</span>
<span class="pysrc-string">  NP -&gt; &quot;John&quot; | &quot;Mary&quot; | &quot;Bob&quot; | Det N | Det N PP</span>
<span class="pysrc-string">  Det -&gt; &quot;a&quot; | &quot;an&quot; | &quot;the&quot; | &quot;my&quot;</span>
<span class="pysrc-string">  N -&gt; &quot;man&quot; | &quot;dog&quot; | &quot;cat&quot; | &quot;telescope&quot; | &quot;park&quot;</span>
<span class="pysrc-string">  P -&gt; &quot;in&quot; | &quot;on&quot; | &quot;by&quot; | &quot;with&quot;</span>
<span class="pysrc-string">  &quot;&quot;&quot;</span>)</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">&quot;Mary saw Bob&quot;</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>rd_parser = nltk.RecursiveDescentParser(grammar1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> rd_parser.parse(sent):
<span class="pysrc-more">... </span>     <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S (NP Mary) (VP (V saw) (NP Bob)))</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_cfg1.py" type="text/x-python"><span class="caption-label">Example 3.1 (code_cfg1.py)</span></a>: <span class="caption-label">Figure 3.1</span>: A Simple Context-Free Grammar</td></tr></p>
</table></div>
<p>The grammar in <a class="reference internal" href="#code-cfg1">3.1</a> contains productions involving various syntactic categories,
as laid out in <a class="reference internal" href="#tab-syncat">3.1</a>.</p>
<span class="target" id="tab-syncat"></span><table border="1" class="docutils" id="tab-syncat">
<colgroup>
<col width="13%" />
<col width="42%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Symbol</th>
<th class="head">Meaning</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>S</td>
<td>sentence</td>
<td><span class="example">the man walked</span></td>
</tr>
<tr><td>NP</td>
<td>noun phrase</td>
<td><span class="example">a dog</span></td>
</tr>
<tr><td>VP</td>
<td>verb phrase</td>
<td><span class="example">saw a park</span></td>
</tr>
<tr><td>PP</td>
<td>prepositional phrase</td>
<td><span class="example">with a telescope</span></td>
</tr>
<tr><td>Det</td>
<td>determiner</td>
<td><span class="example">the</span></td>
</tr>
<tr><td>N</td>
<td>noun</td>
<td><span class="example">dog</span></td>
</tr>
<tr><td>V</td>
<td>verb</td>
<td><span class="example">walked</span></td>
</tr>
<tr><td>P</td>
<td>preposition</td>
<td><span class="example">in</span></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 3.1</span>: <p>Syntactic Categories</p>
</p>
</table>
<p>A production like <tt class="doctest"><span class="pre">VP -&gt; V NP | V NP PP</span></tt> has a disjunction on the
righthand side, shown by the <tt class="doctest"><span class="pre">|</span></tt> and is an abbreviation for the two productions
<tt class="doctest"><span class="pre">VP -&gt; V NP</span></tt> and <tt class="doctest"><span class="pre">VP -&gt; V NP PP</span></tt>.</p>
<span class="target" id="fig-parse-rdparsewindow"></span><div class="figure" id="fig-parse-rdparsewindow">
<img alt="../images/parse_rdparsewindow.png" src="../images/parse_rdparsewindow.png" style="width: 475.0px; height: 464.0px;" />
<p class="caption"><span class="caption-label">Figure 3.2</span>: Recursive Descent Parser Demo: This tool allows you to watch the operation of
a recursive descent parser as it grows the parse tree and matches it against
the input words.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try developing a simple grammar of your own, using the
recursive descent parser application, <tt class="doctest"><span class="pre">nltk.app.rdparser()</span></tt>,
shown in <a class="reference internal" href="#fig-parse-rdparsewindow">3.2</a>.
It comes already loaded with a sample grammar, but you can
edit this as you please (using the <tt class="doctest"><span class="pre">Edit</span></tt> menu).
Change the grammar, and the sentence to be parsed, and
run the parser using the <em>autostep</em> button.</p>
</div>
<p>If we parse the sentence <cite>The dog saw a man in the park</cite> using
the grammar shown in <a class="reference internal" href="#code-cfg1">3.1</a>, we end up with two trees, similar to
those we saw for <a class="reference internal" href="#ex-elephant">(3b)</a>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(9)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch08-tree-4.png" class="align-top" src="tree_images/ch08-tree-4.png" /></td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch08-tree-5.png" class="align-top" src="tree_images/ch08-tree-5.png" /></td></tr></table></p>
</td></tr></table></p>
<p>Since our grammar licenses two trees for this sentence, the sentence is
said to be <a name="structurally_ambiguous_index_term" /><span class="termdef">structurally ambiguous</span>.  The ambiguity in question is called
a <a name="prepositional_phrase_attachment_ambiguity_index_term" /><span class="term">prepositional phrase attachment ambiguity</span>, as we saw earlier in this chapter.
As you may recall, it is an ambiguity about attachment since the
<tt class="doctest"><span class="pre">PP</span></tt> <span class="example">in the park</span> needs to be attached to one of two places
in the tree: either as a child of <tt class="doctest"><span class="pre">VP</span></tt> or else as a child of <tt class="doctest"><span class="pre">NP</span></tt>.
When the <tt class="doctest"><span class="pre">PP</span></tt> is attached to <tt class="doctest"><span class="pre">VP</span></tt>, the intended interpretation
is that the seeing event happened
in the park.  However, if the <tt class="doctest"><span class="pre">PP</span></tt> is attached to <tt class="doctest"><span class="pre">NP</span></tt>,
then it was the man who was in the park, and the agent of the seeing (the dog)
might have been sitting on the balcony of an apartment overlooking the
park.</p>
</div>
<div class="section" id="writing-your-own-grammars">
<h2>3.2&nbsp;&nbsp;&nbsp;Writing Your Own Grammars</h2>
<p>If you are interested in experimenting with writing CFGs, you will
find it helpful to create and edit your grammar in a text
file, say <tt class="doctest"><span class="pre">mygrammar.cfg</span></tt>. You can then load it into NLTK and
parse with it as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>grammar1 = nltk.data.load(<span class="pysrc-string">'file:mygrammar.cfg'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">&quot;Mary saw Bob&quot;</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>rd_parser = nltk.RecursiveDescentParser(grammar1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> rd_parser.parse(sent):
<span class="pysrc-more">... </span>     <span class="pysrc-keyword">print</span>(tree)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Make sure that you put a <tt class="doctest"><span class="pre">.cfg</span></tt> suffix on the filename, and that
there are no spaces in the string <tt class="doctest"><span class="pre"><span class="pysrc-string">'file:mygrammar.cfg'</span></span></tt>. If the
command <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span>(tree)</span></tt> produces no output, this is probably because
your sentence <tt class="doctest"><span class="pre">sent</span></tt> is not admitted by your grammar. In this case,
call the parser with tracing set to be on: <tt class="doctest"><span class="pre">rd_parser =
nltk.RecursiveDescentParser(grammar1, trace=2)</span></tt>. You can also check
what productions are currently in the grammar with the command <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> p
<span class="pysrc-keyword">in</span> grammar1.productions(): <span class="pysrc-keyword">print</span>(p)</span></tt>.</p>
<p>When you write CFGs for parsing in NLTK, you cannot combine
grammatical categories with lexical items on the righthand side of the
same production. Thus, a production such as <tt class="doctest"><span class="pre">PP -&gt; <span class="pysrc-string">'of'</span> NP</span></tt> is disallowed. In
addition, you are not permitted to place multi-word lexical items on the
righthand side of a production. So rather than writing <tt class="doctest"><span class="pre">NP -&gt; <span class="pysrc-string">'New</span>
<span class="pysrc-string">York'</span></span></tt>, you have to resort to something like <tt class="doctest"><span class="pre">NP -&gt; <span class="pysrc-string">'New_York'</span></span></tt>
instead.</p>
</div>
<div class="section" id="recursion-in-syntactic-structure">
<h2>3.3&nbsp;&nbsp;&nbsp;Recursion in Syntactic Structure</h2>
<p>A grammar is said to be <a name="recursive_index_term" /><span class="termdef">recursive</span> if a category occurring on the left hand
side of a production also appears on
the righthand side of a production, as illustrated in <a class="reference internal" href="#code-cfg2">3.3</a>.
The production <tt class="doctest"><span class="pre">Nom -&gt; Adj Nom</span></tt> (where <tt class="doctest"><span class="pre">Nom</span></tt> is the
category of nominals) involves direct recursion on the category
<tt class="doctest"><span class="pre">Nom</span></tt>, whereas indirect recursion on <tt class="doctest"><span class="pre">S</span></tt> arises from the
combination of two productions, namely <tt class="doctest"><span class="pre">S -&gt; NP VP</span></tt> and <tt class="doctest"><span class="pre">VP -&gt; V S</span></tt>.</p>
<span class="target" id="code-cfg2"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
grammar2 = nltk.CFG.fromstring(<span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-string">  S  -&gt; NP VP</span>
<span class="pysrc-string">  NP -&gt; Det Nom | PropN</span>
<span class="pysrc-string">  Nom -&gt; Adj Nom | N</span>
<span class="pysrc-string">  VP -&gt; V Adj | V NP | V S | V NP PP</span>
<span class="pysrc-string">  PP -&gt; P NP</span>
<span class="pysrc-string">  PropN -&gt; 'Buster' | 'Chatterer' | 'Joe'</span>
<span class="pysrc-string">  Det -&gt; 'the' | 'a'</span>
<span class="pysrc-string">  N -&gt; 'bear' | 'squirrel' | 'tree' | 'fish' | 'log'</span>
<span class="pysrc-string">  Adj  -&gt; 'angry' | 'frightened' |  'little' | 'tall'</span>
<span class="pysrc-string">  V -&gt;  'chased'  | 'saw' | 'said' | 'thought' | 'was' | 'put'</span>
<span class="pysrc-string">  P -&gt; 'on'</span>
<span class="pysrc-string">  &quot;&quot;&quot;</span>)</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_cfg2.py" type="text/x-python"><span class="caption-label">Example 3.3 (code_cfg2.py)</span></a>: <span class="caption-label">Figure 3.3</span>: A Recursive Context-Free Grammar</td></tr></p>
</table></div>
<p>To see how recursion arises from this grammar, consider the following
trees.  <a class="reference internal" href="#ex-recnominals">(10a)</a> involves nested nominal phrases,
while <a class="reference internal" href="#ex-recsentences">(10b)</a> contains nested sentences.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(10)</td><td width="15"></td><td><span class="target" id="ex-recnominals"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch08-tree-6.png" class="align-top" src="tree_images/ch08-tree-6.png" /></td></tr></table></p>
<span class="target" id="ex-recsentences"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch08-tree-7.png" class="align-top" src="tree_images/ch08-tree-7.png" /></td></tr></table></p>
</td></tr></table></p>
<p>We've only illustrated two levels of recursion here, but there's
no upper limit on the depth.  You can experiment with parsing
sentences that involve more deeply nested structures.
Beware that the <tt class="doctest"><span class="pre">RecursiveDescentParser</span></tt> is unable to handle
<a name="left_recursive_index_term" /><span class="termdef">left-recursive</span> productions of the form <tt class="doctest"><span class="pre">X -&gt; X Y</span></tt>; we will
return to this in <a class="reference internal" href="#sec-parsing">4</a>.</p>
</div>
</div>
<div class="section" id="parsing-with-context-free-grammar">
<span id="sec-parsing"></span><h1>4&nbsp;&nbsp;&nbsp;Parsing With Context Free Grammar</h1>
<!-- >>> grammar1 = nltk.CFG.fromstring("""
...     S -> NP VP
...     VP -> V NP | V NP PP
...     PP -> P NP
...     V -> "saw" | "ate" | "walked"
...     NP -> "John" | "Mary" | "Bob" | Det N | Det N PP
...     Det -> "a" | "an" | "the" | "my"
...     N -> "man" | "dog" | "cat" | "telescope" | "park"
...     P -> "in" | "on" | "by" | "with"
...     """)
>>> groucho_grammar = nltk.CFG.fromstring("""
... S -> NP VP
... PP -> P NP
... NP -> Det N | Det N PP | 'I'
... VP -> V NP | VP PP
... Det -> 'an' | 'my'
... N -> 'elephant' | 'pajamas'
... V -> 'shot'
... P -> 'in'
... """) -->
<p>A <a name="parser_index_term" /><span class="termdef">parser</span> processes input sentences according to the
productions of a grammar, and builds one or more
constituent structures that conform to the grammar.
A grammar is a declarative specification of well-formedness &#8212;
it is actually just a string, not a program.
A parser is a procedural interpretation of the grammar.
It searches through the space of trees licensed by a grammar
to find one that has the required sentence along its fringe.</p>
<!-- XXX does the following read as though our audience does not consist
of people who want to do the tasks described in this chapter? -->
<p>A parser permits a grammar to be evaluated against
a collection of test sentences, helping linguists
to discover mistakes in their grammatical analysis.
A parser can serve as a model of psycholinguistic processing,
helping to explain the difficulties that humans have with processing
certain syntactic constructions.
Many natural language applications involve parsing at some point;
for example, we would expect the natural language questions
submitted to a question-answering system to undergo parsing as an initial step.</p>
<p>In this section we see two simple parsing algorithms,
a top-down method called recursive descent parsing,
and a bottom-up method called shift-reduce parsing.
We also see some more sophisticated algorithms,
a top-down method with bottom-up filtering called
left-corner parsing, and a dynamic programming
technique called chart parsing.</p>
<div class="section" id="recursive-descent-parsing">
<h2>4.1&nbsp;&nbsp;&nbsp;Recursive Descent Parsing</h2>
<p>The simplest kind of parser interprets a grammar as a specification
of how to break a high-level goal into several lower-level subgoals.
The top-level goal is to find an <tt class="doctest"><span class="pre">S</span></tt>.  The <tt class="doctest"><span class="pre">S</span></tt> &#8594; <tt class="doctest"><span class="pre">NP VP</span></tt>
production permits the parser to replace this goal with two subgoals:
find an <tt class="doctest"><span class="pre">NP</span></tt>, then find a <tt class="doctest"><span class="pre">VP</span></tt>.  Each of these subgoals can be
replaced in turn by sub-sub-goals, using productions that have <tt class="doctest"><span class="pre">NP</span></tt>
and <tt class="doctest"><span class="pre">VP</span></tt> on their left-hand side.  Eventually, this expansion
process leads to subgoals such as: find the word <span class="example">telescope</span>.  Such
subgoals can be directly compared against the input sequence, and
succeed if the next word is matched.  If there is no match the parser
must back up and try a different alternative.</p>
<p>The recursive descent parser builds a parse tree during the above
process.  With the initial goal (find an <tt class="doctest"><span class="pre">S</span></tt>), the <tt class="doctest"><span class="pre">S</span></tt> root node
is created.  As the above process recursively expands its goals using
the productions of the grammar, the parse tree is extended downwards
(hence the name <em>recursive descent</em>).  We can see this in action using
the graphical demonstration <tt class="doctest"><span class="pre">nltk.app.rdparser()</span></tt>.
Six stages of the execution of this parser are shown in <a class="reference internal" href="#fig-rdparser1-6">4.1</a>.</p>
<span class="target" id="fig-rdparser1-6"></span><div class="figure" id="fig-rdparser1-6">
<img alt="../images/rdparser1-6.png" src="../images/rdparser1-6.png" style="width: 1062.5px; height: 508.5px;" />
<p class="caption"><span class="caption-label">Figure 4.1</span>: Six Stages of a Recursive Descent Parser: the parser begins with a
tree consisting of the node <tt class="doctest"><span class="pre">S</span></tt>; at each stage it consults the grammar
to find a production that can be used to enlarge the tree; when
a lexical production is encountered, its word is compared against the input;
after a complete parse has been found, the parser backtracks to look for
more parses.</p>
</div>
<p>During this process, the parser is often forced to choose between several
possible productions.  For example, in going from step 3 to step 4, it
tries to find productions with <tt class="doctest"><span class="pre">N</span></tt> on the left-hand side.  The
first of these is <tt class="doctest"><span class="pre">N</span></tt> &#8594; <span class="example">man</span>.  When this does not work
it <a name="backtracks_index_term" /><span class="term">backtracks</span>, and tries other <tt class="doctest"><span class="pre">N</span></tt> productions in order, until it
gets to <tt class="doctest"><span class="pre">N</span></tt> &#8594; <span class="example">dog</span>, which matches the next word in the
input sentence.  Much later, as shown in step 5, it finds a complete
parse.  This is a tree that covers the entire sentence, without any
dangling edges.  Once a parse has been found, we can get the parser to
look for additional parses.  Again it will backtrack and explore other
choices of production in case any of them result in a parse.</p>
<p>NLTK provides a recursive descent parser:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>rd_parser = nltk.RecursiveDescentParser(grammar1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">'Mary saw a dog'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> rd_parser.parse(sent):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S (NP Mary) (VP (V saw) (NP (Det a) (N dog))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="doctest"><span class="pre">RecursiveDescentParser()</span></tt> takes an optional parameter <tt class="doctest"><span class="pre">trace</span></tt>.
If <tt class="doctest"><span class="pre">trace</span></tt> is greater than zero, then the parser will report the steps
that it takes as it parses a text.</p>
</div>
<p>Recursive descent parsing has three key shortcomings.  First,
left-recursive productions like <tt class="doctest"><span class="pre">NP -&gt; NP PP</span></tt> send it
into an infinite loop.  Second, the parser wastes a lot of time
considering words and structures that do not correspond to the input
sentence.  Third, the backtracking process may discard parsed
constituents that will need to be rebuilt again later.  For example,
backtracking over <tt class="doctest"><span class="pre">VP -&gt; V NP</span></tt> will discard the subtree
created for the <tt class="doctest"><span class="pre">NP</span></tt>.  If the parser then proceeds with
<tt class="doctest"><span class="pre">VP -&gt; V NP PP</span></tt>, then the <tt class="doctest"><span class="pre">NP</span></tt> subtree must be created all
over again.</p>
<p>Recursive descent parsing is a kind of <a name="top_down_parsing_index_term" /><span class="termdef">top-down parsing</span>.
Top-down parsers use a grammar to <em>predict</em> what the input will be,
before inspecting the input!  However, since the input is available to
the parser all along, it would be more sensible to consider the input
sentence from the very beginning.  This approach is called
<a name="bottom_up_parsing_index_term" /><span class="termdef">bottom-up parsing</span>, and we will see an example in the next section.</p>
</div>
<div class="section" id="shift-reduce-parsing">
<h2>4.2&nbsp;&nbsp;&nbsp;Shift-Reduce Parsing</h2>
<p>A simple kind of bottom-up parser is the <a name="shift_reduce_parser_index_term" /><span class="termdef">shift-reduce parser</span>.
In common with all bottom-up parsers, a shift-reduce
parser tries to find sequences of words and phrases that correspond
to the <em>right hand</em> side of a grammar production, and replace them
with the left-hand side, until the whole sentence is reduced to
an <tt class="doctest"><span class="pre">S</span></tt>.</p>
<!-- XXX earlier section no longer talks about stacks.  Concepts of
pushing and popping will need to be explained somewhere. -->
<p>The shift-reduce parser repeatedly pushes the next input word onto a
stack (<a class="reference external" href="ch04.html#sec-back-to-the-basics">4.1</a>); this is the <a name="shift_index_term" /><span class="termdef">shift</span> operation.
If the top <em>n</em> items on the stack match
the <em>n</em> items on the right hand side of some production,
then they are all popped off the stack, and the item on the left-hand
side of the production is pushed on the stack.  This replacement of
the top <em>n</em> items with a single item is the <a name="reduce_index_term" /><span class="termdef">reduce</span> operation.
This operation may only be applied to the top of the stack;
reducing items lower in the stack must be done before later items are
pushed onto the stack.  The parser finishes when all the input is
consumed and there is only one item remaining on the stack, a parse
tree with an <tt class="doctest"><span class="pre">S</span></tt> node as its root.
The shift-reduce parser builds a parse tree during the above process.
Each time it pops <em>n</em> items off the stack it combines them into
a partial parse tree, and pushes this back on the stack.
We can see the shift-reduce parsing algorithm in action using the
graphical demonstration <tt class="doctest"><span class="pre">nltk.app.srparser()</span></tt>.
Six stages of the execution of this parser are shown in <a class="reference internal" href="#fig-srparser1-6">4.2</a>.</p>
<span class="target" id="fig-srparser1-6"></span><div class="figure" id="fig-srparser1-6">
<img alt="../images/srparser1-6.png" src="../images/srparser1-6.png" style="width: 1010.5px; height: 598.0px;" />
<p class="caption"><span class="caption-label">Figure 4.2</span>: Six Stages of a Shift-Reduce Parser: the parser begins by shifting the
first input word onto its stack; once the top items on the stack match
the right hand side of a grammar production, they can be replaced with
the left hand side of that production; the parser succeeds once all input
is consumed and one <tt class="doctest"><span class="pre">S</span></tt> item remains on the stack.</p>
</div>
<p>NLTK provides <tt class="doctest"><span class="pre">ShiftReduceParser()</span></tt>, a simple
implementation of a shift-reduce parser.  This parser does not
implement any backtracking, so it is not guaranteed to find a parse
for a text, even if one exists.  Furthermore, it will only find at
most one parse, even if more parses exist.  We can provide an
optional <tt class="doctest"><span class="pre">trace</span></tt> parameter that controls how verbosely the
parser reports the steps that it takes as it parses a text:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sr_parser = nltk.ShiftReduceParser(grammar1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">'Mary saw a dog'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> sr_parser.parse(sent):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">  (S (NP Mary) (VP (V saw) (NP (Det a) (N dog))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Run the above parser in tracing mode to see the sequence of shift and reduce
operations, using <tt class="doctest"><span class="pre">sr_parse = nltk.ShiftReduceParser(grammar1, trace=2)</span></tt></p>
</div>
<p>A shift-reduce parser can reach a dead end and fail to find any parse,
even if the input sentence is well-formed according to the grammar.
When this happens, no input remains, and the stack contains items
which cannot be reduced to an <tt class="doctest"><span class="pre">S</span></tt>.  The problem arises because
there are choices made earlier that cannot be undone by the parser
(although users of the graphical demonstration can undo their choices).
There are two kinds of choices to be made by the parser:
(a) which reduction to do when more than one is possible
(b) whether to shift or reduce when either action is possible.</p>
<p>A shift-reduce parser may be extended to implement policies for resolving such
conflicts.  For example, it may address shift-reduce conflicts by
shifting only when no reductions are possible, and it may address
reduce-reduce conflicts by favoring the reduction operation that removes
the most items from the stack.  (A generalization of shift-reduce
parser, a &quot;lookahead LR parser&quot;, is commonly used in programming
language compilers.)</p>
<p>The advantage of shift-reduce parsers over recursive descent parsers
is that they only build structure that corresponds to the words in the
input.  Furthermore, they only build each sub-structure once,
e.g. <tt class="doctest"><span class="pre">NP(Det(the), N(man))</span></tt> is only built and pushed onto the stack
a single time, regardless of whether it will later be used by the
<tt class="doctest"><span class="pre">VP -&gt; V NP PP</span></tt> reduction or the <tt class="doctest"><span class="pre">NP -&gt; NP PP</span></tt> reduction.</p>
</div>
<div class="section" id="the-left-corner-parser">
<h2>4.3&nbsp;&nbsp;&nbsp;The Left-Corner Parser</h2>
<p>One of the problems with the recursive descent parser is that it
goes into an infinite loop when it encounters a left-recursive production.
This is because it applies the grammar
productions blindly, without considering the actual input sentence.
A left-corner parser is a hybrid between the bottom-up and top-down
approaches we have seen.</p>
<p>Grammar <tt class="doctest"><span class="pre">grammar1</span></tt> allows us to produce the following parse of <span class="example">John saw
Mary</span>:</p>
<span class="target" id="ex-jmtree"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(11)</td><td width="15"></td><td><img alt="tree_images/ch08-tree-8.png" class="align-top" src="tree_images/ch08-tree-8.png" /></td></tr></table></p>
<p>Recall that the grammar (defined in <a class="reference internal" href="#code-cfg2">3.3</a>) has the following productions for expanding <tt class="doctest"><span class="pre">NP</span></tt>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(12)</td><td width="15"></td><td><span class="target" id="ex-r1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><tt class="doctest"><span class="pre">NP -&gt; Det N</span></tt></td></tr></table></p>
<span class="target" id="ex-r2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">NP -&gt; Det N PP</span></tt></td></tr></table></p>
<span class="target" id="ex-r3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td><tt class="doctest"><span class="pre">NP -&gt; <span class="pysrc-string">&quot;John&quot;</span> | <span class="pysrc-string">&quot;Mary&quot;</span> | <span class="pysrc-string">&quot;Bob&quot;</span></span></tt></td></tr></table></p>
</td></tr></table></p>
<!-- XXX Following notation with DoubleRightArrow wrongly assumes
this relation has been defined. -->
<p>Suppose we ask you to first look at tree <a class="reference internal" href="#ex-jmtree">(11)</a>, and then decide
which of the <tt class="doctest"><span class="pre">NP</span></tt> productions you'd want a recursive descent parser to
apply first &#8212; obviously, <a class="reference internal" href="#ex-r3">(12c)</a> is the right choice! How do you
know that it would be pointless to apply <a class="reference internal" href="#ex-r1">(12a)</a> or <a class="reference internal" href="#ex-r2">(12b)</a> instead? Because
neither of these productions will derive a sequence whose first word is
<span class="example">John</span>.  That is, we can easily tell that in a successful
parse of <span class="example">John saw Mary</span>, the parser has to expand <tt class="doctest"><span class="pre">NP</span></tt> in
such a way that <tt class="doctest"><span class="pre">NP</span></tt> derives the sequence <span class="example">John</span> &#945;. More
generally, we say that a category <span class="math">B</span> is a <a name="left_corner_index_term" /><span class="termdef">left-corner</span> of
a tree rooted in <span class="math">A</span> if  <span class="math">A</span> &#8658;*
<span class="math">B</span> &#945;.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(13)</td><td width="15"></td><td><img alt="tree_images/ch08-tree-9.png" class="align-top" src="tree_images/ch08-tree-9.png" /></td></tr></table></p>
<p>A <a name="left_corner_parser_index_term" /><span class="termdef">left-corner parser</span> is a top-down parser with bottom-up filtering.
Unlike an ordinary recursive descent parser, it does not get trapped
in left recursive productions.
Before starting its work, a left-corner parser preprocesses the
context-free grammar to build a table where each row contains two
cells, the first holding a non-terminal, and the second holding the
collection of possible left corners of that non-terminal. <a class="reference internal" href="#tab-lc">4.1</a>
illustrates this for the grammar from <tt class="doctest"><span class="pre">grammar2</span></tt>.</p>
<span class="target" id="tab-lc"></span><table border="1" class="docutils" id="tab-lc">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Category</th>
<th class="head">Left-Corners (pre-terminals)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>S</td>
<td>NP</td>
</tr>
<tr><td>NP</td>
<td>Det, PropN</td>
</tr>
<tr><td>VP</td>
<td>V</td>
</tr>
<tr><td>PP</td>
<td>P</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 4.1</span>: <p>Left-Corners in <tt class="doctest"><span class="pre">grammar2</span></tt></p>
</p>
</table>
<p>Each time a production is considered by the parser, it checks that the
next input word is compatible with at least one of the pre-terminal
categories in the left-corner table.</p>
<!-- XXX explain how this effects the action of the parser, and why this solves the problem -->
</div>
<div class="section" id="well-formed-substring-tables">
<h2>4.4&nbsp;&nbsp;&nbsp;Well-Formed Substring Tables</h2>
<p>The simple parsers discussed above suffer from limitations in
both completeness and efficiency. In order to remedy these, we will
apply the algorithm design technique of <a name="dynamic_programming_index_term" /><span class="term">dynamic programming</span> to
the parsing problem.  As we saw in <a class="reference external" href="ch04.html#sec-algorithm-design">4.7</a>,
dynamic programming stores intermediate results and re-uses them when
appropriate, achieving significant efficiency gains. This technique
can be applied to syntactic parsing, allowing us to store
partial solutions to the parsing task and then look them up as
necessary in order to efficiently arrive at a complete solution.
This approach to parsing is known as <a name="chart_parsing_index_term" /><span class="termdef">chart parsing</span>.  We introduce
the main idea in this section; see the online materials available for
this chapter for more implementation details.</p>
<p>Dynamic programming allows us to build the <tt class="doctest"><span class="pre">PP</span></tt> <span class="example">in my pajamas</span>
just once.  The first time we build it we save it in a table, then we look it
up when we need to use it as a subconstituent of either the object <tt class="doctest"><span class="pre">NP</span></tt> or
the higher <tt class="doctest"><span class="pre">VP</span></tt>. This table is known as a
<a name="well_formed_substring_table_index_term" /><span class="termdef">well-formed substring table</span>, or WFST for short.
(The term &quot;substring&quot; refers to a contiguous sequence of words within a sentence.)
We will show how to construct the WFST bottom-up so as to systematically record
what syntactic constituents have been found.</p>
<p>Let's set our input to be the sentence in <a class="reference internal" href="#ex-marx-elephant">(2)</a>.  The numerically specified
spans of the WFST are reminiscent of Python's slice notation (<a class="reference external" href="ch03.html#sec-strings">3.2</a>).  Another
way to think about the data structure is shown in <a class="reference internal" href="#fig-chart-positions1">4.3</a>, a data
structure known as a <a name="chart_index_term" /><span class="termdef">chart</span>.</p>
<span class="target" id="fig-chart-positions1"></span><div class="figure" id="fig-chart-positions1">
<img alt="../images/chart_positions1.png" src="../images/chart_positions1.png" style="width: 129.75px; height: 11.0px;" />
<p class="caption"><span class="caption-label">Figure 4.3</span>: The Chart Data Structure: words are the edge labels of a linear graph structure.</p>
</div>
<p>In a WFST, we record the position of the words
by filling in cells in a triangular matrix:
the vertical axis will denote the start position of a substring,
while the horizontal axis will denote the end position
(thus <span class="example">shot</span> will appear in the cell with coordinates (1, 2)).
To simplify this presentation, we will assume each word has a unique
lexical category, and we will store this (not the word) in the matrix.
So cell (1, 2) will contain the entry <tt class="doctest"><span class="pre">V</span></tt>.
More generally, if our input string is
<cite>a</cite><sub>0</sub><cite>a</cite><sub>1</sub> ... <cite>a</cite><sub>n</sub>, and our grammar
contains a production of the form <em>A</em> &#8594; <cite>a</cite><sub>i</sub>, then we add <em>A</em> to
the cell (<cite>i</cite>, <a href="#id1"><span class="problematic" id="id2">`</span></a>i`+1).</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">ch08.rst2</tt>, line 900); <em><a href="#id2">backlink</a></em></p>
Inline interpreted text or phrase reference start-string without end-string.</div>
<p>So, for every word in <tt class="doctest"><span class="pre">text</span></tt>, we can look up in our grammar what
category it belongs to.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text = [<span class="pysrc-string">'I'</span>, <span class="pysrc-string">'shot'</span>, <span class="pysrc-string">'an'</span>, <span class="pysrc-string">'elephant'</span>, <span class="pysrc-string">'in'</span>, <span class="pysrc-string">'my'</span>, <span class="pysrc-string">'pajamas'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>groucho_grammar.productions(rhs=text[1])
<span class="pysrc-output">[V -&gt; 'shot']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>For our WFST, we create an <span class="math">(n-1)</span> &#215; <span class="math">(n-1)</span> matrix
as a list of lists in Python, and initialize it
with the lexical categories of each token, in the <tt class="doctest"><span class="pre">init_wfst()</span></tt>
function in <a class="reference internal" href="#code-wfst">4.4</a>.  We also define a utility function <tt class="doctest"><span class="pre">display()</span></tt>
to pretty-print the WFST for us.
As expected, there is a <tt class="doctest"><span class="pre">V</span></tt> in cell (1, 2).</p>
<span class="target" id="code-wfst"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">init_wfst</span>(tokens, grammar):
    numtokens = len(tokens)
    wfst = [[None <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(numtokens+1)] <span class="pysrc-keyword">for</span> j <span class="pysrc-keyword">in</span> range(numtokens+1)]
    <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(numtokens):
        productions = grammar.productions(rhs=tokens[i])
        wfst[i][i+1] = productions[0].lhs()
    return wfst

<span class="pysrc-keyword">def</span> <span class="pysrc-defname">complete_wfst</span>(wfst, tokens, grammar, trace=False):
    index = dict((p.rhs(), p.lhs()) <span class="pysrc-keyword">for</span> p <span class="pysrc-keyword">in</span> grammar.productions())
    numtokens = len(tokens)
    <span class="pysrc-keyword">for</span> span <span class="pysrc-keyword">in</span> range(2, numtokens+1):
        <span class="pysrc-keyword">for</span> start <span class="pysrc-keyword">in</span> range(numtokens+1-span):
            end = start + span
            <span class="pysrc-keyword">for</span> mid <span class="pysrc-keyword">in</span> range(start+1, end):
                nt1, nt2 = wfst[start][mid], wfst[mid][end]
                <span class="pysrc-keyword">if</span> nt1 <span class="pysrc-keyword">and</span> nt2 <span class="pysrc-keyword">and</span> (nt1,nt2) <span class="pysrc-keyword">in</span> index:
                    wfst[start][end] = index[(nt1,nt2)]
                    <span class="pysrc-keyword">if</span> trace:
                        <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;[%s] %3s [%s] %3s [%s] ==&gt; [%s] %3s [%s]&quot;</span> % \
                        (start, nt1, mid, nt2, end, start, index[(nt1,nt2)], end))
    return wfst

<span class="pysrc-keyword">def</span> <span class="pysrc-defname">display</span>(wfst, tokens):
    <span class="pysrc-keyword">print</span>(<span class="pysrc-string">'\nWFST '</span> + <span class="pysrc-string">' '</span>.join((<span class="pysrc-string">&quot;%-4d&quot;</span> % i) <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(1, len(wfst))))
    <span class="pysrc-keyword">for</span> i <span class="pysrc-keyword">in</span> range(len(wfst)-1):
        <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;%d   &quot;</span> % i, end=<span class="pysrc-string">&quot; &quot;</span>)
        <span class="pysrc-keyword">for</span> j <span class="pysrc-keyword">in</span> range(1, len(wfst)):
            <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;%-4s&quot;</span> % (wfst[i][j] <span class="pysrc-keyword">or</span> <span class="pysrc-string">'.'</span>), end=<span class="pysrc-string">&quot; &quot;</span>)
        <span class="pysrc-keyword">print</span>()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">&quot;I shot an elephant in my pajamas&quot;</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wfst0 = init_wfst(tokens, groucho_grammar)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>display(wfst0, tokens)
WFST 1    2    3    4    5    6    7
0    NP   .    .    .    .    .    .
1    .    V    .    .    .    .    .
2    .    .    Det  .    .    .    .
3    .    .    .    N    .    .    .
4    .    .    .    .    P    .    .
5    .    .    .    .    .    Det  .
6    .    .    .    .    .    .    N
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wfst1 = complete_wfst(wfst0, tokens, groucho_grammar)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>display(wfst1, tokens)
WFST 1    2    3    4    5    6    7
0    NP   .    .    S    .    .    S
1    .    V    .    VP   .    .    VP
2    .    .    Det  NP   .    .    .
3    .    .    .    N    .    .    .
4    .    .    .    .    P    .    PP
5    .    .    .    .    .    Det  NP
6    .    .    .    .    .    .    N</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_wfst.py" type="text/x-python"><span class="caption-label">Example 4.4 (code_wfst.py)</span></a>: <span class="caption-label">Figure 4.4</span>: Acceptor Using Well-Formed Substring Table</td></tr></p>
</table></div>
<p>Returning to our tabular representation, given that we have <tt class="doctest"><span class="pre">Det</span></tt>
in cell (2, 3) for the word <span class="example">an</span>, and <tt class="doctest"><span class="pre">N</span></tt> in cell (3, 4) for the
word <span class="example">elephant</span>, what should we put into cell (2, 4) for <span class="example">an elephant</span>?
We need to find a production of the form <em>A</em> &#8594; <tt class="doctest"><span class="pre">Det N</span></tt>.
Consulting the grammar, we know that we can enter <tt class="doctest"><span class="pre">NP</span></tt> in cell (2, 4).</p>
<!-- XXX overuse of 'more generally'? Maybe say: 'To summarise'? -->
<p>More generally, we can enter <em>A</em> in <span class="math">(i, j)</span> if there
is a production <em>A</em> &#8594; <em>B</em> <em>C</em>, and we find
nonterminal <em>B</em> in <span class="math">(i, k)</span> and <em>C</em> in <span class="math">(k, j)</span>.
The program in <a class="reference internal" href="#code-wfst">4.4</a> uses this rule to complete the WFST.
By setting <tt class="doctest"><span class="pre">trace</span></tt> to <tt class="doctest"><span class="pre">True</span></tt> when calling the function <tt class="doctest"><span class="pre">complete_wfst()</span></tt>,
we see tracing output that shows the WFST being constructed:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wfst1 = complete_wfst(wfst0, tokens, groucho_grammar, trace=True)
<span class="pysrc-output">[2] Det [3]   N [4] ==&gt; [2]  NP [4]</span>
<span class="pysrc-output">[5] Det [6]   N [7] ==&gt; [5]  NP [7]</span>
<span class="pysrc-output">[1]   V [2]  NP [4] ==&gt; [1]  VP [4]</span>
<span class="pysrc-output">[4]   P [5]  NP [7] ==&gt; [4]  PP [7]</span>
<span class="pysrc-output">[0]  NP [1]  VP [4] ==&gt; [0]   S [4]</span>
<span class="pysrc-output">[1]  VP [4]  PP [7] ==&gt; [1]  VP [7]</span>
<span class="pysrc-output">[0]  NP [1]  VP [7] ==&gt; [0]   S [7]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>For example, this says that since we found <tt class="doctest"><span class="pre">Det</span></tt> at
<tt class="doctest"><span class="pre">wfst[2][3]</span></tt> and <tt class="doctest"><span class="pre">N</span></tt> at <tt class="doctest"><span class="pre">wfst[3][4]</span></tt>, we can add <tt class="doctest"><span class="pre">NP</span></tt> to
<tt class="doctest"><span class="pre">wfst[2][4]</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To help us easily retrieve productions by their right hand
sides, we create an index for the grammar.
This is an example of a space-time trade-off: we do a reverse lookup
on the grammar, instead of having to check through the entire list of
productions each time we want to look up via the right hand side.</p>
</div>
<span class="target" id="fig-chart-positions2"></span><div class="figure" id="fig-chart-positions2">
<img alt="../images/chart_positions2.png" src="../images/chart_positions2.png" style="width: 129.75px; height: 44.0px;" />
<p class="caption"><span class="caption-label">Figure 4.5</span>: The Chart Data Structure: non-terminals are represented as extra edges in the chart.</p>
</div>
<p>We conclude that there is a parse for the whole input string once
we have constructed an <tt class="doctest"><span class="pre">S</span></tt> node in cell (0, 7), showing that we
have found a sentence that covers the whole input.  The final state of
the WFST is depicted in <a class="reference internal" href="#fig-chart-positions2">4.5</a>.</p>
<p>Notice that we have not used any built-in parsing functions here.
We've implemented a complete, primitive chart parser from the ground up!</p>
<!-- XXX distinction between recognition and parsing should be explained
more carefully or else dropped. -->
<p>WFST's have several shortcomings.
First, as you can see, the WFST is not itself a parse tree, so the technique is
strictly speaking <a name="recognizing_index_term" /><span class="termdef">recognizing</span> that a sentence is admitted by a
grammar, rather than parsing it.
Second, it requires every non-lexical grammar production to be <span class="emphasis">binary</span>.
Although it is possible to convert an arbitrary CFG into this form,
we would prefer to use an approach without such a requirement.
Third, as a bottom-up approach it is potentially wasteful, being
able to propose constituents in locations that would not be licensed by
the grammar.</p>
<!-- XXX is this correct? There isn't an NP -> NP PP edge in the table -->
<p>Finally, the WFST did not represent the structural ambiguity in
the sentence (i.e. the two verb phrase readings).  The <tt class="doctest"><span class="pre">VP</span></tt>
in cell (1, 7) was actually entered twice, once for a <tt class="doctest"><span class="pre">V NP</span></tt>
reading, and once for a <tt class="doctest"><span class="pre">VP PP</span></tt> reading.  These are different
hypotheses, and the second overwrote the first (as it happens this didn't
matter since the left hand side was the same.)
Chart parsers use a slighly richer data structure and some interesting
algorithms to solve these problems (see the Further Reading section at
the end of this chapter for details).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try out the interactive chart parser application <tt class="doctest"><span class="pre">nltk.app.chartparser()</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="dependencies-and-dependency-grammar">
<h1>5&nbsp;&nbsp;&nbsp;Dependencies and Dependency Grammar</h1>
<p>Phrase structure grammar is concerned with how words and sequences of
words <span class="emphasis">combine</span> to form constituents. A distinct and complementary
approach, dependency grammar, focusses instead on how words
<span class="emphasis">relate</span> to other words. Dependency is a binary asymmetric relation that
holds between a <a name="head_index_term" /><span class="termdef">head</span> and its <a name="dependents_index_term" /><span class="termdef">dependents</span>.
The head of a sentence is usually taken to be the tensed verb, and every other word is
either dependent on the sentence head, or connects to it through a path of
dependencies.</p>
<!-- XXX explain concept of "head"? -->
<p>A dependency representation is a labeled directed graph, where the
nodes are the lexical items and the labeled arcs represent dependency
relations from heads to dependents.  <a class="reference internal" href="#fig-depgraph0">5.1</a> illustrates a
dependency graph, where arrows point from heads to their dependents.</p>
<span class="target" id="fig-depgraph0"></span><div class="figure" id="fig-depgraph0">
<img alt="../images/depgraph0.png" src="../images/depgraph0.png" style="width: 643.3px; height: 109.55px;" />
<p class="caption"><span class="caption-label">Figure 5.1</span>: Dependency Structure: arrows point from heads to their dependents;
labels indicate the grammatical function of the dependent as
subject, object or modifier.</p>
</div>
<p>The arcs in <a class="reference internal" href="#fig-depgraph0">5.1</a> are labeled with the grammatical
function that holds between a dependent and its head. For example,
<span class="example">I</span> is the <tt class="doctest"><span class="pre">SBJ</span></tt> (subject) of <span class="example">shot</span> (which is the head of
the whole sentence), and <span class="example">in</span> is an <tt class="doctest"><span class="pre">NMOD</span></tt> (noun modifier of
<span class="example">elephant</span>). In contrast to phrase structure grammar, therefore,
dependency grammars can be used to directly express grammatical
functions as a type of dependency.</p>
<p>Here's one way of encoding a
dependency grammar in NLTK &#8212; note that it only captures bare
dependency information without specifying the type of dependency:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>groucho_dep_grammar = nltk.DependencyGrammar.fromstring(<span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-more">... </span><span class="pysrc-string">'shot' -&gt; 'I' | 'elephant' | 'in'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">'elephant' -&gt; 'an' | 'in'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">'in' -&gt; 'pajamas'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">'pajamas' -&gt; 'my'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;&quot;&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(groucho_dep_grammar)
<span class="pysrc-output">Dependency grammar with 7 productions</span>
<span class="pysrc-output">  'shot' -&gt; 'I'</span>
<span class="pysrc-output">  'shot' -&gt; 'elephant'</span>
<span class="pysrc-output">  'shot' -&gt; 'in'</span>
<span class="pysrc-output">  'elephant' -&gt; 'an'</span>
<span class="pysrc-output">  'elephant' -&gt; 'in'</span>
<span class="pysrc-output">  'in' -&gt; 'pajamas'</span>
<span class="pysrc-output">  'pajamas' -&gt; 'my'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A dependency graph is <a name="projective_index_term" /><span class="termdef">projective</span> if, when all the words are
written in linear order, the edges can be drawn above the words
without crossing. This is equivalent to saying that a word and all its
descendents (dependents and dependents of its dependents, etc.) form a
contiguous sequence of words within the sentence. <a class="reference internal" href="#fig-depgraph0">5.1</a> is
projective, and we can parse many sentences in English using a
projective dependency parser. The next example shows how
<tt class="doctest"><span class="pre">groucho_dep_grammar</span></tt> provides an alternative approach to capturing
the attachment ambiguity that we examined earlier with phrase
structure grammar.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>pdp = nltk.ProjectiveDependencyParser(groucho_dep_grammar)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">'I shot an elephant in my pajamas'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>trees = pdp.parse(sent)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(shot I (elephant an (in (pajamas my))))</span>
<span class="pysrc-output">(shot I (elephant an) (in (pajamas my)))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>These bracketed dependency structures can also be displayed as trees,
where dependents are shown as children of their heads.</p>
<span class="target" id="ex-depgraph1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(14)</td><td width="15"></td><td><img alt="tree_images/ch08-tree-10.png" class="align-top" src="tree_images/ch08-tree-10.png" /><img alt="tree_images/ch08-tree-11.png" class="align-top" src="tree_images/ch08-tree-11.png" /></td></tr></table></p>
<p>In languages with more flexible word order than English,
non-projective dependencies are more frequent.</p>
<!-- give example of parsing non-projective example -->
<!-- really needs better technique for visualizing a DependencyGraph -->
<p>Various criteria have been proposed for deciding what is the head <em>H</em> and
what is the dependent <em>D</em> in a construction <em>C</em>. Some of the most important
are the following:</p>
<ol class="arabic simple">
<li><em>H</em> determines the distribution class of <em>C</em>; or alternatively, the
external syntactic properties of <em>C</em> are due to <em>H</em>.</li>
<li><em>H</em> determines the semantic type of <em>C</em>.</li>
<li><em>H</em> is obligatory while <em>D</em> may be optional.</li>
<li><em>H</em> selects <em>D</em> and determines whether it is obligatory or
optional.</li>
<li>The morphological form of <em>D</em> is determined by <em>H</em> (e.g. agreement
or case government).</li>
</ol>
<p>When we say in a phrase structure grammar that the immediate
constituents of a <tt class="doctest"><span class="pre">PP</span></tt> are <tt class="doctest"><span class="pre">P</span></tt> and <tt class="doctest"><span class="pre">NP</span></tt>, we are implicitly
appealing to the head / dependent distinction. A prepositional phrase
is a phrase whose head is a preposition; moreover, the <tt class="doctest"><span class="pre">NP</span></tt> is a
dependent of <tt class="doctest"><span class="pre">P</span></tt>.  The same distinction carries over to the other
types of phrase that we have discussed. The key point to note here is
that although phrase structure grammars seem very different from
dependency grammars, they implicitly embody a recognition of
dependency relations. While CFGs are not intended to directly capture
dependencies, more recent linguistic frameworks have increasingly
adopted formalisms which combine aspects of both approaches.</p>
<div class="section" id="valency-and-the-lexicon">
<h2>5.1&nbsp;&nbsp;&nbsp;Valency and the Lexicon</h2>
<p>Let us take a closer look at verbs and their dependents.
The grammar in <a class="reference internal" href="#code-cfg2">3.3</a> correctly generates examples like
<a class="reference internal" href="#ex-subcat1">(15d)</a>.</p>
<span class="target" id="ex-subcat1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(15)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The squirrel was frightened.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Chatterer saw the bear.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>Chatterer thought Buster was angry.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">d.</td><td width="15"></td><td>Joe put the fish on the log.</td></tr></table></p>
</td></tr></table></p>
<!-- XXX CFG productions in the DG section? -->
<p>These possibilities correspond to the following productions:</p>
<span class="target" id="tab-subcat"></span><table border="1" class="docutils" id="tab-subcat">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">VP -&gt; V Adj</span></tt></td>
<td><span class="example">was</span></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">VP -&gt; V NP</span></tt></td>
<td><span class="example">saw</span></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">VP -&gt; V S</span></tt></td>
<td><span class="example">thought</span></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">VP -&gt; V NP PP</span></tt></td>
<td><span class="example">put</span></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 5.1</span>: <p>VP productions and their lexical heads</p>
</p>
</table>
<!-- XXX above table is missing a caption, required for formal tables -->
<p>That is, <span class="example">was</span> can occur with a following <tt class="doctest"><span class="pre">Adj</span></tt>, <span class="example">saw</span> can occur with a
following <tt class="doctest"><span class="pre">NP</span></tt>, <span class="example">thought</span> can occur with a following <tt class="doctest"><span class="pre">S</span></tt> and <span class="example">put</span> can
occur with a following <tt class="doctest"><span class="pre">NP</span></tt> and <tt class="doctest"><span class="pre">PP</span></tt>. The dependents <tt class="doctest"><span class="pre">Adj</span></tt>, <tt class="doctest"><span class="pre">NP</span></tt>, <tt class="doctest"><span class="pre">PP</span></tt> and
<tt class="doctest"><span class="pre">S</span></tt> are often called <a name="complements_index_term" /><span class="termdef">complements</span> of the respective verbs and there are strong
constraints on what verbs can occur with what complements. By contrast with
<a class="reference internal" href="#ex-subcat1">(15d)</a>, the word sequences in <a class="reference internal" href="#ex-subcat2">(16d)</a> are ill-formed:</p>
<span class="target" id="ex-subcat2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(16)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>*The squirrel was Buster was angry.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*Chatterer saw frightened.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>*Chatterer thought the bear.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">d.</td><td width="15"></td><td>*Joe put on the log.</td></tr></table></p>
</td></tr></table></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With a little imagination, it is possible to
invent contexts in which unusual combinations of verbs and
complements are interpretable. However, we assume that the above
examples are to be interpreted in neutral contexts.</p>
</div>
<!-- XXX does the historical note matter here?  Can we just talk about
valency without linking it to a tradition? -->
<p>In the tradition of dependency grammar, the verbs in <a class="reference internal" href="#tab-subcat">5.1</a> are said
to have different <a name="valencies_index_term" /><span class="termdef">valencies</span>. Valency restrictions are not just
applicable to verbs, but also to the other classes of heads.</p>
<!-- XXX "techniques within frameworks based on PSG" overly complicated.
This paragraph probably works just fine without this sentence. -->
<p>Within frameworks based on phrase structure grammar, various
techniques have been proposed for excluding the
ungrammatical examples in <a class="reference internal" href="#ex-subcat2">(16d)</a>. In a CFG, we need some way of constraining
grammar productions which expand <tt class="doctest"><span class="pre">VP</span></tt> so that verbs <em>only</em> co-occur
with their correct complements. We can do this by dividing the class of
verbs into &quot;subcategories&quot;, each of which is associated with a
different set of complements. For example, <a name="transitive_verbs_index_term" /><span class="termdef">transitive verbs</span> such
as <span class="example">chased</span> and <span class="example">saw</span> require a following <tt class="doctest"><span class="pre">NP</span></tt>
object complement; that is, they are <a name="subcategorized_index_term" /><span class="termdef">subcategorized</span> for <tt class="doctest"><span class="pre">NP</span></tt>
direct objects. If we introduce a new category label for transitive verbs, namely
<tt class="doctest"><span class="pre">TV</span></tt> (for Transitive Verb), then we can use it in the following productions:</p>
<pre class="literal-block">
VP -&gt; TV NP
TV -&gt; 'chased' | 'saw'
</pre>
<p>Now <span class="example">*Joe thought the bear</span> is excluded since we haven't listed
<span class="example">thought</span> as a <tt class="doctest"><span class="pre">TV</span></tt>, but <span class="example">Chatterer saw the bear</span> is still allowed.
<a class="reference internal" href="#tab-verbcat">5.2</a> provides more examples of labels for verb subcategories.</p>
<span class="target" id="tab-verbcat"></span><table border="1" class="docutils" id="tab-verbcat">
<colgroup>
<col width="12%" />
<col width="40%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Symbol</th>
<th class="head">Meaning</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>IV</td>
<td>intransitive verb</td>
<td><em>barked</em></td>
</tr>
<tr><td>TV</td>
<td>transitive verb</td>
<td><em>saw a man</em></td>
</tr>
<tr><td>DatV</td>
<td>dative verb</td>
<td><em>gave a dog to a man</em></td>
</tr>
<tr><td>SV</td>
<td>sentential verb</td>
<td><em>said that a dog barked</em></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 5.2</span>: <p>Verb Subcategories</p>
</p>
</table>
<p>Valency is a property of lexical items, and we will discuss it further
in <a class="reference external" href="ch09.html#chap-featgram">9.</a>.</p>
<p>Complements are often contrasted with modifiers (or adjuncts),
although both are kinds of dependent. Prepositional phrases,
adjectives and adverbs typically function as modifiers. Unlike
complements, modifiers are optional, can often be iterated, and are
not selected for by heads in the same way as complements. For
example, the adverb <span class="example">really</span> can be added as a modifer to all the
sentence in <a class="reference internal" href="#ex-mod">(17d)</a>:</p>
<span class="target" id="ex-mod"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(17)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The squirrel really was frightened.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Chatterer really saw the bear.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>Chatterer really thought Buster was angry.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">d.</td><td width="15"></td><td>Joe really put the fish on the log.</td></tr></table></p>
</td></tr></table></p>
<p>The structural ambiguity of <tt class="doctest"><span class="pre">PP</span></tt> attachment, which we have
illustrated in both phrase structure and dependency grammars,
corresponds semantically to an ambiguity in the scope of the modifier.</p>
</div>
<div class="section" id="scaling-up">
<h2>5.2&nbsp;&nbsp;&nbsp;Scaling Up</h2>
<p>So far, we have only considered &quot;toy grammars,&quot; small grammars that
illustrate the key aspects of parsing.  But there is an obvious
question as to whether the approach can be scaled up to cover
large corpora of natural languages. How hard would it be to construct
such a set of productions by hand? In general, the answer is: <em>very
hard</em>. Even if we allow ourselves to use various formal devices that
give much more succinct representations of grammar productions, it is still extremely
difficult to keep control of the complex interactions between the many
productions required to cover the major constructions of a
language. In other words, it is hard to modularize grammars so that
one portion can be developed independently of the other parts. This in
turn means that it is difficult to distribute the task of grammar
writing across a team of linguists. Another difficulty is that as the
grammar expands to cover a wider and wider range of constructions,
there is a corresponding increase in the number of analyses which are
admitted for any one sentence. In other words, ambiguity increases
with coverage.</p>
<p>Despite these problems, some large collaborative
projects have achieved interesting and impressive results in
developing rule-based grammars for several languages. Examples are the
Lexical Functional Grammar (LFG) Pargram project,
the Head-Driven Phrase Structure Grammar (HPSG) LinGO Matrix framework,
and the Lexicalized Tree Adjoining Grammar XTAG Project.</p>
</div>
</div>
<div class="section" id="grammar-development">
<span id="sec-grammar-development"></span><h1>6&nbsp;&nbsp;&nbsp;Grammar Development</h1>
<p>Parsing builds trees over sentences, according to a phrase
structure grammar.  Now, all the examples we gave above
only involved toy grammars containing a handful of productions.
What happens if we try to scale up this approach to deal
with realistic corpora of language?  In this section we will
see how to access treebanks, and look at the challenge of developing
broad-coverage grammars.</p>
<div class="section" id="treebanks-and-grammars">
<h2>6.1&nbsp;&nbsp;&nbsp;Treebanks and Grammars</h2>
<p>The <tt class="doctest"><span class="pre">corpus</span></tt> module defines the <tt class="doctest"><span class="pre">treebank</span></tt> corpus reader,
which contains a 10% sample of the Penn Treebank corpus.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> treebank
<span class="pysrc-prompt">&gt;&gt;&gt; </span>t = treebank.parsed_sents(<span class="pysrc-string">'wsj_0001.mrg'</span>)[0]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(t)
<span class="pysrc-output">(S</span>
<span class="pysrc-output">  (NP-SBJ</span>
<span class="pysrc-output">    (NP (NNP Pierre) (NNP Vinken))</span>
<span class="pysrc-output">    (, ,)</span>
<span class="pysrc-output">    (ADJP (NP (CD 61) (NNS years)) (JJ old))</span>
<span class="pysrc-output">    (, ,))</span>
<span class="pysrc-output">  (VP</span>
<span class="pysrc-output">    (MD will)</span>
<span class="pysrc-output">    (VP</span>
<span class="pysrc-output">      (VB join)</span>
<span class="pysrc-output">      (NP (DT the) (NN board))</span>
<span class="pysrc-output">      (PP-CLR</span>
<span class="pysrc-output">        (IN as)</span>
<span class="pysrc-output">        (NP (DT a) (JJ nonexecutive) (NN director)))</span>
<span class="pysrc-output">      (NP-TMP (NNP Nov.) (CD 29))))</span>
<span class="pysrc-output">  (. .))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can use this data to help develop a grammar.
For example, the program in <a class="reference internal" href="#code-sentential-complement">6.1</a>
uses a simple filter to find verbs that take sentential complements.
Assuming we already have a production of the form <tt class="doctest"><span class="pre">VP -&gt; Vs S</span></tt>,
this information enables us to identify particular verbs
that would be included in the expansion of <tt class="doctest"><span class="pre">Vs</span></tt>.</p>
<span class="target" id="code-sentential-complement"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">filter</span>(tree):
    child_nodes = [child.label() <span class="pysrc-keyword">for</span> child <span class="pysrc-keyword">in</span> tree
                   <span class="pysrc-keyword">if</span> isinstance(child, nltk.Tree)]
    return  (tree.label() == <span class="pysrc-string">'VP'</span>) <span class="pysrc-keyword">and</span> (<span class="pysrc-string">'S'</span> <span class="pysrc-keyword">in</span> child_nodes)</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.corpus <span class="pysrc-keyword">import</span> treebank
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[subtree <span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> treebank.parsed_sents()
<span class="pysrc-more">... </span>         <span class="pysrc-keyword">for</span> subtree <span class="pysrc-keyword">in</span> tree.subtrees(filter)]
<span class="pysrc-output"> [Tree('VP', [Tree('VBN', ['named']), Tree('S', [Tree('NP-SBJ', ...]), ...]), ...]</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_sentential_complement.py" type="text/x-python"><span class="caption-label">Example 6.1 (code_sentential_complement.py)</span></a>: <span class="caption-label">Figure 6.1</span>: Searching a Treebank to find Sentential Complements</td></tr></p>
</table></div>
<p>The Prepositional Phrase Attachment Corpus, <tt class="doctest"><span class="pre">nltk.corpus.ppattach</span></tt>
is another source of information about the valency of particular verbs.
Here we illustrate a technique for mining this corpus.
It finds pairs of prepositional phrases where the preposition
and noun are fixed, but where the choice of verb determines whether
the prepositional phrase is attached to the <tt class="doctest"><span class="pre">VP</span></tt> or to the <tt class="doctest"><span class="pre">NP</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> collections <span class="pysrc-keyword">import</span> defaultdict
<span class="pysrc-prompt">&gt;&gt;&gt; </span>entries = nltk.corpus.ppattach.attachments(<span class="pysrc-string">'training'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>table = defaultdict(<span class="pysrc-keyword">lambda</span>: defaultdict(set))
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> entry <span class="pysrc-keyword">in</span> entries:
<span class="pysrc-more">... </span>    key = entry.noun1 + <span class="pysrc-string">'-'</span> + entry.prep + <span class="pysrc-string">'-'</span> + entry.noun2
<span class="pysrc-more">... </span>    table[key][entry.attachment].add(entry.verb)
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> key <span class="pysrc-keyword">in</span> sorted(table):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> len(table[key]) &gt; 1:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span>(key, <span class="pysrc-string">'N:'</span>, sorted(table[key][<span class="pysrc-string">'N'</span>]), <span class="pysrc-string">'V:'</span>, sorted(table[key][<span class="pysrc-string">'V'</span>]))</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Amongst the output lines of this program we find
<tt class="doctest"><span class="pre">offer-<span class="pysrc-keyword">from</span>-group N: [<span class="pysrc-string">'rejected'</span>] V: [<span class="pysrc-string">'received'</span>]</span></tt>,
which indicates that <span class="example">received</span> expects a separate
<tt class="doctest"><span class="pre">PP</span></tt> complement attached to the <tt class="doctest"><span class="pre">VP</span></tt>, while <span class="example">rejected</span> does not.
As before, we can use this information to help construct the grammar.</p>
<p>The NLTK corpus collection includes data from the PE08
Cross-Framework and Cross Domain Parser Evaluation Shared Task.
A collection of larger grammars has been prepared for the purpose of
comparing different parsers, which can be obtained by downloading
the <tt class="doctest"><span class="pre">large_grammars</span></tt> package
(e.g. <tt class="doctest"><span class="pre">python -m nltk.downloader large_grammars</span></tt>).</p>
<p>The NLTK corpus collection also includes a sample from the <em>Sinica Treebank Corpus</em>,
consisting of 10,000 parsed sentences drawn from the
<em>Academia Sinica Balanced Corpus of Modern Chinese</em>.
Let's load and display one of the trees in this corpus.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.corpus.sinica_treebank.parsed_sents()[3450].draw()               </pre>
</td>
</tr></table></td></tr>
</table></div>
<img alt="../images/sinica-tree.png" src="../images/sinica-tree.png" style="width: 703.1999999999999px; height: 208.2px;" />
</div>
<div class="section" id="pernicious-ambiguity">
<h2>6.2&nbsp;&nbsp;&nbsp;Pernicious Ambiguity</h2>
<p>Unfortunately, as the coverage of
the grammar increases and the length of the input sentences grows, the
number of parse trees grows rapidly.  In fact, it grows at an
astronomical rate.</p>
<p>Let's explore this issue with the help of a simple example.
The word
<span class="example">fish</span> is both a noun and a verb.  We can make up the sentence
<span class="example">fish fish fish</span>, meaning <em>fish like to fish for other fish</em>.
(Try this with <span class="example">police</span> if you prefer something more sensible.)
Here is a toy grammar for the &quot;fish&quot; sentences.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>grammar = nltk.CFG.fromstring(<span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-more">... </span><span class="pysrc-string">S -&gt; NP V NP</span>
<span class="pysrc-more">... </span><span class="pysrc-string">NP -&gt; NP Sbar</span>
<span class="pysrc-more">... </span><span class="pysrc-string">Sbar -&gt; NP V</span>
<span class="pysrc-more">... </span><span class="pysrc-string">NP -&gt; 'fish'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">V -&gt; 'fish'</span>
<span class="pysrc-more">... </span><span class="pysrc-string">&quot;&quot;&quot;</span>)</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now we can try parsing a longer sentence, <span class="example">fish fish fish fish
fish</span>, which amongst other things, means 'fish that other fish
fish are in the habit of fishing fish themselves'. We use the NLTK
chart parser, which was mentioned earlier in this chapter.  This
sentence has two readings.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = [<span class="pysrc-string">&quot;fish&quot;</span>] * 5
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = nltk.ChartParser(grammar)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> cp.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S (NP fish) (V fish) (NP (NP fish) (Sbar (NP fish) (V fish))))</span>
<span class="pysrc-output">(S (NP (NP fish) (Sbar (NP fish) (V fish))) (V fish) (NP fish))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>As the length of this sentence goes up (3, 5, 7, ...) we get the
following numbers of parse trees:
1; 2; 5; 14; 42; 132; 429; 1,430; 4,862; 16,796; 58,786; 208,012; ...
(These are the <a name="catalan_numbers_index_term" /><span class="term">Catalan numbers</span>, which we saw in an exercise
in <a class="reference external" href="ch04.html#chap-structured-programming">4</a>).
The last of these is for a sentence of length 23, the average length
of sentences in the  WSJ section of Penn Treebank.  For a sentence
of length 50 there would be over 10<sup>12</sup> parses, and this
is only half the length of the Piglet sentence
(<a class="reference internal" href="#sec-dilemmas">1</a>),
which young children process effortlessly.
No practical NLP system could construct millions of trees for a
sentence and choose the appropriate one in the context.
It's clear that humans don't do this either!</p>
<p>Note that the problem is not with our choice of example.
<a class="reference external" href="bibliography.html#church1982csa" id="id3">(Church &amp; Patil, 1982)</a> point out that the syntactic ambiguity of <tt class="doctest"><span class="pre">PP</span></tt>
attachment in sentences like <a class="reference internal" href="#ex-pp">(18)</a> also grows in proportion to the Catalan
numbers.</p>
<span class="target" id="ex-pp"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(18)</td><td width="15"></td><td>Put the block in the box on the table.</td></tr></table></p>
<p>So much for structural ambiguity; what about lexical ambiguity?
As soon as we try to construct a broad-coverage grammar, we
are forced to make lexical entries highly ambiguous for their part of
speech.  In a toy grammar, <span class="example">a</span> is only a determiner, <span class="example">dog</span> is
only a noun, and <span class="example">runs</span> is only a verb.  However, in a
broad-coverage grammar, <cite>a</cite> is also a noun (e.g. <span class="example">part a</span>),
<span class="example">dog</span> is also a verb (meaning to follow closely), and <span class="example">runs</span>
is also a noun (e.g. <span class="example">ski runs</span>).  In fact, all words can be
referred to by name: e.g. <span class="example">the verb 'ate' is spelled with three
letters</span>; in speech we do not need to supply quotation marks.
Furthermore, it is possible to <em>verb</em> most nouns.  Thus a parser for a
broad-coverage grammar will be overwhelmed with ambiguity.  Even
complete gibberish will often have a reading, e.g. <span class="example">the a are of
I</span>.  As <a class="reference external" href="bibliography.html#abney1996sml" id="id4">(Klavans &amp; Resnik, 1996)</a> has pointed out, this is not word salad but a
grammatical noun phrase, in which <span class="example">are</span> is a noun meaning a
hundredth of a hectare (or 100 sq m), and <span class="example">a</span> and <span class="example">I</span> are
nouns designating coordinates, as shown in <a class="reference internal" href="#fig-are">6.2</a>.</p>
<span class="target" id="fig-are"></span><div class="figure" id="fig-are">
<img alt="../images/are.png" src="../images/are.png" style="width: 452.6px; height: 182.60000000000002px;" />
<p class="caption"><span class="caption-label">Figure 6.2</span>: &quot;The a are of I&quot;: a schematic drawing of 27 paddocks, each being
one &quot;are&quot; in size, and each identified using coordinates;
the top left cell is the <span class="emphasis">a</span> &quot;are&quot; of column <span class="emphasis">I</span> (after Abney).</p>
</div>
<p>
Even though this phrase is unlikely, it is still grammatical and
a broad-coverage parser should be able to construct a parse tree
for it.  Similarly, sentences that seem to be
unambiguous, such as <span class="example">John saw Mary</span>, turn out to have other
readings we would not have anticipated  (as Abney explains).  This
ambiguity is unavoidable, and leads to horrendous inefficiency in
parsing seemingly innocuous sentences.
The solution to these problems is provided by
<span class="emphasis">probabilistic parsing</span>, which allows us to <span class="emphasis">rank</span>
the parses of an ambiguous sentence on the basis of evidence from corpora.</p>
</div>
<div class="section" id="weighted-grammar">
<h2>6.3&nbsp;&nbsp;&nbsp;Weighted Grammar</h2>
<!-- TODO: mention interest in having weights is because they can be learned.
Without this it is mysterious why we would want to bother.
Technical aspects follow, but this is important motivation (Steven) -->
<p>As we have just seen, dealing with ambiguity
is a key challenge in developing broad coverage parsers.
Chart parsers improve the efficiency of computing multiple
parses of the same sentences, but they are still overwhelmed by
the sheer number of possible parses.  Weighted grammars and
probabilistic parsing algorithms have provided an effective
solution to these problems.</p>
<p>Before looking at these, we need to understand why the notion of
grammaticality could be <span class="emphasis">gradient</span>.  Considering the verb <span class="example">give</span>.
This verb requires both a direct object (the thing being given)
and an indirect object (the recipient).
These complements can be given in either order, as
illustrated in <a class="reference internal" href="#ex-dative">(19)</a>.  In the &quot;prepositional dative&quot; form in
<a class="reference internal" href="#ex-dative-prepositional">(19a)</a>, the direct object appears first, followed
by a prepositional phrase containing the indirect object.</p>
<span class="target" id="ex-dative"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(19)</td><td width="15"></td><td><span class="target" id="ex-dative-prepositional"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Kim gave a bone to the dog</td></tr></table></p>
<span class="target" id="ex-dative-double-object"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Kim gave the dog a bone</td></tr></table></p>
</td></tr></table></p>
<p>In the &quot;double object&quot; form in <a class="reference internal" href="#ex-dative-double-object">(19b)</a>,
the indirect object appears first, followed by the direct object.
In the above case, either order is acceptable.  However, if
the indirect object is a pronoun, there is a strong preference for
the double object construction:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(20)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><em>Kim gives the heebie-jeebies to me (*prepositional dative</em>)</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Kim gives me the heebie-jeebies (<em>double object</em>)</td></tr></table></p>
</td></tr></table></p>
<p>Using the Penn Treebank sample, we can examine all instances of
prepositional dative and double object constructions involving
<span class="example">give</span>, as shown in <a class="reference internal" href="#code-give">6.3</a>.</p>
<span class="target" id="code-give"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">give</span>(t):
    return t.label() == <span class="pysrc-string">'VP'</span> <span class="pysrc-keyword">and</span> len(t) &gt; 2 <span class="pysrc-keyword">and</span> t[1].label() == <span class="pysrc-string">'NP'</span>\
           <span class="pysrc-keyword">and</span> (t[2].label() == <span class="pysrc-string">'PP-DTV'</span> <span class="pysrc-keyword">or</span> t[2].label() == <span class="pysrc-string">'NP'</span>)\
           <span class="pysrc-keyword">and</span> (<span class="pysrc-string">'give'</span> <span class="pysrc-keyword">in</span> t[0].leaves() <span class="pysrc-keyword">or</span> <span class="pysrc-string">'gave'</span> <span class="pysrc-keyword">in</span> t[0].leaves())
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">sent</span>(t):
    return <span class="pysrc-string">' '</span>.join(token <span class="pysrc-keyword">for</span> token <span class="pysrc-keyword">in</span> t.leaves() <span class="pysrc-keyword">if</span> token[0] <span class="pysrc-keyword">not</span> <span class="pysrc-keyword">in</span> <span class="pysrc-string">'*-0'</span>)
<span class="pysrc-keyword">def</span> <span class="pysrc-defname">print_node</span>(t, width):
        output = <span class="pysrc-string">&quot;%s %s: %s / %s: %s&quot;</span> %\
            (sent(t[0]), t[1].label(), sent(t[1]), t[2].label(), sent(t[2]))
        <span class="pysrc-keyword">if</span> len(output) &gt; width:
            output = output[:width] + <span class="pysrc-string">&quot;...&quot;</span>
        <span class="pysrc-keyword">print</span>(output)</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> nltk.corpus.treebank.parsed_sents():
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">for</span> t <span class="pysrc-keyword">in</span> tree.subtrees(give):
<span class="pysrc-more">... </span>        print_node(t, 72)
<span class="pysrc-output">gave NP: the chefs / NP: a standing ovation</span>
<span class="pysrc-output">give NP: advertisers / NP: discounts for maintaining or increasing ad sp...</span>
<span class="pysrc-output">give NP: it / PP-DTV: to the politicians</span>
<span class="pysrc-output">gave NP: them / NP: similar help</span>
<span class="pysrc-output">give NP: them / NP:</span>
<span class="pysrc-output">give NP: only French history questions / PP-DTV: to students in a Europe...</span>
<span class="pysrc-output">give NP: federal judges / NP: a raise</span>
<span class="pysrc-output">give NP: consumers / NP: the straight scoop on the U.S. waste crisis</span>
<span class="pysrc-output">gave NP: Mitsui / NP: access to a high-tech medical product</span>
<span class="pysrc-output">give NP: Mitsubishi / NP: a window on the U.S. glass industry</span>
<span class="pysrc-output">give NP: much thought / PP-DTV: to the rates she was receiving , nor to ...</span>
<span class="pysrc-output">give NP: your Foster Savings Institution / NP: the gift of hope and free...</span>
<span class="pysrc-output">give NP: market operators / NP: the authority to suspend trading in futu...</span>
<span class="pysrc-output">gave NP: quick approval / PP-DTV: to $ 3.18 billion in supplemental appr...</span>
<span class="pysrc-output">give NP: the Transportation Department / NP: up to 50 days to review any...</span>
<span class="pysrc-output">give NP: the president / NP: such power</span>
<span class="pysrc-output">give NP: me / NP: the heebie-jeebies</span>
<span class="pysrc-output">give NP: holders / NP: the right , but not the obligation , to buy a cal...</span>
<span class="pysrc-output">gave NP: Mr. Thomas / NP: only a `` qualified '' rating , rather than ``...</span>
<span class="pysrc-output">give NP: the president / NP: line-item veto power</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_give.py" type="text/x-python"><span class="caption-label">Example 6.3 (code_give.py)</span></a>: <span class="caption-label">Figure 6.3</span>: Usage of Give and Gave in the Penn Treebank sample</td></tr></p>
</table></div>
<p>We can observe a strong tendency for the shortest complement to appear
first.  However, this does not account for a form like
<tt class="doctest"><span class="pre">give NP: federal judges / NP: a raise</span></tt>, where animacy may
play a role.  In fact there turn out to be a large number of contributing
factors, as surveyed by <a class="reference external" href="bibliography.html#bresnan2006gg" id="id5">(Bresnan &amp; Hay, 2006)</a>.
Such preferences can be represented in a weighted grammar.</p>
<p>A <a name="probabilistic_context_free_grammar_index_term" /><span class="termdef">probabilistic context free grammar</span> (or <em>PCFG</em>) is a context free
grammar that associates a probability with each of its productions.
It generates the same set of parses for a text that the corresponding
context free grammar does, and assigns a probability to each parse.
The probability of a parse generated by a PCFG is simply the product
of the probabilities of the productions used to generate it.</p>
<p>The simplest way to define a PCFG is to load it from a specially
formatted string consisting of a sequence of weighted productions,
where weights appear in brackets, as shown in <a class="reference internal" href="#code-pcfg1">6.4</a>.</p>
<span class="target" id="code-pcfg1"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
grammar = nltk.PCFG.fromstring(<span class="pysrc-string">&quot;&quot;&quot;</span>
<span class="pysrc-string">    S    -&gt; NP VP              [1.0]</span>
<span class="pysrc-string">    VP   -&gt; TV NP              [0.4]</span>
<span class="pysrc-string">    VP   -&gt; IV                 [0.3]</span>
<span class="pysrc-string">    VP   -&gt; DatV NP NP         [0.3]</span>
<span class="pysrc-string">    TV   -&gt; 'saw'              [1.0]</span>
<span class="pysrc-string">    IV   -&gt; 'ate'              [1.0]</span>
<span class="pysrc-string">    DatV -&gt; 'gave'             [1.0]</span>
<span class="pysrc-string">    NP   -&gt; 'telescopes'       [0.8]</span>
<span class="pysrc-string">    NP   -&gt; 'Jack'             [0.2]</span>
<span class="pysrc-string">    &quot;&quot;&quot;</span>)</pre>
</td>
</tr></table></td></tr>
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(grammar)
<span class="pysrc-output">Grammar with 9 productions (start state = S)</span>
<span class="pysrc-output">    S -&gt; NP VP [1.0]</span>
<span class="pysrc-output">    VP -&gt; TV NP [0.4]</span>
<span class="pysrc-output">    VP -&gt; IV [0.3]</span>
<span class="pysrc-output">    VP -&gt; DatV NP NP [0.3]</span>
<span class="pysrc-output">    TV -&gt; 'saw' [1.0]</span>
<span class="pysrc-output">    IV -&gt; 'ate' [1.0]</span>
<span class="pysrc-output">    DatV -&gt; 'gave' [1.0]</span>
<span class="pysrc-output">    NP -&gt; 'telescopes' [0.8]</span>
<span class="pysrc-output">    NP -&gt; 'Jack' [0.2]</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_pcfg1.py" type="text/x-python"><span class="caption-label">Example 6.4 (code_pcfg1.py)</span></a>: <span class="caption-label">Figure 6.4</span>: Defining a Probabilistic Context Free Grammar (PCFG)</td></tr></p>
</table></div>
<p>It is sometimes convenient to combine multiple productions into a single line,
e.g. <tt class="doctest"><span class="pre">VP -&gt; TV NP [0.4] | IV [0.3] | DatV NP NP [0.3]</span></tt>.
In order to ensure that the trees generated by the grammar form a
probability distribution, PCFG grammars impose the constraint
that all productions with a given left-hand side must have
probabilities that sum to one.
The grammar in <a class="reference internal" href="#code-pcfg1">6.4</a> obeys this constraint: for <tt class="doctest"><span class="pre">S</span></tt>,
there is only one production, with a probability of 1.0; for <tt class="doctest"><span class="pre">VP</span></tt>,
0.4+0.3+0.3=1.0; and for <tt class="doctest"><span class="pre">NP</span></tt>, 0.8+0.2=1.0.
The parse tree returned by <tt class="doctest"><span class="pre">parse()</span></tt> includes probabilities:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>viterbi_parser = nltk.ViterbiParser(grammar)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> viterbi_parser.parse([<span class="pysrc-string">'Jack'</span>, <span class="pysrc-string">'saw'</span>, <span class="pysrc-string">'telescopes'</span>]):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S (NP Jack) (VP (TV saw) (NP telescopes))) (p=0.064)</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now that parse trees are assigned probabilities, it no longer matters
that there may be a huge number of possible parses for a given sentence.
A parser will be responsible for finding the most likely parses.</p>
</div>
</div>
<div class="section" id="summary">
<h1>7&nbsp;&nbsp;&nbsp;Summary</h1>
<ul class="simple">
<li>Sentences have internal organization
that can be represented using a tree. Notable features of constituent
structure are: recursion, heads, complements and modifiers.</li>
<li>A grammar is a compact characterization of a potentially infinite set of sentences;
we say that a tree is well-formed according to a grammar, or that a grammar licenses a tree.</li>
<li>A grammar is a formal model for describing whether a given phrase can be
assigned a particular constituent or dependency structure.</li>
<li>Given a set of syntactic categories, a context-free grammar
uses a set of productions to say how a phrase of some category <em>A</em> can
be analyzed into a sequence of smaller parts &#945;<sub>1</sub>
... &#945;<sub>n</sub>.</li>
<li>A dependency grammar uses productions to specify what the dependents
are of a given lexical head.</li>
<li>Syntactic ambiguity arises when one sentence has more than one syntactic analysis
(e.g. prepositional phrase attachment ambiguity).</li>
<li>A parser is a procedure for finding one or more trees corresponding to a grammatically
well-formed sentence.</li>
<li>A simple top-down parser is the recursive descent parser, which recursively
expands the start symbol (usually <tt class="doctest"><span class="pre">S</span></tt>) with the help of the grammar
productions, and tries to match the input sentence.  This parser cannot
handle left-recursive productions (e.g., productions such as <tt class="doctest"><span class="pre">NP -&gt; NP PP</span></tt>).
It is inefficient in the way it blindly expands
categories without checking whether they are compatible with the input string, and
in repeatedly expanding the same non-terminals and discarding the results.</li>
<li>A simple bottom-up parser is the shift-reduce parser, which shifts input onto
a stack and tries to match the items at the top of the stack with the right
hand side of grammar productions.  This parser is not guaranteed to find
a valid parse for the input even if one exists, and builds substructure without
checking whether it is globally consistent with the grammar.</li>
</ul>
<!-- * It is difficult to develop a broad-coverage grammar ... -->
</div>
<div class="section" id="further-reading">
<h1>8&nbsp;&nbsp;&nbsp;Further Reading</h1>
<p>Extra materials for this chapter are posted at <tt class="doctest"><span class="pre">http://nltk.org/</span></tt>, including links to freely
available resources on the web.
For more examples of parsing with NLTK, please see the
Parsing HOWTO at <tt class="doctest"><span class="pre">http://nltk.org/howto</span></tt>.</p>
<p>There are many introductory books on syntax. <a class="reference external" href="bibliography.html#ogrady2004" id="id6">(O'Grady et al, 2004)</a> is a
general introduction to linguistics, while <a class="reference external" href="bibliography.html#radford1988tg" id="id7">(Radford, 1988)</a> provides a
gentle introduction to transformational grammar, and can be
recommended for its coverage of transformational approaches to
unbounded dependency constructions.  The most widely used
term in linguistics for formal grammar is <a name="generative_grammar_index_term" /><span class="termdef">generative grammar</span>,
though it has nothing to do with generation <a class="reference external" href="bibliography.html#chomsky1965" id="id8">(Chomsky, 1965)</a>.
The framework of X-bar Syntax is
due to <a class="reference external" href="bibliography.html#chomsky1970rn" id="id9">(Jacobs &amp; Rosenbaum, 1970)</a>, and is explored at greater length in <a class="reference external" href="bibliography.html#jackendoff1977xs" id="id10">(Jackendoff, 1977)</a>
(The primes we use replace Chomsky's typographically more demanding horizontal bars.)</p>
<p><a class="reference external" href="bibliography.html#burtonroberts1997as" id="id11">(Burton-Roberts, 1997)</a> is a practically oriented textbook on how to
analyze constituency in English, with extensive exemplification and
exercises. <a class="reference external" href="bibliography.html#huddleston2002cge" id="id12">(Huddleston &amp; Pullum, 2002)</a> provides an up-to-date and comprehensive analysis of
syntactic phenomena in English.</p>
<p>Chapter 12 of <a class="reference external" href="bibliography.html#jurafskymartin2008" id="id13">(Jurafsky &amp; Martin, 2008)</a> covers formal grammars of English;
Sections 13.1-3 cover simple parsing algorithms and techniques
for dealing with ambiguity;
Chapter 14 covers statistical parsing;
Chapter 16 covers the Chomsky hierarchy and the formal complexity
of natural language.
<a class="reference external" href="bibliography.html#levin1993" id="id14">(Levin, 1993)</a> has categorized English verbs into fine-grained classes,
according to their syntactic properties.</p>
<p>There are several ongoing efforts to build large-scale rule-based grammars,
e.g. the LFG Pargram project <tt class="doctest"><span class="pre">http://www2.parc.com/istl/groups/nltt/pargram/</span></tt>,
the HPSG LinGO Matrix framework <tt class="doctest"><span class="pre">http://www.delph-<span class="pysrc-keyword">in</span>.net/matrix/</span></tt>
and the XTAG Project <tt class="doctest"><span class="pre">http://www.cis.upenn.edu/~xtag/</span></tt>.</p>
</div>
<div class="section" id="exercises">
<h1>9&nbsp;&nbsp;&nbsp;Exercises</h1>
<ol class="arabic">
<li><p class="first">&#9788; Can you come up with grammatical sentences that have probably never
been uttered before?  (Take turns with a partner.)  What does this tell you
about human language?</p>
</li>
<li><p class="first">&#9788; Recall Strunk and White's prohibition against sentence-initial
<span class="example">however</span> used to mean &quot;although&quot;.
Do a web search for <span class="example">however</span> used at the start of the sentence.
How widely used is this construction?</p>
</li>
<li><p class="first">&#9788; Consider the sentence <cite>Kim arrived or Dana left and everyone cheered</cite>.
Write down the parenthesized forms to show the relative scope of <span class="example">and</span>
and <span class="example">or</span>.  Generate tree structures corresponding to both of these interpretations.</p>
</li>
<li><p class="first">&#9788; The <tt class="doctest"><span class="pre">Tree</span></tt> class implements a variety of other useful methods.
See the <tt class="doctest"><span class="pre">Tree</span></tt> help documentation for more details, i.e. import
the Tree class and then type <tt class="doctest"><span class="pre">help(Tree)</span></tt>.</p>
</li>
<li><p class="first">&#9788; In this exercise you will manually construct some parse trees.</p>
<ol class="loweralpha simple">
<li>Write code to produce two trees, one for each reading of the phrase
<span class="example">old men and women</span></li>
<li>Encode any of the trees presented in this chapter as a labeled
bracketing and use <tt class="doctest"><span class="pre">nltk.Tree()</span></tt> to check that it is well-formed.
Now use <tt class="doctest"><span class="pre">draw()</span></tt> to display the tree.</li>
<li>As in (a) above, draw a tree for <span class="example">The woman saw a man last Thursday</span>.</li>
</ol>
</li>
<li><p class="first">&#9788; Write a recursive function to traverse a tree and return the
depth of the tree, such that a tree with a single node would have
depth zero.  (Hint: the depth of a subtree is the maximum depth
of its children, plus one.)</p>
</li>
<li><p class="first">&#9788; Analyze the A.A. Milne sentence about Piglet, by underlining all
of the sentences it contains then replacing these with <tt class="doctest"><span class="pre">S</span></tt>
(e.g. the first sentence becomes <tt class="doctest"><span class="pre">S</span></tt> <cite>when</cite>:lx` <tt class="doctest"><span class="pre">S</span></tt>).
Draw a tree structure for this &quot;compressed&quot; sentence.  What are
the main syntactic constructions used for building such a long
sentence?</p>
</li>
<li><p class="first">&#9788; In the recursive descent parser demo, experiment with changing the
sentence to be parsed by selecting <em>Edit Text</em> in the <em>Edit</em> menu.</p>
</li>
<li><p class="first">&#9788; Can the grammar in <tt class="doctest"><span class="pre">grammar1</span></tt> be used to describe sentences that are
more than 20 words in length?</p>
</li>
<li><p class="first">&#9788; Use the graphical chart-parser interface to experiment with
different rule invocation strategies. Come up with your own strategy
that you can execute manually using the graphical interface. Describe
the steps, and report any efficiency improvements it has (e.g. in terms
of the size of the resulting chart). Do these improvements depend on
the structure of the grammar? What do you think of the prospects for
significant performance boosts from cleverer rule invocation
strategies?</p>
</li>
<li><p class="first">&#9788; With pen and paper, manually trace the execution of a recursive descent
parser and a shift-reduce parser, for a CFG you have already seen, or one
of your own devising.</p>
</li>
<li><p class="first">&#9788; We have seen that a chart parser adds but never removes edges
from a chart.  Why?</p>
</li>
<li><p class="first">&#9788; Consider the sequence of words:
<span class="example">Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo</span>.
This is a grammatically correct sentence, as explained at
<tt class="doctest"><span class="pre">http://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo.</span></tt>
Consider the tree diagram presented on this Wikipedia page, and write down a suitable
grammar.  Normalize case to lowercase, to simulate the problem that a listener has when hearing
this sentence.  Can you find other parses for this sentence?
How does the number of parse trees grow as the sentence gets longer?
(More examples of these sentences can be found at <tt class="doctest"><span class="pre">http://en.wikipedia.org/wiki/List_of_homophonous_phrases</span></tt>).</p>
</li>
<li><p class="first">&#9681; You can modify the grammar in the recursive descent parser demo
by selecting <em>Edit Grammar</em>  in the <em>Edit</em> menu. Change
the second expansion production, namely <tt class="doctest"><span class="pre">NP -&gt; Det N PP</span></tt>, to <tt class="doctest"><span class="pre">NP -&gt; NP
PP</span></tt>. Using the <em>Step</em> button, try to build a parse tree. What happens?</p>
</li>
<li><p class="first">&#9681; Extend the grammar in <tt class="doctest"><span class="pre">grammar2</span></tt> with productions that expand prepositions as
intransitive, transitive and requiring a <tt class="doctest"><span class="pre">PP</span></tt>
complement. Based on these productions, use the method of the
preceding exercise to draw a tree for the sentence <span class="example">Lee ran away home</span>.</p>
</li>
<li><p class="first">&#9681; Pick some common verbs and complete the following tasks:</p>
<ol class="loweralpha simple">
<li>Write a program to find those verbs in the Prepositional Phrase Attachment Corpus
<tt class="doctest"><span class="pre">nltk.corpus.ppattach</span></tt>.  Find any cases where the same verb
exhibits two different attachments, but where the first noun,
or second noun, or preposition, stay unchanged (as we saw in
our discussion of syntactic ambiguity in <a class="reference internal" href="#sec-whats-the-use-of-syntax">2</a>).</li>
<li>Devise CFG grammar productions to cover some of these cases.</li>
</ol>
</li>
<li><p class="first">&#9681; Write a program to compare the efficiency of a top-down chart parser
compared with a recursive descent parser (<a class="reference internal" href="#sec-parsing">4</a>).
Use the same grammar and input sentences for both.  Compare their performance
using the <tt class="doctest"><span class="pre">timeit</span></tt> module (see <a class="reference external" href="ch04.html#sec-algorithm-design">4.7</a> for an example of
how to do this).</p>
</li>
<li><p class="first">&#9681; Compare the performance of the top-down, bottom-up, and left-corner
parsers using the same grammar and three grammatical test
sentences. Use <tt class="doctest"><span class="pre">timeit</span></tt> to log the amount of time each
parser takes on the same sentence.  Write a function that runs all
three parsers on all three sentences, and prints a 3-by-3 grid of
times, as well as row and column totals. Discuss your findings.</p>
</li>
<li><p class="first">&#9681; Read up on &quot;garden path&quot; sentences.  How might the computational
work of a parser relate to the difficulty humans have with
processing these sentences?
<tt class="doctest"><span class="pre">http://en.wikipedia.org/wiki/Garden_path_sentence</span></tt></p>
</li>
<li><p class="first">&#9681; To compare multiple trees in a single window, we can use the
<tt class="doctest"><span class="pre">draw_trees()</span></tt> method.  Define some trees and try it out:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.draw.tree <span class="pysrc-keyword">import</span> draw_trees
<span class="pysrc-prompt">&gt;&gt;&gt; </span>draw_trees(tree1, tree2, tree3)                    </pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">&#9681; Using tree positions, list the subjects of the first 100
sentences in the Penn treebank; to make the results easier to view,
limit the extracted subjects to subtrees whose height is 2.</p>
</li>
<li><p class="first">&#9681; Inspect the Prepositional Phrase Attachment Corpus
and try to suggest some factors that influence <tt class="doctest"><span class="pre">PP</span></tt> attachment.</p>
</li>
<li><p class="first">&#9681; In this section we claimed that there are linguistic regularities
that cannot be described simply in terms of n-grams.
Consider the following sentence, particularly the position of the phrase
<span class="example">in his turn</span>.  Does this illustrate a problem for an approach based
on n-grams?</p>
<blockquote>
<p><cite>What was more, the in his turn somewhat youngish Nikolay Parfenovich
also turned out to be the only person in the entire world to acquire a
sincere liking to our &quot;discriminated-against&quot; public procurator.</cite>
(Dostoevsky: The Brothers Karamazov)</p>
</blockquote>
</li>
<li><p class="first">&#9681; Write a recursive function that produces a nested bracketing for
a tree, leaving out the leaf nodes, and displaying the non-terminal
labels after their subtrees.  So the above example about Pierre
Vinken would produce:
<tt class="doctest"><span class="pre">[[[NNP NNP]NP , [ADJP [CD NNS]NP JJ]ADJP ,]NP-SBJ MD [VB [DT NN]NP [IN [DT JJ NN]NP]PP-CLR [NNP CD]NP-TMP]VP .]S</span></tt>
Consecutive categories should be separated by space.</p>
</li>
<li><p class="first">&#9681; Download several electronic books from Project Gutenberg.
Write a program to scan these texts for any extremely long sentences.
What is the longest sentence you can find?  What syntactic construction(s)
are responsible for such long sentences?</p>
</li>
<li><p class="first">&#9681; Modify the functions <tt class="doctest"><span class="pre">init_wfst()</span></tt> and <tt class="doctest"><span class="pre">complete_wfst()</span></tt> so
that the contents of each cell in the WFST is a set of
non-terminal symbols rather than a single non-terminal.</p>
</li>
<li><p class="first">&#9681; Consider the algorithm in <a class="reference internal" href="#code-wfst">4.4</a>.  Can you explain why
parsing context-free grammar is proportional to <cite>n</cite><sup>3</sup>, where <em>n</em>
is the length of the input sentence.</p>
</li>
<li><p class="first">&#9681; Process each tree of the Treebank corpus sample <tt class="doctest"><span class="pre">nltk.corpus.treebank</span></tt>
and extract the productions with the help of <tt class="doctest"><span class="pre">Tree.productions()</span></tt>.  Discard
the productions that occur only once.  Productions with the same left hand side,
and similar right hand sides can be collapsed, resulting in an equivalent but
more compact set of rules.  Write code to output a compact grammar.</p>
</li>
<li><p class="first">&#9733; One common way of defining the subject of a sentence <tt class="doctest"><span class="pre">S</span></tt> in
English is as <em>the noun phrase that is the child of</em> <tt class="doctest"><span class="pre">S</span></tt> <em>and
the sibling of</em> <tt class="doctest"><span class="pre">VP</span></tt>.   Write a function that takes the tree for
a sentence and returns the subtree corresponding to the subject of the
sentence.  What should it do if the root node of the tree passed to
this function is not <tt class="doctest"><span class="pre">S</span></tt>, or it lacks a subject?</p>
</li>
<li><p class="first">&#9733; Write a function that takes a grammar (such as the one defined in
<a class="reference internal" href="#code-cfg1">3.1</a>) and returns a random sentence generated by the grammar.
(Use <tt class="doctest"><span class="pre">grammar.start()</span></tt> to find the start symbol of the grammar;
<tt class="doctest"><span class="pre">grammar.productions(lhs)</span></tt> to get the list of productions from the grammar
that have the specified left-hand side; and <tt class="doctest"><span class="pre">production.rhs()</span></tt> to get
the right-hand side of a production.)</p>
</li>
<li><p class="first">&#9733; Implement a version of the shift-reduce parser using backtracking,
so that it finds all possible parses for a sentence, what might be called
a &quot;recursive ascent parser.&quot;  Consult the Wikipedia entry for backtracking
at <tt class="doctest"><span class="pre">http://en.wikipedia.org/wiki/Backtracking</span></tt></p>
</li>
<li><p class="first">&#9733;
As we saw in <a class="reference external" href="ch07.html#chap-chunk">7.</a>, it is possible
to collapse chunks down to their chunk label.  When we do this
for sentences involving the word <span class="example">gave</span>, we find patterns
such as the following:</p>
<pre class="literal-block">
gave NP
gave up NP in NP
gave NP up
gave NP NP
gave NP to NP
</pre>
<ol class="loweralpha simple">
<li>Use this method to study the complementation patterns of a verb
of interest, and write suitable grammar productions.  (This task
is sometimes called <a name="lexical_acquisition_index_term" /><span class="termdef">lexical acquisition</span>.)</li>
<li>Identify some English verbs that are near-synonyms, such as the
<span class="example">dumped/filled/loaded</span> example from earlier in this chapter.
Use the chunking method to study the complementation patterns of
these verbs.  Create a grammar to cover these cases.  Can the verbs
be freely substituted for each other, or are their constraints?
Discuss your findings.</li>
</ol>
</li>
<li><p class="first">&#9733; Develop a left-corner parser based on the
recursive descent parser, and inheriting from <tt class="doctest"><span class="pre">ParseI</span></tt>.</p>
</li>
<li><p class="first">&#9733; Extend NLTK's shift-reduce parser to incorporate backtracking, so
that it is guaranteed to find all parses that exist (i.e. it is <a name="complete_index_term" /><span class="termdef">complete</span>).</p>
</li>
<li><p class="first">&#9733; Modify the functions <tt class="doctest"><span class="pre">init_wfst()</span></tt> and <tt class="doctest"><span class="pre">complete_wfst()</span></tt> so
that when a non-terminal symbol is added to a cell in the WFST, it includes
a record of the cells from which it was derived. Implement a
function that will convert a WFST in this form to a parse tree.</p>
</li>
</ol>
<!-- recurse over tree to look for coordinate constructions (cf 4th
example in chapter 1.1); (possible extension: callback function for Tree.subtrees()) -->
<!-- Footer to be used in all chapters -->
<div class="admonition admonition-about-this-document">
<p class="first admonition-title">About this document...</p>
<p>UPDATED FOR NLTK 3.0.
This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://stevenbird.net/">Steven Bird</a>, <a class="reference external" href="http://homepages.inf.ed.ac.uk/ewan/">Ewan Klein</a> and <a class="reference external" href="http://ed.loper.org/">Edward Loper</a>,
Copyright &#169; 2019 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://nltk.org/</span></tt>],
Version 3.0, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Wed  4 Sep 2019 11:40:48 ACST</p>
</div>
</div>
</div>
</body>
</html>
