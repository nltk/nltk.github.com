<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.15: http://docutils.sourceforge.net/" />
<title>9. Building Feature Based Grammars</title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}
table pre span {
  white-space: pre-wrap;
}
table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document" id="building-feature-based-grammars">
<span id="chap-featgram"></span>
<h1 class="title">9. Building Feature Based Grammars</h1>

<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
<!-- standard global imports

>>> from __future__ import division
>>> import nltk, re, pprint -->
<!-- TODO:
discuss applications of unify() to dicts, lists, and mixtures of dicts and lists
FeatureValueTuple: '[x=(1,2,3)]'
FeatureValueSet: '[x={1,2,3}]'
NB: Unification does *not* descend into tuples or sets; but variable
substitution from bindings does.  Generally speaking, tuples and set
feature values should never contain feature structures.
FeatureValueUnion: '{?a+?b}', which will automatically collapse to a
FeatureValueSet as soon as all top-level variables are replaced with set values.
As with FeatureValueSet, unification does not descend into FeatureValueUnion,
but variable binding does.
More examples are in Edward's email of 24 August 2007

* AP: Give example of grammar with HPSG style subcat? Probably not
  doable :-(

* AP: The "Heads Revisited" subsection: there is some interaction
  of the material of this subsection with the material of the
  previous subsection, on "Subcategorization".  In fact, something
  like X-bar theory is implicitly introduced in that previous
  section, with V'' = V[SUBCAT <>], and V' = V[SUBCAT <NP>].
  Shouldn't these two subsections be merged (or otherwise
  reorganised)?

* AP (70) and Figure 9.3: maybe I am thinking in terms of HPSG again,
  but would it be possible to generalise these grammar fragments to
  gaps of any type, not just NP?  For example, instead of (70), I'd
  like something like:

  (70') ?x/?x - ->

  and in the grammar in Figure 9.3, the first rule could (?) be
  generalised to something like:

  S[-INV] - -> ?x S/?x

  etc. If this is possible in this formalism, maybe it would make sense
  to mention it?

* AP (72) and the sentence above - - there are also German verbs taking
  *genitive* complements.

  Figure 9.4: it's a pity the grammar uses IV/TV instead of illustrating
  the list-valued SUBCAT...

  "Further Reading": reference to GPSG garbled; some interesting
  given ereferences not in the bibliography chapter (e.g., Grosz and
  Stickel 1983, Dahl and Saint-Dizier 1985, etc.). -->
<p>Natural languages have an extensive range of grammatical constructions which
are hard to handle with the simple methods described in <a class="reference external" href="ch08.html#chap-parse">8.</a>. In order to gain
more flexibility, we change our treatment of grammatical categories like <tt class="doctest"><span class="pre">S</span></tt>,
<tt class="doctest"><span class="pre">NP</span></tt> and <tt class="doctest"><span class="pre">V</span></tt>. In place of atomic labels, we decompose them into structures like
dictionaries, where features can take on a range of values.</p>
<p>The goal of this chapter is to answer the following questions:</p>
<ol class="arabic simple">
<li>How can we extend the framework of context free grammars with features so as to
gain more fine-grained control over grammatical categories and productions?</li>
<li>What are the main formal properties of feature structures and how do we use them
computationally?</li>
<li>What kinds of linguistic patterns and grammatical constructions can we now capture
with feature based grammars?</li>
</ol>
<p>Along the way, we will cover more topics in English syntax, including phenomena such as
agreement, subcategorization, and unbounded dependency constructions.</p>
<div class="section" id="grammatical-features">
<h1>1&nbsp;&nbsp;&nbsp;Grammatical Features</h1>
<p>In <a class="reference external" href="ch06.html#chap-data-intensive">chap-data-intensive</a>, we described how to build classifiers that rely on detecting features of
text.  Such features may be quite simple, such as extracting the last letter of a
word, or more complex, such as a part-of-speech tag which has itself been predicted
by the classifier.  In this chapter, we will investigate the role of features in
building rule-based grammars.  In contrast to feature extractors, which record
features that have been automatically detected, we are now going to
<em>declare</em> the features of words and phrases. We start off with a
very simple example, using dictionaries to store features and their values.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>kim = {<span class="pysrc-string">'CAT'</span>: <span class="pysrc-string">'NP'</span>, <span class="pysrc-string">'ORTH'</span>: <span class="pysrc-string">'Kim'</span>, <span class="pysrc-string">'REF'</span>: <span class="pysrc-string">'k'</span>}
<span class="pysrc-prompt">&gt;&gt;&gt; </span>chase = {<span class="pysrc-string">'CAT'</span>: <span class="pysrc-string">'V'</span>, <span class="pysrc-string">'ORTH'</span>: <span class="pysrc-string">'chased'</span>, <span class="pysrc-string">'REL'</span>: <span class="pysrc-string">'chase'</span>}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The objects <tt class="doctest"><span class="pre">kim</span></tt> and <tt class="doctest"><span class="pre">chase</span></tt> both have a couple of shared features, <tt class="doctest"><span class="pre">CAT</span></tt>
(grammatical category) and <tt class="doctest"><span class="pre">ORTH</span></tt> (orthography, i.e., spelling). In addition, each
has a more semantically-oriented feature: <tt class="doctest"><span class="pre">kim[<span class="pysrc-string">'REF'</span>]</span></tt> is intended to give the
referent of <tt class="doctest"><span class="pre">kim</span></tt>, while <tt class="doctest"><span class="pre">chase[<span class="pysrc-string">'REL'</span>]</span></tt> gives the relation expressed by
<tt class="doctest"><span class="pre">chase</span></tt>.  In the context of rule-based grammars, such pairings of features and
values are known as <a name="feature_structures_index_term" /><span class="termdef">feature structures</span>, and we will shortly see alternative
notations for them.</p>
<p>Feature structures contain various kinds of information about grammatical
entities. The information need not be exhaustive, and we might want to add further
properties. For example, in the case of a verb, it is often useful to know what
&quot;semantic role&quot; is played by the arguments of the verb. In the case of <span class="example">chase</span>,
the subject plays the role of &quot;agent&quot;, while the object has the role of
&quot;patient&quot;. Let's add this information, using <tt class="doctest"><span class="pre"><span class="pysrc-string">'sbj'</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-string">'obj'</span></span></tt> as placeholders
which will get filled once the verb combines with its grammatical arguments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>chase[<span class="pysrc-string">'AGT'</span>] = <span class="pysrc-string">'sbj'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>chase[<span class="pysrc-string">'PAT'</span>] = <span class="pysrc-string">'obj'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>If we now process a sentence <cite>Kim chased Lee</cite>, we want to &quot;bind&quot; the verb's agent role to
the subject and the patient role to the object. We do this by linking to the
<tt class="doctest"><span class="pre">REF</span></tt> feature of the relevant <tt class="doctest"><span class="pre">NP</span></tt>. In the following example, we make the
simple-minded assumption that the <tt class="doctest"><span class="pre">NP</span></tt>s immediately to the left and right of the
verb are the subject and object respectively. We also add a feature
structure for <span class="example">Lee</span> to complete the example.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = <span class="pysrc-string">&quot;Kim chased Lee&quot;</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = sent.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lee = {<span class="pysrc-string">'CAT'</span>: <span class="pysrc-string">'NP'</span>, <span class="pysrc-string">'ORTH'</span>: <span class="pysrc-string">'Lee'</span>, <span class="pysrc-string">'REF'</span>: <span class="pysrc-string">'l'</span>}
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">lex2fs</span>(word):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">for</span> fs <span class="pysrc-keyword">in</span> [kim, lee, chase]:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">if</span> fs[<span class="pysrc-string">'ORTH'</span>] == word:
<span class="pysrc-more">... </span>            return fs
<span class="pysrc-prompt">&gt;&gt;&gt; </span>subj, verb, obj = lex2fs(tokens[0]), lex2fs(tokens[1]), lex2fs(tokens[2])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>verb[<span class="pysrc-string">'AGT'</span>] = subj[<span class="pysrc-string">'REF'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>verb[<span class="pysrc-string">'PAT'</span>] = obj[<span class="pysrc-string">'REF'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> k <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'ORTH'</span>, <span class="pysrc-string">'REL'</span>, <span class="pysrc-string">'AGT'</span>, <span class="pysrc-string">'PAT'</span>]:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(<span class="pysrc-string">&quot;%-5s =&gt; %s&quot;</span> % (k, verb[k]))
<span class="pysrc-output">ORTH  =&gt; chased</span>
<span class="pysrc-output">REL   =&gt; chase</span>
<span class="pysrc-output">AGT   =&gt; k</span>
<span class="pysrc-output">PAT   =&gt; l</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The same approach could be adopted for a different verb, say <span class="example">surprise</span>, though in
this case, the subject would play the role of &quot;source&quot; (<tt class="doctest"><span class="pre">SRC</span></tt>) and the object,
the role of &quot;experiencer&quot; (<tt class="doctest"><span class="pre">EXP</span></tt>):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>surprise = {<span class="pysrc-string">'CAT'</span>: <span class="pysrc-string">'V'</span>, <span class="pysrc-string">'ORTH'</span>: <span class="pysrc-string">'surprised'</span>, <span class="pysrc-string">'REL'</span>: <span class="pysrc-string">'surprise'</span>,
<span class="pysrc-more">... </span>            <span class="pysrc-string">'SRC'</span>: <span class="pysrc-string">'sbj'</span>, <span class="pysrc-string">'EXP'</span>: <span class="pysrc-string">'obj'</span>}</pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Feature structures are pretty powerful, but the way
in which we have manipulated them is extremely <em>ad hoc</em>. Our next task in this
chapter is to show how the framework of context free grammar and parsing can be
expanded to accommodate feature structures, so that we can build analyses like this
in a more generic and principled way.
We will start off by looking  at the
phenomenon of syntactic agreement; we will show how agreement
constraints can be expressed elegantly using features, and illustrate
their use in a simple grammar.</p>
<p>Since feature structures are a general data
structure for representing information of any kind, we will briefly
look at them from a more formal point of view, and illustrate the support for feature
structures offered by NLTK. In the final part of the chapter,
we demonstrate that the additional expressiveness of features opens
up a wide spectrum of possibilities for describing sophisticated
aspects of linguistic structure.</p>
<div class="section" id="syntactic-agreement">
<h2>1.1&nbsp;&nbsp;&nbsp;Syntactic Agreement</h2>
<p>The following examples show pairs of word sequences, the first of which is
grammatical and the second not. (We use an asterisk at the start of a
word sequence to signal that it is ungrammatical.)</p>
<span class="target" id="ex-thisdog"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>this dog</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*these dog</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-thesedogs"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(2)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>these dogs</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*this dogs</td></tr></table></p>
</td></tr></table></p>
<p>In English, nouns are usually marked as being singular
or plural. The form of the demonstrative also varies:
<span class="example">this</span> (singular) and <span class="example">these</span> (plural).
Examples <a class="reference internal" href="#ex-thisdog">(1b)</a> and <a class="reference internal" href="#ex-thesedogs">(2b)</a> show that there are constraints on
the use of demonstratives and nouns within a noun phrase:
either both are singular or both are plural. A similar
constraint holds between subjects and predicates:</p>
<span class="target" id="ex-subjpredsg"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(3)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>the dog runs</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*the dog run</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-subjpredpl"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(4)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>the dogs run</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*the dogs runs</td></tr></table></p>
</td></tr></table></p>
<!-- Proposed for deletion: The element which determines the
agreement, here the subject noun phrase, is called the agreement
`controller`:dt:, while the element whose form is determined by
agreement, here the verb, is called the `target`:dt:. -->
<p>Here we can see that morphological properties of the verb co-vary
with syntactic properties of the subject noun phrase.  This co-variance is
called <a name="agreement_index_term" /><span class="termdef">agreement</span>.
If we look further at verb agreement in English, we will see that
present tense verbs typically have two inflected forms: one for third person
singular, and another for every other combination of person and number,
as shown in <a class="reference internal" href="#tab-agreement-paradigm">1.1</a>.</p>
<span class="target" id="tab-agreement-paradigm"></span><table border="1" class="docutils" id="tab-agreement-paradigm">
<colgroup>
<col width="34%" />
<col width="37%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr><td>&nbsp;</td>
<td><strong>singular</strong></td>
<td><strong>plural</strong></td>
</tr>
<tr><td><strong>1st per</strong></td>
<td><em>I run</em></td>
<td><em>we run</em></td>
</tr>
<tr><td><strong>2nd per</strong></td>
<td><em>you run</em></td>
<td><em>you run</em></td>
</tr>
<tr><td><strong>3rd per</strong></td>
<td><em>he/she/it
runs</em></td>
<td><em>they run</em></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 1.1</span>: <p>Agreement Paradigm for English Regular Verbs</p>
</p>
</table>
<p>We can make the role of morphological properties a bit more explicit
as illustrated in <a class="reference internal" href="#ex-runs">ex-runs</a> and <a class="reference internal" href="#ex-run">ex-run</a>. These representations indicate that
the verb agrees with its subject in person and number. (We use &quot;3&quot; as
an abbreviation for 3rd person, &quot;SG&quot; for singular and &quot;PL&quot; for plural.)</p>
<div class="system-message" id="ex-runs">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 252)</p>
Error in &quot;gloss&quot; directive: may contain a single table only.</div>
<div class="system-message" id="ex-run">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 257)</p>
Error in &quot;gloss&quot; directive: may contain a single table only.</div>
<p>Let's see what happens when we encode these agreement constraints in a
context-free grammar.  We will begin with the simple CFG in <a class="reference internal" href="#ex-agcfg0">(5)</a>.</p>
<span class="target" id="ex-agcfg0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(5)</td><td width="15"></td><td><pre class="literal-block">
S   -&gt;   NP VP
NP  -&gt;   Det N
VP  -&gt;   V

Det  -&gt;  'this'
N    -&gt;  'dog'
V    -&gt;  'runs'
</pre>
</td></tr></table></p>
<p>Grammar <a class="reference internal" href="#ex-agcfg0">(5)</a> allows us to generate the sentence <span class="example">this dog runs</span>;
however, what we really want to do is also generate <span class="example">these dogs
run</span> while blocking unwanted sequences like <span class="example">*this dogs run</span>
and <span class="example">*these dog runs</span>. The most straightforward approach is to
add new non-terminals and productions to the grammar:</p>
<span class="target" id="ex-agcfg1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(6)</td><td width="15"></td><td><pre class="literal-block">
S -&gt; NP_SG VP_SG
S -&gt; NP_PL VP_PL
NP_SG -&gt; Det_SG N_SG
NP_PL -&gt; Det_PL N_PL
VP_SG -&gt; V_SG
VP_PL -&gt; V_PL

Det_SG -&gt; 'this'
Det_PL -&gt; 'these'
N_SG -&gt; 'dog'
N_PL -&gt; 'dogs'
V_SG -&gt; 'runs'
V_PL -&gt; 'run'
</pre>
</td></tr></table></p>
<p>In place of a single production expanding <tt class="doctest"><span class="pre">S</span></tt>, we now have two
productions, one covering the sentences involving singular subject
<tt class="doctest"><span class="pre">NP</span></tt>s and <tt class="doctest"><span class="pre">VP</span></tt>s, the other covering sentences with plural
subject <tt class="doctest"><span class="pre">NP</span></tt>s and <tt class="doctest"><span class="pre">VP</span></tt>s. In fact, every production in
<a class="reference internal" href="#ex-agcfg0">(5)</a> has two counterparts in <a class="reference internal" href="#ex-agcfg1">(6)</a>. With a small grammar,
this is not really such a problem, although it is aesthetically
unappealing. However, with a larger grammar that covers a reasonable
subset of English constructions, the prospect of doubling the grammar
size is very unattractive. Let's suppose now that we used the same
approach to deal with first, second and third person agreement, for
both singular and plural. This would lead to the original grammar
being multiplied by a factor of 6, which we definitely want to
avoid. Can we do better than this? In the next section we will show
that capturing number and person agreement need not come at the cost
of &quot;blowing up&quot; the number of productions.</p>
<!-- Rule multiplication is of course more severe if we add in
person agreement constraints.
"rule multiplication" will be meaningless to some readers.
We need to be consistent in referring to these as productions. -->
</div>
<div class="section" id="using-attributes-and-constraints">
<h2>1.2&nbsp;&nbsp;&nbsp;Using Attributes and Constraints</h2>
<p>We spoke informally of linguistic categories having <em>properties</em>; for
example, that a noun has the property of being plural. Let's
make this explicit:</p>
<span class="target" id="ex-num0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(7)</td><td width="15"></td><td><pre class="literal-block">
N[NUM=pl]
</pre>
</td></tr></table></p>
<p>In <a class="reference internal" href="#ex-num0">(7)</a>, we have introduced some new notation which says that the
category <tt class="doctest"><span class="pre">N</span></tt> has a (grammatical) <a name="feature_index_term" /><span class="termdef">feature</span> called <tt class="doctest"><span class="pre">NUM</span></tt> (short for
'number') and that the value of this feature is <tt class="doctest"><span class="pre">pl</span></tt> (short for
'plural'). We can add similar annotations to other categories, and use
them in lexical entries:</p>
<span class="target" id="ex-agcfg2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(8)</td><td width="15"></td><td><pre class="literal-block">
Det[NUM=sg] -&gt; 'this'
Det[NUM=pl] -&gt; 'these'

N[NUM=sg] -&gt; 'dog'
N[NUM=pl] -&gt; 'dogs'
V[NUM=sg] -&gt; 'runs'
V[NUM=pl] -&gt; 'run'
</pre>
</td></tr></table></p>
<p>Does this help at all? So far, it looks just like a slightly more
verbose alternative to what was specified in <a class="reference internal" href="#ex-agcfg1">(6)</a>. Things become
more interesting when we allow <em>variables</em> over feature values, and use
these to state constraints:</p>
<span class="target" id="ex-agcfg3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(9)</td><td width="15"></td><td><pre class="literal-block">
S -&gt; NP[NUM=?n] VP[NUM=?n]
NP[NUM=?n] -&gt; Det[NUM=?n] N[NUM=?n]
VP[NUM=?n] -&gt; V[NUM=?n]
</pre>
</td></tr></table></p>
<p>We are using <tt class="doctest"><span class="pre">?n</span></tt> as a variable over values of <tt class="doctest"><span class="pre">NUM</span></tt>; it can
be instantiated either to <tt class="doctest"><span class="pre">sg</span></tt> or <tt class="doctest"><span class="pre">pl</span></tt>, within a given production.
We can read the first production as saying that whatever
value <tt class="doctest"><span class="pre">NP</span></tt> takes for the feature <tt class="doctest"><span class="pre">NUM</span></tt>,
<tt class="doctest"><span class="pre">VP</span></tt> must take the same value.</p>
<p>In order to understand how these feature constraints work, it's
helpful to think about how one would go about building a tree. Lexical
productions will admit the following local trees (trees of
depth one):</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(10)</td><td width="15"></td><td><span class="target" id="ex-this"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-1.png" class="align-top" src="tree_images/ch09-tree-1.png" /></td></tr></table></p>
<span class="target" id="ex-these"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-2.png" class="align-top" src="tree_images/ch09-tree-2.png" /></td></tr></table></p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(11)</td><td width="15"></td><td><span class="target" id="ex-dog"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-3.png" class="align-top" src="tree_images/ch09-tree-3.png" /></td></tr></table></p>
<span class="target" id="ex-dogs"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-4.png" class="align-top" src="tree_images/ch09-tree-4.png" /></td></tr></table></p>
</td></tr></table></p>
<p>Now <tt class="doctest"><span class="pre">S -&gt; NP[NUM=?n] VP[NUM=?n]</span></tt> says that whatever the <tt class="doctest"><span class="pre">NUM</span></tt>
values of <tt class="doctest"><span class="pre">N</span></tt> and <tt class="doctest"><span class="pre">Det</span></tt> are, they have to be the
same. Consequently, <tt class="doctest"><span class="pre">NP[NUM=?n] -&gt; Det[NUM=?n] N[NUM=?n]</span></tt> will
permit <a class="reference internal" href="#ex-this">(10a)</a> and <a class="reference internal" href="#ex-dog">(11a)</a> to be combined into an <tt class="doctest"><span class="pre">NP</span></tt> as shown
in <a class="reference internal" href="#ex-good1">(12a)</a> and it will also allow <a class="reference internal" href="#ex-these">(10b)</a> and <a class="reference internal" href="#ex-dogs">(11b)</a> to be
combined, as in <a class="reference internal" href="#ex-good2">(12b)</a>. By contrast, <a class="reference internal" href="#ex-bad1">(13a)</a> and <a class="reference internal" href="#ex-bad2">(13b)</a> are
prohibited because the roots of their subtrees differ
in their values for the <tt class="doctest"><span class="pre">NUM</span></tt> feature; this incompatibility of values is
indicated informally with a <em>FAIL</em> value at the top node.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(12)</td><td width="15"></td><td><span class="target" id="ex-good1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-5.png" class="align-top" src="tree_images/ch09-tree-5.png" /></td></tr></table></p>
<span class="target" id="ex-good2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-6.png" class="align-top" src="tree_images/ch09-tree-6.png" /></td></tr></table></p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(13)</td><td width="15"></td><td><span class="target" id="ex-bad1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-7.png" class="align-top" src="tree_images/ch09-tree-7.png" /></td></tr></table></p>
<span class="target" id="ex-bad2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-8.png" class="align-top" src="tree_images/ch09-tree-8.png" /></td></tr></table></p>
</td></tr></table></p>
<p>Production <tt class="doctest"><span class="pre">VP[NUM=?n] -&gt; V[NUM=?n]</span></tt> says
that the <tt class="doctest"><span class="pre">NUM</span></tt> value of the head verb has to be the same as the
<tt class="doctest"><span class="pre">NUM</span></tt> value of the <tt class="doctest"><span class="pre">VP</span></tt> parent. Combined with the production for
expanding <tt class="doctest"><span class="pre">S</span></tt>, we
derive the consequence that if the <tt class="doctest"><span class="pre">NUM</span></tt> value of the subject head
noun is <tt class="doctest"><span class="pre">pl</span></tt>, then so is the <tt class="doctest"><span class="pre">NUM</span></tt> value of the <tt class="doctest"><span class="pre">VP</span></tt>'s
head verb.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(14)</td><td width="15"></td><td><img alt="tree_images/ch09-tree-9.png" class="align-top" src="tree_images/ch09-tree-9.png" /></td></tr></table></p>
<p>Grammar <a class="reference internal" href="#ex-agcfg2">(8)</a> illustrated lexical productions for determiners like <span class="example">this</span>
and <span class="example">these</span> which require a singular or plural head noun
respectively. However, other determiners in English are not choosy
about the grammatical number of the noun they combine with.
One way of describing this would be to add
two lexical entries to the grammar, one each for the singular and
plural versions of determiner such as <span class="example">the</span></p>
<pre class="literal-block">
Det[NUM=sg] -&gt; 'the' | 'some' | 'any'
Det[NUM=pl] -&gt; 'the' | 'some' | 'any'
</pre>
<p>However, a more elegant solution is to
leave the <tt class="doctest"><span class="pre">NUM</span></tt> value <a name="underspecified_index_term" /><span class="termdef">underspecified</span> and letting it agree
in number with whatever noun it combines with. Assigning a variable
value to <tt class="doctest"><span class="pre">NUM</span></tt> is one way of achieving this result:</p>
<pre class="literal-block">
Det[NUM=?n] -&gt; 'the' | 'some' | 'any'
</pre>
<p>But in fact we can be even more economical, and just omit any
specification for <tt class="doctest"><span class="pre">NUM</span></tt> in such productions. We only need
to explicitly enter a variable value when this constrains another
value elsewhere in the same production.</p>
<p>The grammar in <a class="reference internal" href="#code-feat0cfg">1.1</a> illustrates most of the ideas we have introduced so
far in this chapter, plus a couple of new ones.</p>
<!-- XXX name show_cfg() is idiosyncratic for something which print a file -->
<!-- XXX The contents of feat0.fcfg seems to have changed in the file.
I won't pull in the updated version in case the discussion also needs to be updated. -->
<span class="target" id="code-feat0cfg"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.data.show_cfg(<span class="pysrc-string">'grammars/book_grammars/feat0.fcfg'</span>)
% start S
<span class="pysrc-comment"># ###################</span>
<span class="pysrc-comment"># Grammar Productions</span>
<span class="pysrc-comment"># ###################</span>
<span class="pysrc-comment"># S expansion productions</span>
S -&gt; NP[NUM=?n] VP[NUM=?n]
<span class="pysrc-comment"># NP expansion productions</span>
NP[NUM=?n] -&gt; N[NUM=?n]
NP[NUM=?n] -&gt; PropN[NUM=?n]
NP[NUM=?n] -&gt; Det[NUM=?n] N[NUM=?n]
NP[NUM=pl] -&gt; N[NUM=pl]
<span class="pysrc-comment"># VP expansion productions</span>
VP[TENSE=?t, NUM=?n] -&gt; IV[TENSE=?t, NUM=?n]
VP[TENSE=?t, NUM=?n] -&gt; TV[TENSE=?t, NUM=?n] NP
<span class="pysrc-comment"># ###################</span>
<span class="pysrc-comment"># Lexical Productions</span>
<span class="pysrc-comment"># ###################</span>
Det[NUM=sg] -&gt; <span class="pysrc-string">'this'</span> | <span class="pysrc-string">'every'</span>
Det[NUM=pl] -&gt; <span class="pysrc-string">'these'</span> | <span class="pysrc-string">'all'</span>
Det -&gt; <span class="pysrc-string">'the'</span> | <span class="pysrc-string">'some'</span> | <span class="pysrc-string">'several'</span>
PropN[NUM=sg]-&gt; <span class="pysrc-string">'Kim'</span> | <span class="pysrc-string">'Jody'</span>
N[NUM=sg] -&gt; <span class="pysrc-string">'dog'</span> | <span class="pysrc-string">'girl'</span> | <span class="pysrc-string">'car'</span> | <span class="pysrc-string">'child'</span>
N[NUM=pl] -&gt; <span class="pysrc-string">'dogs'</span> | <span class="pysrc-string">'girls'</span> | <span class="pysrc-string">'cars'</span> | <span class="pysrc-string">'children'</span>
IV[TENSE=pres,  NUM=sg] -&gt; <span class="pysrc-string">'disappears'</span> | <span class="pysrc-string">'walks'</span>
TV[TENSE=pres, NUM=sg] -&gt; <span class="pysrc-string">'sees'</span> | <span class="pysrc-string">'likes'</span>
IV[TENSE=pres,  NUM=pl] -&gt; <span class="pysrc-string">'disappear'</span> | <span class="pysrc-string">'walk'</span>
TV[TENSE=pres, NUM=pl] -&gt; <span class="pysrc-string">'see'</span> | <span class="pysrc-string">'like'</span>
IV[TENSE=past] -&gt; <span class="pysrc-string">'disappeared'</span> | <span class="pysrc-string">'walked'</span>
TV[TENSE=past] -&gt; <span class="pysrc-string">'saw'</span> | <span class="pysrc-string">'liked'</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_feat0cfg.py" type="text/x-python"><span class="caption-label">Example 1.1 (code_feat0cfg.py)</span></a>: <span class="caption-label">Figure 1.1</span>: Example Feature based Grammar</td></tr></p>
</table></div>
<p>Notice that a syntactic category can have more than one feature; for
example,
<tt class="doctest"><span class="pre">V[TENSE=pres, NUM=pl]</span></tt>.
In general, we can add as many features as we like.</p>
<p>A final detail about <a class="reference internal" href="#code-feat0cfg">1.1</a> is the statement <tt class="doctest"><span class="pre">%start S</span></tt>.
This &quot;directive&quot; tells the parser to take <tt class="doctest"><span class="pre">S</span></tt> as the
start symbol for the grammar.</p>
<p>In general, when we are trying to develop even a very small grammar,
it is convenient to put the productions in a file where they can be edited,
tested and revised.  We have saved <a class="reference internal" href="#code-feat0cfg">1.1</a> as a file named
<tt class="doctest"><span class="pre"><span class="pysrc-string">'feat0.fcfg'</span></span></tt> in the NLTK data distribution. You can make your own
copy of this for further experimentation using <tt class="doctest"><span class="pre">nltk.data.load()</span></tt>.</p>
<p><a class="reference internal" href="#code-featurecharttrace">1.2</a> illustrates the operation of a chart
parser with a feature-based grammar.
After tokenizing the input, we import the <tt class="doctest"><span class="pre">load_parser</span></tt> function
<a class="reference internal" href="#load_parser1"><span id="ref-load_parser1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> which takes a grammar filename as input and returns a
chart parser <tt class="doctest"><span class="pre">cp</span></tt> <a class="reference internal" href="#load_parser2"><span id="ref-load_parser2"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.  Calling the parser's
<tt class="doctest"><span class="pre">parse()</span></tt> method will iterate over the resulting parse trees;
<tt class="doctest"><span class="pre">trees</span></tt> will be empty if the grammar fails to parse the input and
will contain one or more parse trees, depending on whether the input
is syntactically ambiguous or not.</p>
<span class="target" id="code-featurecharttrace"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">'Kim likes children'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk <span class="pysrc-keyword">import</span> load_parser <a name="load_parser1" /><a href="#ref-load_parser1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = load_parser(<span class="pysrc-string">'grammars/book_grammars/feat0.fcfg'</span>, trace=2)  <a name="load_parser2" /><a href="#ref-load_parser2"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> cp.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-more">...</span>
|.Kim .like.chil.|
Leaf Init Rule:
|[----]    .    .| [0:1] <span class="pysrc-string">'Kim'</span>
|.    [----]    .| [1:2] <span class="pysrc-string">'likes'</span>
|.    .    [----]| [2:3] <span class="pysrc-string">'children'</span>
Feature Bottom Up Predict Combine Rule:
|[----]    .    .| [0:1] PropN[NUM=<span class="pysrc-string">'sg'</span>] -&gt; <span class="pysrc-string">'Kim'</span> *
Feature Bottom Up Predict Combine Rule:
|[----]    .    .| [0:1] NP[NUM=<span class="pysrc-string">'sg'</span>] -&gt; PropN[NUM=<span class="pysrc-string">'sg'</span>] *
Feature Bottom Up Predict Combine Rule:
|[----&gt;    .    .| [0:1] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: <span class="pysrc-string">'sg'</span>}
Feature Bottom Up Predict Combine Rule:
|.    [----]    .| [1:2] TV[NUM=<span class="pysrc-string">'sg'</span>, TENSE=<span class="pysrc-string">'pres'</span>] -&gt; <span class="pysrc-string">'likes'</span> *
Feature Bottom Up Predict Combine Rule:
|.    [----&gt;    .| [1:2] VP[NUM=?n, TENSE=?t] -&gt; TV[NUM=?n, TENSE=?t] * NP[] {?n: <span class="pysrc-string">'sg'</span>, ?t: <span class="pysrc-string">'pres'</span>}
Feature Bottom Up Predict Combine Rule:
|.    .    [----]| [2:3] N[NUM=<span class="pysrc-string">'pl'</span>] -&gt; <span class="pysrc-string">'children'</span> *
Feature Bottom Up Predict Combine Rule:
|.    .    [----]| [2:3] NP[NUM=<span class="pysrc-string">'pl'</span>] -&gt; N[NUM=<span class="pysrc-string">'pl'</span>] *
Feature Bottom Up Predict Combine Rule:
|.    .    [----&gt;| [2:3] S[] -&gt; NP[NUM=?n] * VP[NUM=?n] {?n: <span class="pysrc-string">'pl'</span>}
Feature Single Edge Fundamental Rule:
|.    [---------]| [1:3] VP[NUM=<span class="pysrc-string">'sg'</span>, TENSE=<span class="pysrc-string">'pres'</span>] -&gt; TV[NUM=<span class="pysrc-string">'sg'</span>, TENSE=<span class="pysrc-string">'pres'</span>] NP[] *
Feature Single Edge Fundamental Rule:
|[==============]| [0:3] S[] -&gt; NP[NUM=<span class="pysrc-string">'sg'</span>] VP[NUM=<span class="pysrc-string">'sg'</span>] *
(S[]
  (NP[NUM=<span class="pysrc-string">'sg'</span>] (PropN[NUM=<span class="pysrc-string">'sg'</span>] Kim))
  (VP[NUM=<span class="pysrc-string">'sg'</span>, TENSE=<span class="pysrc-string">'pres'</span>]
    (TV[NUM=<span class="pysrc-string">'sg'</span>, TENSE=<span class="pysrc-string">'pres'</span>] likes)
    (NP[NUM=<span class="pysrc-string">'pl'</span>] (N[NUM=<span class="pysrc-string">'pl'</span>] children))))</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_featurecharttrace.py" type="text/x-python"><span class="caption-label">Example 1.2 (code_featurecharttrace.py)</span></a>: <span class="caption-label">Figure 1.2</span>: Trace of Feature based Chart Parser</td></tr></p>
</table></div>
<p>The details of the parsing procedure are not that important for
present purposes. However, there is an implementation issue which
bears on our earlier discussion of grammar size. One possible approach
to parsing productions containing feature constraints is to compile
out all admissible values of the features in question so that we end
up with a large, fully specified CFG along the lines of <a class="reference internal" href="#ex-agcfg1">(6)</a>. By
contrast, the parser process illustrated above works directly with the
underspecified productions given by the grammar. Feature values &quot;flow
upwards&quot; from lexical entries, and variable values are then associated
with those values, via bindings (i.e., dictionaries) such as <tt class="doctest"><span class="pre">{?n:
<span class="pysrc-string">'sg'</span>, ?t: <span class="pysrc-string">'pres'</span>}</span></tt>.  As the parser assembles information about the
nodes of the tree it is building, these variable bindings are used to
instantiate values in these nodes; thus the underspecified
<tt class="doctest"><span class="pre">VP[NUM=?n, TENSE=?t] -&gt; TV[NUM=?n, TENSE=?t] NP[]</span></tt> becomes
instantiated as <tt class="doctest"><span class="pre">VP[NUM=<span class="pysrc-string">'sg'</span>, TENSE=<span class="pysrc-string">'pres'</span>] -&gt; TV[NUM=<span class="pysrc-string">'sg'</span>,
TENSE=<span class="pysrc-string">'pres'</span>] NP[]</span></tt> by looking up the values of <tt class="doctest"><span class="pre">?n</span></tt> and <tt class="doctest"><span class="pre">?t</span></tt> in
the bindings.</p>
<p>Finally, we can inspect the resulting parse trees (in this case, a
single one).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> trees: <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[]</span>
<span class="pysrc-output">  (NP[NUM='sg'] (PropN[NUM='sg'] Kim))</span>
<span class="pysrc-output">  (VP[NUM='sg', TENSE='pres']</span>
<span class="pysrc-output">    (TV[NUM='sg', TENSE='pres'] likes)</span>
<span class="pysrc-output">    (NP[NUM='pl'] (N[NUM='pl'] children))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="terminology">
<h2>1.3&nbsp;&nbsp;&nbsp;Terminology</h2>
<p>So far, we have only seen feature values like <tt class="doctest"><span class="pre">sg</span></tt> and
<tt class="doctest"><span class="pre">pl</span></tt>. These simple values are usually called <a name="atomic_index_term" /><span class="termdef">atomic</span>
&#8212; that is, they can't be decomposed into subparts. A special
case of atomic values are <a name="boolean_index_term" /><span class="termdef">boolean</span> values, that is, values that
just specify whether a property is true or false. For
example, we might want to distinguish <a name="auxiliary_index_term" /><span class="termdef">auxiliary</span> verbs such as
<span class="example">can</span>, <span class="example">may</span>, <span class="example">will</span> and <span class="example">do</span> with the boolean feature
<tt class="doctest"><span class="pre">AUX</span></tt>. For example, the production <tt class="doctest"><span class="pre">V[TENSE=pres, AUX=+] -&gt; <span class="pysrc-string">'can'</span></span></tt>
means that <span class="example">can</span> receives the value <tt class="doctest"><span class="pre">pres</span></tt> for <tt class="doctest"><span class="pre">TENSE</span></tt> and
<tt class="doctest"><span class="pre">+</span></tt> or <tt class="doctest"><span class="pre">true</span></tt> for <tt class="doctest"><span class="pre">AUX</span></tt>. There is a widely adopted
convention which abbreviates the representation of boolean
features <tt class="doctest"><span class="pre">f</span></tt>; instead of <tt class="doctest"><span class="pre">AUX=+</span></tt> or <tt class="doctest"><span class="pre">AUX=-</span></tt>, we use <tt class="doctest"><span class="pre">+AUX</span></tt> and
<tt class="doctest"><span class="pre">-AUX</span></tt> respectively. These are just abbreviations, however, and the
parser interprets them as though <tt class="doctest"><span class="pre">+</span></tt> and <tt class="doctest"><span class="pre">-</span></tt> are like any
other atomic value. <a class="reference internal" href="#ex-lex">(15)</a> shows some representative productions:</p>
<span class="target" id="ex-lex"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(15)</td><td width="15"></td><td><pre class="literal-block">
V[TENSE=pres, +AUX] -&gt; 'can'
V[TENSE=pres, +AUX] -&gt; 'may'

V[TENSE=pres, -AUX] -&gt; 'walks'
V[TENSE=pres, -AUX] -&gt; 'likes'
</pre>
</td></tr></table></p>
<p>We have spoken of attaching &quot;feature annotations&quot; to
syntactic categories. A more radical approach represents the whole category
&#8212; that is, the non-terminal symbol plus the annotation &#8212;
as a bundle of features.  For example, <tt class="doctest"><span class="pre">N[NUM=sg]</span></tt> contains part of speech
information which can be represented as
<tt class="doctest"><span class="pre">POS=N</span></tt>.  An alternative notation for this category therefore
is <tt class="doctest"><span class="pre">[POS=N, NUM=sg]</span></tt>.</p>
<p>In addition to atomic-valued features,  features may take values that
are themselves feature structures. For example, we can group
together agreement features (e.g., person, number and gender) as a
distinguished part of a category, grouped together as the value of <tt class="doctest"><span class="pre">AGR</span></tt>. In this case,
we say that <tt class="doctest"><span class="pre">AGR</span></tt> has a <a name="complex_index_term" /><span class="termdef">complex</span> value.  <a class="reference internal" href="#ex-agr0">(16)</a> depicts the structure, in a format
known as an <a name="attribute_value_matrix_index_term" /><span class="termdef">attribute value matrix</span> (AVM).</p>
<span class="target" id="ex-agr0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(16)</td><td width="15"></td><td><pre class="literal-block">
[POS = N           ]
[                  ]
[AGR = [PER = 3   ]]
[      [NUM = pl  ]]
[      [GND = fem ]]
</pre>
</td></tr></table></p>
<span class="target" id="fig-avm1"></span><div class="figure" id="fig-avm1">
<img alt="../images/avm1.png" src="../images/avm1.png" style="width: 221.4px; height: 107.39999999999999px;" />
<p class="caption"><span class="caption-label">Figure 1.3</span>: Rendering a Feature Structure as an Attribute Value Matrix</p>
</div>
<p>In passing, we should point out that there are alternative approaches
for displaying AVMs; <a class="reference internal" href="#fig-avm1">1.3</a> shows an example.
Athough feature structures rendered in the style of <a class="reference internal" href="#ex-agr0">(16)</a> are less
visually pleasing, we will stick with this format, since it
corresponds to the output we will be getting from NLTK.</p>
<!-- XXX if people think of these as dictionaries there's nothing surprising about order -->
<p>On the topic of representation, we also note that feature structures, like
dictionaries, assign no
particular significance to the <em>order</em> of features. So <a class="reference internal" href="#ex-agr0">(16)</a> is equivalent to:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(17)</td><td width="15"></td><td><pre class="literal-block">
[AGR = [NUM = pl  ]]
[      [PER = 3   ]]
[      [GND = fem ]]
[                  ]
[POS = N           ]
</pre>
</td></tr></table></p>
<p>Once we have the possibility of using features like <tt class="doctest"><span class="pre">AGR</span></tt>, we
can refactor a grammar like <a class="reference internal" href="#code-feat0cfg">1.1</a> so that agreement features are
bundled together. A tiny grammar illustrating this idea is shown in <a class="reference internal" href="#ex-agr2">(18)</a>.</p>
<span class="target" id="ex-agr2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(18)</td><td width="15"></td><td><pre class="literal-block">
S                    -&gt; NP[AGR=?n] VP[AGR=?n]
NP[AGR=?n]           -&gt; PropN[AGR=?n]
VP[TENSE=?t, AGR=?n] -&gt; Cop[TENSE=?t, AGR=?n] Adj

Cop[TENSE=pres,  AGR=[NUM=sg, PER=3]] -&gt; 'is'
PropN[AGR=[NUM=sg, PER=3]]            -&gt; 'Kim'
Adj                                   -&gt; 'happy'
</pre>
</td></tr></table></p>
</div>
</div>
<div class="section" id="processing-feature-structures">
<span id="sec-feat-comp"></span><h1>2&nbsp;&nbsp;&nbsp;Processing  Feature Structures</h1>
<p>In this section, we will show how feature structures can be
constructed and manipulated in NLTK. We will also discuss the
fundamental operation of unification, which allows us to combine the
information contained in two different feature structures.</p>
<p>Feature structures in NLTK are declared with the
<tt class="doctest"><span class="pre">FeatStruct()</span></tt> constructor. Atomic feature values can be strings or
integers.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(TENSE=<span class="pysrc-string">'past'</span>, NUM=<span class="pysrc-string">'sg'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs1)
<span class="pysrc-output">[ NUM   = 'sg'   ]</span>
<span class="pysrc-output">[ TENSE = 'past' ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>A feature structure is actually just a kind of dictionary,
and so we access its values by indexing in the usual way.
We can use our familiar syntax to <em>assign</em> values to features:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(PER=3, NUM=<span class="pysrc-string">'pl'</span>, GND=<span class="pysrc-string">'fem'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs1[<span class="pysrc-string">'GND'</span>])
<span class="pysrc-output">fem</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1[<span class="pysrc-string">'CASE'</span>] = <span class="pysrc-string">'acc'</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also define feature structures that have complex values, as
discussed earlier.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(POS=<span class="pysrc-string">'N'</span>, AGR=fs1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2)
<span class="pysrc-output">[       [ CASE = 'acc' ] ]</span>
<span class="pysrc-output">[ AGR = [ GND  = 'fem' ] ]</span>
<span class="pysrc-output">[       [ NUM  = 'pl'  ] ]</span>
<span class="pysrc-output">[       [ PER  = 3     ] ]</span>
<span class="pysrc-output">[                        ]</span>
<span class="pysrc-output">[ POS = 'N'              ]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2[<span class="pysrc-string">'AGR'</span>])
<span class="pysrc-output">[ CASE = 'acc' ]</span>
<span class="pysrc-output">[ GND  = 'fem' ]</span>
<span class="pysrc-output">[ NUM  = 'pl'  ]</span>
<span class="pysrc-output">[ PER  = 3     ]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2[<span class="pysrc-string">'AGR'</span>][<span class="pysrc-string">'PER'</span>])
<span class="pysrc-output">3</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>An alternative method of specifying feature structures is to
use a bracketed string consisting of feature-value pairs in the format
<tt class="doctest"><span class="pre">feature=value</span></tt>, where values may themselves be feature structures:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.FeatStruct(<span class="pysrc-string">&quot;[POS='N', AGR=[PER=3, NUM='pl', GND='fem']]&quot;</span>))
<span class="pysrc-output">[       [ GND = 'fem' ] ]</span>
<span class="pysrc-output">[ AGR = [ NUM = 'pl'  ] ]</span>
<span class="pysrc-output">[       [ PER = 3     ] ]</span>
<span class="pysrc-output">[                       ]</span>
<span class="pysrc-output">[ POS = 'N'             ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Feature structures are not inherently tied to linguistic objects; they are
general purpose structures for representing knowledge. For example, we
could encode information about a person in a feature structure:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.FeatStruct(NAME=<span class="pysrc-string">'Lee'</span>, TELNO=<span class="pysrc-string">'01 27 86 42 96'</span>, AGE=33))
<span class="pysrc-output">[ AGE   = 33               ]</span>
<span class="pysrc-output">[ NAME  = 'Lee'            ]</span>
<span class="pysrc-output">[ TELNO = '01 27 86 42 96' ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In the next couple of pages, we are going to use examples like this
to explore standard operations over feature structures.
This will briefly divert us from processing natural language,
but we need to lay the groundwork before we can
get back to talking about grammars. Hang on tight!</p>
<p>It is often helpful to view feature structures as graphs; more
specifically, <a name="directed_acyclic_graphs_index_term" /><span class="termdef">directed acyclic graphs</span> (DAGs).
<a class="reference internal" href="#ex-dag01">(19)</a> is equivalent to the above AVM.</p>
<span class="target" id="ex-dag01"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(19)</td><td width="15"></td><td><img alt="../images/dag01.png" src="../images/dag01.png" style="width: 209.20000000000002px; height: 176.8px;" /></td></tr></table></p>
<p>The feature names appear as labels on the directed arcs, and feature
values appear as labels on the nodes that are pointed to by the arcs.</p>
<p>Just as before, feature values can be complex:</p>
<span class="target" id="ex-dag02"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(20)</td><td width="15"></td><td><img alt="../images/dag02.png" src="../images/dag02.png" style="width: 260.0px; height: 281.2px;" /></td></tr></table></p>
<p>When we look at such graphs, it is natural to think in terms of
paths through the graph. A <a name="feature_path_index_term" /><span class="termdef">feature path</span> is a sequence of arcs
that can be followed from the root node. We will represent paths as
tuples. Thus, <tt class="doctest"><span class="pre">(<span class="pysrc-string">'ADDRESS'</span>, <span class="pysrc-string">'STREET'</span>)</span></tt> is a feature path whose value
in <a class="reference internal" href="#ex-dag02">(20)</a> is the node labeled <tt class="doctest"><span class="pre"><span class="pysrc-string">'rue Pascal'</span></span></tt>.</p>
<p>Now let's consider a situation where Lee has a spouse named <em>Kim</em>, and
Kim's address is the same as Lee's.
We might represent this as <a class="reference internal" href="#ex-dag04">(21)</a>.</p>
<span class="target" id="ex-dag04"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(21)</td><td width="15"></td><td><img alt="../images/dag04.png" src="../images/dag04.png" style="width: 468.0px; height: 298.0px;" /></td></tr></table></p>
<p>However, rather than repeating the address
information in the feature structure, we can &quot;share&quot; the same
sub-graph between different arcs:</p>
<span class="target" id="ex-dag03"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(22)</td><td width="15"></td><td><img alt="../images/dag03.png" src="../images/dag03.png" style="width: 376.8px; height: 281.2px;" /></td></tr></table></p>
<p>In other words, the value of the path <tt class="doctest"><span class="pre">(<span class="pysrc-string">'ADDRESS'</span>)</span></tt> in <a class="reference internal" href="#ex-dag03">(22)</a> is
identical to the value of the path <tt class="doctest"><span class="pre">(<span class="pysrc-string">'SPOUSE'</span>, <span class="pysrc-string">'ADDRESS'</span>)</span></tt>.  DAGs
such as <a class="reference internal" href="#ex-dag03">(22)</a> are said to involve <a name="structure_sharing_index_term" /><span class="termdef">structure sharing</span> or
<a name="reentrancy_index_term" /><span class="termdef">reentrancy</span>. When two paths have the same value, they are said to
be <a name="equivalent_index_term" /><span class="termdef">equivalent</span>.</p>
<p>In order to indicate reentrancy in our matrix-style representations, we will
prefix the first occurrence of a shared feature structure
with an integer in parentheses, such as <tt class="doctest"><span class="pre">(1)</span></tt>.
Any later reference to that structure will use the notation
<tt class="doctest"><span class="pre">-&gt;(1)</span></tt>, as shown below.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.FeatStruct(<span class="pysrc-string">&quot;&quot;&quot;[NAME='Lee', ADDRESS=(1)[NUMBER=74, STREET='rue Pascal'],</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                         SPOUSE=[NAME='Kim', ADDRESS-&gt;(1)]]&quot;&quot;&quot;</span>))
<span class="pysrc-output">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="pysrc-output">[               [ STREET = 'rue Pascal' ] ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                         ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim' ]           ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The bracketed integer is sometimes called a <a name="tag_index_term" /><span class="termdef">tag</span> or a
<a name="coindex_index_term" /><span class="termdef">coindex</span>. The choice of integer is not significant.
There can be any number of tags within a single feature structure.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(nltk.FeatStruct(<span class="pysrc-string">&quot;[A='a', B=(1)[C='c'], D-&gt;(1), E-&gt;(1)]&quot;</span>))
<span class="pysrc-output">[ A = 'a'             ]</span>
<span class="pysrc-output">[                     ]</span>
<span class="pysrc-output">[ B = (1) [ C = 'c' ] ]</span>
<span class="pysrc-output">[                     ]</span>
<span class="pysrc-output">[ D -&gt; (1)            ]</span>
<span class="pysrc-output">[ E -&gt; (1)            ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- TODO following AVM doesn't currently parse -->
<!-- We can also share empty structures:

    >>> fs2 = nltk.FeatStruct("[A=(1)[], B=(2)[], C->(1), D->(2)]")

.. _ex-reentrant03:
.. ex::
      ::

         [ A = (1) [ ] ]
         [ B = (2) [ ] ]
         [ C -> (1)    ]
         [ D -> (2)    ] -->
<div class="section" id="subsumption-and-unification">
<h2>2.1&nbsp;&nbsp;&nbsp;Subsumption and Unification</h2>
<p>It is standard to think of feature structures as providing <a name="partial_information_index_term" /><span class="termdef">partial
information</span> about some object, in the sense that we can order
feature structures according to how much information they contain. For example,
<a class="reference internal" href="#ex-fs01">(23a)</a> has less information than <a class="reference internal" href="#ex-fs02">(23b)</a>, which in turn has less information than <a class="reference internal" href="#ex-fs03">(23c)</a>.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(23)</td><td width="15"></td><td><span class="target" id="ex-fs01"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><pre class="literal-block">
[NUMBER = 74]
</pre>
</td></tr></table></p>
<span class="target" id="ex-fs02"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><pre class="literal-block">
[NUMBER = 74          ]
[STREET = 'rue Pascal']
</pre>
</td></tr></table></p>
<span class="target" id="ex-fs03"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td><pre class="literal-block">
[NUMBER = 74          ]
[STREET = 'rue Pascal']
[CITY = 'Paris'       ]
</pre>
</td></tr></table></p>
</td></tr></table></p>
<p>This ordering is called <a name="subsumption_index_term" /><span class="termdef">subsumption</span>; <span class="math">FS</span><sub>0</sub> subsumes <span class="math">FS</span><sub>1</sub> if all the
information contained in <span class="math">FS</span><sub>0</sub> is also contained in <span class="math">FS</span><sub>1</sub>.
We use the symbol &#8849; to represent subsumption.</p>
<p>When we add the possibility of reentrancy, we need to be more careful
about how we describe subsumption: if
<span class="math">FS</span><sub>0</sub> &#8849; <span class="math">FS</span><sub>1</sub>, then <span class="math">FS</span><sub>1</sub> must have all the
paths and reentrancies of <span class="math">FS</span><sub>0</sub>. Thus, <a class="reference internal" href="#ex-dag02">(20)</a> subsumes
<a class="reference internal" href="#ex-dag03">(22)</a>, since the latter has additional reentrancies. It should
be obvious that subsumption only provides a partial ordering on
feature structures, since some feature structures are
incommensurable. For example, <a class="reference internal" href="#ex-fs04">(24)</a> neither subsumes nor is subsumed
by <a class="reference internal" href="#ex-fs01">(23a)</a>.</p>
<span class="target" id="ex-fs04"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(24)</td><td width="15"></td><td><pre class="literal-block">
[TELNO = 01 27 86 42 96]
</pre>
</td></tr></table></p>
<p>So we have seen that some feature structures carry more information than
others. How do we go about adding more information to a given feature structure?
For example, we might decide that addresses should
consist of not just a street number and a street name, but also a
city. That is, we might want to <em>merge</em>  graph <a class="reference internal" href="#ex-dag042">(25b)</a> with <a class="reference internal" href="#ex-dag041">(25a)</a> to
yield <a class="reference internal" href="#ex-dag043">(25c)</a>.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(25)</td><td width="15"></td><td><span class="target" id="ex-dag041"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="../images/dag04-1.png" src="../images/dag04-1.png" style="width: 219.20000000000002px; height: 132.4px;" /></td></tr></table></p>
<span class="target" id="ex-dag042"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="../images/dag04-2.png" src="../images/dag04-2.png" style="width: 61.2px; height: 141.20000000000002px;" /></td></tr></table></p>
<span class="target" id="ex-dag043"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td><img alt="../images/dag04-3.png" src="../images/dag04-3.png" style="width: 219.20000000000002px; height: 149.20000000000002px;" /></td></tr></table></p>
</td></tr></table></p>
<p>Merging information from two feature structures is called
<a name="unification_index_term" /><span class="termdef">unification</span> and is supported by the <tt class="doctest"><span class="pre">unify()</span></tt> method.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(NUMBER=74, STREET=<span class="pysrc-string">'rue Pascal'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(CITY=<span class="pysrc-string">'Paris'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs1.unify(fs2))
<span class="pysrc-output">[ CITY   = 'Paris'      ]</span>
<span class="pysrc-output">[ NUMBER = 74           ]</span>
<span class="pysrc-output">[ STREET = 'rue Pascal' ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Unification is formally defined as a (partial) binary operation:
<span class="math">FS</span><sub>0</sub> &#8852;
<span class="math">FS</span><sub>1</sub>.
Unification is symmetric, so
<span class="math">FS</span><sub>0</sub> &#8852;
<span class="math">FS</span><sub>1</sub> = <span class="math">FS</span><sub>1</sub> &#8852;
<span class="math">FS</span><sub>0</sub>.
The same is true in Python:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2.unify(fs1))
<span class="pysrc-output">[ CITY   = 'Paris'      ]</span>
<span class="pysrc-output">[ NUMBER = 74           ]</span>
<span class="pysrc-output">[ STREET = 'rue Pascal' ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- TODO: also mention commutativity -->
<!-- but >>> fs1.unify(fs2) is fs2.unify(fs1)
    False
only works with repr() -->
<p>If we unify two feature structures which stand in the subsumption
relationship, then the result of unification is the most informative of
the two:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(26)</td><td width="15"></td><td>If <span class="math">FS</span><sub>0</sub> &#8849; <span class="math">FS</span><sub>1</sub>,  then <span class="math">FS</span><sub>0</sub>
&#8852; <span class="math">FS</span><sub>1</sub> = <span class="math">FS</span><sub>1</sub></td></tr></table></p>
<p>For example, the result of unifying <a class="reference internal" href="#ex-fs02">(23b)</a> with <a class="reference internal" href="#ex-fs03">(23c)</a> is <a class="reference internal" href="#ex-fs03">(23c)</a>.</p>
<p>Unification between <span class="math">FS</span><sub>0</sub> and <span class="math">FS</span><sub>1</sub> will fail if the two feature structures share a path &#960;,
but the value of &#960; in <span class="math">FS</span><sub>0</sub> is a distinct
atom from the value of &#960; in <span class="math">FS</span><sub>1</sub>.
This is implemented by setting the result of unification to be <tt class="doctest"><span class="pre">None</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs0 = nltk.FeatStruct(A=<span class="pysrc-string">'a'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(A=<span class="pysrc-string">'b'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = fs0.unify(fs1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2)
<span class="pysrc-output">None</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now, if we look at how unification interacts with structure-sharing,
things become really interesting. First, let's define <a class="reference internal" href="#ex-dag04">(21)</a> in Python:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs0 = nltk.FeatStruct(<span class="pysrc-string">&quot;&quot;&quot;[NAME=Lee,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                          ADDRESS=[NUMBER=74,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                                   STREET='rue Pascal'],</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                          SPOUSE= [NAME=Kim,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                                   ADDRESS=[NUMBER=74,</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                                            STREET='rue Pascal']]]&quot;&quot;&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs0)
<span class="pysrc-output">[ ADDRESS = [ NUMBER = 74           ]               ]</span>
<span class="pysrc-output">[           [ STREET = 'rue Pascal' ]               ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                                   ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[           [ ADDRESS = [ NUMBER = 74           ] ] ]</span>
<span class="pysrc-output">[ SPOUSE  = [           [ STREET = 'rue Pascal' ] ] ]</span>
<span class="pysrc-output">[           [                                     ] ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim'                     ] ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>What happens when we augment Kim's address with a specification
for <tt class="doctest"><span class="pre">CITY</span></tt>?  Notice that <tt class="doctest"><span class="pre">fs1</span></tt> needs to include the
whole path from the root of the feature structure down to <tt class="doctest"><span class="pre">CITY</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(<span class="pysrc-string">&quot;[SPOUSE = [ADDRESS = [CITY = Paris]]]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs1.unify(fs0))
<span class="pysrc-output">[ ADDRESS = [ NUMBER = 74           ]               ]</span>
<span class="pysrc-output">[           [ STREET = 'rue Pascal' ]               ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                                   ]</span>
<span class="pysrc-output">[                                                   ]</span>
<span class="pysrc-output">[           [           [ CITY   = 'Paris'      ] ] ]</span>
<span class="pysrc-output">[           [ ADDRESS = [ NUMBER = 74           ] ] ]</span>
<span class="pysrc-output">[ SPOUSE  = [           [ STREET = 'rue Pascal' ] ] ]</span>
<span class="pysrc-output">[           [                                     ] ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim'                     ] ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>By contrast, the result is very different if <tt class="doctest"><span class="pre">fs1</span></tt> is unified with
the structure-sharing version <tt class="doctest"><span class="pre">fs2</span></tt> (also shown earlier as the graph
<a class="reference internal" href="#ex-dag03">(22)</a>):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(<span class="pysrc-string">&quot;&quot;&quot;[NAME=Lee, ADDRESS=(1)[NUMBER=74, STREET='rue Pascal'],</span>
<span class="pysrc-more">... </span><span class="pysrc-string">                          SPOUSE=[NAME=Kim, ADDRESS-&gt;(1)]]&quot;&quot;&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs1.unify(fs2))
<span class="pysrc-output">[               [ CITY   = 'Paris'      ] ]</span>
<span class="pysrc-output">[ ADDRESS = (1) [ NUMBER = 74           ] ]</span>
<span class="pysrc-output">[               [ STREET = 'rue Pascal' ] ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ NAME    = 'Lee'                         ]</span>
<span class="pysrc-output">[                                         ]</span>
<span class="pysrc-output">[ SPOUSE  = [ ADDRESS -&gt; (1)  ]           ]</span>
<span class="pysrc-output">[           [ NAME    = 'Kim' ]           ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Rather than just updating what was in effect Kim's &quot;copy&quot; of Lee's address,
we have now updated <span class="emphasis">both</span> their addresses at the same time. More
generally, if a unification adds information to the value of some
path &#960;, then that unification simultaneously updates the value
of <span class="emphasis">any path that is equivalent to</span> &#960;.</p>
<!-- XXX The ?x gets broken across lines -->
<p>As we have already seen, structure sharing can also be stated
using variables such as <tt class="doctest"><span class="pre">?x</span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs1 = nltk.FeatStruct(<span class="pysrc-string">&quot;[ADDRESS1=[NUMBER=74, STREET='rue Pascal']]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fs2 = nltk.FeatStruct(<span class="pysrc-string">&quot;[ADDRESS1=?x, ADDRESS2=?x]&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2)
<span class="pysrc-output">[ ADDRESS1 = ?x ]</span>
<span class="pysrc-output">[ ADDRESS2 = ?x ]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">print</span>(fs2.unify(fs1))
<span class="pysrc-output">[ ADDRESS1 = (1) [ NUMBER = 74           ] ]</span>
<span class="pysrc-output">[                [ STREET = 'rue Pascal' ] ]</span>
<span class="pysrc-output">[                                          ]</span>
<span class="pysrc-output">[ ADDRESS2 -&gt; (1)                          ]</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="extending-a-feature-based-grammar">
<span id="sec-extending-a-feature-based-grammar"></span><h1>3&nbsp;&nbsp;&nbsp;Extending a Feature based Grammar</h1>
<p>In this section, we return to feature based grammar and explore
a variety of linguistic issues, and demonstrate the benefits
of incorporating features into the grammar.</p>
<div class="section" id="subcategorization">
<h2>3.1&nbsp;&nbsp;&nbsp;Subcategorization</h2>
<p>In <a class="reference external" href="ch08.html#chap-parse">8.</a>, we augmented our category labels to
represent different kinds of verb, and used the labels
<tt class="doctest"><span class="pre">IV</span></tt> and <tt class="doctest"><span class="pre">TV</span></tt> for intransitive and transitive verbs
respectively.  This allowed us to write productions like the
following:</p>
<span class="target" id="ex-subcatcfg0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(27)</td><td width="15"></td><td><pre class="literal-block">
VP -&gt; IV
VP -&gt; TV NP
</pre>
</td></tr></table></p>
<p>Although we know that <tt class="doctest"><span class="pre">IV</span></tt> and <tt class="doctest"><span class="pre">TV</span></tt> are two kinds of <tt class="doctest"><span class="pre">V</span></tt>,
they are just atomic nonterminal symbols from a CFG, as distinct
from each other as any other pair of symbols.  This notation doesn't
let us say anything about verbs in general, e.g. we cannot say
&quot;All lexical items of category <tt class="doctest"><span class="pre">V</span></tt> can be marked for tense&quot;,
since <span class="example">walk</span>, say, is an item of category <tt class="doctest"><span class="pre">IV</span></tt>, not <tt class="doctest"><span class="pre">V</span></tt>.
So, can we replace category labels such as <tt class="doctest"><span class="pre">TV</span></tt> and <tt class="doctest"><span class="pre">IV</span></tt>
by <tt class="doctest"><span class="pre">V</span></tt> along with a feature that tells us whether
the verb combines with a following <tt class="doctest"><span class="pre">NP</span></tt> object
or whether it can occur without any complement?</p>
<p>A simple approach, originally developed for a grammar framework
called Generalized Phrase Structure Grammar (GPSG), tries to solve
this problem by allowing lexical
categories to bear a <tt class="doctest"><span class="pre">SUBCAT</span></tt> which tells us what subcategorization
class the item belongs to. While GPSG used integer values for
<tt class="doctest"><span class="pre">SUBCAT</span></tt>, the example below adopts more mnemonic values, namely
<tt class="doctest"><span class="pre">intrans</span></tt>, <tt class="doctest"><span class="pre">trans</span></tt> and <tt class="doctest"><span class="pre">clause</span></tt>:</p>
<span class="target" id="ex-subcatgpsg"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(28)</td><td width="15"></td><td><pre class="literal-block">
VP[TENSE=?t, NUM=?n] -&gt; V[SUBCAT=intrans, TENSE=?t, NUM=?n]
VP[TENSE=?t, NUM=?n] -&gt; V[SUBCAT=trans, TENSE=?t, NUM=?n] NP
VP[TENSE=?t, NUM=?n] -&gt; V[SUBCAT=clause, TENSE=?t, NUM=?n] SBar

V[SUBCAT=intrans, TENSE=pres, NUM=sg] -&gt; 'disappears' | 'walks'
V[SUBCAT=trans, TENSE=pres, NUM=sg] -&gt; 'sees' | 'likes'
V[SUBCAT=clause, TENSE=pres, NUM=sg] -&gt; 'says' | 'claims'

V[SUBCAT=intrans, TENSE=pres, NUM=pl] -&gt; 'disappear' | 'walk'
V[SUBCAT=trans, TENSE=pres, NUM=pl] -&gt; 'see' | 'like'
V[SUBCAT=clause, TENSE=pres, NUM=pl] -&gt; 'say' | 'claim'

V[SUBCAT=intrans, TENSE=past, NUM=?n] -&gt; 'disappeared' | 'walked'
V[SUBCAT=trans, TENSE=past, NUM=?n] -&gt; 'saw' | 'liked'
V[SUBCAT=clause, TENSE=past, NUM=?n] -&gt; 'said' | 'claimed'
</pre>
</td></tr></table></p>
<p>When we see a lexical category like <tt class="doctest"><span class="pre">V[SUBCAT=trans]</span></tt>, we can
interpret the <tt class="doctest"><span class="pre">SUBCAT</span></tt> specification as a pointer to a production in
which <tt class="doctest"><span class="pre">V[SUBCAT=trans]</span></tt> is introduced as the head child in a
<tt class="doctest"><span class="pre">VP</span></tt> production.  By convention, there is a correspondence between
the values of <tt class="doctest"><span class="pre">SUBCAT</span></tt> and the productions that introduce lexical
heads.  On this approach, <tt class="doctest"><span class="pre">SUBCAT</span></tt> can <em>only</em> appear on lexical
categories; it makes no sense, for example, to specify a <tt class="doctest"><span class="pre">SUBCAT</span></tt>
value on <tt class="doctest"><span class="pre">VP</span></tt>. As required, <span class="example">walk</span> and <span class="example">like</span> both belong to
the category <tt class="doctest"><span class="pre">V</span></tt>. Nevertheless, <span class="example">walk</span> will only occur in
<tt class="doctest"><span class="pre">VP</span></tt>s expanded by a production with the feature <tt class="doctest"><span class="pre">SUBCAT=intrans</span></tt>
on the right hand side, as opposed to <span class="example">like</span>, which requires a
<tt class="doctest"><span class="pre">SUBCAT=trans</span></tt>.</p>
<p>In our third class of verbs above, we have specified a category
<tt class="doctest"><span class="pre">SBar</span></tt>. This is a label for subordinate clauses such as the
complement of <span class="example">claim</span> in the example <span class="example">You claim that you like
children</span>. We require two further productions to analyze such sentences:</p>
<span class="target" id="ex-sbar"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(29)</td><td width="15"></td><td><pre class="literal-block">
SBar -&gt; Comp S
Comp -&gt; 'that'
</pre>
</td></tr></table></p>
<p>The resulting structure is the following.</p>
<span class="target" id="ex-sbartree"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(30)</td><td width="15"></td><td><img alt="tree_images/ch09-tree-10.png" class="align-top" src="tree_images/ch09-tree-10.png" /></td></tr></table></p>
<p>An alternative treatment of subcategorization, due originally to a framework
known as categorial grammar, is represented in feature based frameworks such as PATR
and Head-driven Phrase Structure Grammar. Rather than using
<tt class="doctest"><span class="pre">SUBCAT</span></tt> values as a way of indexing productions, the <tt class="doctest"><span class="pre">SUBCAT</span></tt>
value directly encodes the valency of a head (the list of
arguments that it can combine with). For example, a verb like
<span class="example">put</span> that takes <tt class="doctest"><span class="pre">NP</span></tt> and <tt class="doctest"><span class="pre">PP</span></tt> complements (<span class="example">put the
book on the table</span>) might be represented as <a class="reference internal" href="#ex-subcathpsg0">(31)</a>:</p>
<!-- TODO: angle brackets don't appear -->
<span class="target" id="ex-subcathpsg0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(31)</td><td width="15"></td><td><pre class="literal-block">
V[SUBCAT=&lt;NP, NP, PP&gt;]
</pre>
</td></tr></table></p>
<p>This says that the verb can combine with three arguments. The
leftmost element in the list is the subject <tt class="doctest"><span class="pre">NP</span></tt>, while everything
else &#8212; an <tt class="doctest"><span class="pre">NP</span></tt> followed by a <tt class="doctest"><span class="pre">PP</span></tt> in this case &#8212; comprises the
subcategorized-for complements. When a verb like <span class="example">put</span> is combined
with appropriate complements, the requirements which are specified in
the  <tt class="doctest"><span class="pre">SUBCAT</span></tt> are discharged, and only a subject <tt class="doctest"><span class="pre">NP</span></tt> is
needed. This category, which corresponds to what is traditionally
thought of as <tt class="doctest"><span class="pre">VP</span></tt>, might be represented as follows.</p>
<span class="target" id="ex-subcathpsg1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(32)</td><td width="15"></td><td><pre class="literal-block">
V[SUBCAT=&lt;NP&gt;]
</pre>
</td></tr></table></p>
<p>Finally, a sentence is a kind of verbal category that has <span class="emphasis">no</span>
requirements for further arguments, and hence has a <tt class="doctest"><span class="pre">SUBCAT</span></tt>
whose value is the empty list. The tree <a class="reference internal" href="#ex-subcathpsg2">(33)</a> shows how these
category assignments combine in a parse of <span class="example">Kim put the book on the table</span>.</p>
<span class="target" id="ex-subcathpsg2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(33)</td><td width="15"></td><td><img alt="tree_images/ch09-tree-11.png" class="align-top" src="tree_images/ch09-tree-11.png" /></td></tr></table></p>
</div>
<div class="section" id="heads-revisited">
<h2>3.2&nbsp;&nbsp;&nbsp;Heads Revisited</h2>
<!-- XXX changed mother / head-daughter to parent / head-child in following -->
<p>We noted in the previous section that by factoring subcategorization
information out of the main category label, we could express more
generalizations about properties of verbs. Another property of this
kind is the following: expressions of category <tt class="doctest"><span class="pre">V</span></tt> are heads of
phrases of category <tt class="doctest"><span class="pre">VP</span></tt>. Similarly,
<tt class="doctest"><span class="pre">N</span></tt>s are heads of <tt class="doctest"><span class="pre">NP</span></tt>s,
<tt class="doctest"><span class="pre">A</span></tt>s (i.e., adjectives) are heads of <tt class="doctest"><span class="pre">AP</span></tt>s,  and
<tt class="doctest"><span class="pre">P</span></tt>s (i.e., prepositions) are heads of <tt class="doctest"><span class="pre">PP</span></tt>s.
Not all phrases have heads &#8212; for example, it is standard to say that coordinate
phrases (e.g., <span class="example">the book and the bell</span>) lack heads &#8212;
nevertheless, we would like our grammar formalism to express the
parent / head-child relation where it holds.
At present, <tt class="doctest"><span class="pre">V</span></tt> and <tt class="doctest"><span class="pre">VP</span></tt> are just atomic symbols, and
we need to find a way to relate them using features
(as we did earlier to relate <tt class="doctest"><span class="pre">IV</span></tt> and <tt class="doctest"><span class="pre">TV</span></tt>).</p>
<p>X-bar Syntax addresses
this issue by abstracting out the notion of <a name="phrasal_level_index_term" /><span class="termdef">phrasal level</span>. It is
usual to recognize three such levels. If <tt class="doctest"><span class="pre">N</span></tt> represents the
lexical level, then <tt class="doctest"><span class="pre">N</span></tt>' represents the next level up,
corresponding to the more traditional category <cite>Nom</cite>, while
<tt class="doctest"><span class="pre">N</span></tt>'' represents the phrasal level, corresponding to the
category <tt class="doctest"><span class="pre">NP</span></tt>.   <a class="reference internal" href="#ex-xbar0">(34a)</a> illustrates a
representative structure while  <a class="reference internal" href="#ex-xbar01">(34b)</a> is the more conventional counterpart.</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(34)</td><td width="15"></td><td><span class="target" id="ex-xbar0"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-12.png" class="align-top" src="tree_images/ch09-tree-12.png" /></td></tr></table></p>
<span class="target" id="ex-xbar01"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><img alt="tree_images/ch09-tree-13.png" class="align-top" src="tree_images/ch09-tree-13.png" /></td></tr></table></p>
</td></tr></table></p>
<!-- XXX The second half of the next paragraph is heavy going, for
a relatively simple idea; it would be easier to follow if
there was a diagram to demonstrate the contrast, giving
a pair of structures that are minimally different, e.g.
"put the chair on the stage" vs "saw the chair on the stage".
After this, prose could formalize the concepts. -->
<p>The head of the structure <a class="reference internal" href="#ex-xbar0">(34a)</a> is <tt class="doctest"><span class="pre">N</span></tt> while <tt class="doctest"><span class="pre">N</span></tt>'
and <tt class="doctest"><span class="pre">N</span></tt>'' are called <a name="_phrasal__projections_index_term" /><span class="termdef">(phrasal) projections</span> of <tt class="doctest"><span class="pre">N</span></tt>. <tt class="doctest"><span class="pre">N</span></tt>''
is the <a name="maximal_projection_index_term" /><span class="termdef">maximal projection</span>, and <tt class="doctest"><span class="pre">N</span></tt> is sometimes called the
<a name="zero_projection_index_term" /><span class="termdef">zero projection</span>. One of the central claims of X-bar syntax is
that all constituents share a structural similarity. Using <tt class="doctest"><span class="pre">X</span></tt> as
a variable over <tt class="doctest"><span class="pre">N</span></tt>, <tt class="doctest"><span class="pre">V</span></tt>, <tt class="doctest"><span class="pre">A</span></tt> and <tt class="doctest"><span class="pre">P</span></tt>, we say that
directly subcategorized <span class="emphasis">complements</span> of a lexical head  <tt class="doctest"><span class="pre">X</span></tt> are always
placed as siblings of the head, whereas <span class="emphasis">adjuncts</span> are
placed as siblings of the intermediate category, <tt class="doctest"><span class="pre">X</span></tt>'. Thus, the
configuration of the two <tt class="doctest"><span class="pre">P</span></tt>'' adjuncts in <a class="reference internal" href="#ex-xbar1">(35)</a> contrasts with that
of the complement <tt class="doctest"><span class="pre">P</span></tt>'' in <a class="reference internal" href="#ex-xbar0">(34a)</a>.</p>
<span class="target" id="ex-xbar1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(35)</td><td width="15"></td><td><img alt="tree_images/ch09-tree-14.png" class="align-top" src="tree_images/ch09-tree-14.png" /></td></tr></table></p>
<p>The productions in <a class="reference internal" href="#ex-xbar2">(36)</a> illustrate how bar levels can be encoded
using feature structures. The nested structure in <a class="reference internal" href="#ex-xbar1">(35)</a> is
achieved by two applications of the recursive rule expanding <tt class="doctest"><span class="pre">N[BAR=1]</span></tt>.</p>
<span class="target" id="ex-xbar2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(36)</td><td width="15"></td><td><pre class="literal-block">
S -&gt; N[BAR=2] V[BAR=2]
N[BAR=2] -&gt; Det N[BAR=1]
N[BAR=1] -&gt; N[BAR=1] P[BAR=2]
N[BAR=1] -&gt; N[BAR=0] P[BAR=2]
N[BAR=1] -&gt; N[BAR=0]XS
</pre>
</td></tr></table></p>
</div>
<div class="section" id="auxiliary-verbs-and-inversion">
<h2>3.3&nbsp;&nbsp;&nbsp;Auxiliary Verbs and Inversion</h2>
<p>Inverted clauses &#8212; where the order of subject and verb is
switched &#8212; occur in English interrogatives and also after
'negative' adverbs:</p>
<span class="target" id="ex-inv1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(37)</td><td width="15"></td><td><span class="target" id="ex-inv1a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Do you like children?</td></tr></table></p>
<span class="target" id="ex-inv1b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Can Jody walk?</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-inv2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(38)</td><td width="15"></td><td><span class="target" id="ex-inv2a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Rarely do you see Kim.</td></tr></table></p>
<span class="target" id="ex-inv2b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Never have I seen this dog.</td></tr></table></p>
</td></tr></table></p>
<p>However, we cannot place just any verb in pre-subject position:</p>
<span class="target" id="ex-inv3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(39)</td><td width="15"></td><td><span class="target" id="ex-inv3a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>*Like you children?</td></tr></table></p>
<span class="target" id="ex-inv3b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*Walks Jody?</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-inv4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(40)</td><td width="15"></td><td><span class="target" id="ex-inv4a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>*Rarely see you Kim.</td></tr></table></p>
<span class="target" id="ex-inv4b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*Never saw I this dog.</td></tr></table></p>
</td></tr></table></p>
<p>Verbs that can be positioned initially in inverted clauses belong to
the class known as <a name="auxiliaries_index_term" /><span class="termdef">auxiliaries</span>, and as well as  <span class="example">do</span>,
<span class="example">can</span> and <span class="example">have</span>  include <span class="example">be</span>, <span class="example">will</span>  and
<span class="example">shall</span>. One way of capturing such structures is with the
following production:</p>
<span class="target" id="ex-sinv"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(41)</td><td width="15"></td><td><pre class="literal-block">
S[+INV] -&gt; V[+AUX] NP VP
</pre>
</td></tr></table></p>
<p>That is, a clause marked as [<cite>+INV</cite>] consists of an auxiliary
verb followed by a <tt class="doctest"><span class="pre">VP</span></tt>. (In a more detailed grammar, we would
need to place some constraints on the form of the <tt class="doctest"><span class="pre">VP</span></tt>, depending
on the choice of auxiliary.) <a class="reference internal" href="#ex-invtree">(42)</a> illustrates the structure of an
inverted clause.</p>
<span class="target" id="ex-invtree"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(42)</td><td width="15"></td><td><img alt="tree_images/ch09-tree-15.png" class="align-top" src="tree_images/ch09-tree-15.png" /></td></tr></table></p>
</div>
<div class="section" id="unbounded-dependency-constructions">
<h2>3.4&nbsp;&nbsp;&nbsp;Unbounded Dependency Constructions</h2>
<p>Consider the following contrasts:</p>
<span class="target" id="ex-gap1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(43)</td><td width="15"></td><td><span class="target" id="ex-gap1a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>You like Jody.</td></tr></table></p>
<span class="target" id="ex-gap1b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*You like.</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-gap2"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(44)</td><td width="15"></td><td><span class="target" id="ex-gap2a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>You put the card into the slot.</td></tr></table></p>
<span class="target" id="ex-gap2b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*You put into the slot.</td></tr></table></p>
<span class="target" id="ex-gap2c"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>*You put the card.</td></tr></table></p>
<span class="target" id="ex-gap2d"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">d.</td><td width="15"></td><td>*You put.</td></tr></table></p>
</td></tr></table></p>
<p>The verb <span class="example">like</span> requires an <tt class="doctest"><span class="pre">NP</span></tt> complement, while
<span class="example">put</span> requires both a following <tt class="doctest"><span class="pre">NP</span></tt> and <tt class="doctest"><span class="pre">PP</span></tt>.
<a class="reference internal" href="#ex-gap1">(43)</a> and <a class="reference internal" href="#ex-gap2">(44)</a> show that these complements are <em>obligatory</em>:
omitting them leads to ungrammaticality. Yet there are contexts in
which obligatory complements can be omitted, as <a class="reference internal" href="#ex-gap3">(45)</a> and <a class="reference internal" href="#ex-gap4">(46)</a>
illustrate.</p>
<span class="target" id="ex-gap3"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(45)</td><td width="15"></td><td><span class="target" id="ex-gap3a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Kim knows who you like.</td></tr></table></p>
<span class="target" id="ex-gap3b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>This music, you really like.</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-gap4"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(46)</td><td width="15"></td><td><span class="target" id="ex-gap4a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Which card do you put into the slot?</td></tr></table></p>
<span class="target" id="ex-gap4b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Which slot do you put the card into?</td></tr></table></p>
</td></tr></table></p>
<p>That is, an obligatory complement can be omitted if there is an
appropriate <a name="filler_index_term" /><span class="termdef">filler</span> in the sentence, such as the question word
<span class="example">who</span> in <a class="reference internal" href="#ex-gap3a">(45a)</a>, the preposed topic <span class="example">this music</span> in <a class="reference internal" href="#ex-gap3b">(45b)</a>, or
the <span class="example">wh</span> phrases <span class="example">which card/slot</span> in <a class="reference internal" href="#ex-gap4">(46)</a>. It is common to
say that sentences like <a class="reference internal" href="#ex-gap3">(45)</a> &#8211; <a class="reference internal" href="#ex-gap4">(46)</a> contain <a name="gaps_index_term" /><span class="termdef">gaps</span> where
the obligatory complements have been omitted, and these gaps are
sometimes made explicit using an underscore:</p>
<span class="target" id="ex-gap5"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(47)</td><td width="15"></td><td><span class="target" id="ex-gap5a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Which card do you put __ into the slot?</td></tr></table></p>
<span class="target" id="ex-gap5b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Which slot do you put the card into __?</td></tr></table></p>
</td></tr></table></p>
<p>So, a gap can occur if it is <a name="licensed_index_term" /><span class="termdef">licensed</span> by a filler. Conversely,
fillers can only occur if there is an appropriate gap elsewhere  in
the sentence, as shown by the following examples.</p>
<span class="target" id="ex-gap6"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(48)</td><td width="15"></td><td><span class="target" id="ex-gap6a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>*Kim knows who you like Jody.</td></tr></table></p>
<span class="target" id="ex-gap6b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*This music, you really like hip-hop.</td></tr></table></p>
</td></tr></table></p>
<span class="target" id="ex-gap7"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(49)</td><td width="15"></td><td><span class="target" id="ex-gap7a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>*Which card do you put this into the slot?</td></tr></table></p>
<span class="target" id="ex-gap7b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>*Which slot do you put the card into this one?</td></tr></table></p>
</td></tr></table></p>
<p>The mutual co-occurence between filler and gap is sometimes termed a
&quot;dependency&quot;. One issue of considerable importance in theoretical
linguistics has been the nature of the material that can intervene
between a filler and the gap that it licenses; in particular, can we
simply list a finite set of sequences that separate the two? The answer
is No: there is no upper bound on the distance between filler and
gap. This fact can be easily illustrated with constructions involving
sentential complements, as shown in <a class="reference internal" href="#ex-gap8">(50)</a>.</p>
<span class="target" id="ex-gap8"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(50)</td><td width="15"></td><td><span class="target" id="ex-gap8a"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Who do you like __?</td></tr></table></p>
<span class="target" id="ex-gap8b"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Who do you claim that you like __?</td></tr></table></p>
<span class="target" id="ex-gap8c"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>Who do you claim that Jody says that you like __?</td></tr></table></p>
</td></tr></table></p>
<p>Since we can have indefinitely deep recursion of sentential
complements, the gap can be embedded indefinitely far inside the whole
sentence. This constellation of properties leads to the notion of an
<a name="unbounded_dependency_construction_index_term" /><span class="termdef">unbounded dependency construction</span>; that is, a filler-gap
dependency where there is no upper bound on the distance between
filler and gap.</p>
<p>A variety of mechanisms have been suggested for handling unbounded
dependencies in formal grammars; here we illustrate the approach due to
Generalized Phrase Structure Grammar that involves
<a name="slash_categories_index_term" /><span class="termdef">slash categories</span>. A slash category has the form <tt class="doctest"><span class="pre">Y/XP</span></tt>;
we interpret this as a phrase of category <tt class="doctest"><span class="pre">Y</span></tt> that
is missing a sub-constituent of category <tt class="doctest"><span class="pre">XP</span></tt>. For example,
<tt class="doctest"><span class="pre">S/NP</span></tt> is an <tt class="doctest"><span class="pre">S</span></tt> that is missing an <tt class="doctest"><span class="pre">NP</span></tt>. The use of
slash categories is illustrated in <a class="reference internal" href="#ex-gaptree1">(51)</a>.</p>
<span class="target" id="ex-gaptree1"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(51)</td><td width="15"></td><td><img alt="tree_images/ch09-tree-16.png" class="align-top" src="tree_images/ch09-tree-16.png" /></td></tr></table></p>
<p>The top part of the tree introduces the filler <span class="example">who</span> (treated as
an expression of category <tt class="doctest"><span class="pre">NP[+wh]</span></tt>) together with a
corresponding gap-containing constituent <tt class="doctest"><span class="pre">S/NP</span></tt>. The gap information is
then &quot;percolated&quot; down the tree via the <tt class="doctest"><span class="pre">VP/NP</span></tt> category, until it
reaches the category <tt class="doctest"><span class="pre">NP/NP</span></tt>. At this point, the dependency
is discharged by realizing the gap information as the empty string,
immediately dominated by <tt class="doctest"><span class="pre">NP/NP</span></tt>.</p>
<p>Do we need to think of slash categories as a completely new kind of
object?  Fortunately, we
can accommodate them within our existing feature based framework,
by treating slash as a feature, and the category to its right
as a value; that is,  <tt class="doctest"><span class="pre">S/NP</span></tt> is reducible to <tt class="doctest"><span class="pre">S[SLASH=NP]</span></tt>. In practice,
this is also how the parser interprets slash categories.</p>
<p>The grammar shown in <a class="reference internal" href="#code-slashcfg">3.1</a> illustrates
the main principles of slash categories, and also includes productions for
inverted clauses. To simplify presentation, we have omitted any
specification of tense on the verbs.</p>
<!-- XXX The contents of feat1.fcfg seems to have changed in the file.
I won't pull in the updated version in case the discussion also needs to be updated. -->
<span class="target" id="code-slashcfg"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.data.show_cfg(<span class="pysrc-string">'grammars/book_grammars/feat1.fcfg'</span>)
% start S
<span class="pysrc-comment"># ###################</span>
<span class="pysrc-comment"># Grammar Productions</span>
<span class="pysrc-comment"># ###################</span>
S[-INV] -&gt; NP VP
S[-INV]/?x -&gt; NP VP/?x
S[-INV] -&gt; NP S/NP
S[-INV] -&gt; Adv[+NEG] S[+INV]
S[+INV] -&gt; V[+AUX] NP VP
S[+INV]/?x -&gt; V[+AUX] NP VP/?x
SBar -&gt; Comp S[-INV]
SBar/?x -&gt; Comp S[-INV]/?x
VP -&gt; V[SUBCAT=intrans, -AUX]
VP -&gt; V[SUBCAT=trans, -AUX] NP
VP/?x -&gt; V[SUBCAT=trans, -AUX] NP/?x
VP -&gt; V[SUBCAT=clause, -AUX] SBar
VP/?x -&gt; V[SUBCAT=clause, -AUX] SBar/?x
VP -&gt; V[+AUX] VP
VP/?x -&gt; V[+AUX] VP/?x
<span class="pysrc-comment"># ###################</span>
<span class="pysrc-comment"># Lexical Productions</span>
<span class="pysrc-comment"># ###################</span>
V[SUBCAT=intrans, -AUX] -&gt; <span class="pysrc-string">'walk'</span> | <span class="pysrc-string">'sing'</span>
V[SUBCAT=trans, -AUX] -&gt; <span class="pysrc-string">'see'</span> | <span class="pysrc-string">'like'</span>
V[SUBCAT=clause, -AUX] -&gt; <span class="pysrc-string">'say'</span> | <span class="pysrc-string">'claim'</span>
V[+AUX] -&gt; <span class="pysrc-string">'do'</span> | <span class="pysrc-string">'can'</span>
NP[-WH] -&gt; <span class="pysrc-string">'you'</span> | <span class="pysrc-string">'cats'</span>
NP[+WH] -&gt; <span class="pysrc-string">'who'</span>
Adv[+NEG] -&gt; <span class="pysrc-string">'rarely'</span> | <span class="pysrc-string">'never'</span>
NP/NP -&gt;
Comp -&gt; <span class="pysrc-string">'that'</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_slashcfg.py" type="text/x-python"><span class="caption-label">Example 3.1 (code_slashcfg.py)</span></a>: <span class="caption-label">Figure 3.1</span>: Grammar with productions for inverted clauses and
long-distance dependencies, making use of slash categories</td></tr></p>
</table></div>
<p>The grammar in <a class="reference internal" href="#code-slashcfg">3.1</a> contains one &quot;gap-introduction&quot;
production, namely <tt class="doctest"><span class="pre">S[-INV] -&gt; NP S/NP</span></tt>.
In order to percolate the slash feature correctly, we need to add
slashes with variable values to both sides of the arrow in productions
that expand <tt class="doctest"><span class="pre">S</span></tt>, <tt class="doctest"><span class="pre">VP</span></tt> and <tt class="doctest"><span class="pre">NP</span></tt>. For example, <tt class="doctest"><span class="pre">VP/?x -&gt; V SBar/?x</span></tt> is
the slashed version of <tt class="doctest"><span class="pre">VP -&gt; V SBar</span></tt> and
says that a slash value can be specified on the <tt class="doctest"><span class="pre">VP</span></tt> parent of a
constituent if the same value is also specified on the <tt class="doctest"><span class="pre">SBar</span></tt>
child. Finally, <tt class="doctest"><span class="pre">NP/NP -&gt;</span></tt>  allows the slash information on <tt class="doctest"><span class="pre">NP</span></tt> to
be discharged as the empty string.
Using <a class="reference internal" href="#code-slashcfg">3.1</a>, we can parse the sequence <span class="example">who do you claim that you
like</span></p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">'who do you claim that you like'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk <span class="pysrc-keyword">import</span> load_parser
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = load_parser(<span class="pysrc-string">'grammars/book_grammars/feat1.fcfg'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> cp.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[-INV]</span>
<span class="pysrc-output">  (NP[+WH] who)</span>
<span class="pysrc-output">  (S[+INV]/NP[]</span>
<span class="pysrc-output">    (V[+AUX] do)</span>
<span class="pysrc-output">    (NP[-WH] you)</span>
<span class="pysrc-output">    (VP[]/NP[]</span>
<span class="pysrc-output">      (V[-AUX, SUBCAT='clause'] claim)</span>
<span class="pysrc-output">      (SBar[]/NP[]</span>
<span class="pysrc-output">        (Comp[] that)</span>
<span class="pysrc-output">        (S[-INV]/NP[]</span>
<span class="pysrc-output">          (NP[-WH] you)</span>
<span class="pysrc-output">          (VP[]/NP[] (V[-AUX, SUBCAT='trans'] like) (NP[]/NP[] )))))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<!-- XXX actual output has SUBCAT=2 instead of SUBCAT='clause' -->
<p>A more readable version of this tree is shown in <a class="reference internal" href="#ex-gapparse">(52)</a>.</p>
<span class="target" id="ex-gapparse"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(52)</td><td width="15"></td><td><img alt="tree_images/ch09-tree-17.png" class="align-top" src="tree_images/ch09-tree-17.png" /></td></tr></table></p>
<p>The grammar in <a class="reference internal" href="#code-slashcfg">3.1</a> will also allow us to parse sentences
without gaps:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">'you claim that you like cats'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> cp.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[-INV]</span>
<span class="pysrc-output">  (NP[-WH] you)</span>
<span class="pysrc-output">  (VP[]</span>
<span class="pysrc-output">    (V[-AUX, SUBCAT='clause'] claim)</span>
<span class="pysrc-output">    (SBar[]</span>
<span class="pysrc-output">      (Comp[] that)</span>
<span class="pysrc-output">      (S[-INV]</span>
<span class="pysrc-output">        (NP[-WH] you)</span>
<span class="pysrc-output">        (VP[] (V[-AUX, SUBCAT='trans'] like) (NP[-WH] cats))))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In addition, it admits inverted sentences which do not involve
<span class="example">wh</span> constructions:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">'rarely do you sing'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> cp.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[-INV]</span>
<span class="pysrc-output">  (Adv[+NEG] rarely)</span>
<span class="pysrc-output">  (S[+INV]</span>
<span class="pysrc-output">    (V[+AUX] do)</span>
<span class="pysrc-output">    (NP[-WH] you)</span>
<span class="pysrc-output">    (VP[] (V[-AUX, SUBCAT='intrans'] sing))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="case-and-gender-in-german">
<h2>3.5&nbsp;&nbsp;&nbsp;Case and Gender in German</h2>
<p>Compared with English, German has a relatively rich morphology for
agreement. For example, the definite article in German varies with
case, gender and number, as shown in <a class="reference internal" href="#tab-german-def-art">3.1</a>.</p>
<span class="target" id="tab-german-def-art"></span><table border="1" class="docutils" id="tab-german-def-art">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr><td><strong>Case</strong></td>
<td><strong>Masc</strong></td>
<td><strong>Fem</strong></td>
<td><strong>Neut</strong></td>
<td><strong>Plural</strong></td>
</tr>
<tr><td><em>Nom</em></td>
<td>der</td>
<td>die</td>
<td>das</td>
<td>die</td>
</tr>
<tr><td><em>Gen</em></td>
<td>des</td>
<td>der</td>
<td>des</td>
<td>der</td>
</tr>
<tr><td><em>Dat</em></td>
<td>dem</td>
<td>der</td>
<td>dem</td>
<td>den</td>
</tr>
<tr><td><em>Acc</em></td>
<td>den</td>
<td>die</td>
<td>das</td>
<td>die</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 3.1</span>: <p>Morphological Paradigm for the German definite Article</p>
</p>
</table>
<p>Subjects in German take the nominative case, and most verbs
govern their objects in the accusative case. However, there are
exceptions like <span class="example">helfen</span> that govern the dative case:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(53)</td><td width="15"></td><td><div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 1693)</p>
Error in &quot;gloss&quot; directive: may contain a single table only.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 1698)</p>
Error in &quot;gloss&quot; directive: may contain a single table only.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 1702)</p>
Error in &quot;gloss&quot; directive: may contain a single table only.</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 1707)</p>
Error in &quot;gloss&quot; directive: may contain a single table only.</div>
</td></tr></table></p>
<p>The grammar in <a class="reference internal" href="#code-germancfg">3.2</a> illustrates the interaction of agreement
(comprising person, number and gender) with case.</p>
<!-- XXX The contents of german.fcfg seems to have changed in the file.
I won't pull in the updated version in case the discussion also needs to be updated. -->
<span class="target" id="code-germancfg"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.data.show_cfg(<span class="pysrc-string">'grammars/book_grammars/german.fcfg'</span>)
<span class="pysrc-output">% start S</span>
<span class="pysrc-output"> # Grammar Productions</span>
<span class="pysrc-output"> S -&gt; NP[CASE=nom, AGR=?a] VP[AGR=?a]</span>
<span class="pysrc-output"> NP[CASE=?c, AGR=?a] -&gt; PRO[CASE=?c, AGR=?a]</span>
<span class="pysrc-output"> NP[CASE=?c, AGR=?a] -&gt; Det[CASE=?c, AGR=?a] N[CASE=?c, AGR=?a]</span>
<span class="pysrc-output"> VP[AGR=?a] -&gt; IV[AGR=?a]</span>
<span class="pysrc-output"> VP[AGR=?a] -&gt; TV[OBJCASE=?c, AGR=?a] NP[CASE=?c]</span>
<span class="pysrc-output"> # Lexical Productions</span>
<span class="pysrc-output"> # Singular determiners</span>
<span class="pysrc-output"> # masc</span>
<span class="pysrc-output"> Det[CASE=nom, AGR=[GND=masc,PER=3,NUM=sg]] -&gt; 'der'</span>
<span class="pysrc-output"> Det[CASE=dat, AGR=[GND=masc,PER=3,NUM=sg]] -&gt; 'dem'</span>
<span class="pysrc-output"> Det[CASE=acc, AGR=[GND=masc,PER=3,NUM=sg]] -&gt; 'den'</span>
<span class="pysrc-output"> # fem</span>
<span class="pysrc-output"> Det[CASE=nom, AGR=[GND=fem,PER=3,NUM=sg]] -&gt; 'die'</span>
<span class="pysrc-output"> Det[CASE=dat, AGR=[GND=fem,PER=3,NUM=sg]] -&gt; 'der'</span>
<span class="pysrc-output"> Det[CASE=acc, AGR=[GND=fem,PER=3,NUM=sg]] -&gt; 'die'</span>
<span class="pysrc-output"> # Plural determiners</span>
<span class="pysrc-output"> Det[CASE=nom, AGR=[PER=3,NUM=pl]] -&gt; 'die'</span>
<span class="pysrc-output"> Det[CASE=dat, AGR=[PER=3,NUM=pl]] -&gt; 'den'</span>
<span class="pysrc-output"> Det[CASE=acc, AGR=[PER=3,NUM=pl]] -&gt; 'die'</span>
<span class="pysrc-output"> # Nouns</span>
<span class="pysrc-output"> N[AGR=[GND=masc,PER=3,NUM=sg]] -&gt; 'Hund'</span>
<span class="pysrc-output"> N[CASE=nom, AGR=[GND=masc,PER=3,NUM=pl]] -&gt; 'Hunde'</span>
<span class="pysrc-output"> N[CASE=dat, AGR=[GND=masc,PER=3,NUM=pl]] -&gt; 'Hunden'</span>
<span class="pysrc-output"> N[CASE=acc, AGR=[GND=masc,PER=3,NUM=pl]] -&gt; 'Hunde'</span>
<span class="pysrc-output"> N[AGR=[GND=fem,PER=3,NUM=sg]] -&gt; 'Katze'</span>
<span class="pysrc-output"> N[AGR=[GND=fem,PER=3,NUM=pl]] -&gt; 'Katzen'</span>
<span class="pysrc-output"> # Pronouns</span>
<span class="pysrc-output"> PRO[CASE=nom, AGR=[PER=1,NUM=sg]] -&gt; 'ich'</span>
<span class="pysrc-output"> PRO[CASE=acc, AGR=[PER=1,NUM=sg]] -&gt; 'mich'</span>
<span class="pysrc-output"> PRO[CASE=dat, AGR=[PER=1,NUM=sg]] -&gt; 'mir'</span>
<span class="pysrc-output"> PRO[CASE=nom, AGR=[PER=2,NUM=sg]] -&gt; 'du'</span>
<span class="pysrc-output"> PRO[CASE=nom, AGR=[PER=3,NUM=sg]] -&gt; 'er' | 'sie' | 'es'</span>
<span class="pysrc-output"> PRO[CASE=nom, AGR=[PER=1,NUM=pl]] -&gt; 'wir'</span>
<span class="pysrc-output"> PRO[CASE=acc, AGR=[PER=1,NUM=pl]] -&gt; 'uns'</span>
<span class="pysrc-output"> PRO[CASE=dat, AGR=[PER=1,NUM=pl]] -&gt; 'uns'</span>
<span class="pysrc-output"> PRO[CASE=nom, AGR=[PER=2,NUM=pl]] -&gt; 'ihr'</span>
<span class="pysrc-output"> PRO[CASE=nom, AGR=[PER=3,NUM=pl]] -&gt; 'sie'</span>
<span class="pysrc-output"> # Verbs</span>
<span class="pysrc-output"> IV[AGR=[NUM=sg,PER=1]] -&gt; 'komme'</span>
<span class="pysrc-output"> IV[AGR=[NUM=sg,PER=2]] -&gt; 'kommst'</span>
<span class="pysrc-output"> IV[AGR=[NUM=sg,PER=3]] -&gt; 'kommt'</span>
<span class="pysrc-output"> IV[AGR=[NUM=pl, PER=1]] -&gt; 'kommen'</span>
<span class="pysrc-output"> IV[AGR=[NUM=pl, PER=2]] -&gt; 'kommt'</span>
<span class="pysrc-output"> IV[AGR=[NUM=pl, PER=3]] -&gt; 'kommen'</span>
<span class="pysrc-output"> TV[OBJCASE=acc, AGR=[NUM=sg,PER=1]] -&gt; 'sehe' | 'mag'</span>
<span class="pysrc-output"> TV[OBJCASE=acc, AGR=[NUM=sg,PER=2]] -&gt; 'siehst' | 'magst'</span>
<span class="pysrc-output"> TV[OBJCASE=acc, AGR=[NUM=sg,PER=3]] -&gt; 'sieht' | 'mag'</span>
<span class="pysrc-output"> TV[OBJCASE=dat, AGR=[NUM=sg,PER=1]] -&gt; 'folge' | 'helfe'</span>
<span class="pysrc-output"> TV[OBJCASE=dat, AGR=[NUM=sg,PER=2]] -&gt; 'folgst' | 'hilfst'</span>
<span class="pysrc-output"> TV[OBJCASE=dat, AGR=[NUM=sg,PER=3]] -&gt; 'folgt' | 'hilft'</span>
<span class="pysrc-output"> TV[OBJCASE=acc, AGR=[NUM=pl,PER=1]] -&gt; 'sehen' | 'moegen'</span>
<span class="pysrc-output"> TV[OBJCASE=acc, AGR=[NUM=pl,PER=2]] -&gt; 'sieht' | 'moegt'</span>
<span class="pysrc-output"> TV[OBJCASE=acc, AGR=[NUM=pl,PER=3]] -&gt; 'sehen' | 'moegen'</span>
<span class="pysrc-output"> TV[OBJCASE=dat, AGR=[NUM=pl,PER=1]] -&gt; 'folgen' | 'helfen'</span>
<span class="pysrc-output"> TV[OBJCASE=dat, AGR=[NUM=pl,PER=2]] -&gt; 'folgt' | 'helft'</span>
<span class="pysrc-output"> TV[OBJCASE=dat, AGR=[NUM=pl,PER=3]] -&gt; 'folgen' | 'helfen'</span></pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_germancfg.py" type="text/x-python"><span class="caption-label">Example 3.2 (code_germancfg.py)</span></a>: <span class="caption-label">Figure 3.2</span>: Example Feature based Grammar</td></tr></p>
</table></div>
<p>As you can see, the feature <cite>objcase</cite> is used to specify the case that
a verb governs on its object. The next example illustrates the parse
tree for a sentence containing a verb which governs dative case.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">'ich folge den Katzen'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = load_parser(<span class="pysrc-string">'grammars/book_grammars/german.fcfg'</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> cp.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">(S[]</span>
<span class="pysrc-output">  (NP[AGR=[NUM='sg', PER=1], CASE='nom']</span>
<span class="pysrc-output">    (PRO[AGR=[NUM='sg', PER=1], CASE='nom'] ich))</span>
<span class="pysrc-output">  (VP[AGR=[NUM='sg', PER=1]]</span>
<span class="pysrc-output">    (TV[AGR=[NUM='sg', PER=1], OBJCASE='dat'] folge)</span>
<span class="pysrc-output">    (NP[AGR=[GND='fem', NUM='pl', PER=3], CASE='dat']</span>
<span class="pysrc-output">      (Det[AGR=[NUM='pl', PER=3], CASE='dat'] den)</span>
<span class="pysrc-output">      (N[AGR=[GND='fem', NUM='pl', PER=3]] Katzen))))</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>In developing grammars, excluding ungrammatical word sequences is often as
challenging as parsing grammatical ones. In order to get an idea
where and why a sequence fails to parse, setting the <tt class="doctest"><span class="pre">trace</span></tt>
parameter of the <tt class="doctest"><span class="pre">load_parser()</span></tt> method can be crucial. Consider the
following parse failure:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = <span class="pysrc-string">'ich folge den Katze'</span>.split()
<span class="pysrc-prompt">&gt;&gt;&gt; </span>cp = load_parser(<span class="pysrc-string">'grammars/book_grammars/german.fcfg'</span>, trace=2)
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> tree <span class="pysrc-keyword">in</span> cp.parse(tokens):
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span>(tree)
<span class="pysrc-output">|.ich.fol.den.Kat.|</span>
<span class="pysrc-output">Leaf Init Rule:</span>
<span class="pysrc-output">|[---]   .   .   .| [0:1] 'ich'</span>
<span class="pysrc-output">|.   [---]   .   .| [1:2] 'folge'</span>
<span class="pysrc-output">|.   .   [---]   .| [2:3] 'den'</span>
<span class="pysrc-output">|.   .   .   [---]| [3:4] 'Katze'</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|[---]   .   .   .| [0:1] PRO[AGR=[NUM='sg', PER=1], CASE='nom']</span>
<span class="pysrc-output">                          -&gt; 'ich' *</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|[---]   .   .   .| [0:1] NP[AGR=[NUM='sg', PER=1], CASE='nom'] -&gt; PRO[AGR=[NUM='sg', PER=1], CASE='nom'] *</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|[---&gt;   .   .   .| [0:1] S[] -&gt; NP[AGR=?a, CASE='nom'] * VP[AGR=?a] {?a: [NUM='sg', PER=1]}</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|.   [---]   .   .| [1:2] TV[AGR=[NUM='sg', PER=1], OBJCASE='dat'] -&gt; 'folge' *</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|.   [---&gt;   .   .| [1:2] VP[AGR=?a] -&gt; TV[AGR=?a, OBJCASE=?c] * NP[CASE=?c] {?a: [NUM='sg', PER=1], ?c: 'dat'}</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|.   .   [---]   .| [2:3] Det[AGR=[GND='masc', NUM='sg', PER=3], CASE='acc'] -&gt; 'den' *</span>
<span class="pysrc-output">|.   .   [---]   .| [2:3] Det[AGR=[NUM='pl', PER=3], CASE='dat'] -&gt; 'den' *</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|.   .   [---&gt;   .| [2:3] NP[AGR=?a, CASE=?c] -&gt; Det[AGR=?a, CASE=?c] * N[AGR=?a, CASE=?c] {?a: [NUM='pl', PER=3], ?c: 'dat'}</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|.   .   [---&gt;   .| [2:3] NP[AGR=?a, CASE=?c] -&gt; Det[AGR=?a, CASE=?c] * N[AGR=?a, CASE=?c] {?a: [GND='masc', NUM='sg', PER=3], ?c: 'acc'}</span>
<span class="pysrc-output">Feature Bottom Up Predict Combine Rule:</span>
<span class="pysrc-output">|.   .   .   [---]| [3:4] N[AGR=[GND='fem', NUM='sg', PER=3]] -&gt; 'Katze' *</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The last two <tt class="doctest"><span class="pre">Scanner</span></tt> lines in the trace show that <span class="example">den</span> is recognized as
admitting two possible categories: <tt class="doctest"><span class="pre">Det[AGR=[GND=<span class="pysrc-string">'masc'</span>, NUM=<span class="pysrc-string">'sg'</span>,
PER=3], CASE=<span class="pysrc-string">'acc'</span>]</span></tt> and <tt class="doctest"><span class="pre">Det[AGR=[NUM=<span class="pysrc-string">'pl'</span>, PER=3], CASE=<span class="pysrc-string">'dat'</span>]</span></tt>.
We know from the grammar in <a class="reference internal" href="#code-germancfg">3.2</a> that <tt class="doctest"><span class="pre">Katze</span></tt> has category
<tt class="doctest"><span class="pre">N[AGR=[GND=fem, NUM=sg, PER=3]]</span></tt>. Thus there is no binding for the
variable <tt class="doctest"><span class="pre">?a</span></tt> in production <tt class="doctest"><span class="pre">NP[CASE=?c, AGR=?a] -&gt; Det[CASE=?c,
AGR=?a] N[CASE=?c, AGR=?a]</span></tt> which will satisfy these constraints, since the
<tt class="doctest"><span class="pre">AGR</span></tt> value of <tt class="doctest"><span class="pre">Katze</span></tt> will not unify with either of the <tt class="doctest"><span class="pre">AGR</span></tt>
values of  <span class="example">den</span>, that is, with either <tt class="doctest"><span class="pre">[GND=<span class="pysrc-string">'masc'</span>, NUM=<span class="pysrc-string">'sg'</span>,
PER=3]</span></tt> or <tt class="doctest"><span class="pre">[NUM=<span class="pysrc-string">'pl'</span>, PER=3]</span></tt>.</p>
</div>
</div>
<div class="section" id="summary">
<h1>4&nbsp;&nbsp;&nbsp;Summary</h1>
<ul class="simple">
<li>The traditional categories of context-free grammar are atomic
symbols. An important motivation for feature structures is to capture
fine-grained distinctions that would otherwise require a massive
multiplication of atomic categories.</li>
<li>By using variables over feature values, we can express constraints
in grammar productions that allow the realization of different feature
specifications to be inter-dependent.</li>
<li>Typically we specify fixed values of features at the lexical level
and constrain the values of features in phrases to unify with the
corresponding values in their children.</li>
<li>Feature values are either atomic or complex. A particular sub-case of
atomic value is the Boolean value, represented by convention as
[+/- <tt class="doctest"><span class="pre">f</span></tt>].</li>
<li>Two features can share a value (either atomic or
complex). Structures with shared values are said to be
re-entrant. Shared values are represented by numerical indexes (or
tags) in AVMs.</li>
<li>A path in a feature structure is a tuple of features
corresponding to the labels on  a sequence of arcs from the root of the graph
representation.</li>
<li>Two paths are equivalent if they share a value.</li>
<li>Feature structures are partially ordered by subsumption.
<span class="math">FS</span><sub>0</sub> subsumes <span class="math">FS</span><sub>1</sub> when
all the information contained in
<span class="math">FS</span><sub>0</sub> is also present in
<span class="math">FS</span><sub>1</sub>.</li>
<li>The unification of two structures <span class="math">FS</span><sub>0</sub> and
<span class="math">FS</span><sub>1</sub>, if successful, is the feature
structure <span class="math">FS</span><sub>2</sub> that contains the combined
information of both <span class="math">FS</span><sub>0</sub> and <span class="math">FS</span><sub>1</sub>.</li>
<li>If unification adds information to a path &#960; in <span class="math">FS</span>, then it also
adds information to every path &#960;' equivalent to &#960;.</li>
<li>We can use feature structures to build succinct analyses of a wide
variety of linguistic phenomena, including verb subcategorization,
inversion constructions, unbounded dependency constructions and case government.</li>
</ul>
</div>
<div class="section" id="further-reading">
<span id="sec-featgram-further-reading"></span><h1>5&nbsp;&nbsp;&nbsp;Further Reading</h1>
<p>Please consult <tt class="doctest"><span class="pre">http://nltk.org/</span></tt> for further materials on this chapter, including
feature structures, feature grammars, and grammar test suites.</p>
<p>X-bar Syntax: <a class="reference external" href="bibliography.html#chomsky1970rn" id="id9">(Jacobs &amp; Rosenbaum, 1970)</a>, <a class="reference external" href="bibliography.html#jackendoff1977xs" id="id10">(Jackendoff, 1977)</a>
(The primes we use replace Chomsky's typographically more demanding horizontal bars.)</p>
<p>For an excellent introduction to the phenomenon of agreement, see
<a class="reference external" href="bibliography.html#corbett2006a" id="id11">(Corbett, 2006)</a>.</p>
<p>The earliest use of features in theoretical linguistics was designed
to capture phonological properties of phonemes. For example, a sound
like /<strong>b</strong>/ might be decomposed into the structure <tt class="doctest"><span class="pre">[+labial, +voice]</span></tt>. An important motivation was to capture
generalizations across classes of segments; for example, that /<strong>n</strong>/ gets
realized as /<strong>m</strong>/ preceding any <tt class="doctest"><span class="pre">+labial</span></tt> consonant.
Within Chomskyan grammar, it was standard to use atomic features for
phenomena like agreement, and also to capture generalizations across
syntactic categories, by analogy with phonology.
A radical expansion of the use of features in theoretical syntax was
advocated by Generalized Phrase Structure Grammar (GPSG;
<a class="reference external" href="bibliography.html#gazdar1985gps" id="id12">(Gazdar, Klein, &amp; and, 1985)</a>), particularly in the use of features with complex values.</p>
<p>Coming more from the perspective of computational linguistics,
<a class="reference external" href="bibliography.html#kay1984ug" id="id13">(Dahl &amp; Saint-Dizier, 1985)</a> proposed that functional aspects of language could be
captured by unification of attribute-value structures, and a similar
approach was elaborated by <a class="reference external" href="bibliography.html#shieber1983fip" id="id14">(Grosz &amp; Stickel, 1983)</a> within the PATR-II
formalism. Early work in Lexical-Functional grammar (LFG;
<a class="reference external" href="bibliography.html#kaplan1982lfg" id="id15">(Bresnan, 1982)</a>) introduced the notion of an <a name="f_structure_index_term" /><span class="termdef">f-structure</span> that
was primarily intended to represent the grammatical relations and
predicate-argument structure associated with a constituent structure
parse.  <a class="reference external" href="bibliography.html#shieber1986iub" id="id16">(Shieber, 1986)</a> provides an excellent introduction to this
phase of research into feature based grammars.</p>
<p>One conceptual difficulty with algebraic approaches to feature
structures arose when researchers attempted to model negation. An
alternative perspective, pioneered by <a class="reference external" href="bibliography.html#kasper1986lsf" id="id17">(Kasper &amp; Rounds, 1986)</a> and
<a class="reference external" href="bibliography.html#johnson1988avl" id="id18">(Johnson, 1988)</a>, argues that grammars involve <span class="emphasis">descriptions</span> of
feature structures rather than the structures themselves. These
descriptions are combined using logical operations such as
conjunction, and negation is just the usual logical operation over
feature descriptions. This description-oriented perspective was
integral to LFG from the outset (cf. <a class="reference external" href="bibliography.html#kaplan1989fal" id="id19">(Huang &amp; Chen, 1989)</a>, and was also adopted by later
versions of Head-Driven Phrase Structure Grammar (HPSG;
<a class="reference external" href="bibliography.html#sag1999st" id="id20">(Sag &amp; Wasow, 1999)</a>). A comprehensive bibliography of HPSG literature can be
found at <tt class="doctest"><span class="pre">http://www.cl.uni-bremen.de/HPSG-Bib/</span></tt>.</p>
<p>Feature structures, as presented in this chapter, are unable to
capture important constraints on linguistic information. For example,
there is no way of saying that the only permissible values for
<tt class="doctest"><span class="pre">NUM</span></tt> are <tt class="doctest"><span class="pre">sg</span></tt> and <tt class="doctest"><span class="pre">pl</span></tt>, while a specification such
as <tt class="doctest"><span class="pre">[NUM=masc]</span></tt> is anomalous. Similarly, we cannot say
that the complex value of <tt class="doctest"><span class="pre">AGR</span></tt> <span class="emphasis">must</span> contain
specifications for the features <tt class="doctest"><span class="pre">PER</span></tt>, <tt class="doctest"><span class="pre">NUM</span></tt> and
<tt class="doctest"><span class="pre">gnd</span></tt>, but <span class="emphasis">cannot</span> contain a specification such as
<tt class="doctest"><span class="pre">[SUBCAT=trans]</span></tt>.  <a name="typed_feature_structures_index_term" /><span class="termdef">Typed feature structures</span> were developed to
remedy this deficiency. To begin with, we stipulate that feature
values are always typed. In the case of atomic values, the values just
are types. For example, we would say that the value of <tt class="doctest"><span class="pre">NUM</span></tt> is
the type <tt class="doctest"><span class="pre">num</span></tt>. Moreover, <tt class="doctest"><span class="pre">num</span></tt> is the most general type of value for
<tt class="doctest"><span class="pre">NUM</span></tt>. Since types are organized hierarchically, we can be more
informative by specifying the value of <tt class="doctest"><span class="pre">NUM</span></tt> is a <a name="subtype_index_term" /><span class="termdef">subtype</span>
of <tt class="doctest"><span class="pre">num</span></tt>, namely either <tt class="doctest"><span class="pre">sg</span></tt> or <tt class="doctest"><span class="pre">pl</span></tt>.</p>
<p>In the case of complex values, we say that feature structures are
themselves typed. So for example the value of <tt class="doctest"><span class="pre">AGR</span></tt> will be a
feature structure of type <tt class="doctest"><span class="pre">AGR</span></tt>. We also stipulate that all and only
<tt class="doctest"><span class="pre">PER</span></tt>, <tt class="doctest"><span class="pre">NUM</span></tt> and <tt class="doctest"><span class="pre">GND</span></tt> are <a name="appropriate_index_term" /><span class="termdef">appropriate</span> features for
a structure of type <tt class="doctest"><span class="pre">AGR</span></tt>.  A good early review of work on typed
feature structures is <a class="reference external" href="bibliography.html#emele1990tug" id="id21">(Emele &amp; Zajac, 1990)</a>. A more comprehensive examination of
the formal foundations can be found in <a class="reference external" href="bibliography.html#carpenter1992ltf" id="id22">(Carpenter, 1992)</a>, while
<a class="reference external" href="bibliography.html#copestake2002itf" id="id23">(Copestake, 2002)</a> focuses on implementing an HPSG-oriented approach
to typed feature structures.</p>
<p>There is a copious literature on the analysis of German within
feature based grammar frameworks. <a class="reference external" href="bibliography.html#nerbonne1994ghd" id="id24">(Nerbonne, Netter, &amp; Pollard, 1994)</a> is a good
starting point for the HPSG literature on this topic, while
<a class="reference external" href="bibliography.html#mueller2002cp" id="id25">(M{\&quot;u}ller, 2002)</a> gives a very extensive and detailed analysis of
German syntax in HPSG.</p>
<p>Chapter 15 of <a class="reference external" href="bibliography.html#jurafskymartin2008" id="id26">(Jurafsky &amp; Martin, 2008)</a> discusses feature structures,
the unification algorithm, and the integration of unification into
parsing algorithms.</p>
</div>
<div class="section" id="exercises">
<h1>6&nbsp;&nbsp;&nbsp;Exercises</h1>
<ol class="arabic">
<li><p class="first">&#9788; What constraints are required to correctly parse word sequences like <span class="example">I am
happy</span> and <span class="example">she is happy</span> but not <span class="example">*you is happy</span> or
<span class="example">*they am happy</span>? Implement two solutions for the present tense
paradigm of the verb <span class="example">be</span> in English, first taking Grammar
<a class="reference internal" href="#ex-agcfg1">(6)</a> as your starting point, and then taking Grammar <a class="reference internal" href="#ex-agr2">(18)</a>
as the starting point.</p>
</li>
<li><p class="first">&#9788; Develop a variant of grammar in <a class="reference internal" href="#code-feat0cfg">1.1</a> that uses a
feature <cite>count</cite> to make the distinctions shown below:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(54)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><p>The boy sings.</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><p>*Boy sings.</p>
</td></tr></table></p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(55)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><p>The boys sing.</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><p>Boys sing.</p>
</td></tr></table></p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(56)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><p>The boys sing.</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><p>Boys sing.</p>
</td></tr></table></p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(57)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><p>The water is precious.</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><p>Water is precious.</p>
</td></tr></table></p>
</td></tr></table></p>
</li>
<li><p class="first">&#9788; Write a function <cite>subsumes()</cite> which holds of two feature
structures <tt class="doctest"><span class="pre">fs1</span></tt> and <tt class="doctest"><span class="pre">fs2</span></tt> just in case <tt class="doctest"><span class="pre">fs1</span></tt> subsumes <tt class="doctest"><span class="pre">fs2</span></tt>.</p>
</li>
<li><p class="first">&#9788; Modify the grammar illustrated in <a class="reference internal" href="#ex-subcatgpsg">(28)</a> to
incorporate a <cite>bar</cite> feature for dealing with phrasal projections.</p>
</li>
<li><p class="first">&#9788; Modify the German grammar in <a class="reference internal" href="#code-germancfg">3.2</a> to incorporate the
treatment of subcategorization presented in <a class="reference internal" href="#sec-extending-a-feature-based-grammar">3</a>.</p>
</li>
<li><p class="first">&#9681; Develop a feature based grammar that will correctly describe the following
Spanish noun phrases:</p>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 2028)</p>
<p>Error in &quot;gloss&quot; directive: may contain a single table only.</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 2033)</p>
<p>Error in &quot;gloss&quot; directive: may contain a single table only.</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 2038)</p>
<p>Error in &quot;gloss&quot; directive: may contain a single table only.</p>
</div>
<div class="system-message">
<p class="system-message-title">System Message: ERROR/3 (<tt class="docutils">ch09.rst2</tt>, line 2043)</p>
<p>Error in &quot;gloss&quot; directive: may contain a single table only.</p>
</div>
</li>
<li><p class="first">&#9681; Develop your own version of the <tt class="doctest"><span class="pre">EarleyChartParser</span></tt> which only
prints a trace if the input sequence fails to parse.</p>
</li>
<li><p class="first">&#9681; Consider the feature structures shown in <a class="reference internal" href="#code-featstructures">6.1</a>.</p>
<!-- XX NOTE: This example is somewhat broken - - nltk doesn't support
reentrance for base feature values.  (See email ~7/23/08 to the
nltk-users mailing list for details.)
Now updated to avoid this problem. EK -->
<span class="target" id="code-featstructures"></span><div class="pylisting">
<table border="0" cellpadding="0" cellspacing="0" class="pylisting" width="95%">
<tr><td class="codeblock">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_codeblock_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
fs1 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = ?x, B= [C = ?x]]&quot;</span>)
fs2 = nltk.FeatStruct(<span class="pysrc-string">&quot;[B = [D = d]]&quot;</span>)
fs3 = nltk.FeatStruct(<span class="pysrc-string">&quot;[B = [C = d]]&quot;</span>)
fs4 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = (1)[B = b], C-&gt;(1)]&quot;</span>)
fs5 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = (1)[D = ?x], C = [E -&gt; (1), F = ?x] ]&quot;</span>)
fs6 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = [D = d]]&quot;</span>)
fs7 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = [D = d], C = [F = [D = d]]]&quot;</span>)
fs8 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = (1)[D = ?x, G = ?x], C = [B = ?x, E -&gt; (1)] ]&quot;</span>)
fs9 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = [B = b], C = [E = [G = e]]]&quot;</span>)
fs10 = nltk.FeatStruct(<span class="pysrc-string">&quot;[A = (1)[B = b], C -&gt; (1)]&quot;</span>)</pre>
</td>
</tr></table></td></tr>
<tr><td class="caption"><p class="caption"><a class="reference external" href="pylisting/code_featstructures.py" type="text/x-python"><span class="caption-label">Example 6.1 (code_featstructures.py)</span></a>: <span class="caption-label">Figure 6.1</span>: Exploring Feature Structures</td></tr></p>
</table></div>
<p>Work out on paper what the result is of the following
unifications. (Hint: you might find it useful to draw the graph structures.)</p>
<ol class="arabic simple">
<li><tt class="doctest"><span class="pre">fs1</span></tt> and <tt class="doctest"><span class="pre">fs2</span></tt></li>
<li><tt class="doctest"><span class="pre">fs1</span></tt> and <tt class="doctest"><span class="pre">fs3</span></tt></li>
<li><tt class="doctest"><span class="pre">fs4</span></tt> and <tt class="doctest"><span class="pre">fs5</span></tt></li>
<li><tt class="doctest"><span class="pre">fs5</span></tt> and <tt class="doctest"><span class="pre">fs6</span></tt></li>
<li><tt class="doctest"><span class="pre">fs5</span></tt> and <tt class="doctest"><span class="pre">fs7</span></tt></li>
<li><tt class="doctest"><span class="pre">fs8</span></tt> and <tt class="doctest"><span class="pre">fs9</span></tt></li>
<li><tt class="doctest"><span class="pre">fs8</span></tt> and <tt class="doctest"><span class="pre">fs10</span></tt></li>
</ol>
<p>Check your answers using Python.</p>
</li>
<li><p class="first">&#9681; List two feature structures that subsume [A=?x, B=?x].</p>
</li>
<li><p class="first">&#9681; Ignoring structure sharing, give an informal algorithm for unifying
two feature structures.</p>
</li>
<li><p class="first">&#9681; Extend the German grammar in <a class="reference internal" href="#code-germancfg">3.2</a> so that it can
handle so-called verb-second structures like the following:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(58)</td><td width="15"></td><td><p>Heute sieht der Hund die Katze.</p>
</td></tr></table></p>
</li>
<li><p class="first">&#9681; Seemingly synonymous verbs have slightly different
syntactic properties <a class="reference external" href="bibliography.html#levin1993" id="id27">(Levin, 1993)</a>.  Consider the patterns
of grammaticality for the verbs <span class="example">loaded</span>, <span class="example">filled</span>, and <span class="example">dumped</span>
below.  Can you write grammar productions to handle such data?</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(59)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><p>The farmer <em>loaded</em> the cart with sand</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><p>The farmer <em>loaded</em> sand into the cart</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td><p>The farmer <em>filled</em> the cart with sand</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">d.</td><td width="15"></td><td><p>*The farmer <em>filled</em> sand into the cart</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">e.</td><td width="15"></td><td><p>*The farmer <em>dumped</em> the cart with sand</p>
</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">f.</td><td width="15"></td><td><p>The farmer <em>dumped</em> sand into the cart</p>
</td></tr></table></p>
</td></tr></table></p>
</li>
<li><p class="first">&#9733; Morphological paradigms are rarely completely regular, in
the sense of every cell in the matrix having a different
realization. For example, the present tense conjugation of the
lexeme <span class="lex">walk</span> only has two distinct forms: <span class="example">walks</span> for the
3rd person singular, and <span class="example">walk</span> for all other combinations of
person and number. A successful analysis should not require
redundantly specifying that 5 out of the 6 possible morphological
combinations have the same realization.  Propose and implement a
method for dealing with this.</p>
</li>
<li><p class="first">&#9733; So-called <a name="head_features_index_term" /><span class="termdef">head features</span> are shared between the parent
node and head child. For example, <tt class="doctest"><span class="pre">TENSE</span></tt> is a head feature
that is shared between a <tt class="doctest"><span class="pre">VP</span></tt> and its head <tt class="doctest"><span class="pre">V</span></tt>
child. See <a class="reference external" href="bibliography.html#gazdar1985gps" id="id28">(Gazdar, Klein, &amp; and, 1985)</a> for more details. Most of the
features we have looked at are head features &#8212; exceptions are
<tt class="doctest"><span class="pre">SUBCAT</span></tt> and <tt class="doctest"><span class="pre">SLASH</span></tt>. Since the sharing of head
features is predictable, it should not need to be stated explicitly
in the grammar productions. Develop an approach that automatically
accounts for this regular behavior of head features.</p>
</li>
<li><p class="first">&#9733; Extend NLTK's treatment of feature structures to allow unification into
list-valued features, and use this to implement an HPSG-style analysis of
subcategorization, whereby the <tt class="doctest"><span class="pre">SUBCAT</span></tt> of a head category is the
concatenation its complements' categories with the <tt class="doctest"><span class="pre">SUBCAT</span></tt> value of its
immediate parent.</p>
</li>
<li><p class="first">&#9733; Extend NLTK's treatment of feature structures to allow productions with
underspecified categories, such as <tt class="doctest"><span class="pre">S[-INV] --&gt; ?x S/?x</span></tt>.</p>
</li>
<li><p class="first">&#9733; Extend NLTK's treatment of feature structures to allow typed feature
structures.</p>
</li>
<li><p class="first">&#9733; Pick some grammatical constructions described in <a class="reference external" href="bibliography.html#huddleston2002cge" id="id29">(Huddleston &amp; Pullum, 2002)</a>,
and develop a feature based grammar to account for them.</p>
</li>
</ol>
<!-- Footer to be used in all chapters -->
<div class="admonition admonition-about-this-document">
<p class="first admonition-title">About this document...</p>
<p>UPDATED FOR NLTK 3.0.
This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://stevenbird.net/">Steven Bird</a>, <a class="reference external" href="http://homepages.inf.ed.ac.uk/ewan/">Ewan Klein</a> and <a class="reference external" href="http://ed.loper.org/">Edward Loper</a>,
Copyright &#169; 2019 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://nltk.org/</span></tt>],
Version 3.0, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Wed  4 Sep 2019 11:40:48 ACST</p>
</div>
</div>
</div>
</body>
</html>
