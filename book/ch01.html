<?xml version="1.0" encoding="ascii" ?>

<script language="javascript" type="text/javascript">

function astext(node)
{
    return node.innerHTML.replace(/(<([^>]+)>)/ig,"")
                         .replace(/&gt;/ig, ">")
                         .replace(/&lt;/ig, "<")
                         .replace(/&quot;/ig, '"')
                         .replace(/&amp;/ig, "&");
}

function copy_notify(node, bar_color, data)
{
    // The outer box: relative + inline positioning.
    var box1 = document.createElement("div");
    box1.style.position = "relative";
    box1.style.display = "inline";
    box1.style.top = "2em";
    box1.style.left = "1em";
  
    // A shadow for fun
    var shadow = document.createElement("div");
    shadow.style.position = "absolute";
    shadow.style.left = "-1.3em";
    shadow.style.top = "-1.3em";
    shadow.style.background = "#404040";
    
    // The inner box: absolute positioning.
    var box2 = document.createElement("div");
    box2.style.position = "relative";
    box2.style.border = "1px solid #a0a0a0";
    box2.style.left = "-.2em";
    box2.style.top = "-.2em";
    box2.style.background = "white";
    box2.style.padding = ".3em .4em .3em .4em";
    box2.style.fontStyle = "normal";
    box2.style.background = "#f0e0e0";

    node.insertBefore(box1, node.childNodes.item(0));
    box1.appendChild(shadow);
    shadow.appendChild(box2);
    box2.innerHTML="Copied&nbsp;to&nbsp;the&nbsp;clipboard: " +
                   "<pre class='copy-notify'>"+
                   data+"</pre>";
    setTimeout(function() { node.removeChild(box1); }, 1000);

    var elt = node.parentNode.firstChild;
    elt.style.background = "#ffc0c0";
    setTimeout(function() { elt.style.background = bar_color; }, 200);
}

function copy_codeblock_to_clipboard(node)
{
    var data = astext(node)+"\n";
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#40a060", data);
    }
}

function copy_doctest_to_clipboard(node)
{
    var s = astext(node)+"\n   ";
    var data = "";

    var start = 0;
    var end = s.indexOf("\n");
    while (end >= 0) {
        if (s.substring(start, start+4) == ">>> ") {
            data += s.substring(start+4, end+1);
        }
        else if (s.substring(start, start+4) == "... ") {
            data += s.substring(start+4, end+1);
        }
        /*
        else if (end-start > 1) {
            data += "# " + s.substring(start, end+1);
        }*/
        // Grab the next line.
        start = end+1;
        end = s.indexOf("\n", start);
    }
    
    if (copy_text_to_clipboard(data)) {
        copy_notify(node, "#4060a0", data);
    }
}
    
function copy_text_to_clipboard(data)
{
    if (window.clipboardData) {
        window.clipboardData.setData("Text", data);
        return true;
     }
    else if (window.netscape) {
        // w/ default firefox settings, permission will be denied for this:
        netscape.security.PrivilegeManager
                      .enablePrivilege("UniversalXPConnect");
    
        var clip = Components.classes["@mozilla.org/widget/clipboard;1"]
                      .createInstance(Components.interfaces.nsIClipboard);
        if (!clip) return;
    
        var trans = Components.classes["@mozilla.org/widget/transferable;1"]
                       .createInstance(Components.interfaces.nsITransferable);
        if (!trans) return;
    
        trans.addDataFlavor("text/unicode");
    
        var str = new Object();
        var len = new Object();
    
        var str = Components.classes["@mozilla.org/supports-string;1"]
                     .createInstance(Components.interfaces.nsISupportsString);
        var datacopy=data;
        str.data=datacopy;
        trans.setTransferData("text/unicode",str,datacopy.length*2);
        var clipid=Components.interfaces.nsIClipboard;
    
        if (!clip) return false;
    
        clip.setData(trans,null,clipid.kGlobalClipboard);
        return true;
    }
    return false;
}
//-->
</script>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ascii" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: Edward Loper, James Curran
:Copyright: This stylesheet has been placed in the public domain.

Stylesheet for use with Docutils.

This stylesheet defines new css classes used by NLTK.

It uses a Python syntax highlighting scheme that matches
the colour scheme used by IDLE, which makes it easier for
beginners to check they are typing things in correctly.
*/

/* Include the standard docutils stylesheet. */
@import url(default.css);

/* Custom inline roles */
span.placeholder    { font-style: italic; font-family: monospace; }
span.example        { font-style: italic; }
span.emphasis       { font-style: italic; }
span.termdef        { font-weight: bold; }
/*span.term           { font-style: italic; }*/
span.category       { font-variant: small-caps; }
span.feature        { font-variant: small-caps; }
span.fval           { font-style: italic; }
span.math           { font-style: italic; }
span.mathit         { font-style: italic; }
span.lex            { font-variant: small-caps; }
span.guide-linecount{ text-align: right; display: block;}

/* Python souce code listings */
span.pysrc-prompt   { color: #9b0000; }
span.pysrc-more     { color: #9b00ff; }
span.pysrc-keyword  { color: #e06000; }
span.pysrc-builtin  { color: #940094; }
span.pysrc-string   { color: #00aa00; }
span.pysrc-comment  { color: #ff0000; }
span.pysrc-output   { color: #0000ff; }
span.pysrc-except   { color: #ff0000; }
span.pysrc-defname  { color: #008080; }


/* Doctest blocks */
pre.doctest         { margin: 0; padding: 0; font-weight: bold; }
div.doctest         { margin: 0 1em 1em 1em; padding: 0; }
table.doctest       { margin: 0; padding: 0;
                      border-top: 1px solid gray;
                      border-bottom: 1px solid gray; }
pre.copy-notify     { margin: 0; padding: 0.2em; font-weight: bold;
                      background-color: #ffffff; }

/* Python source listings */
div.pylisting       { margin: 0 1em 1em 1em; padding: 0; }
table.pylisting     { margin: 0; padding: 0;
                      border-top: 1px solid gray; }
td.caption { border-top: 1px solid black; margin: 0; padding: 0; }
.caption-label { font-weight: bold;  }
td.caption p { margin: 0; padding: 0; font-style: normal;}

table tr td.codeblock { 
  padding: 0.2em ! important; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeffee;
}

table tr td.doctest  { 
  padding: 0.2em; margin: 0;
  border-left: 1px solid gray;
  border-right: 2px solid gray;
  border-top: 0px solid gray;
  border-bottom: 1px solid gray;
  font-weight: bold; background-color: #eeeeff;
}

td.codeblock table tr td.copybar {
    background: #40a060; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }
td.doctest table tr td.copybar {
    background: #4060a0; border: 1px solid gray;
    font-family: monospace; padding: 0; margin: 0; }

td.pysrc { padding-left: 0.5em; }

img.callout { border-width: 0px; }

table.docutils {
    border-style: solid;
    border-width: 1px;
    margin-top: 6px;
    border-color: grey;
    border-collapse: collapse; }

table.docutils th {
    border-style: none;
    border-width: 1px;
    border-color: grey;
    padding: 0 .5em 0 .5em; }

table.docutils td {
    border-style: none;
    border-width: 1px;
    border-color: grey; 
    padding: 0 .5em 0 .5em; }

table.footnote td { padding: 0; }
table.footnote { border-width: 0; }
table.footnote td { border-width: 0; }
table.footnote th { border-width: 0; }

table.noborder { border-width: 0; }

table.example pre { margin-top: 4px; margin-bottom: 0; }

/* For figures & tables */
p.caption { margin-bottom: 0; }
div.figure { text-align: center; }

/* The index */
div.index { border: 1px solid black;
            background-color: #eeeeee; }
div.index h1 { padding-left: 0.5em; margin-top: 0.5ex;
               border-bottom: 1px solid black; }
ul.index { margin-left: 0.5em; padding-left: 0; }
li.index { list-style-type: none; }
p.index-heading { font-size: 120%; font-style: italic; margin: 0; }
li.index ul { margin-left: 2em; padding-left: 0; }

/* 'Note' callouts */
div.note
{
  border-right:   #87ceeb 1px solid;
  padding-right: 4px;
  border-top: #87ceeb 1px solid;
  padding-left: 4px;
  padding-bottom: 4px;
  margin: 2px 5% 10px;
  border-left: #87ceeb 1px solid;
  padding-top: 4px;
  border-bottom: #87ceeb 1px solid;
  font-style: normal;
  font-family: verdana, arial;
  background-color: #b0c4de;
}

table.avm { border: 0px solid black; width: 0; }
table.avm tbody tr {border: 0px solid black; }
table.avm tbody tr td { padding: 2px; }
table.avm tbody tr td.avm-key { padding: 5px; font-variant: small-caps; }
table.avm tbody tr td.avm-eq { padding: 5px; }
table.avm tbody tr td.avm-val { padding: 5px; font-style: italic; }
p.avm-empty { font-style: normal; }
table.avm colgroup col { border: 0px solid black; }
table.avm tbody tr td.avm-topleft 
    { border-left: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botleft 
    { border-left: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-topright
    { border-right: 2px solid #000080; border-top: 2px solid #000080; }
table.avm tbody tr td.avm-botright
    { border-right: 2px solid #000080; border-bottom: 2px solid #000080; }
table.avm tbody tr td.avm-left
    { border-left: 2px solid #000080; }
table.avm tbody tr td.avm-right
    { border-right: 2px solid #000080; }
table.avm tbody tr td.avm-topbotleft
    { border: 2px solid #000080; border-right: 0px solid black; }
table.avm tbody tr td.avm-topbotright
    { border: 2px solid #000080; border-left: 0px solid black; }
table.avm tbody tr td.avm-ident
    { font-size: 80%; padding: 0; padding-left: 2px; vertical-align: top; }
.avm-pointer
{ border: 1px solid #008000; padding: 1px; color: #008000; 
  background: #c0ffc0; font-style: normal; }

table.gloss { border: 0px solid black; width: 0; }
table.gloss tbody tr { border: 0px solid black; }
table.gloss tbody tr td { border: 0px solid black; }
table.gloss colgroup col { border: 0px solid black; }
table.gloss p { margin: 0; padding: 0; }

table.rst-example { border: 1px solid black; }
table.rst-example tbody tr td { background: #eeeeee; }
table.rst-example thead tr th { background: #c0ffff; }
td.rst-raw { width: 0; }

/* Used by nltk.org/doc/test: */
div.doctest-list { text-align: center; }
table.doctest-list { border: 1px solid black;
  margin-left: auto; margin-right: auto;
}
table.doctest-list tbody tr td { background: #eeeeee;
  border: 1px solid #cccccc; text-align: left; }
table.doctest-list thead tr th { background: #304050; color: #ffffff;
  border: 1px solid #000000;}
table.doctest-list thead tr a { color: #ffffff; }
span.doctest-passed { color: #008000; }
span.doctest-failed { color: #800000; }

</style>
</head>
<body>
<div class="document">


<!-- -*- mode: rst -*- -->
<!-- -*- mode: rst -*- -->
<div class="compound">
<!-- CAP abbreviations (map to small caps in LaTeX) -->
<!-- Other candidates for global consistency -->
<!-- PTB removed since it must be indexed -->
<!-- WN removed since it must be indexed -->
<!-- misc & punctuation -->
<!-- cdots was unicode U+22EF but not working -->
<!-- exercise meta-tags -->
<!-- Unicode tests -->
<!-- phonetic -->
<!-- misc -->
<!-- used in Unicode section -->
<!-- arrows -->
<!-- unification stuff -->
<!-- Math & Logic -->
<!-- sets -->
<!-- Greek -->
<!-- Chinese -->
<!-- URLs -->
<!-- Python example - a snippet of code in running text -->
<!-- PlaceHolder example -  something that should be replaced by actual code -->
<!-- Linguistic eXample - cited form in running text -->
<!-- Emphasized (more declarative than just using *) -->
<!-- Grammatical Category - e.g. NP and verb as technical terms
.. role:: gc
   :class: category -->
<!-- Math expression - e.g. especially for variables -->
<!-- Textual Math expression - for words 'inside' a math environment -->
<!-- Feature (or attribute) -->
<!-- Raw LaTeX -->
<!-- Raw HTML -->
<!-- Feature-value -->
<!-- Lexemes -->
<!-- Replacements that rely on previous definitions :-) -->
</div>
<!-- TODO: update cspy reference to more recent book -->
<!-- TODO: add some literature references (esp to other intro linguistics textbooks) -->
<!-- TODO: adopt simpler hacker example with only single character transpositions;
move hacker example to later section (later chapter?) -->
<!-- TODO: get URL hyperlinks to be fixed width -->
<!-- TODO: websites with automatically generated language - - lobner prize... -->
<div class="section" id="language-processing-and-python">
<span id="chap-introduction"></span><h1>1&nbsp;&nbsp;&nbsp;Language Processing and Python</h1>
<p>It is easy to get our hands on millions of words of text.
What can we do with it, assuming we can write some simple programs?
In this chapter we'll address the following questions:</p>
<ol class="arabic simple">
<li>What can we achieve by combining simple programming techniques with large quantities of text?</li>
<li>How can we automatically extract key words and phrases that sum up the style and content of a text?</li>
<li>What tools and techniques does the Python programming language provide for such work?</li>
<li>What are some of the interesting challenges of natural language processing?</li>
</ol>
<p>This chapter is divided into sections that skip between two quite
different styles.  In the &quot;computing with language&quot; sections we will
take on some linguistically motivated programming tasks without necessarily
explaining how they work.  In the &quot;closer look at Python&quot; sections we
will systematically review key programming concepts.  We'll flag the two styles in the section titles,
but later chapters will mix both styles without being so up-front about it.
We hope this style of introduction gives you an
authentic taste of what will come later, while covering a range of
elementary concepts in linguistics and computer science.
If you have basic familiarity with both areas, you can skip to
<a class="reference internal" href="#sec-automatic-natural-language-understanding">1.5</a>;
we will repeat any important points in later chapters, and if you miss anything
you can easily consult the online reference material at <tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>.
If the material is completely new to you, this chapter will raise
more questions than it answers, questions that are addressed in
the rest of this book.</p>
<div class="section" id="computing-with-language-texts-and-words">
<span id="sec-computing-with-language-texts-and-words"></span><h2>1.1&nbsp;&nbsp;&nbsp;Computing with Language: Texts and Words</h2>
<p>We're all very familiar with text, since we read and write it every day.
Here we will treat text as <span class="emphasis">raw data</span> for the programs we write,
programs that manipulate and analyze it in a variety of interesting ways.
But before we can do this, we have to get started with the Python interpreter.</p>
<div class="section" id="getting-started-with-python">
<h3>Getting Started with Python</h3>
<p>One of the friendly things about Python is that it allows you
to type directly into the interactive <a name="interpreter_index_term" /><span class="termdef">interpreter</span> &#8212;
the program that will be running your Python programs.
You can access the Python interpreter using a simple graphical interface
called the Interactive DeveLopment Environment (IDLE).
On a Mac you can find this under <em>Applications</em>&#8594;<em>MacPython</em>,
and on Windows under <em>All Programs</em>&#8594;<em>Python</em>.
Under Unix you can run Python from the shell by typing <tt class="doctest"><span class="pre">idle</span></tt>
(if this is not installed, try typing <tt class="doctest"><span class="pre">python</span></tt>).
The interpreter will print a blurb about your Python version;
simply check that you are running Python 2.4 or 2.5 (here it is 2.5.1):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
Python 2.5.1 (r251:54863, Apr 15 2008, 22:57:26)
[GCC 4.0.1 (Apple Inc. build 5465)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">If you are unable to run the Python interpreter, you probably don't
have Python installed correctly.  Please visit <tt class="doctest"><span class="pre">http://python.org/</span></tt> for
detailed instructions.</p>
</div>
<p>The <tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> prompt indicates that the Python interpreter is now waiting
for input.  When copying examples from this book, don't type
the &quot;<tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt>&quot; yourself.  Now, let's begin by using Python as a calculator:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>1 + 5 * 2 - 3
<span class="pysrc-output">8</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Once the interpreter has finished calculating the answer and displaying it, the
prompt reappears. This means the Python interpreter is waiting for another instruction.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Enter a few more expressions of your own. You can use asterisk (<tt class="doctest"><span class="pre">*</span></tt>)
for multiplication and slash (<tt class="doctest"><span class="pre">/</span></tt>) for division, and parentheses for
bracketing expressions.  Note that division doesn't always behave
as you might expect &#8212; it does integer division (with rounding
of fractions downwards) when you type
<tt class="doctest"><span class="pre">1/3</span></tt> and &quot;floating point&quot; (or decimal) division when you type <tt class="doctest"><span class="pre">1.0/3.0</span></tt>.
In order to get the expected behavior of division (standard in Python 3.0),
you need to type: <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> __future__ <span class="pysrc-keyword">import</span> division</span></tt></p>
</div>
<!-- XXX The following example currently wraps over a page boundary, which
makes it difficult to read, esp since you can't see where the "^" is
pointing. -->
<p>The preceding examples demonstrate how you can work interactively with the
Python interpreter, experimenting with various expressions in the language
to see what they do.
Now let's try a nonsensical expression to see how the interpreter handles it:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>1 +
<span class="pysrc-output">  File &quot;&lt;stdin&gt;&quot;, line 1</span>
<span class="pysrc-output">    1 +</span>
<span class="pysrc-output">      ^</span>
<span class="pysrc-output">SyntaxError: invalid syntax</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This produced a <a name="syntax_error_index_term" /><span class="termdef">syntax error</span>.  In Python, it doesn't make sense
to end an instruction with a plus sign. The Python interpreter
indicates the line where the problem occurred (line 1 of <tt class="doctest"><span class="pre">&lt;stdin&gt;</span></tt>,
which stands for &quot;standard input&quot;).</p>
<p>Now that we can use the Python interpreter, we're ready to start working
with language data.</p>
</div>
<div class="section" id="getting-started-with-nltk">
<h3>Getting Started with NLTK</h3>
<p>Before going further you should install NLTK, downloadable for free from <tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>.
Follow the instructions there to download the version required for your platform.</p>
<p>Once you've installed NLTK, start up the Python interpreter as
before, and install the data required for the book by
typing the following two commands at the Python prompt, then selecting
the <tt class="doctest"><span class="pre">book</span></tt> collection as shown in <a class="reference internal" href="#fig-nltk-downloader">1.1</a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">import</span> nltk
<span class="pysrc-prompt">&gt;&gt;&gt; </span>nltk.download()</pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-nltk-downloader"></span><div class="figure" id="fig-nltk-downloader">
<img alt="../images/nltk-downloader.png" src="../images/nltk-downloader.png" style="width: 668.0px; height: 276.0px;" />
<p class="caption"><span class="caption-label">Figure 1.1</span>: Downloading the NLTK Book Collection: browse the available packages
using <tt class="doctest"><span class="pre">nltk.download()</span></tt>.  The <strong>Collections</strong> tab on the downloader
shows how the packages are grouped into sets, and you should select the line labeled
<strong>book</strong> to obtain all
data required for the examples and exercises in this book.  It consists
of about 30 compressed files requiring about 100Mb disk space.
The full collection of data (i.e., <strong>all</strong> in the downloader) is
about five times this size (at the time
of writing) and continues to expand.</p>
</div>
<p>Once the data is downloaded to your machine, you can load some of it
using the Python interpreter.
The first step is to type a special command at the
Python prompt which tells the interpreter to load some texts for us to
explore: <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> nltk.book <span class="pysrc-keyword">import</span> *</span></tt>.
This says &quot;from NLTK's <tt class="doctest"><span class="pre">book</span></tt> module, load
all items.&quot;  The <tt class="doctest"><span class="pre">book</span></tt> module contains all the data you will need
as you read this chapter.  After printing a welcome message, it loads
the text of several books (this will take a few seconds).  Here's the
command again, together with the output that
you will see.  Take care to get spelling and punctuation right, and
remember that you don't type the <tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> nltk.book <span class="pysrc-keyword">import</span> *
<span class="pysrc-output">*** Introductory Examples for the NLTK Book ***</span>
<span class="pysrc-output">Loading text1, ..., text9 and sent1, ..., sent9</span>
<span class="pysrc-output">Type the name of the text or sentence to view it.</span>
<span class="pysrc-output">Type: 'texts()' or 'sents()' to list the materials.</span>
<span class="pysrc-output">text1: Moby Dick by Herman Melville 1851</span>
<span class="pysrc-output">text2: Sense and Sensibility by Jane Austen 1811</span>
<span class="pysrc-output">text3: The Book of Genesis</span>
<span class="pysrc-output">text4: Inaugural Address Corpus</span>
<span class="pysrc-output">text5: Chat Corpus</span>
<span class="pysrc-output">text6: Monty Python and the Holy Grail</span>
<span class="pysrc-output">text7: Wall Street Journal</span>
<span class="pysrc-output">text8: Personals Corpus</span>
<span class="pysrc-output">text9: The Man Who Was Thursday by G . K . Chesterton 1908</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Any time we want to find out about these texts, we just have
to enter their names at the Python prompt:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text1
<span class="pysrc-output">&lt;Text: Moby Dick by Herman Melville 1851&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>text2
<span class="pysrc-output">&lt;Text: Sense and Sensibility by Jane Austen 1811&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now that we can use the Python interpreter, and have some data to work with,
we're ready to get started.</p>
</div>
<div class="section" id="searching-text">
<h3>Searching Text</h3>
<p>There are many ways to examine the context of a text apart from
simply reading it.  A concordance view shows us every occurrence of a given word, together
with some context.  Here we look up the word <span class="example">monstrous</span> in <em>Moby
Dick</em> by entering <tt class="doctest"><span class="pre">text1</span></tt> followed by a period, then the term
<tt class="doctest"><span class="pre">concordance</span></tt>, and then placing <tt class="doctest"><span class="pre"><span class="pysrc-string">&quot;monstrous&quot;</span></span></tt> in parentheses:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text1.concordance(<span class="pysrc-string">&quot;monstrous&quot;</span>)
<span class="pysrc-output">Building index...</span>
<span class="pysrc-output">Displaying 11 of 11 matches:</span>
<span class="pysrc-output">ong the former , one was of a most monstrous size . ... This came towards us ,</span>
<span class="pysrc-output">ON OF THE PSALMS . &quot; Touching that monstrous bulk of the whale or ork we have r</span>
<span class="pysrc-output">ll over with a heathenish array of monstrous clubs and spears . Some were thick</span>
<span class="pysrc-output">d as you gazed , and wondered what monstrous cannibal and savage could ever hav</span>
<span class="pysrc-output">that has survived the flood ; most monstrous and most mountainous ! That Himmal</span>
<span class="pysrc-output">they might scout at Moby Dick as a monstrous fable , or still worse and more de</span>
<span class="pysrc-output">th of Radney .'&quot; CHAPTER 55 Of the monstrous Pictures of Whales . I shall ere l</span>
<span class="pysrc-output">ing Scenes . In connexion with the monstrous pictures of whales , I am strongly</span>
<span class="pysrc-output">ere to enter upon those still more monstrous stories of them which are to be fo</span>
<span class="pysrc-output">ght have been rummaged out of this monstrous cabinet there is no telling . But</span>
<span class="pysrc-output">of Whale - Bones ; for Whales of a monstrous size are oftentimes cast up dead u</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try searching for other words; to save re-typing, you might be able to
use up-arrow, Ctrl-up-arrow or Alt-p to access the previous command and modify the word being searched.
You can also try searches on some of the other texts we have included.
For example, search <em>Sense and Sensibility</em> for the word
<span class="example">affection</span>, using <tt class="doctest"><span class="pre">text2.concordance(<span class="pysrc-string">&quot;affection&quot;</span>)</span></tt>.  Search the book of Genesis
to find out how long some people lived, using
<tt class="doctest"><span class="pre">text3.concordance(<span class="pysrc-string">&quot;lived&quot;</span>)</span></tt>.  You could look at <tt class="doctest"><span class="pre">text4</span></tt>, the
<em>Inaugural Address Corpus</em>, to see examples of English going
back to 1789, and search for words like <span class="example">nation</span>, <span class="example">terror</span>, <span class="example">god</span>
to see how these words have been used differently over time.
We've also included <tt class="doctest"><span class="pre">text5</span></tt>, the <em>NPS Chat Corpus</em>: search this for
unconventional words like <span class="example">im</span>, <span class="example">ur</span>, <span class="example">lol</span>.
(Note that this corpus is uncensored!)</p>
</div>
<p>Once you've spent a little while examining these texts, we hope you have a new
sense of the richness and diversity of language.  In the next chapter
you will learn how to access a broader range of text, including text in
languages other than English.</p>
<p>A concordance permits us to see words in context.  For example, we saw that
<span class="example">monstrous</span> occurred in contexts such as <span class="example">the ___ pictures</span>
and <span class="example">the ___ size</span> .  What other words appear in a similar range
of contexts?  We can find out
by appending the term <tt class="doctest"><span class="pre">similar</span></tt> to the name of the text in
question, then inserting the relevant word in parentheses:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text1.similar(<span class="pysrc-string">&quot;monstrous&quot;</span>)
<span class="pysrc-output">Building word-context index...</span>
<span class="pysrc-output">subtly impalpable pitiable curious imperial perilous trustworthy</span>
<span class="pysrc-output">abundant untoward singular lamentable few maddens horrible loving lazy</span>
<span class="pysrc-output">mystifying christian exasperate puzzled</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>text2.similar(<span class="pysrc-string">&quot;monstrous&quot;</span>)
<span class="pysrc-output">Building word-context index...</span>
<span class="pysrc-output">very exceedingly so heartily a great good amazingly as sweet</span>
<span class="pysrc-output">remarkably extremely vast</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Observe that we get different results for different texts.
Austen uses this word quite differently from Melville; for her, <span class="example">monstrous</span> has
positive connotations, and sometimes functions as an intensifier like the word
<span class="example">very</span>.</p>
<p>The term <tt class="doctest"><span class="pre">common_contexts</span></tt> allows us to examine just the
contexts that are shared by two or more words, such as <span class="example">monstrous</span>
and <span class="example">very</span>. We have to enclose these words by square brackets as
well as parentheses, and separate them with a comma:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text2.common_contexts([<span class="pysrc-string">&quot;monstrous&quot;</span>, <span class="pysrc-string">&quot;very&quot;</span>])
<span class="pysrc-output">be_glad am_glad a_pretty is_pretty a_lucky</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Pick another pair of words and compare their usage in two different texts, using
the <tt class="doctest"><span class="pre">similar()</span></tt> and <tt class="doctest"><span class="pre">common_contexts()</span></tt> functions.</p>
</div>
<p>It is one thing to automatically detect that a particular word occurs in a text,
and to display some words that appear in the same context.  However, we can also determine
the <em>location</em> of a word in the text: how many words from the beginning it appears.
This positional information can be displayed using a <a name="dispersion_plot_index_term" /><span class="termdef">dispersion plot</span>.
Each stripe represents an instance
of a word, and each row represents the entire text.  In <a class="reference internal" href="#fig-inaugural">1.2</a> we
see some striking patterns of word usage over the last 220 years
(in an artificial text constructed by joining
the texts of the Inaugural Address Corpus end-to-end).
You can produce this plot as shown below.
You might like to try more words (e.g., <span class="example">liberty</span>, <span class="example">constitution</span>),
and different texts.  Can you predict the
dispersion of a word before you view it?  As before, take
care to get the quotes, commas, brackets and parentheses exactly right.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text4.dispersion_plot([<span class="pysrc-string">&quot;citizens&quot;</span>, <span class="pysrc-string">&quot;democracy&quot;</span>, <span class="pysrc-string">&quot;freedom&quot;</span>, <span class="pysrc-string">&quot;duties&quot;</span>, <span class="pysrc-string">&quot;America&quot;</span>])
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<span class="target" id="fig-inaugural"></span><div class="figure" id="fig-inaugural">
<img alt="../images/inaugural.png" src="../images/inaugural.png" style="width: 738.0px; height: 324.0px;" />
<p class="caption"><span class="caption-label">Figure 1.2</span>: Lexical Dispersion Plot for Words in U.S. Presidential Inaugural Addresses:
This can be used to investigate changes in language use over time.</p>
</div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Important:</strong>
You need to have Python's NumPy and Matplotlib packages installed
in order to produce the graphical plots used in this book.
Please see <tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt> for installation instructions.</p>
</div>
<p>Now, just for fun, let's try generating some random text in the various
styles we have just seen.  To do this, we type the name of the text
followed by the term <tt class="doctest"><span class="pre">generate</span></tt>. (We need to include the
parentheses, but there's nothing that goes between them.)</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text3.generate()
<span class="pysrc-output">In the beginning of his brother is a hairy man , whose top may reach</span>
<span class="pysrc-output">unto heaven ; and ye shall sow the land of Egypt there was no bread in</span>
<span class="pysrc-output">all that he was taken out of the month , upon the earth . So shall thy</span>
<span class="pysrc-output">wages be ? And they made their father ; and Isaac was old , and kissed</span>
<span class="pysrc-output">him : and Laban with his cattle in the midst of the hands of Esau thy</span>
<span class="pysrc-output">first born , and Phichol the chief butler unto his son Isaac , she</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Note that the first time you run this command, it is slow because it gathers statistics
about word sequences.  Each time you run it, you will get different output text.
Now try generating random text in the style of an inaugural address or an
Internet chat room.  Although the text is random, it re-uses common words and
phrases from the source text and gives us a sense of its style and content.
(What is lacking in this randomly generated text?)</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">When <tt class="doctest"><span class="pre">generate</span></tt> produces its output, punctuation is split off
from the preceding word.  While this is not correct formatting
for English text, we do it to make clear that words and
punctuation are independent of one another. You will learn
more about this in <a class="reference external" href="ch03.html#chap-words">3</a>.</p>
</div>
</div>
<div class="section" id="counting-vocabulary">
<h3>Counting Vocabulary</h3>
<p>The most obvious fact about texts that emerges from the preceding examples is that
they differ in the vocabulary they use.  In this section we will see how to use the
computer to count the words in a text in a variety of useful ways.
As before, you will jump right in and experiment with
the Python interpreter, even though you may not have studied Python systematically
yet.  Test your understanding by modifying the examples, and trying the
exercises at the end of the chapter.</p>
<p>Let's begin by finding out the length of a text from start to finish,
in terms of the words and punctuation symbols that appear.  We use the
term <tt class="doctest"><span class="pre">len</span></tt> to get the length of something, which we'll apply here to the
book of Genesis:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(text3)
<span class="pysrc-output">44764</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>So Genesis has 44,764 words and punctuation symbols, or &quot;tokens.&quot;
A <a name="token_index_term" /><span class="termdef">token</span> is the technical name for a sequence of characters
&#8212; such as <tt class="doctest"><span class="pre">hairy</span></tt>, <tt class="doctest"><span class="pre">his</span></tt>, or <tt class="doctest"><span class="pre">:)</span></tt> &#8212; that we want to treat as a
group. When we count the number of tokens in a text, say, the phrase
<span class="example">to be or not to be</span>, we are counting occurrences of these
sequences. Thus, in our example phrase there are two occurrences of <span class="example">to</span>,
two of <span class="example">be</span>, and one each of <span class="example">or</span> and <span class="example">not</span>. But there are
only four distinct vocabulary items in this phrase.
How many distinct words does the book of Genesis contain?
To work this out in Python, we have to pose the question slightly
differently.  The vocabulary of a text is just the <em>set</em> of tokens
that it uses, since in a set, all duplicates are collapsed
together. In Python we can obtain the vocabulary items of <tt class="doctest"><span class="pre">text3</span></tt> with the
command: <tt class="doctest"><span class="pre">set(text3)</span></tt>.  When you do this, many screens of words will
fly past.  Now try the following:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(set(text3)) <a name="sorted-set" /><a href="#ref-sorted-set"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['!', &quot;'&quot;, '(', ')', ',', ',)', '.', '.)', ':', ';', ';)', '?', '?)',</span>
<span class="pysrc-output">'A', 'Abel', 'Abelmizraim', 'Abidah', 'Abide', 'Abimael', 'Abimelech',</span>
<span class="pysrc-output">'Abr', 'Abrah', 'Abraham', 'Abram', 'Accad', 'Achbor', 'Adah', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(text3)) <a name="len-set" /><a href="#ref-len-set"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">2789</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>By wrapping <tt class="doctest"><span class="pre">sorted()</span></tt> around the Python expression <tt class="doctest"><span class="pre">set(text3)</span></tt>
<a class="reference internal" href="#sorted-set"><span id="ref-sorted-set"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,  we obtain a sorted list of vocabulary items, beginning
with various punctuation symbols and continuing with words starting with <span class="example">A</span>.  All
capitalized words precede lowercase words.
We discover the size of the vocabulary indirectly, by asking
for the number of items in the set, and again we can use <tt class="doctest"><span class="pre">len</span></tt> to
obtain this number <a class="reference internal" href="#len-set"><span id="ref-len-set"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.  Although it has 44,764 tokens, this book
has only 2,789 distinct words, or &quot;word types.&quot;
A <a name="word_type_index_term" /><span class="termdef">word type</span> is the form or spelling of the word independently of its
specific occurrences in a text &#8212; that is, the
word considered as a unique item of vocabulary.  Our count of 2,789 items
will include punctuation symbols, so we will generally call these
unique items <a name="types_index_term" /><span class="termdef">types</span> instead of word types.</p>
<p>Now, let's calculate a measure of the lexical
richness of the text.  The next example shows us that each word is used 16 times on average
(we need to make sure Python uses floating point division):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">from</span> __future__ <span class="pysrc-keyword">import</span> division
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(text3) / len(set(text3))
<span class="pysrc-output">16.050197203298673</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Next, let's focus on particular words.  We can count how often a word occurs
in a text, and compute what percentage of the text is taken up by a specific word:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text3.count(<span class="pysrc-string">&quot;smote&quot;</span>)
<span class="pysrc-output">5</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>100 * text4.count(<span class="pysrc-string">'a'</span>) / len(text4)
<span class="pysrc-output">1.4643016433938312</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
How many times does the word <span class="example">lol</span> appear in <tt class="doctest"><span class="pre">text5</span></tt>?
How much is this as a percentage of the total number of words
in this text?</p>
</div>
<p>You may want to repeat such calculations on several texts,
but it is tedious to keep retyping the formula.  Instead,
you can come up with your own name for a task, like
&quot;lexical_diversity&quot; or &quot;percentage&quot;, and associate it with a block of code.
Now you only have to type a short
name instead of one or more complete lines of Python code, and
you can re-use it as often as we like. The block of code that does a
task for us is called a <a name="function_index_term" /><span class="termdef">function</span>, and
we define a short name for our function with the keyword <tt class="doctest"><span class="pre">def</span></tt>. The
next example shows how to define two new functions,
<tt class="doctest"><span class="pre">lexical_diversity()</span></tt> and   <tt class="doctest"><span class="pre">percentage()</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">lexical_diversity</span>(text): <a name="fun-parameter1" /><a href="#ref-fun-parameter1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-more">... </span>    return len(text) / len(set(text)) <a name="locvar" /><a href="#ref-locvar"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">def</span> <span class="pysrc-defname">percentage</span>(count, total): <a name="fun-parameter2" /><a href="#ref-fun-parameter2"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-more">... </span>    return 100 * count / total
<span class="pysrc-more">...</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">The Python interpreter changes the prompt from
<tt class="doctest"><span class="pre"><span class="pysrc-prompt">&gt;&gt;&gt;</span></span></tt> to <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> after encountering the colon at the
end of the first line.  The <tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt> prompt indicates
that Python expects an <a name="indented_code_block_index_term" /><span class="termdef">indented code block</span> to appear next.
It is up to you to do the indentation, by typing four
spaces or hitting the tab key.  To finish the indented block just
enter a blank line.</p>
</div>
<p>In the definition of <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> <a class="reference internal" href="#fun-parameter1"><span id="ref-fun-parameter1"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, we
specify a <a name="parameter_index_term" /><span class="termdef">parameter</span> labeled <tt class="doctest"><span class="pre">text</span></tt> . This parameter is
a &quot;placeholder&quot; for the actual text whose lexical diversity we want to
compute, and reoccurs in the block of code that will run when the
function is used <a class="reference internal" href="#locvar"><span id="ref-locvar"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>. Similarly, <tt class="doctest"><span class="pre">percentage()</span></tt> is defined to
take two parameters, labeled <tt class="doctest"><span class="pre">count</span></tt> and <tt class="doctest"><span class="pre">total</span></tt> <a class="reference internal" href="#fun-parameter2"><span id="ref-fun-parameter2"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<p>Once Python knows that <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> and <tt class="doctest"><span class="pre">percentage()</span></tt>
are the names for specific blocks
of code, we can go ahead and use these functions:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>lexical_diversity(text3)
<span class="pysrc-output">16.050197203298673</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>lexical_diversity(text5)
<span class="pysrc-output">7.4200461589185629</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>percentage(4, 5)
<span class="pysrc-output">80.0</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>percentage(text4.count(<span class="pysrc-string">'a'</span>), len(text4))
<span class="pysrc-output">1.4643016433938312</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>To recap, we use or <a name="call_index_term" /><span class="termdef">call</span> a function such as <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> by typing its name, followed
by an open parenthesis, the name of the text, and then a close
parenthesis. These parentheses will show up often; their role is to separate
the name of a task &#8212; such as <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> &#8212; from the data
that the task is to be performed on &#8212; such as <tt class="doctest"><span class="pre">text3</span></tt>.
The data value that we place in the parentheses when we call a
function is an <a name="argument_index_term" /><span class="termdef">argument</span> to the function.</p>
<p>You have already encountered several functions in this chapter, such
as <tt class="doctest"><span class="pre">len()</span></tt>, <tt class="doctest"><span class="pre">set()</span></tt>, and <tt class="doctest"><span class="pre">sorted()</span></tt>. By convention, we will
always add an empty pair of parentheses after a function name, as in
<tt class="doctest"><span class="pre">len()</span></tt>, just to make clear that what we are talking about is a
function rather than some other kind of Python expression.
Functions are an important concept in programming, and we only
mention them at the outset to give newcomers a sense of the
power and creativity of programming.  Don't worry if you find it a bit
confusing right now.</p>
<p>Later we'll see how to use functions when tabulating data, as in <a class="reference internal" href="#tab-brown-types">1.1</a>.
Each row of the table will involve the same computation but
with different data, and we'll do this repetitive work using a function.</p>
<span class="target" id="tab-brown-types"></span><table border="1" class="docutils" id="tab-brown-types">
<colgroup>
<col width="39%" />
<col width="13%" />
<col width="11%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Genre</th>
<th class="head">Tokens</th>
<th class="head">Types</th>
<th class="head">Lexical diversity</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>skill and hobbies</td>
<td>82345</td>
<td>11935</td>
<td>6.9</td>
</tr>
<tr><td>humor</td>
<td>21695</td>
<td>5017</td>
<td>4.3</td>
</tr>
<tr><td>fiction: science</td>
<td>14470</td>
<td>3233</td>
<td>4.5</td>
</tr>
<tr><td>press: reportage</td>
<td>100554</td>
<td>14394</td>
<td>7.0</td>
</tr>
<tr><td>fiction: romance</td>
<td>70022</td>
<td>8452</td>
<td>8.3</td>
</tr>
<tr><td>religion</td>
<td>39399</td>
<td>6373</td>
<td>6.2</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 1.1</span>: <p>Lexical Diversity of Various Genres in the <em>Brown Corpus</em></p>
</p>
</table>
</div>
</div>
<div class="section" id="a-closer-look-at-python-texts-as-lists-of-words">
<span id="sec-a-closer-look-at-python-texts-as-lists-of-words"></span><h2>1.2&nbsp;&nbsp;&nbsp;A Closer Look at Python: Texts as Lists of Words</h2>
<!-- reimport

>>> from nltk.book import *
>>> def lexical_diversity(text):
...     return len(text) / len(set(text)) -->
<p>You've seen some important elements of the Python programming language.
Let's take a few moments to review them systematically.</p>
<div class="section" id="lists">
<h3>Lists</h3>
<!-- XXX it's a little confusing that we assign a value to sent1 here,
when it's already received on from the "from nltk.book import *"
statement.  Granted it's the same value, but still... -->
<p>What is a text?  At one level, it is a sequence of symbols on a page such
as this one.  At another level, it is a sequence of chapters, made up
of a sequence of sections, where each section is a sequence of paragraphs,
and so on.  However, for our purposes, we will think of a text as nothing
more than a sequence of words and punctuation.  Here's how we represent
text in Python, in this case the opening sentence of <em>Moby Dick</em>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent1 = [<span class="pysrc-string">'Call'</span>, <span class="pysrc-string">'me'</span>, <span class="pysrc-string">'Ishmael'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>After the prompt we've given a name we made up, <tt class="doctest"><span class="pre">sent1</span></tt>, followed
by the equals sign, and then some quoted words, separated with
commas, and surrounded with brackets.  This bracketed material
is known as a <a name="list_index_term" /><span class="termdef">list</span> in Python: it is how we store a text.
We can inspect it by typing the name <a class="reference internal" href="#inspect-var"><span id="ref-inspect-var"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>. We can ask for its length <a class="reference internal" href="#len-sent"><span id="ref-len-sent"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.
We can even apply our own <tt class="doctest"><span class="pre">lexical_diversity()</span></tt> function to it <a class="reference internal" href="#apply-function"><span id="ref-apply-function"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent1 <a name="inspect-var" /><a href="#ref-inspect-var"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['Call', 'me', 'Ishmael', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(sent1) <a name="len-sent" /><a href="#ref-len-sent"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">4</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>lexical_diversity(sent1) <a name="apply-function" /><a href="#ref-apply-function"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">1.0</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Some more lists have been defined for you,
one for the opening sentence of each of our texts,
<tt class="doctest"><span class="pre">sent2</span></tt> &#8230; <tt class="doctest"><span class="pre">sent9</span></tt>.  We inspect two of them
here; you can see the rest for yourself using the Python interpreter
(if you get an error which says that <tt class="doctest"><span class="pre">sent2</span></tt> is not defined, you
need to first type <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> nltk.book <span class="pysrc-keyword">import</span> *</span></tt>).</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent2
<span class="pysrc-output">['The', 'family', 'of', 'Dashwood', 'had', 'long',</span>
<span class="pysrc-output">'been', 'settled', 'in', 'Sussex', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent3
<span class="pysrc-output">['In', 'the', 'beginning', 'God', 'created', 'the',</span>
<span class="pysrc-output">'heaven', 'and', 'the', 'earth', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Make up a few sentences of your own, by typing a name, equals
sign, and a list of words, like this:
<tt class="doctest"><span class="pre">ex1 = [<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>, <span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'Holy'</span>, <span class="pysrc-string">'Grail'</span>]</span></tt>.
Repeat some of the other Python operations we saw earlier in
<a class="reference internal" href="#sec-computing-with-language-texts-and-words">1.1</a>,
e.g., <tt class="doctest"><span class="pre">sorted(ex1)</span></tt>, <tt class="doctest"><span class="pre">len(set(ex1))</span></tt>, <tt class="doctest"><span class="pre">ex1.count(<span class="pysrc-string">'the'</span>)</span></tt>.</p>
</div>
<p>A pleasant surprise is that we can use Python's addition operator on lists.
Adding two lists <a class="reference internal" href="#list-plus-list"><span id="ref-list-plus-list"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a> creates a new list
with everything from the first list, followed
by everything from the second list:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>] + [<span class="pysrc-string">'and'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'Holy'</span>, <span class="pysrc-string">'Grail'</span>] <a name="list-plus-list" /><a href="#ref-list-plus-list"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['Monty', 'Python', 'and', 'the', 'Holy', 'Grail']</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This special use of the addition operation is called <a name="concatenation_index_term" /><span class="termdef">concatenation</span>;
it combines the lists together into a single list.  We can concatenate
sentences to build up a text.</p>
</div>
<p>We don't have to literally type the lists either; we can use short
names that refer to pre-defined lists.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent4 + sent1
<span class="pysrc-output">['Fellow', '-', 'Citizens', 'of', 'the', 'Senate', 'and', 'of', 'the',</span>
<span class="pysrc-output">'House', 'of', 'Representatives', ':', 'Call', 'me', 'Ishmael', '.']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>What if we want to add a single item to a list? This is known as <a name="appending_index_term" /><span class="termdef">appending</span>.
When we <tt class="doctest"><span class="pre">append()</span></tt> to a list, the list itself is updated as a result
of the operation.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent1.append(<span class="pysrc-string">&quot;Some&quot;</span>)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent1
<span class="pysrc-output">['Call', 'me', 'Ishmael', '.', 'Some']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
<div class="section" id="indexing-lists">
<h3>Indexing Lists</h3>
<!-- XXX I think a picture would be very helpful for this section, namely
one showing something like:
    | Call   | me     | Ishmael | .     |
    0        1        2         3       4
This might obviate the need to use a contrived sentence "word1
word2 etc".  I find this picture especially useful for understanding
slicing, but it also gives a reasonable motivation for zero-indexing. -->
<!-- XXX If we end up doing this, can we offset the integers slightly so
that they (just) fall inside the corresponding cell?

    +- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -+
    | Call   | me     | Ishmael| .      |
    |0       |1       |2       |3       |4
    +- - - - - - - -+- - - - - - - -+- - - - - - - -+- - - - - - - -+ -->
<p>As we have seen, a text in Python is a list of words, represented
using a combination of brackets and quotes.  Just as with an ordinary
page of text, we can count up the total number of words in <tt class="doctest"><span class="pre">text1</span></tt>
with <tt class="doctest"><span class="pre">len(text1)</span></tt>, and count the occurrences in a text of a
particular word &#8212; say, <tt class="doctest"><span class="pre"><span class="pysrc-string">'heaven'</span></span></tt> &#8212; using <tt class="doctest"><span class="pre">text1.count(<span class="pysrc-string">'heaven'</span>)</span></tt>.</p>
<p>With some patience, we can pick out the 1st, 173rd, or even 14,278th
word in a printed text. Analogously, we can identify the elements of a
Python list by their order of occurrence in the list. The number that
represents this position is the item's <a name="index_index_term" /><span class="termdef">index</span>.  We instruct Python
to show us the item that occurs at an index such as <tt class="doctest"><span class="pre">173</span></tt> in a text
by writing the name of the text followed by the index inside square brackets:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text4[173]
<span class="pysrc-output">'awaken'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can do the converse; given a word, find the index of when it first
occurs:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text4.index(<span class="pysrc-string">'awaken'</span>)
<span class="pysrc-output">173</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Indexes are a common way to access the words of a text,
or, more generally, the elements of any list.
Python permits us to access sublists as well, extracting
manageable pieces of language from large texts, a technique
known as <a name="slicing_index_term" /><span class="termdef">slicing</span>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text5[16715:16735]
<span class="pysrc-output">['U86', 'thats', 'why', 'something', 'like', 'gamefly', 'is', 'so', 'good',</span>
<span class="pysrc-output">'because', 'you', 'can', 'actually', 'play', 'a', 'full', 'game', 'without',</span>
<span class="pysrc-output">'buying', 'it']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>text6[1600:1625]
<span class="pysrc-output">['We', &quot;'&quot;, 're', 'an', 'anarcho', '-', 'syndicalist', 'commune', '.', 'We',</span>
<span class="pysrc-output">'take', 'it', 'in', 'turns', 'to', 'act', 'as', 'a', 'sort', 'of', 'executive',</span>
<span class="pysrc-output">'officer', 'for', 'the', 'week']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Indexes have some subtleties, and we'll explore these with
the help of an artificial sentence:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent = [<span class="pysrc-string">'word1'</span>, <span class="pysrc-string">'word2'</span>, <span class="pysrc-string">'word3'</span>, <span class="pysrc-string">'word4'</span>, <span class="pysrc-string">'word5'</span>,
<span class="pysrc-more">... </span>        <span class="pysrc-string">'word6'</span>, <span class="pysrc-string">'word7'</span>, <span class="pysrc-string">'word8'</span>, <span class="pysrc-string">'word9'</span>, <span class="pysrc-string">'word10'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[0]
<span class="pysrc-output">'word1'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[9]
<span class="pysrc-output">'word10'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice that our indexes start from zero: <tt class="doctest"><span class="pre">sent</span></tt> element zero, written <tt class="doctest"><span class="pre">sent[0]</span></tt>,
is the first word, <tt class="doctest"><span class="pre"><span class="pysrc-string">'word1'</span></span></tt>, whereas <tt class="doctest"><span class="pre">sent</span></tt> element 9 is <tt class="doctest"><span class="pre"><span class="pysrc-string">'word10'</span></span></tt>.
The reason is simple: the moment Python accesses the content of a list from
the computer's memory, it is already at the first element;
we have to tell it how many elements forward to go.
Thus, zero steps forward leaves it at the first element.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This practice of counting from zero is initially confusing,
but typical of modern programming languages.
You'll quickly get the hang of it if
you've mastered the system of counting centuries where 19XY is a year
in the 20th century, or if you live in a country where the floors of
a building are numbered from 1, and so walking up <span class="math">n-1</span> flights of
stairs takes you to level <span class="math">n</span>.</p>
</div>
<p>Now, if we accidentally use an index that is too large, we get an error:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[10]
<span class="pysrc-except">Traceback (most recent call last):</span>
<span class="pysrc-except">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="pysrc-except">IndexError: list index out of range</span>
<span class="pysrc-except"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This time it is not a syntax error, because the program fragment is syntactically correct.
Instead, it is a <a name="runtime_error_index_term" /><span class="termdef">runtime error</span>, and it produces a <tt class="doctest"><span class="pre">Traceback</span></tt> message that
shows the context of the error, followed by the name of the error,
<tt class="doctest"><span class="pre">IndexError</span></tt>, and a brief explanation.</p>
<p>Let's take a closer look at slicing, using our artificial sentence again.
Here we verify that the slice <tt class="doctest"><span class="pre">5:8</span></tt> includes <tt class="doctest"><span class="pre">sent</span></tt> elements at
indexes 5, 6, and 7:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[5:8]
<span class="pysrc-output">['word6', 'word7', 'word8']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[5]
<span class="pysrc-output">'word6'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[6]
<span class="pysrc-output">'word7'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[7]
<span class="pysrc-output">'word8'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>By convention, <tt class="doctest"><span class="pre">m:n</span></tt> means elements <span class="mathit">m</span>&#8230;<span class="mathit">n-1</span>.
As the next example shows,
we can omit the first number if the slice begins at the start of the
list <a class="reference internal" href="#slice2"><span id="ref-slice2"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>, and we can omit the second number if the slice goes to the end <a class="reference internal" href="#slice3"><span id="ref-slice3"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[:3] <a name="slice2" /><a href="#ref-slice2"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">['word1', 'word2', 'word3']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>text2[141525:] <a name="slice3" /><a href="#ref-slice3"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">['among', 'the', 'merits', 'and', 'the', 'happiness', 'of', 'Elinor', 'and', 'Marianne',</span>
<span class="pysrc-output">',', 'let', 'it', 'not', 'be', 'ranked', 'as', 'the', 'least', 'considerable', ',',</span>
<span class="pysrc-output">'that', 'though', 'sisters', ',', 'and', 'living', 'almost', 'within', 'sight', 'of',</span>
<span class="pysrc-output">'each', 'other', ',', 'they', 'could', 'live', 'without', 'disagreement', 'between',</span>
<span class="pysrc-output">'themselves', ',', 'or', 'producing', 'coolness', 'between', 'their', 'husbands', '.',</span>
<span class="pysrc-output">'THE', 'END']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can modify an element of a list by assigning to one of its index values.
In the next example, we put <tt class="doctest"><span class="pre">sent[0]</span></tt> on the left of the equals sign <a class="reference internal" href="#list-assignment"><span id="ref-list-assignment"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>.  We can also
replace an entire slice with new material <a class="reference internal" href="#slice-assignment"><span id="ref-slice-assignment"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>.  A consequence of this
last change is that the list only has four elements, and accessing a later value
generates an error <a class="reference internal" href="#list-error"><span id="ref-list-error"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[0] = <span class="pysrc-string">'First'</span> <a name="list-assignment" /><a href="#ref-list-assignment"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[9] = <span class="pysrc-string">'Last'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(sent)
<span class="pysrc-output">10</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[1:9] = [<span class="pysrc-string">'Second'</span>, <span class="pysrc-string">'Third'</span>] <a name="slice-assignment" /><a href="#ref-slice-assignment"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent
<span class="pysrc-output">['First', 'Second', 'Third', 'Last']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sent[9] <a name="list-error" /><a href="#ref-list-error"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-except">Traceback (most recent call last):</span>
<span class="pysrc-except">  File &quot;&lt;stdin&gt;&quot;, line 1, in ?</span>
<span class="pysrc-except">IndexError: list index out of range</span>
<span class="pysrc-except"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Take a few minutes to define a sentence of your own and modify individual words and
groups of words (slices) using the same methods used earlier.  Check your understanding
by trying the exercises on lists at the end of this chapter.</p>
</div>
</div>
<div class="section" id="variables">
<h3>Variables</h3>
<p>From the start of <a class="reference internal" href="#sec-computing-with-language-texts-and-words">1.1</a>, you have had
access to texts called <tt class="doctest"><span class="pre">text1</span></tt>, <tt class="doctest"><span class="pre">text2</span></tt>, and so on.  It saved a lot
of typing to be able to refer to a 250,000-word book with a short name
like this!  In general, we can make up names for anything we care
to calculate.  We did this ourselves in the previous sections, e.g.,
defining a <a name="variable_index_term" /><span class="termdef">variable</span> <tt class="doctest"><span class="pre">sent1</span></tt>, as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent1 = [<span class="pysrc-string">'Call'</span>, <span class="pysrc-string">'me'</span>, <span class="pysrc-string">'Ishmael'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Such lines have the form: <em>variable = expression</em>.  Python will evaluate
the expression, and save its result to the variable.  This process is
called <a name="assignment_index_term" /><span class="termdef">assignment</span>.  It does not generate any output;
you have to type the variable on a line of its
own to inspect its contents.  The equals sign is slightly misleading,
since information is moving from the right side to the left.
It might help to think of it as a left-arrow.
The name of the variable can be anything you like, e.g., <tt class="doctest"><span class="pre">my_sent</span></tt>, <tt class="doctest"><span class="pre">sentence</span></tt>, <tt class="doctest"><span class="pre">xyzzy</span></tt>.
It must start with a letter, and can include numbers and underscores.
Here are some examples of variables and assignments:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>my_sent = [<span class="pysrc-string">'Bravely'</span>, <span class="pysrc-string">'bold'</span>, <span class="pysrc-string">'Sir'</span>, <span class="pysrc-string">'Robin'</span>, <span class="pysrc-string">','</span>, <span class="pysrc-string">'rode'</span>,
<span class="pysrc-more">... </span><span class="pysrc-string">'forth'</span>, <span class="pysrc-string">'from'</span>, <span class="pysrc-string">'Camelot'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>noun_phrase = my_sent[1:4]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>noun_phrase
<span class="pysrc-output">['bold', 'Sir', 'Robin']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>wOrDs = sorted(noun_phrase)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>wOrDs
<span class="pysrc-output">['Robin', 'Sir', 'bold']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Remember that capitalized words appear before lowercase words in sorted lists.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Notice in the previous example that we split the definition
of <tt class="doctest"><span class="pre">my_sent</span></tt> over two lines.  Python expressions can be split across
multiple lines, so long as this happens within any kind of brackets.
Python uses the &quot;<tt class="doctest"><span class="pre"><span class="pysrc-more">...</span></span></tt>&quot; prompt to indicate that more input is
expected.  It doesn't matter how much indentation is used in these
continuation lines, but some indentation usually makes them easier to read.</p>
</div>
<p>It is good to choose meaningful variable names to remind you &#8212; and to help anyone
else who reads your Python code &#8212; what your code is meant to do.
Python does not try to make sense of the names; it blindly follows your instructions,
and does not object if you do something confusing, such as <tt class="doctest"><span class="pre">one = <span class="pysrc-string">'two'</span></span></tt> or <tt class="doctest"><span class="pre">two = 3</span></tt>.
The only restriction is that
a variable name cannot be any of Python's reserved words, such as
<tt class="doctest"><span class="pre">def</span></tt>, <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt>, <tt class="doctest"><span class="pre"><span class="pysrc-keyword">not</span></span></tt>,
and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span></span></tt>.  If you use a reserved word, Python will produce a syntax error:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">not</span> = <span class="pysrc-string">'Camelot'</span>
<span class="pysrc-output">File &quot;&lt;stdin&gt;&quot;, line 1</span>
<span class="pysrc-output">    not = 'Camelot'</span>
<span class="pysrc-output">        ^</span>
<span class="pysrc-output">SyntaxError: invalid syntax</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We will often use variables to hold intermediate steps of a computation, especially
when this makes the code easier to follow.  Thus <tt class="doctest"><span class="pre">len(set(text1))</span></tt> could also be written:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>vocab = set(text1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>vocab_size = len(vocab)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>vocab_size
<span class="pysrc-output">19317</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="caution">
<p class="first admonition-title">Caution!</p>
<p class="last">Take care with your choice of names (or <a name="identifiers_index_term" /><span class="termdef">identifiers</span>) for Python
variables.  First, you should start the name with a letter, optionally
followed by digits (<tt class="doctest"><span class="pre">0</span></tt> to <tt class="doctest"><span class="pre">9</span></tt>) or letters. Thus, <tt class="doctest"><span class="pre">abc23</span></tt> is fine, but
<tt class="doctest"><span class="pre">23abc</span></tt> will cause a syntax error.
Names are case-sensitive, which means that <tt class="doctest"><span class="pre">myVar</span></tt> and <tt class="doctest"><span class="pre">myvar</span></tt>
are distinct variables.  Variable names cannot contain whitespace,
but you can separate words using an underscore, e.g.,
<tt class="doctest"><span class="pre">my_var</span></tt>. Be careful not to insert a hyphen instead of an
underscore: <tt class="doctest"><span class="pre">my-var</span></tt> is wrong, since Python interprets the
&quot;<tt class="doctest"><span class="pre">-</span></tt>&quot; as a minus sign.</p>
</div>
</div>
<div class="section" id="strings">
<h3>Strings</h3>
<p>Some of the methods we used to access the elements of a list also work with individual words,
or <a name="strings_index_term" /><span class="termdef">strings</span>.  For example, we can assign a string to a variable <a class="reference internal" href="#assign-string"><span id="ref-assign-string"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
index a string <a class="reference internal" href="#index-string"><span id="ref-index-string"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>, and slice a string <a class="reference internal" href="#slice-string"><span id="ref-slice-string"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>name = <span class="pysrc-string">'Monty'</span> <a name="assign-string" /><a href="#ref-assign-string"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>name[0] <a name="index-string" /><a href="#ref-index-string"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">'M'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>name[:4] <a name="slice-string" /><a href="#ref-slice-string"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">'Mont'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also perform multiplication and addition with strings:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>name * 2
<span class="pysrc-output">'MontyMonty'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>name + <span class="pysrc-string">'!'</span>
<span class="pysrc-output">'Monty!'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can join the words of a list to make a single string, or split a string into a list, as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-string">' '</span>.join([<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>])
<span class="pysrc-output">'Monty Python'</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-string">'Monty Python'</span>.split()
<span class="pysrc-output">['Monty', 'Python']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We will come back to the topic of strings in <a class="reference external" href="ch03.html#chap-words">3</a>.
For the time being, we have two important building blocks
&#8212; lists and strings &#8212;
and are ready to get back to some language analysis.</p>
</div>
</div>
<div class="section" id="computing-with-language-simple-statistics">
<span id="sec-computing-with-language-simple-statistics"></span><h2>1.3&nbsp;&nbsp;&nbsp;Computing with Language: Simple Statistics</h2>
<!-- reimport

>>> from nltk.book import * -->
<p>Let's return to our exploration of the ways we can bring our computational
resources to bear on large quantities of text.  We began this discussion in
<a class="reference internal" href="#sec-computing-with-language-texts-and-words">1.1</a>, and saw how to search for words
in context, how to compile the vocabulary of a text, how to generate random
text in the same style, and so on.</p>
<p>In this section we pick up the question of what makes a text distinct,
and use automatic methods to find characteristic words and expressions
of a text.  As in <a class="reference internal" href="#sec-computing-with-language-texts-and-words">1.1</a>, you can try
new features of the Python language by copying them into the interpreter,
and you'll learn about these features systematically in the following section.</p>
<p>Before continuing further, you might like to check your understanding of the
last section by predicting the output of the following code.  You can use
the interpreter to check whether you got it right.  If you're not sure how
to do this task, it would be a good idea to review the previous section
before continuing further.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>saying = [<span class="pysrc-string">'After'</span>, <span class="pysrc-string">'all'</span>, <span class="pysrc-string">'is'</span>, <span class="pysrc-string">'said'</span>, <span class="pysrc-string">'and'</span>, <span class="pysrc-string">'done'</span>,
<span class="pysrc-more">... </span>          <span class="pysrc-string">'more'</span>, <span class="pysrc-string">'is'</span>, <span class="pysrc-string">'said'</span>, <span class="pysrc-string">'than'</span>, <span class="pysrc-string">'done'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = set(saying)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens = sorted(tokens)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tokens[-2:]
<span class="pysrc-output">what output do you expect here?</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<div class="section" id="frequency-distributions">
<h3>Frequency Distributions</h3>
<p>How can we automatically identify the words of a text that are most
informative about the topic and genre of the text?  Imagine how you might
go about finding the 50 most frequent words of a book.  One method
would be to keep a tally for each vocabulary item, like that shown in <a class="reference internal" href="#fig-tally">1.3</a>.
The tally would need thousands of rows, and it would be an exceedingly
laborious process &#8212; so laborious that we would rather assign the task to a machine.</p>
<span class="target" id="fig-tally"></span><div class="figure" id="fig-tally">
<img alt="../images/tally.png" src="../images/tally.png" style="width: 231.8px; height: 155.0px;" />
<p class="caption"><span class="caption-label">Figure 1.3</span>: Counting Words Appearing in a Text (a frequency distribution)</p>
</div>
<p>The table in <a class="reference internal" href="#fig-tally">1.3</a> is known as a <a name="frequency_distribution_index_term" /><span class="termdef">frequency distribution</span>,
and it tells us the frequency of each vocabulary item in the text.
(In general, it could count any kind of observable event.)
It is a &quot;distribution&quot;
because it tells us how the total number of word tokens in the text
are distributed across the vocabulary items.
Since we often need frequency distributions in language processing, NLTK
provides built-in support for them.  Let's use a <tt class="doctest"><span class="pre">FreqDist</span></tt> to find the
50 most frequent words of <em>Moby Dick</em>.  Try to work out what is going on here,
then read the explanation that follows.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist1 = FreqDist(text1) <a name="freq-dist-call" /><a href="#ref-freq-dist-call"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist1 <a name="freq-dist-inspect" /><a href="#ref-freq-dist-inspect"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-output">&lt;FreqDist with 260819 outcomes&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>vocabulary1 = fdist1.keys() <a name="freq-dist-keys" /><a href="#ref-freq-dist-keys"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>vocabulary1[:50] <a name="freq-dist-slice" /><a href="#ref-freq-dist-slice"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></a>
<span class="pysrc-output">[',', 'the', '.', 'of', 'and', 'a', 'to', ';', 'in', 'that', &quot;'&quot;, '-',</span>
<span class="pysrc-output">'his', 'it', 'I', 's', 'is', 'he', 'with', 'was', 'as', '&quot;', 'all', 'for',</span>
<span class="pysrc-output">'this', '!', 'at', 'by', 'but', 'not', '--', 'him', 'from', 'be', 'on',</span>
<span class="pysrc-output">'so', 'whale', 'one', 'you', 'had', 'have', 'there', 'But', 'or', 'were',</span>
<span class="pysrc-output">'now', 'which', '?', 'me', 'like']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist1[<span class="pysrc-string">'whale'</span>]
<span class="pysrc-output">906</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>When we first invoke <tt class="doctest"><span class="pre">FreqDist</span></tt>, we pass the name of the text as an
argument <a class="reference internal" href="#freq-dist-call"><span id="ref-freq-dist-call"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>. We can inspect the total number of words (&quot;outcomes&quot;)
that have been counted up <a class="reference internal" href="#freq-dist-inspect"><span id="ref-freq-dist-inspect"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a> &#8212; 260,819 in the
case of <em>Moby Dick</em>. The expression <tt class="doctest"><span class="pre"><span class="pysrc-builtin">keys</span>()</span></tt> gives us a list of all
the distinct types in the text <a class="reference internal" href="#freq-dist-keys"><span id="ref-freq-dist-keys"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a>, and we can look at the
first 50 of these by slicing the list <a class="reference internal" href="#freq-dist-slice"><span id="ref-freq-dist-slice"><img src="callouts/callout4.gif" alt="[4]" class="callout" /></span></a>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try the preceding frequency distribution example for yourself, for
<tt class="doctest"><span class="pre">text2</span></tt>.  Be careful to use the correct parentheses and uppercase letters.
If you get an error message <tt class="doctest"><span class="pre">NameError: name <span class="pysrc-string">'FreqDist'</span> <span class="pysrc-keyword">is</span> <span class="pysrc-keyword">not</span> defined</span></tt>,
you need to start your work with <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> nltk.book <span class="pysrc-keyword">import</span> *</span></tt></p>
</div>
<!-- SB: no period after the above import statement -->
<p>Do any words produced in the last example help us grasp the topic or genre of this text?
Only one word, <span class="example">whale</span>, is slightly informative!  It occurs over 900 times.
The rest of the words tell us nothing about the text; they're just English &quot;plumbing.&quot;
What proportion of the text is taken up with such words?
We can generate a cumulative frequency plot for these words,
using <tt class="doctest"><span class="pre">fdist1.plot(50, cumulative=True)</span></tt>, to produce the graph in <a class="reference internal" href="#fig-fdist-moby">1.4</a>.
These 50 words account for nearly half the book!</p>
<span class="target" id="fig-fdist-moby"></span><div class="figure" id="fig-fdist-moby">
<img alt="../images/fdist-moby.png" src="../images/fdist-moby.png" style="width: 207.2px; height: 116.2px;" />
<p class="caption"><span class="caption-label">Figure 1.4</span>: Cumulative Frequency Plot for 50 Most Frequently Words in <em>Moby Dick</em>:
these account for nearly half of the tokens.</p>
</div>
<p>If the frequent words don't help us, how about the words that occur once
only, the so-called <a name="hapaxes_index_term" /><span class="termdef">hapaxes</span>?  View them by typing <tt class="doctest"><span class="pre">fdist1.hapaxes()</span></tt>.
This list contains <span class="example">lexicographer</span>, <span class="example">cetological</span>,
<span class="example">contraband</span>, <span class="example">expostulations</span>, and about 9,000 others.
It seems that there are too many rare words, and without seeing the
context we probably can't guess what half of the hapaxes mean in any case!
Since neither frequent nor infrequent words help, we need to try
something else.</p>
</div>
<div class="section" id="fine-grained-selection-of-words">
<h3>Fine-grained Selection of Words</h3>
<p>Next, let's look at the <em>long</em> words of a text; perhaps these will be
more characteristic and informative.  For this we adapt some notation
from set theory.  We would like to find the words from the vocabulary
of the text that are more than 15 characters long.  Let's call
this property <span class="math">P</span>, so that <span class="math">P(w)</span> is true
if and only if <span class="math">w</span> is more than 15 characters long.
Now we can express the words of interest using mathematical
set notation as shown in <a class="reference internal" href="#ex-set-comprehension-math">(1a)</a>.
This means &quot;the set of all <span class="math">w</span> such that <span class="math">w</span> is an
element of <span class="math">V</span> (the vocabulary) and <span class="math">w</span> has property <span class="math">P</span>&quot;.</p>
<span class="target" id="ex-set-comprehension"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(1)</td><td width="15"></td><td><span class="target" id="ex-set-comprehension-math"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>{<span class="math">w</span> | <span class="math">w</span> &#8712; <span class="math">V</span> &amp; <span class="math">P(w)</span>}</td></tr></table></p>
<span class="target" id="ex-set-comprehension-python"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><tt class="doctest"><span class="pre">[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> V <span class="pysrc-keyword">if</span> p(w)]</span></tt></td></tr></table></p>
</td></tr></table></p>
<p>The corresponding Python expression is given in <a class="reference internal" href="#ex-set-comprehension-python">(1b)</a>.
(Note that it produces a list, not a set, which means that duplicates are possible.)
Observe how similar the two notations are.  Let's go one more step and
write executable Python code:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>V = set(text1)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>long_words = [w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> V <span class="pysrc-keyword">if</span> len(w) &gt; 15]
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(long_words)
<span class="pysrc-output">['CIRCUMNAVIGATION', 'Physiognomically', 'apprehensiveness', 'cannibalistically',</span>
<span class="pysrc-output">'characteristically', 'circumnavigating', 'circumnavigation', 'circumnavigations',</span>
<span class="pysrc-output">'comprehensiveness', 'hermaphroditical', 'indiscriminately', 'indispensableness',</span>
<span class="pysrc-output">'irresistibleness', 'physiognomically', 'preternaturalness', 'responsibilities',</span>
<span class="pysrc-output">'simultaneousness', 'subterraneousness', 'supernaturalness', 'superstitiousness',</span>
<span class="pysrc-output">'uncomfortableness', 'uncompromisedness', 'undiscriminating', 'uninterpenetratingly']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>For each word <tt class="doctest"><span class="pre">w</span></tt> in the vocabulary <tt class="doctest"><span class="pre">V</span></tt>, we check whether
<tt class="doctest"><span class="pre">len(w)</span></tt> is greater than 15; all other words will
be ignored.  We will discuss this syntax more carefully later.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
Try out the previous statements in the Python interpreter,
and experiment with changing the text and changing the length condition.
Does it make an difference to your results if you change the
variable names, e.g., using <tt class="doctest"><span class="pre">[word <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> vocab <span class="pysrc-keyword">if</span> ...]</span></tt>?</p>
</div>
<p>Let's return to our task of finding words that characterize a text.
Notice that the long words in <tt class="doctest"><span class="pre">text4</span></tt> reflect its national focus
&#8212; <span class="example">constitutionally</span>, <span class="example">transcontinental</span> &#8212;
whereas those in <tt class="doctest"><span class="pre">text5</span></tt> reflect its informal content:
<span class="example">boooooooooooglyyyyyy</span> and <span class="example">yuuuuuuuuuuuummmmmmmmmmmm</span>.
Have we succeeded in automatically extracting words that typify
a text?  Well, these very long words are often hapaxes (i.e., unique)
and perhaps it would be better to find <em>frequently occurring</em>
long words.  This seems promising since it eliminates
frequent short words (e.g., <span class="example">the</span>) and infrequent long words
(e.g. <span class="example">antiphilosophists</span>).
Here are all words from the chat corpus
that are longer than seven characters, that occur more than seven times:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist5 = FreqDist(text5)
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text5) <span class="pysrc-keyword">if</span> len(w) &gt; 7 <span class="pysrc-keyword">and</span> fdist5[w] &gt; 7])
<span class="pysrc-output">['#14-19teens', '#talkcity_adults', '((((((((((', '........', 'Question',</span>
<span class="pysrc-output">'actually', 'anything', 'computer', 'cute.-ass', 'everyone', 'football',</span>
<span class="pysrc-output">'innocent', 'listening', 'remember', 'seriously', 'something', 'together',</span>
<span class="pysrc-output">'tomorrow', 'watching']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Notice how we have used two conditions: <tt class="doctest"><span class="pre">len(w) &gt; 7</span></tt> ensures that the
words are longer than seven letters, and <tt class="doctest"><span class="pre">fdist5[w] &gt; 7</span></tt> ensures that
these words occur more than seven times.  At last we have managed to
automatically identify the frequently-occurring content-bearing
words of the text.  It is a modest but important milestone: a tiny piece of code,
processing tens of thousands of words, produces some informative output.</p>
</div>
<div class="section" id="collocations-and-bigrams">
<h3>Collocations and Bigrams</h3>
<p>A <a name="collocation_index_term" /><span class="termdef">collocation</span> is a sequence of words that occur together
unusually often. Thus <span class="example">red wine</span> is a collocation, whereas <span class="example">the
wine</span> is not. A characteristic of collocations is that they are
resistant to substitution with words that have similar senses;
for example, <span class="example">maroon wine</span> sounds definitely odd.</p>
<p>To get a handle on collocations, we start off by extracting from a text
a list of word pairs, also known as <a name="bigrams_index_term" /><span class="termdef">bigrams</span>. This is easily
accomplished with the function <tt class="doctest"><span class="pre">bigrams()</span></tt>:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>bigrams([<span class="pysrc-string">'more'</span>, <span class="pysrc-string">'is'</span>, <span class="pysrc-string">'said'</span>, <span class="pysrc-string">'than'</span>, <span class="pysrc-string">'done'</span>])
<span class="pysrc-output">[('more', 'is'), ('is', 'said'), ('said', 'than'), ('than', 'done')]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Here we see that the pair of words <span class="example">than-done</span> is a bigram, and we write
it in Python as <tt class="doctest"><span class="pre">(<span class="pysrc-string">'than'</span>, <span class="pysrc-string">'done'</span>)</span></tt>.  Now, collocations are essentially
just frequent bigrams, except that we want to pay more attention to the
cases that involve rare words.  In particular, we want to find
bigrams that occur more often than we would expect based on
the frequency of individual words.  The <tt class="doctest"><span class="pre">collocations()</span></tt> function
does this for us (we will see how it works later):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>text4.collocations()
<span class="pysrc-output">Building collocations list</span>
<span class="pysrc-output">United States; fellow citizens; years ago; Federal Government; General</span>
<span class="pysrc-output">Government; American people; Vice President; Almighty God; Fellow</span>
<span class="pysrc-output">citizens; Chief Magistrate; Chief Justice; God bless; Indian tribes;</span>
<span class="pysrc-output">public debt; foreign nations; political parties; State governments;</span>
<span class="pysrc-output">National Government; United Nations; public money</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>text8.collocations()
<span class="pysrc-output">Building collocations list</span>
<span class="pysrc-output">medium build; social drinker; quiet nights; long term; age open;</span>
<span class="pysrc-output">financially secure; fun times; similar interests; Age open; poss</span>
<span class="pysrc-output">rship; single mum; permanent relationship; slim build; seeks lady;</span>
<span class="pysrc-output">Late 30s; Photo pls; Vibrant personality; European background; ASIAN</span>
<span class="pysrc-output">LADY; country drives</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>The collocations that emerge are very specific to the genre of the
texts. In order to find  <span class="example">red wine</span> as a collocation, we would
need to process a much larger body of text.</p>
</div>
<div class="section" id="counting-other-things">
<h3>Counting Other Things</h3>
<p>Counting words is useful, but we can count other things too.  For example, we can
look at the distribution of word lengths in a text, by creating a <tt class="doctest"><span class="pre">FreqDist</span></tt>
out of a long list of numbers, where each number is the length of the corresponding
word in the text:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[len(w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1] <a name="word-lengths" /><a href="#ref-word-lengths"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">[1, 4, 4, 2, 6, 8, 4, 1, 9, 1, 1, 8, 2, 1, 4, 11, 5, 2, 1, 7, 6, 1, 3, 4, 5, 2, ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist = FreqDist([len(w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1])  <a name="freq-word-lengths" /><a href="#ref-freq-word-lengths"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></a>
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist  <a name="freq-word-lengths-size" /><a href="#ref-freq-word-lengths-size"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></a>
<span class="pysrc-output">&lt;FreqDist with 260819 outcomes&gt;</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist.keys()
<span class="pysrc-output">[3, 1, 4, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We start by deriving a list of the lengths of words in <tt class="doctest"><span class="pre">text1</span></tt>
<a class="reference internal" href="#word-lengths"><span id="ref-word-lengths"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>,
and the <tt class="doctest"><span class="pre">FreqDist</span></tt> then counts the number of times each of these
occurs <a class="reference internal" href="#freq-word-lengths"><span id="ref-freq-word-lengths"><img src="callouts/callout2.gif" alt="[2]" class="callout" /></span></a>. The result <a class="reference internal" href="#freq-word-lengths-size"><span id="ref-freq-word-lengths-size"><img src="callouts/callout3.gif" alt="[3]" class="callout" /></span></a> is a distribution containing
a quarter of a million items, each of which is a number corresponding to a
word token in the text.  But there are only 20 distinct
items being counted, the numbers 1 through 20, because there are only 20
different word lengths.  I.e., there are words consisting of just one character,
two characters, ..., twenty characters, but none with twenty one or more
characters.  One might wonder how frequent the different lengths of word are
(e.g., how many words of length four appear in the text, are there more words of length five
than length four, etc). We can do this as follows:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist.items()
<span class="pysrc-output">[(3, 50223), (1, 47933), (4, 42345), (2, 38513), (5, 26597), (6, 17111), (7, 14399),</span>
<span class="pysrc-output">(8, 9966), (9, 6428), (10, 3528), (11, 1873), (12, 1053), (13, 567), (14, 177),</span>
<span class="pysrc-output">(15, 70), (16, 22), (17, 12), (18, 1), (20, 1)]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist.max()
<span class="pysrc-output">3</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist[3]
<span class="pysrc-output">50223</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>fdist.freq(3)
<span class="pysrc-output">0.19255882431878046</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>From this we see that the most frequent word length is 3, and that
words of length 3 account for roughly 50,000 (or 20%) of the words making up the
book.  Although we will not pursue it here, further analysis of word
length might help us understand differences between authors, genres, or
languages.</p>
<p><a class="reference internal" href="#tab-freqdist">1.2</a> summarizes the functions defined in frequency distributions.</p>
<span class="target" id="tab-freqdist"></span><table border="1" class="docutils" id="tab-freqdist">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Example</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">fdist = FreqDist(samples)</span></tt></td>
<td>create a frequency distribution containing the given samples</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.inc(sample)</span></tt></td>
<td>increment the count for this sample</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist[<span class="pysrc-string">'monstrous'</span>]</span></tt></td>
<td>count of the number of times a given sample occurred</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.freq(<span class="pysrc-string">'monstrous'</span>)</span></tt></td>
<td>frequency of a given sample</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.N()</span></tt></td>
<td>total number of samples</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.keys()</span></tt></td>
<td>the samples sorted in order of decreasing frequency</td>
</tr>
<tr><td><tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> sample <span class="pysrc-keyword">in</span> fdist:</span></tt></td>
<td>iterate over the samples, in order of decreasing frequency</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.max()</span></tt></td>
<td>sample with the greatest count</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.tabulate()</span></tt></td>
<td>tabulate the frequency distribution</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.plot()</span></tt></td>
<td>graphical plot of the frequency distribution</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist.plot(cumulative=True)</span></tt></td>
<td>cumulative plot of the frequency distribution</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">fdist1 &lt; fdist2</span></tt></td>
<td>test if samples in <tt class="doctest"><span class="pre">fdist1</span></tt> occur less frequently than in <tt class="doctest"><span class="pre">fdist2</span></tt></td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 1.2</span>: <p>Functions Defined for NLTK's Frequency Distributions</p>
</p>
</table>
<p>Our discussion of frequency distributions has introduced some important Python concepts,
and we will look at them systematically in <a class="reference internal" href="#sec-making-decisions">1.4</a>.</p>
<!-- We've also touched on the topic of normalization, and we'll explore this in
depth in chap-words_. -->
</div>
</div>
<div class="section" id="back-to-python-making-decisions-and-taking-control">
<span id="sec-making-decisions"></span><h2>1.4&nbsp;&nbsp;&nbsp;Back to Python: Making Decisions and Taking Control</h2>
<!-- reimport

>>> from nltk.book import * -->
<p>So far, our little programs have had some interesting qualities:
the ability to work with language, and
the potential to save human effort through automation.
A key feature of programming is the ability of machines to
make decisions on our behalf, executing instructions when
certain conditions are met, or repeatedly looping through
text data until some condition is satisfied.  This feature
is known as <a name="control_index_term" /><span class="termdef">control</span>, and is the focus of this section.</p>
<div class="section" id="conditionals">
<h3>Conditionals</h3>
<p>Python supports a wide range of operators, such as <tt class="doctest"><span class="pre">&lt;</span></tt> and <tt class="doctest"><span class="pre">&gt;=</span></tt>, for
testing the relationship between values. The full set of these <a name="relational_operators_index_term" /><span class="termdef">relational
operators</span> are shown in <a class="reference internal" href="#tab-inequalities">1.3</a>.</p>
<span class="target" id="tab-inequalities"></span><table border="1" class="docutils" id="tab-inequalities">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Operator</th>
<th class="head">Relationship</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">&lt;</span></tt></td>
<td>less than</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">&lt;=</span></tt></td>
<td>less than or equal to</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">==</span></tt></td>
<td>equal to (note this is two &quot;<tt class="doctest"><span class="pre">=</span></tt>&quot; signs, not one)</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">!=</span></tt></td>
<td>not equal to</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">&gt;</span></tt></td>
<td>greater than</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">&gt;=</span></tt></td>
<td>greater than or equal to</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 1.3</span>: <p>Numerical Comparison Operators</p>
</p>
</table>
<p>We can use these to select different words from a sentence of news text.
Here are some examples &#8212; only the operator is changed from one
line to the next.  They all use <tt class="doctest"><span class="pre">sent7</span></tt>, the first sentence from <tt class="doctest"><span class="pre">text7</span></tt>
(<em>Wall Street Journal</em>).  As before, if you get an error saying that <tt class="doctest"><span class="pre">sent7</span></tt>
is undefined, you need to first type: <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> nltk.book <span class="pysrc-keyword">import</span> *</span></tt></p>
<!-- SB: no period after above import statement

>>> sent7
['Pierre', 'Vinken', ',', '61', 'years', 'old', ',', 'will', 'join', 'the',
'board', 'as', 'a', 'nonexecutive', 'director', 'Nov.', '29', '.']
>>> [w for w in sent7 if len(w) < 4]
[',', '61', 'old', ',', 'the', 'as', 'a', '29', '.']
>>> [w for w in sent7 if len(w) <= 4]
[',', '61', 'old', ',', 'will', 'join', 'the', 'as', 'a', 'Nov.', '29', '.']
>>> [w for w in sent7 if len(w) == 4]
['will', 'join', 'Nov.']
>>> [w for w in sent7 if len(w) != 4]
['Pierre', 'Vinken', ',', '61', 'years', 'old', ',', 'the', 'board',
'as', 'a', 'nonexecutive', 'director', '29', '.']
>>> -->
<p>There is a common pattern to all of these examples:
<tt class="doctest"><span class="pre">[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text <span class="pysrc-keyword">if</span></span></tt> <em>condition</em> <tt class="doctest"><span class="pre">]</span></tt>, where <em>condition</em> is a
Python &quot;test&quot; that yields either true or false.
In the cases shown in the previous code example, the condition is always a numerical comparison.
However, we can also test various properties of words,
using the functions listed in <a class="reference internal" href="#tab-word-tests">1.4</a>.</p>
<span class="target" id="tab-word-tests"></span><table border="1" class="docutils" id="tab-word-tests">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Function</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="doctest"><span class="pre">s.startswith(t)</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> starts with <tt class="doctest"><span class="pre">t</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.endswith(t)</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> ends with <tt class="doctest"><span class="pre">t</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">t <span class="pysrc-keyword">in</span> s</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">t</span></tt> is contained inside <tt class="doctest"><span class="pre">s</span></tt></td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.islower()</span></tt></td>
<td>test if all cased characters in <tt class="doctest"><span class="pre">s</span></tt> are lowercase</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isupper()</span></tt></td>
<td>test if all cased characters in <tt class="doctest"><span class="pre">s</span></tt> are uppercase</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isalpha()</span></tt></td>
<td>test if all characters in <tt class="doctest"><span class="pre">s</span></tt> are alphabetic</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isalnum()</span></tt></td>
<td>test if all characters in <tt class="doctest"><span class="pre">s</span></tt> are alphanumeric</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.isdigit()</span></tt></td>
<td>test if all characters in <tt class="doctest"><span class="pre">s</span></tt> are digits</td>
</tr>
<tr><td><tt class="doctest"><span class="pre">s.istitle()</span></tt></td>
<td>test if <tt class="doctest"><span class="pre">s</span></tt> is titlecased (all words in <tt class="doctest"><span class="pre">s</span></tt> have have initial capitals)</td>
</tr>
</tbody>
<p class="caption"><span class="caption-label">Table 1.4</span>: <p>Some Word Comparison Operators</p>
</p>
</table>
<p>Here are some examples of these operators being used to
select words from our texts:
words ending with <span class="example">-ableness</span>;
words containing <span class="example">gnt</span>;
words having an initial capital;
and words consisting entirely of digits.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text1) <span class="pysrc-keyword">if</span> w.endswith(<span class="pysrc-string">'ableness'</span>)])
<span class="pysrc-output">['comfortableness', 'honourableness', 'immutableness', 'indispensableness', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([term <span class="pysrc-keyword">for</span> term <span class="pysrc-keyword">in</span> set(text4) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'gnt'</span> <span class="pysrc-keyword">in</span> term])
<span class="pysrc-output">['Sovereignty', 'sovereignties', 'sovereignty']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([item <span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(text6) <span class="pysrc-keyword">if</span> item.istitle()])
<span class="pysrc-output">['A', 'Aaaaaaaaah', 'Aaaaaaaah', 'Aaaaaah', 'Aaaah', 'Aaaaugh', 'Aaagh', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([item <span class="pysrc-keyword">for</span> item <span class="pysrc-keyword">in</span> set(sent7) <span class="pysrc-keyword">if</span> item.isdigit()])
<span class="pysrc-output">['29', '61']</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>We can also create more complex conditions.  If <span class="math">c</span> is a
condition, then <tt class="doctest"><span class="pre"><span class="pysrc-keyword">not</span></span></tt> <span class="math">c</span> is also a condition.
If we have two conditions <span class="math">c</span><sub>1</sub> and <span class="math">c</span><sub>2</sub>,
then we can combine them to form a new condition using conjunction and disjunction:
<span class="math">c</span><sub>1</sub> <tt class="doctest"><span class="pre"><span class="pysrc-keyword">and</span></span></tt> <span class="math">c</span><sub>2</sub>,
<span class="math">c</span><sub>1</sub> <tt class="doctest"><span class="pre"><span class="pysrc-keyword">or</span></span></tt> <span class="math">c</span><sub>2</sub>.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p><strong>Your Turn:</strong>
Run the following examples and try to explain what is going on in each one.
Next, try to make up some conditions of your own.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text7) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'-'</span> <span class="pysrc-keyword">in</span> w <span class="pysrc-keyword">and</span> <span class="pysrc-string">'index'</span> <span class="pysrc-keyword">in</span> w])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([wd <span class="pysrc-keyword">for</span> wd <span class="pysrc-keyword">in</span> set(text3) <span class="pysrc-keyword">if</span> wd.istitle() <span class="pysrc-keyword">and</span> len(wd) &gt; 10])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(sent7) <span class="pysrc-keyword">if</span> <span class="pysrc-keyword">not</span> w.islower()])
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([t <span class="pysrc-keyword">for</span> t <span class="pysrc-keyword">in</span> set(text2) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'cie'</span> <span class="pysrc-keyword">in</span> t <span class="pysrc-keyword">or</span> <span class="pysrc-string">'cei'</span> <span class="pysrc-keyword">in</span> t])</pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="operating-on-every-element">
<h3>Operating on Every Element</h3>
<p>In <a class="reference internal" href="#sec-computing-with-language-simple-statistics">1.3</a>, we saw some examples of
counting items other than words.  Let's take a closer look at the notation we used:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>[len(w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1]
<span class="pysrc-output">[1, 4, 4, 2, 6, 8, 4, 1, 9, 1, 1, 8, 2, 1, 4, 11, 5, 2, 1, 7, 6, 1, 3, 4, 5, 2, ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>[w.upper() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1]
<span class="pysrc-output">['[', 'MOBY', 'DICK', 'BY', 'HERMAN', 'MELVILLE', '1851', ']', 'ETYMOLOGY', '.', ...]</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>These expressions have the form <tt class="doctest"><span class="pre">[f(w) <span class="pysrc-keyword">for</span> ...]</span></tt> or <tt class="doctest"><span class="pre">[w.f() <span class="pysrc-keyword">for</span> ...]</span></tt>, where
<tt class="doctest"><span class="pre">f</span></tt> is a function that operates on a word to compute its length, or to
convert it to uppercase.
For now, you don't need to understand the difference between the notations <tt class="doctest"><span class="pre">f(w)</span></tt> and
<tt class="doctest"><span class="pre">w.f()</span></tt>.  Instead, simply learn this Python idiom which performs the
same operation on every element of a list.  In the preceding examples, it goes through
each word in <tt class="doctest"><span class="pre">text1</span></tt>, assigning each one in turn to the variable <tt class="doctest"><span class="pre">w</span></tt> and
performing the specified operation on the variable.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The notation just described is called a &quot;list comprehension.&quot;  This is our first example
of a Python idiom, a fixed notation that we use habitually without bothering to
analyze each time.  Mastering such idioms is an important part of becoming a
fluent Python programmer.</p>
</div>
<p>Let's return to the question of vocabulary size, and apply the same idiom here:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(text1)
<span class="pysrc-output">260819</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set(text1))
<span class="pysrc-output">19317</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set([word.lower() <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text1]))
<span class="pysrc-output">17231</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Now that we are not double-counting words like <span class="example">This</span> and <span class="example">this</span>, which differ only
in capitalization, we've wiped 2,000 off the vocabulary count!  We can go a step further
and eliminate numbers and punctuation from the vocabulary count by filtering out any
non-alphabetic items:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>len(set([word.lower() <span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text1 <span class="pysrc-keyword">if</span> word.isalpha()]))
<span class="pysrc-output">16948</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This example is slightly complicated: it lowercases all the purely alphabetic items.
Perhaps it would have been simpler just to count the lowercase-only items, but this
gives the wrong answer (why?).</p>
<p>Don't worry if you don't feel confident with list comprehensions yet,
since you'll see many more examples along with explanations in the following chapters.</p>
</div>
<div class="section" id="nested-code-blocks">
<h3>Nested Code Blocks</h3>
<p>Most programming languages permit us to execute a block of code when a
<a name="conditional_expression_index_term" /><span class="termdef">conditional expression</span>, or <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement, is satisfied.  We
already saw examples of conditional tests in code like <tt class="doctest"><span class="pre">[w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span>
sent7 <span class="pysrc-keyword">if</span> len(w) &lt; 4]</span></tt>. In the following program, we have created a
variable called <tt class="doctest"><span class="pre">word</span></tt> containing the string value <tt class="doctest"><span class="pre"><span class="pysrc-string">'cat'</span></span></tt>. The
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement checks whether the test <tt class="doctest"><span class="pre">len(word) &lt; 5</span></tt> is true.
It is, so the body of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement is invoked and the
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> statement is executed, displaying a message to the user.
Remember to indent the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> statement by typing four spaces.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>word = <span class="pysrc-string">'cat'</span>
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">if</span> len(word) &lt; 5:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> <span class="pysrc-string">'word length is less than 5'</span>
<span class="pysrc-more">... </span>  <a name="blank-line" /><a href="#ref-blank-line"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></a>
<span class="pysrc-output">word length is less than 5</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>When we use the Python interpreter we have to add an extra blank line <a class="reference internal" href="#blank-line"><span id="ref-blank-line"><img src="callouts/callout1.gif" alt="[1]" class="callout" /></span></a>
in order for it to detect that the nested block is complete.</p>
<p>If we change the conditional test to <tt class="doctest"><span class="pre">len(word) &gt;= 5</span></tt>,
to check that the length of <tt class="doctest"><span class="pre">word</span></tt> is greater than or equal to <tt class="doctest"><span class="pre">5</span></tt>,
then the test will no longer be true.
This time, the body of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement will not be executed,
and no message is shown to the user:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">if</span> len(word) &gt;= 5:
<span class="pysrc-more">... </span>  <span class="pysrc-keyword">print</span> <span class="pysrc-string">'word length is greater than or equal to 5'</span>
<span class="pysrc-more">...</span>
<span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>An <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement is known as a <a name="control_structure_index_term" /><span class="termdef">control structure</span>
because it controls whether the code in the indented block will be run.
Another control structure is the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> loop.
Try the following, and remember to include the colon and the four spaces:</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> [<span class="pysrc-string">'Call'</span>, <span class="pysrc-string">'me'</span>, <span class="pysrc-string">'Ishmael'</span>, <span class="pysrc-string">'.'</span>]:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> word
<span class="pysrc-more">...</span>
<span class="pysrc-output">Call</span>
<span class="pysrc-output">me</span>
<span class="pysrc-output">Ishmael</span>
<span class="pysrc-output">.</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>This is called a loop because Python executes the code in
circular fashion.  It starts by performing the
assignment <tt class="doctest"><span class="pre">word = <span class="pysrc-string">'Call'</span></span></tt>,
effectively using the <tt class="doctest"><span class="pre">word</span></tt> variable to name the first
item of the list.  Then, it displays the value of <tt class="doctest"><span class="pre">word</span></tt>
to the user.  Next, it goes back to the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statement,
and performs the assignment <tt class="doctest"><span class="pre">word = <span class="pysrc-string">'me'</span></span></tt>, before displaying this new value
to the user, and so on.  It continues in this fashion until
every item of the list has been processed.</p>
</div>
<div class="section" id="looping-with-conditions">
<h3>Looping with Conditions</h3>
<p>Now we can combine the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statements.
We will loop over every item of the list, and print
the item only if it ends with the letter <em>l</em>.  We'll pick another
name for the variable to demonstrate that Python doesn't
try to make sense of variable names.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sent1 = [<span class="pysrc-string">'Call'</span>, <span class="pysrc-string">'me'</span>, <span class="pysrc-string">'Ishmael'</span>, <span class="pysrc-string">'.'</span>]
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> xyzzy <span class="pysrc-keyword">in</span> sent1:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> xyzzy.endswith(<span class="pysrc-string">'l'</span>):
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span> xyzzy
<span class="pysrc-more">...</span>
<span class="pysrc-output">Call</span>
<span class="pysrc-output">Ishmael</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>You will notice that <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statements
have a colon at the end of the line,
before the indentation begins. In fact, all Python
control structures end with a colon.  The colon
indicates that the current statement relates to the
indented block that follows.</p>
<p>We can also specify an action to be taken if
the condition of the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement is not met.
Here we see the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">elif</span></span></tt> (else if) statement, and
the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">else</span></span></tt> statement.  Notice that these also have
colons before the indented code.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> token <span class="pysrc-keyword">in</span> sent1:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">if</span> token.islower():
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span> token, <span class="pysrc-string">'is a lowercase word'</span>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">elif</span> token.istitle():
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span> token, <span class="pysrc-string">'is a titlecase word'</span>
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">else</span>:
<span class="pysrc-more">... </span>        <span class="pysrc-keyword">print</span> token, <span class="pysrc-string">'is punctuation'</span>
<span class="pysrc-more">...</span>
<span class="pysrc-output">Call is a titlecase word</span>
<span class="pysrc-output">me is a lowercase word</span>
<span class="pysrc-output">Ishmael is a titlecase word</span>
<span class="pysrc-output">. is punctuation</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>As you can see, even with this small amount of Python knowledge,
you can start to build multiline Python programs.
It's important to develop such programs in pieces,
testing that each piece does what you expect before
combining them into a program.  This is why the Python
interactive interpreter is so invaluable, and why you should get
comfortable using it.</p>
<p>Finally, let's combine the idioms we've been exploring.
First, we create a list of <span class="example">cie</span> and <span class="example">cei</span> words,
then we loop over each item and print it.  Notice the
comma at the end of the print statement, which tells
Python to produce its output on a single line.</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>tricky = sorted([w <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text2) <span class="pysrc-keyword">if</span> <span class="pysrc-string">'cie'</span> <span class="pysrc-keyword">in</span> w <span class="pysrc-keyword">or</span> <span class="pysrc-string">'cei'</span> <span class="pysrc-keyword">in</span> w])
<span class="pysrc-prompt">&gt;&gt;&gt; </span><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> tricky:
<span class="pysrc-more">... </span>    <span class="pysrc-keyword">print</span> word,
<span class="pysrc-output">ancient ceiling conceit conceited conceive conscience</span>
<span class="pysrc-output">conscientious conscientiously deceitful deceive ...</span>
<span class="pysrc-output"></span><span class="pysrc-prompt">&gt;&gt;&gt;</span></pre>
</td>
</tr></table></td></tr>
</table></div>
</div>
</div>
<div class="section" id="automatic-natural-language-understanding">
<span id="sec-automatic-natural-language-understanding"></span><h2>1.5&nbsp;&nbsp;&nbsp;Automatic Natural Language Understanding</h2>
<!-- >>> from nltk.misc import babelize_shell -->
<p>We have been exploring language bottom-up, with the help of texts and
the Python programming
language.  However, we're also interested in exploiting our knowledge of language and computation
by building useful language technologies. We'll take the opportunity
now to step back from the nitty-gritty of code in order to paint a
bigger picture of natural language processing.</p>
<p>At a purely practical level, we all need help to navigate the universe of information
locked up in text on the Web.  Search engines have been crucial to the
growth and popularity of the Web, but have some shortcomings.
It takes skill, knowledge, and some luck,
to extract answers to such questions as: <span class="example">What tourist sites can I
visit between Philadelphia and Pittsburgh on a limited budget?</span>
<span class="example">What do experts say about digital SLR cameras?</span> <span class="example">What
predictions about the steel market were made by credible commentators
in the past week?</span> Getting a computer to answer them automatically
involves a range of language processing tasks, including information extraction,
inference, and summarization, and would need to be carried out on a scale
and with a level of robustness that is still beyond our current capabilities.</p>
<p>On a more philosophical level, a long-standing challenge within artificial intelligence
has been to build intelligent machines, and a major part of intelligent behaviour is understanding
language.  For many years this goal has been seen as too difficult.
However, as NLP technologies become more mature, and robust methods for
analyzing unrestricted text become more widespread, the prospect of
natural language understanding has re-emerged as a plausible goal.</p>
<p>In this section we describe some language understanding technologies,
to give you a sense of the interesting challenges that are waiting for you.</p>
<div class="section" id="word-sense-disambiguation">
<h3>Word Sense Disambiguation</h3>
<p>In <a name="word_sense_disambiguation_index_term" /><span class="termdef">word sense disambiguation</span> we want to work out
which sense of a word was intended in a given context.  Consider the
ambiguous words <span class="example">serve</span> and <span class="example">dish</span>:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(2)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><span class="example">serve</span>: help with food or drink; hold an office; put ball into play</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><span class="example">dish</span>: plate; course of a meal; communications device</td></tr></table></p>
</td></tr></table></p>
<p>In a sentence containing the phrase: <span class="example">he served the dish</span>, you
can detect that both <span class="example">serve</span> and <span class="example">dish</span> are being used with
their food meanings.  It's unlikely that the topic of discussion
shifted from sports to crockery in the space of three words.
This would force you to invent bizarre images, like a tennis pro
taking out their frustrations on a china tea-set laid out beside the court.
In other words, we automatically disambiguate words using context, exploiting
the simple fact that nearby words have closely related meanings.
As another example of this contextual effect, consider the word
<span class="example">by</span>, which has several meanings, e.g.: <span class="example">the book by
Chesterton</span> (agentive &#8212; Chesterton was the author of the book);
<span class="example">the cup by the stove</span> (locative &#8212; the stove is where the
cup is); and <span class="example">submit by Friday</span> (temporal &#8212; Friday is the
time of the submitting).
Observe in <a class="reference internal" href="#ex-lost-children">(3c)</a> that the meaning of the italicized word helps us
interpret the meaning of <span class="example">by</span>.</p>
<span class="target" id="ex-lost-children"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(3)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The lost children were found by the <span class="emphasis">searchers</span>  (agentive)</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>The lost children were found by the <span class="emphasis">mountain</span>   (locative)</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>The lost children were found by the <span class="emphasis">afternoon</span>  (temporal)</td></tr></table></p>
</td></tr></table></p>
</div>
<div class="section" id="pronoun-resolution">
<h3>Pronoun Resolution</h3>
<p>A deeper kind of language understanding is to work out &quot;who did what to whom&quot; &#8212;
i.e., to detect the subjects and objects of verbs.  You learnt to do this in
elementary school, but it's harder than you might think.
In the sentence <span class="example">the thieves stole the paintings</span>
it is easy to tell who performed the stealing action.
Consider three possible following sentences in <a class="reference internal" href="#ex-thieves">(4c)</a>, and try to determine
what was sold, caught, and found (one case is ambiguous).</p>
<span class="target" id="ex-thieves"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(4)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The thieves stole the paintings.  They were subsequently <span class="emphasis">sold</span>.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>The thieves stole the paintings.  They were subsequently <span class="emphasis">caught</span>.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>The thieves stole the paintings.  They were subsequently <span class="emphasis">found</span>.</td></tr></table></p>
</td></tr></table></p>
<p>Answering this question involves finding the <a name="antecedent_index_term" /><span class="termdef">antecedent</span> of the pronoun <span class="example">they</span>,
either thieves or paintings.  Computational techniques for tackling this problem
include <a name="anaphora_resolution_index_term" /><span class="termdef">anaphora resolution</span> &#8212; identifying what a pronoun or noun phrase
refers to &#8212; and <a name="semantic_role_labeling_index_term" /><span class="termdef">semantic role labeling</span> &#8212; identifying how a noun phrase
relates to the verb (as agent, patient, instrument, and so on).</p>
</div>
<div class="section" id="generating-language-output">
<h3>Generating Language Output</h3>
<p>If we can automatically solve such problems of language understanding, we will
be able to move on to tasks that involve generating language output, such as
<a name="question_answering_index_term" /><span class="termdef">question answering</span> and <a name="machine_translation_index_term" /><span class="termdef">machine translation</span>.  In the first case,
a machine should be able to answer a user's questions relating to collection of texts:</p>
<span class="target" id="ex-qa-application"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(5)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td><em>Text:</em> ... The thieves stole the paintings.  They were subsequently sold. ...</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td><em>Human:</em> Who or what was sold?</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td><em>Machine:</em> The paintings.</td></tr></table></p>
</td></tr></table></p>
<p>The machine's answer demonstrates that it has correctly worked out that <span class="example">they</span>
refers to paintings and not to thieves.  In the second case, the machine should
be able to translate the text into another language, accurately
conveying the meaning of the original text.  In translating the example text into French,
we are forced to choose the gender of the pronoun in the second sentence:
<span class="example">ils</span> (masculine) if the thieves are found, and <span class="example">elles</span> (feminine) if
the paintings are found.  Correct translation actually depends on correct understanding of
the pronoun.</p>
<span class="target" id="ex-mt-application"></span><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(6)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>The thieves stole the paintings.  They were subsequently found.</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Les voleurs ont vol&#233; les peintures. Ils ont &#233;t&#233; trouv&#233;s plus tard.  (the thieves)</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">c.</td><td width="15"></td><td>Les voleurs ont vol&#233; les peintures. Elles ont &#233;t&#233; trouv&#233;es plus tard.  (the paintings)</td></tr></table></p>
</td></tr></table></p>
<p>In all of these examples, working out the sense of a word, the subject of a verb, and the
antecedent of a pronoun are steps in establishing the meaning of a sentence, things
we would expect a language understanding system to be able to do.</p>
</div>
<div class="section" id="machine-translation">
<h3>Machine Translation</h3>
<p>For a long time now, machine translation (MT) has
been the holy grail of language understanding,
ultimately seeking to provide high-quality,
idiomatic translation between any pair of languages.
Its roots go back to the early days of the Cold War, when the promise
of automatic translation led to substantial government sponsorship,
and with it, the genesis of NLP itself.</p>
<p>Today, practical translation systems exist for particular pairs
of languages, and some are integrated into web search engines.
However, these systems have some serious shortcomings.
We can explore them with the help of NLTK's &quot;babelizer&quot;
(which is automatically loaded when you import ths chapter's
materials using <tt class="doctest"><span class="pre"><span class="pysrc-keyword">from</span> nltk.book <span class="pysrc-keyword">import</span> *</span></tt>).
This program submits a sentence for translation into a
specified language, then submits the resulting sentence for translation
back into English.  It stops after 12 iterations, or if it receives
a translation that was produced already (indicating a loop):</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>babelize_shell()
<span class="pysrc-output">NLTK Babelizer: type 'help' for a list of commands.</span>
<span class="pysrc-output">Babel&gt; how long before the next flight to Alice Springs?</span>
<span class="pysrc-output">Babel&gt; german</span>
<span class="pysrc-output">Babel&gt; run</span>
<span class="pysrc-output">0&gt; how long before the next flight to Alice Springs?</span>
<span class="pysrc-output">1&gt; wie lang vor dem folgenden Flug zu Alice Springs?</span>
<span class="pysrc-output">2&gt; how long before the following flight to Alice jump?</span>
<span class="pysrc-output">3&gt; wie lang vor dem folgenden Flug zu Alice springen Sie?</span>
<span class="pysrc-output">4&gt; how long before the following flight to Alice do you jump?</span>
<span class="pysrc-output">5&gt; wie lang, bevor der folgende Flug zu Alice tun, Sie springen?</span>
<span class="pysrc-output">6&gt; how long, before the following flight to Alice does, do you jump?</span>
<span class="pysrc-output">7&gt; wie lang bevor der folgende Flug zu Alice tut, tun Sie springen?</span>
<span class="pysrc-output">8&gt; how long before the following flight to Alice does, do you jump?</span>
<span class="pysrc-output">9&gt; wie lang, bevor der folgende Flug zu Alice tut, tun Sie springen?</span>
<span class="pysrc-output">10&gt; how long, before the following flight does to Alice, do do you jump?</span>
<span class="pysrc-output">11&gt; wie lang bevor der folgende Flug zu Alice tut, Sie tun Sprung?</span>
<span class="pysrc-output">12&gt; how long before the following flight does leap to Alice, does you?</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Observe that the system correctly translates <span class="example">Alice Springs</span> from English
to German (in the line starting <tt class="doctest"><span class="pre">1&gt;</span></tt>), but on the way back to English, this ends up as <span class="example">Alice jump</span>
(line <tt class="doctest"><span class="pre">2</span></tt>).  The preposition <span class="example">before</span> is initially translated into the corresponding
German preposition <span class="example">vor</span>, but later into the conjunction <span class="example">bevor</span> (line 5).
After line <tt class="doctest"><span class="pre">5</span></tt> the sentences become nonsensical (but notice the various phrasings
indicated by the commas, and the change from <span class="example">jump</span> to <span class="example">leap</span>).
The translation system did not recognize when a word was part of a proper name,
and it misinterpreted the grammatical structure.  The grammatical problems
are more obvious in the following example.  Did John find the pig, or did the
pig find John?</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>babelize_shell()
<span class="pysrc-output">Babel&gt; The pig that John found looked happy</span>
<span class="pysrc-output">Babel&gt; german</span>
<span class="pysrc-output">Babel&gt; run</span>
<span class="pysrc-output">0&gt; The pig that John found looked happy</span>
<span class="pysrc-output">1&gt; Das Schwein, das John fand, schaute gl?cklich</span>
<span class="pysrc-output">2&gt; The pig, which found John, looked happy</span></pre>
</td>
</tr></table></td></tr>
</table></div>
<p>Machine translation is difficult because a given word could have several possible
translations (depending on its meaning), and because word order must be changed
in keeping with the grammatical structure of the target language.
Today these difficulties are being faced by collecting massive quantities of
parallel texts from news and government websites that publish documents
in two or more languages.  Given a document in German and English, and possibly
a bilingual dictionary, we can automatically pair up the sentences,
a process called <a name="text_alignment_index_term" /><span class="termdef">text alignment</span>.  Once we have a million or more sentence
pairs, we can detect corresponding words and phrases, and build a model
that can be used for translating new text.</p>
</div>
<div class="section" id="spoken-dialog-systems">
<h3>Spoken Dialog Systems</h3>
<p>In the history of artificial intelligence, the chief measure of intelligence
has been a linguistic one, namely the <a name="turing_test_index_term" /><span class="termdef">Turing Test</span>: can a dialogue system,
responding to a user's text input, perform so naturally that we cannot distinguish
it from a human-generated response?  In contrast, today's commercial dialogue systems
are very limited, but still perform useful functions in narrowly-defined domains,
as we see here:</p>
<div class="line-block">
<div class="line">S: How may I help you?</div>
<div class="line">U: When is Saving Private Ryan playing?</div>
<div class="line">S: For what theater?</div>
<div class="line">U: The Paramount theater.</div>
<div class="line">S: Saving Private Ryan is not playing at the Paramount theater, but</div>
<div class="line">it's playing at the Madison theater at 3:00, 5:30, 8:00, and 10:30.</div>
</div>
<p>You could not ask this system to provide driving instructions or
details of nearby restaurants unless the required information
had already been stored and suitable question-answer pairs
had been incorporated into the language processing system.</p>
<p>Observe that this system seems to understand the user's goals:
the user asks when a movie is showing and the system
correctly determines from this that the user wants to see
the movie. This inference seems so obvious that you probably
didn't notice it was made, yet a natural language system
needs to be endowed with this capability in order to interact
naturally.  Without it, when asked <span class="example">Do you know when Saving Private
Ryan is playing?</span>, a system might unhelpfully respond with a cold <span class="example">Yes</span>.
However, the developers of commercial dialogue systems use
contextual assumptions and business logic to ensure that the different ways in which a user might
express requests or provide information are handled in a way that
makes sense for the particular application.  So, if you type
<span class="example">When is ...</span>, or <span class="example">I want to know when ...</span>, or <span class="example">Can you tell me
when ...</span>, simple rules will always yield screening times.  This is
enough for the system to provide a useful service.</p>
<span class="target" id="fig-sds"></span><div class="figure" id="fig-sds">
<img alt="../images/dialogue.png" src="../images/dialogue.png" style="width: 600.0px; height: 324.0px;" />
<p class="caption"><span class="caption-label">Figure 1.5</span>: Simple Pipeline Architecture for a Spoken Dialogue System:
Spoken input (top left) is analyzed, words are recognized, sentences are parsed and
interpreted in context, application-specific actions take place (top right);
a response is planned, realized as a syntactic structure, then to suitably
inflected words, and finally to spoken output; different types of
linguistic knowledge inform each stage of the process.</p>
</div>
<p>Dialogue systems give us an opportunity to mention the
commonly assumed pipeline for NLP.
<a class="reference internal" href="#fig-sds">1.5</a> shows the architecture of a simple dialogue system.
Along the top of the diagram, moving from left to right, is a
&quot;pipeline&quot; of some language understanding <a name="components_index_term" /><span class="termdef">components</span>.
These map from speech input via syntactic parsing
to some kind of meaning representation.  Along the middle, moving from
right to left, is the reverse pipeline of components for converting
concepts to speech.  These components make up the dynamic aspects of the system.
At the bottom of the diagram are some representative bodies of
static information: the repositories of language-related data that
the processing components draw on to do their work.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Your Turn:</strong>
For an example of a primitive dialogue system, try having
a conversation with an NLTK chatbot.  To see the available chatbots,
run <tt class="doctest"><span class="pre">nltk.chat.chatbots()</span></tt>.
(Remember to <tt class="doctest"><span class="pre"><span class="pysrc-keyword">import</span> nltk</span></tt> first.)</p>
</div>
</div>
<div class="section" id="textual-entailment">
<h3>Textual Entailment</h3>
<p>The challenge of language understanding has been brought into focus in recent years by a public
&quot;shared task&quot; called Recognizing Textual Entailment (RTE). The basic
scenario is simple.  Suppose you want to find evidence to support
the hypothesis: <span class="example">Sandra Goudie was defeated by Max Purnell</span>, and
that you have another short text that seems to be relevant, for example,
<span class="example">Sandra Goudie was first elected to Parliament in the 2002 elections,
narrowly winning the seat of Coromandel by defeating Labour candidate
Max Purnell and pushing incumbent Green MP Jeanette Fitzsimons into
third place</span>.  Does the text provide enough evidence for you to
accept the hypothesis?  In this particular case, the answer will be &quot;No.&quot;
You can draw this conclusion easily, but it is very hard to come up with
automated methods for making the right decision. The RTE
Challenges provide data that allow competitors to develop their
systems, but not enough data for &quot;brute force&quot; machine learning techniques (a topic
we will cover in <a class="reference external" href="ch06.html#chap-data-intensive">chap-data-intensive</a>).  Consequently, some
linguistic analysis is crucial. In the previous example, it is important
for the system to note that <span class="example">Sandra Goudie</span> names the person being
defeated in the hypothesis, not the person doing the defeating in the
text. As another illustration of the difficulty of the task, consider
the following text-hypothesis pair:</p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">(7)</td><td width="15"></td><td><p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">a.</td><td width="15"></td><td>Text: David Golinkin is the editor or author of eighteen books, and over 150 responsa, articles, sermons and books</td></tr></table></p>
<p><table border="0" cellpadding="0" cellspacing="0" class="example">
  <tr valign="top"><td width="30" align="right">b.</td><td width="15"></td><td>Hypothesis: Golinkin has written eighteen books</td></tr></table></p>
</td></tr></table></p>
<p>In order to determine whether the hypothesis is supported by the
text, the system needs the following background knowledge:
(i) if someone is an author of a book, then he/she has written that
book; (ii) if someone is an editor of a book, then he/she has not
written (all of) that book; (iii) if someone is editor or author of eighteen
books, then one cannot conclude that he/she is author of eighteen books.</p>
</div>
<div class="section" id="limitations-of-nlp">
<h3>Limitations of NLP</h3>
<p>Despite the research-led advances in tasks like RTE, natural language
systems that have been deployed for real-world applications still cannot perform
common-sense reasoning or draw on world knowledge in a general and
robust manner.  We can wait for these difficult artificial
intelligence problems to be solved, but in the meantime it is
necessary to live with some severe limitations on the reasoning and
knowledge capabilities of natural language systems. Accordingly, right
from the beginning, an important goal of NLP research has been to
make progress on the difficult task of building technologies that
&quot;understand language,&quot; using superficial yet powerful techniques instead of
unrestricted knowledge and reasoning capabilities.
Indeed, this is one of the goals of this book, and we hope to equip you with
the knowledge and skills to build useful NLP systems, and to
contribute to the long-term aspiration of building intelligent machines.</p>
</div>
</div>
<div class="section" id="summary">
<h2>1.6&nbsp;&nbsp;&nbsp;Summary</h2>
<ul class="simple">
<li>Texts are represented in Python using lists:
<tt class="doctest"><span class="pre">[<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>]</span></tt>.  We can use indexing, slicing,
and the <tt class="doctest"><span class="pre">len()</span></tt> function on lists.</li>
<li>A word &quot;token&quot; is a particular appearance of a given word in a text;
a word &quot;type&quot; is the unique form of the word as a particular sequence
of letters.  We count word tokens using <tt class="doctest"><span class="pre">len(text)</span></tt> and word types using
<tt class="doctest"><span class="pre">len(set(text))</span></tt>.</li>
<li>We obtain the vocabulary of a text <tt class="doctest"><span class="pre">t</span></tt> using <tt class="doctest"><span class="pre">sorted(set(t))</span></tt>.</li>
<li>We operate on each item of a text using <tt class="doctest"><span class="pre">[f(x) <span class="pysrc-keyword">for</span> x <span class="pysrc-keyword">in</span> text]</span></tt>.</li>
<li>To derive the vocabulary, collapsing case distinctions and ignoring punctuation,
we can write <tt class="doctest"><span class="pre">set([w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text <span class="pysrc-keyword">if</span> w.isalpha()])</span></tt>.</li>
<li>We process each word in a text using a <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> statement, such
as <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> t:</span></tt> or <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span> word <span class="pysrc-keyword">in</span> text:</span></tt>.  This must be followed by the colon character
and an indented block of code, to be executed each time through the loop.</li>
<li>We test a condition using an <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statement: <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span> len(word) &lt; 5:</span></tt>.
This must be followed by the colon character and an indented block of
code, to be executed only if the condition is true.</li>
<li>A frequency distribution is a collection of items along with their frequency counts
(e.g., the words of a text and their frequency of appearance).</li>
<li>A function is a block of code that has been assigned a name and can
be reused. Functions are defined using the <tt class="doctest"><span class="pre">def</span></tt> keyword, as in
<tt class="doctest"><span class="pre"><span class="pysrc-keyword">def</span> <span class="pysrc-defname">mult</span>(x, y)</span></tt>; <tt class="doctest"><span class="pre">x</span></tt> and <tt class="doctest"><span class="pre">y</span></tt> are parameters of the function,
and act as placeholders for actual data values.</li>
<li>A function is called by specifying its name followed by one or more
arguments inside parentheses, like this: <tt class="doctest"><span class="pre">mult(3, 4)</span></tt>, e.g., <tt class="doctest"><span class="pre">len(text1)</span></tt>.</li>
</ul>
</div>
<div class="section" id="further-reading">
<h2>1.7&nbsp;&nbsp;&nbsp;Further Reading</h2>
<p>This chapter has introduced new concepts in programming, natural language processing,
and linguistics, all mixed in together.
Many of them are consolidated in the following chapters.  However, you may also want to
consult the online materials provided with this chapter (at <tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>), including links
to additional background materials, and links to online NLP systems.
You may also like to read up on
some linguistics and NLP-related concepts in Wikipedia (e.g., collocations,
the Turing Test, the type-token distinction).</p>
<p>You should acquaint yourself with the Python documentation available at <tt class="doctest"><span class="pre">http://docs.python.org/</span></tt>,
including the many tutorials and comprehensive reference materials linked there.
A <span class="emphasis">Beginner's Guide to Python</span> is available at <tt class="doctest"><span class="pre">http://wiki.python.org/moin/BeginnersGuide</span></tt>.
Miscellaneous questions about Python might be answered in the FAQ at
<tt class="doctest"><span class="pre">http://www.python.org/doc/faq/general/</span></tt>.</p>
<p>As you delve into NLTK, you might want to subscribe to the mailing list where new
releases of the toolkit are announced.  There is also an NLTK-Users mailing list,
where users help each other as they learn how to use Python and NLTK for
language analysis work.  Details of these lists are available at <tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>.</p>
<p>For more information on the topics covered in <a class="reference internal" href="#sec-automatic-natural-language-understanding">1.5</a>,
and on NLP more generally, you might like to consult one of the following excellent
books:</p>
<ul class="simple">
<li>Indurkhya, Nitin and Fred Damerau (eds, 2010) <em>Handbook of Natural Language Processing</em>
(Second Edition) Chapman &amp; Hall/CRC. 2010.  <a class="reference external" href="bibliography.html#indurkhyadamerau2010" id="id1">(Indurkhya &amp; Damerau, 2010)</a> <a class="reference external" href="bibliography.html#dale00handbook" id="id2">(Dale, Moisl, &amp; Somers, 2000)</a></li>
<li>Jurafsky, Daniel and James Martin (2008) <em>Speech and Language Processing</em> (Second Edition).  Prentice Hall.
<a class="reference external" href="bibliography.html#jurafskymartin2008" id="id3">(Jurafsky &amp; Martin, 2008)</a></li>
<li>Mitkov, Ruslan (ed, 2003) <em>The Oxford Handbook of Computational Linguistics</em>.  Oxford University Press.
(second edition expected in 2010).  <a class="reference external" href="bibliography.html#mitkov02handbook" id="id4">(Mitkov, 2002)</a></li>
</ul>
<p>The Association for Computational Linguistics is the international organization that
represents the field of NLP.  The ACL website (<tt class="doctest"><span class="pre">http://www.aclweb.org/</span></tt>) hosts many useful resources, including:
information about international and regional conferences and workshops;
the <span class="emphasis">ACL Wiki</span> with links to hundreds of useful resources;
and the <span class="emphasis">ACL Anthology</span>, which contains most of the NLP research literature
from the past 50 years, fully indexed and freely downloadable.</p>
<p>Some excellent introductory Linguistics textbooks are:
<a class="reference external" href="bibliography.html#finegan2007" id="id5">(Finegan, 2007)</a>, <a class="reference external" href="bibliography.html#ogrady2004" id="id6">(O'Grady et al, 2004)</a>, <a class="reference external" href="bibliography.html#osu2007" id="id7">(OSU, 2007)</a>.  You might like to consult
<span class="emphasis">LanguageLog</span>, a popular linguistics blog with occasional posts that
use the techniques described in this book.</p>
</div>
<div class="section" id="exercises">
<h2>1.8&nbsp;&nbsp;&nbsp;Exercises</h2>
<!-- TODO: add lots more exercises on lists! -->
<ol class="arabic">
<li><p class="first">&#9788; Try using the Python interpreter as a calculator, and
typing expressions like <tt class="doctest"><span class="pre">12 / (4 + 1)</span></tt>.</p>
</li>
<li><p class="first">&#9788; Given an alphabet of 26 letters, there are 26 to the power
10, or <tt class="doctest"><span class="pre">26 ** 10</span></tt>, ten-letter strings we can form.  That works out
to <tt class="doctest"><span class="pre">141167095653376L</span></tt> (the <tt class="doctest"><span class="pre">L</span></tt> at the end just indicates that
this is Python's long-number format).  How many hundred-letter
strings are possible?</p>
</li>
<li><p class="first">&#9788; The Python multiplication operation can be applied to lists.
What happens when you type <tt class="doctest"><span class="pre">[<span class="pysrc-string">'Monty'</span>, <span class="pysrc-string">'Python'</span>] * 20</span></tt>,
or <tt class="doctest"><span class="pre">3 * sent1</span></tt>?</p>
</li>
<li><p class="first">&#9788; Review <a class="reference internal" href="#sec-computing-with-language-texts-and-words">1.1</a> on
computing with language.  How many words are there in <tt class="doctest"><span class="pre">text2</span></tt>?
How many distinct words are there?</p>
</li>
<li><p class="first">&#9788; Compare the lexical diversity scores for humor
and romance fiction in <a class="reference internal" href="#tab-brown-types">1.1</a>.  Which genre is
more lexically diverse?</p>
</li>
<li><p class="first">&#9788; Produce a dispersion plot of the four main protagonists in
<em>Sense and Sensibility</em>: Elinor, Marianne, Edward, and Willoughby.
What can you observe about the different roles played by the males
and females in this novel?  Can you identify the couples?</p>
</li>
<li><p class="first">&#9788; Find the collocations in <tt class="doctest"><span class="pre">text5</span></tt>.</p>
</li>
<li><p class="first">&#9788; Consider the following Python expression: <tt class="doctest"><span class="pre">len(set(text4))</span></tt>.
State the purpose of this expression.  Describe the two steps
involved in performing this computation.</p>
</li>
<li><p class="first">&#9788; Review <a class="reference internal" href="#sec-a-closer-look-at-python-texts-as-lists-of-words">1.2</a>
on lists and strings.</p>
<ol class="loweralpha simple">
<li>Define a string and assign it to a variable, e.g.,
<tt class="doctest"><span class="pre">my_string = <span class="pysrc-string">'My String'</span></span></tt> (but put something more interesting in the string).
Print the contents of this variable in two ways, first
by simply typing the variable name and pressing enter, then
by using the <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> statement.</li>
<li>Try adding the string to itself using <tt class="doctest"><span class="pre">my_string + my_string</span></tt>, or multiplying
it by a number, e.g., <tt class="doctest"><span class="pre">my_string * 3</span></tt>.  Notice that the strings
are joined together without any spaces.  How could you fix this?</li>
</ol>
</li>
<li><p class="first">&#9788; Define a variable <tt class="doctest"><span class="pre">my_sent</span></tt> to be a list of words, using
the syntax <tt class="doctest"><span class="pre">my_sent = [<span class="pysrc-string">&quot;My&quot;</span>, <span class="pysrc-string">&quot;sent&quot;</span>]</span></tt> (but with your own words,
or a favorite saying).</p>
<ol class="loweralpha simple">
<li>Use <tt class="doctest"><span class="pre"><span class="pysrc-string">' '</span>.join(my_sent)</span></tt> to convert this into a string.</li>
<li>Use <tt class="doctest"><span class="pre">split()</span></tt> to split the string back into the list form
you had to start with.</li>
</ol>
</li>
<li><p class="first">&#9788; Define several variables containing lists of words, e.g., <tt class="doctest"><span class="pre">phrase1</span></tt>,
<tt class="doctest"><span class="pre">phrase2</span></tt>, and so on.  Join them together in various combinations (using the plus operator)
to form whole sentences.  What is the relationship between
<tt class="doctest"><span class="pre">len(phrase1 + phrase2)</span></tt> and <tt class="doctest"><span class="pre">len(phrase1) + len(phrase2)</span></tt>?</p>
</li>
<li><p class="first">&#9788; Consider the following two expressions, which have the same
value.  Which one will typically be more relevant in NLP?  Why?</p>
<ol class="loweralpha simple">
<li><tt class="doctest"><span class="pre"><span class="pysrc-string">&quot;Monty Python&quot;</span>[6:12]</span></tt></li>
<li><tt class="doctest"><span class="pre">[<span class="pysrc-string">&quot;Monty&quot;</span>, <span class="pysrc-string">&quot;Python&quot;</span>][1]</span></tt></li>
</ol>
</li>
<li><p class="first">&#9788; We have seen how to represent a sentence as a list of words, where
each word is a sequence of characters.  What does <tt class="doctest"><span class="pre">sent1[2][2]</span></tt> do?
Why?  Experiment with other index values.</p>
</li>
<li><p class="first">&#9788; The first sentence of <tt class="doctest"><span class="pre">text3</span></tt> is provided to you in the
variable <tt class="doctest"><span class="pre">sent3</span></tt>.  The index of <span class="example">the</span> in <tt class="doctest"><span class="pre">sent3</span></tt> is 1, because <tt class="doctest"><span class="pre">sent3[1]</span></tt>
gives us <tt class="doctest"><span class="pre"><span class="pysrc-string">'the'</span></span></tt>.  What are the indexes of the two other occurrences
of this word in <tt class="doctest"><span class="pre">sent3</span></tt>?</p>
</li>
<li><p class="first">&#9788; Review the discussion of conditionals in <a class="reference internal" href="#sec-making-decisions">1.4</a>.
Find all words in the Chat Corpus (<tt class="doctest"><span class="pre">text5</span></tt>)
starting with the letter <span class="example">b</span>.  Show them in alphabetical order.</p>
</li>
<li><p class="first">&#9788; Type the expression <tt class="doctest"><span class="pre">range(10)</span></tt> at the interpreter prompt.
Now try <tt class="doctest"><span class="pre">range(10, 20)</span></tt>, <tt class="doctest"><span class="pre">range(10, 20, 2)</span></tt>, and <tt class="doctest"><span class="pre">range(20, 10, -2)</span></tt>.
We will see a variety of uses for this built-in function in later chapters.</p>
</li>
<li><p class="first">&#9681; Use <tt class="doctest"><span class="pre">text9.index()</span></tt> to find the index of the word <span class="example">sunset</span>.
You'll need to insert this word as an argument between the parentheses.
By a process of trial and error, find the slice for the complete sentence that
contains this word.</p>
</li>
<li><p class="first">&#9681; Using list addition, and the <tt class="doctest"><span class="pre">set</span></tt> and <tt class="doctest"><span class="pre">sorted</span></tt> operations, compute the
vocabulary of the sentences <tt class="doctest"><span class="pre">sent1</span></tt> ... <tt class="doctest"><span class="pre">sent8</span></tt>.</p>
</li>
<li><p class="first">&#9681; What is the difference between the following two lines?
Which one will give a larger value?  Will this be the case for other texts?</p>
<div class="doctest">
<table border="0" cellpadding="0" cellspacing="0" class="doctest" width="95%">
<tr><td class="doctest">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td width="1" class="copybar"
        onclick="javascript:copy_doctest_to_clipboard(this.nextSibling);"
        >&nbsp;</td>
<td class="pysrc"><pre class="doctest">
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted(set([w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1]))
<span class="pysrc-prompt">&gt;&gt;&gt; </span>sorted([w.lower() <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> set(text1)])</pre>
</td>
</tr></table></td></tr>
</table></div>
</li>
<li><p class="first">&#9681; What is the difference between the following two tests:
<tt class="doctest"><span class="pre">w.isupper()</span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">not</span> w.islower()</span></tt>?</p>
</li>
<li><p class="first">&#9681; Write the slice expression that extracts the last two words of <tt class="doctest"><span class="pre">text2</span></tt>.</p>
</li>
<li><p class="first">&#9681; Find all the four-letter words in the Chat Corpus (<tt class="doctest"><span class="pre">text5</span></tt>).
With the help of a frequency distribution (<tt class="doctest"><span class="pre">FreqDist</span></tt>), show these
words in decreasing order of frequency.</p>
</li>
<li><p class="first">&#9681; Review the discussion of looping with conditions in <a class="reference internal" href="#sec-making-decisions">1.4</a>.
Use a combination of <tt class="doctest"><span class="pre"><span class="pysrc-keyword">for</span></span></tt> and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">if</span></span></tt> statements to loop over the words of
the movie script for <em>Monty Python and the Holy Grail</em> (<tt class="doctest"><span class="pre">text6</span></tt>)
and <tt class="doctest"><span class="pre"><span class="pysrc-keyword">print</span></span></tt> all the uppercase words, one per line.</p>
</li>
<li><p class="first">&#9681; Write expressions for finding all words in <tt class="doctest"><span class="pre">text6</span></tt> that
meet the following conditions.  The result should be in the form of
a list of words: <tt class="doctest"><span class="pre">[<span class="pysrc-string">'word1'</span>, <span class="pysrc-string">'word2'</span>, ...]</span></tt>.</p>
<ol class="loweralpha simple">
<li>Ending in <span class="example">ize</span></li>
<li>Containing the letter <span class="example">z</span></li>
<li>Containing the sequence of letters <span class="example">pt</span></li>
<li>All lowercase letters except for an initial capital (i.e., <tt class="doctest"><span class="pre">titlecase</span></tt>)</li>
</ol>
</li>
<li><p class="first">&#9681; Define <tt class="doctest"><span class="pre">sent</span></tt> to be the list of words
<tt class="doctest"><span class="pre">[<span class="pysrc-string">'she'</span>, <span class="pysrc-string">'sells'</span>, <span class="pysrc-string">'sea'</span>, <span class="pysrc-string">'shells'</span>, <span class="pysrc-string">'by'</span>, <span class="pysrc-string">'the'</span>, <span class="pysrc-string">'sea'</span>, <span class="pysrc-string">'shore'</span>]</span></tt>.
Now write code to perform the following tasks:</p>
<ol class="loweralpha simple">
<li>Print all words beginning with <span class="example">sh</span></li>
<li>Print all words longer than four characters</li>
</ol>
</li>
<li><p class="first">&#9681; What does the following Python code do?  <tt class="doctest"><span class="pre">sum([len(w) <span class="pysrc-keyword">for</span> w <span class="pysrc-keyword">in</span> text1])</span></tt>
Can you use it to work out the average word length of a text?</p>
</li>
<li><p class="first">&#9681; Define a function called <tt class="doctest"><span class="pre">vocab_size(text)</span></tt> that has a single
parameter for the text, and which returns the vocabulary size of the text.</p>
</li>
<li><p class="first">&#9681; Define a function <tt class="doctest"><span class="pre">percent(word, text)</span></tt> that calculates
how often a given word occurs in a text, and expresses the result
as a percentage.</p>
</li>
<li><p class="first">&#9681; We have been using sets to store vocabularies.  Try the following
Python expression: <tt class="doctest"><span class="pre">set(sent3) &lt; set(text1)</span></tt>.  Experiment with this using
different arguments to <tt class="doctest"><span class="pre">set()</span></tt>.  What does it do?
Can you think of a practical application for this?</p>
</li>
</ol>
<!-- Footer to be used in all chapters -->
<div class="admonition-about-this-document admonition">
<p class="first admonition-title">About this document...</p>
<p>This is a chapter from <em>Natural Language Processing with Python</em>,
by <a class="reference external" href="http://www.csse.unimelb.edu.au/~sb/">Steven Bird</a>, <a class="reference external" href="http://www.ltg.ed.ac.uk/~ewan/">Ewan Klein</a> and <a class="reference external" href="http://www.cis.upenn.edu/~edloper/">Edward Loper</a>,
Copyright &#169; 2009 the authors.
It is distributed with the <em>Natural Language Toolkit</em> [<tt class="doctest"><span class="pre">http://www.nltk.org/</span></tt>],
Version 2.0.1rc1, under the terms of the
<em>Creative Commons Attribution-Noncommercial-No Derivative Works 3.0 United States License</em>
[<a class="reference external" href="http://creativecommons.org/licenses/by-nc-nd/3.0/us/">http://creativecommons.org/licenses/by-nc-nd/3.0/us/</a>].</p>
<p class="last">This document was built on
Mon 15 Oct 2012 16:46:09 EST</p>
</div>
</div>
</div>
</div>
</body>
</html>
